(window.webpackJsonp = window.webpackJsonp || []).push([
    [1], {
        "+m56": function(e, t, n) {
            "use strict";
            /**
             * A WP REST API client for Node.js
             *
             * @example
             *     var wp = new WPAPI({ endpoint: 'http://src.wordpress-develop.dev/wp-json' });
             *     wp.posts().then(function( posts ) {
             *         console.log( posts );
             *     }).catch(function( err ) {
             *         console.error( err );
             *     });
             *
             * @license MIT
             })
             */
            const s = n("iJE/"),
                r = n("CuLW"),
                i = n("YTqf").build,
                o = n("o2Ax").generate;
            let a;
            const l = n("zO7K"),
                c = n("ml1J"),
                u = n("E58G");

            function h(e) {
                if (this instanceof h == !1) return new h(e);
                if ("string" != typeof e.endpoint) throw new Error("options hash must contain an API endpoint URL string");
                return this._ns = {}, this._options = {
                    endpoint: e.endpoint.replace(/\/?$/, "/")
                }, e && (e.username || e.password || e.nonce) && this.auth(e), this.transport(e.transport).bootstrap(e && e.routes)
            }
            h.prototype.transport = function(e) {
                const t = this._options;
                return t.transport || (t.transport = Object.create(h.transport)), ["get", "head", "post", "put", "delete"].forEach(n => {
                    e && e[n] && (t.transport[n] = e[n])
                }), this
            }, h.transport = Object.create(u), Object.freeze(h.transport), h.site = function(e, t) {
                return new h({
                    endpoint: e,
                    routes: t
                })
            }, h.prototype.url = function(e) {
                return new c({ ...this._options,
                    endpoint: e
                })
            }, h.prototype.root = function(e) {
                e = e || "";
                const t = { ...this._options
                    },
                    n = new c(t);
                return n._path = {
                    0: e
                }, n
            }, h.prototype.setHeaders = c.prototype.setHeaders, h.prototype.auth = c.prototype.auth, h.prototype.registerRoute = n("w88U"), h.prototype.bootstrap = function(e) {
                let t, n;
                return e ? (t = i(e), n = o(t)) : (a || (t = i(r), a = o(t)), n = a), s(n, (e, t, n) => (e._ns[n] = s(t, (e, t, n) => (e[n] = t, e), e._ns[n] || {
                    _options: e._options
                }), "wp/v2" === n && Object.keys(e._ns[n]).forEach(t => {
                    e[t] = e._ns[n][t]
                }), e), this)
            }, h.prototype.namespace = function(e) {
                if (!this._ns[e]) throw new Error("Error: namespace " + e + " is not recognized");
                return this._ns[e]
            }, h.discover = e => {
                let t;
                const n = h.site(e).root();
                return n.headers().catch(() => n.get()).then(l.locateAPIRootHeader).then(e => (t = e, h.site(e).root().get())).then(e => new h({
                    endpoint: t,
                    routes: e.routes
                })).catch(e => {
                    if (console.error(e), t) return console.warn("Endpoint detected, proceeding despite error..."), console.warn("Binding to " + t + " and assuming default routes"), new h.site(t);
                    throw new Error("Autodiscovery failed")
                })
            }, e.exports = h
        },
        "/fTC": function(e, t, n) {
            var s, r, i, o;
            i = function() {
                var e = /^;\s*([^"=]+)=(?:"([^"]+)"|([^";,]+)(?:[;,]|$))/,
                    t = /^<([^>]*)>/,
                    n = /^\s*,\s*/;
                return {
                    parse: function(s, r) {
                        for (var i, o, a, l = r && r.extended || !1, c = []; s && (s = s.trim(), o = t.exec(s));) {
                            for (var u = {
                                    link: o[1]
                                }, h = (s = s.slice(o[0].length)).match(n); s && (!h || h.index > 0) && (i = e.exec(s));) h = (s = s.slice(i[0].length)).match(n), "rel" === i[1] || "rev" === i[1] ? (a = (i[2] || i[3]).split(/\s+/), u[i[1]] = a) : u[i[1]] = i[2] || i[3];
                            c.push(u), s = s.replace(n, "")
                        }
                        return l ? c : c.reduce(function(e, t) {
                            return t.rel && t.rel.forEach(function(n) {
                                e[n] = t.link
                            }), e
                        }, {})
                    },
                    stringify: function(e) {
                        var t = Object.keys(e).reduce(function(t, n) {
                            return t[e[n]] = t[e[n]] || [], t[e[n]].push(n), t
                        }, {});
                        return Object.keys(t).reduce(function(e, n) {
                            return e.concat("<" + n + '>; rel="' + t[n].join(" ") + '"')
                        }, []).join(", ")
                    }
                }
            }, o = this, e.exports ? e.exports = i() : "function" == typeof o.define && o.define.amd ? void 0 === (r = "function" == typeof(s = i) ? s.call(t, n, t, e) : s) || (e.exports = r) : o.li = i()
        },
        "/yFf": function(e, t, n) {
            "use strict";
            const s = n("oHnp");

            function r(e) {
                if (e) return function(e) {
                    for (const t in r.prototype) e[t] = r.prototype[t];
                    return e
                }(e)
            }
            e.exports = r, r.prototype.get = function(e) {
                return this.header[e.toLowerCase()]
            }, r.prototype._setHeaderProperties = function(e) {
                const t = e["content-type"] || "";
                this.type = s.type(t);
                const n = s.params(t);
                for (const s in n) this[s] = n[s];
                this.links = {};
                try {
                    e.link && (this.links = s.parseLinks(e.link))
                } catch (r) {}
            }, r.prototype._setStatusProperties = function(e) {
                const t = e / 100 | 0;
                this.status = this.statusCode = e, this.statusType = t, this.info = 1 == t, this.ok = 2 == t, this.redirect = 3 == t, this.clientError = 4 == t, this.serverError = 5 == t, this.error = (4 == t || 5 == t) && this.toError(), this.created = 201 == e, this.accepted = 202 == e, this.noContent = 204 == e, this.badRequest = 400 == e, this.unauthorized = 401 == e, this.notAcceptable = 406 == e, this.forbidden = 403 == e, this.notFound = 404 == e, this.unprocessableEntity = 422 == e
            }
        },
        0: function(e, t, n) {
            e.exports = n("zUnb")
        },
        "0KBE": function(e, t, n) {
            "use strict";
            e.exports = e => function(t) {
                return this.param(e, t)
            }
        },
        "0jNN": function(e, t, n) {
            "use strict";
            var s = n("sxOR"),
                r = Object.prototype.hasOwnProperty,
                i = Array.isArray,
                o = function() {
                    for (var e = [], t = 0; t < 256; ++t) e.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
                    return e
                }(),
                a = function(e, t) {
                    for (var n = t && t.plainObjects ? Object.create(null) : {}, s = 0; s < e.length; ++s) void 0 !== e[s] && (n[s] = e[s]);
                    return n
                };
            e.exports = {
                arrayToObject: a,
                assign: function(e, t) {
                    return Object.keys(t).reduce(function(e, n) {
                        return e[n] = t[n], e
                    }, e)
                },
                combine: function(e, t) {
                    return [].concat(e, t)
                },
                compact: function(e) {
                    for (var t = [{
                            obj: {
                                o: e
                            },
                            prop: "o"
                        }], n = [], s = 0; s < t.length; ++s)
                        for (var r = t[s], o = r.obj[r.prop], a = Object.keys(o), l = 0; l < a.length; ++l) {
                            var c = a[l],
                                u = o[c];
                            "object" == typeof u && null !== u && -1 === n.indexOf(u) && (t.push({
                                obj: o,
                                prop: c
                            }), n.push(u))
                        }
                    return function(e) {
                        for (; e.length > 1;) {
                            var t = e.pop(),
                                n = t.obj[t.prop];
                            if (i(n)) {
                                for (var s = [], r = 0; r < n.length; ++r) void 0 !== n[r] && s.push(n[r]);
                                t.obj[t.prop] = s
                            }
                        }
                    }(t), e
                },
                decode: function(e, t, n) {
                    var s = e.replace(/\+/g, " ");
                    if ("iso-8859-1" === n) return s.replace(/%[0-9a-f]{2}/gi, unescape);
                    try {
                        return decodeURIComponent(s)
                    } catch (r) {
                        return s
                    }
                },
                encode: function(e, t, n, r, i) {
                    if (0 === e.length) return e;
                    var a = e;
                    if ("symbol" == typeof e ? a = Symbol.prototype.toString.call(e) : "string" != typeof e && (a = String(e)), "iso-8859-1" === n) return escape(a).replace(/%u[0-9a-f]{4}/gi, function(e) {
                        return "%26%23" + parseInt(e.slice(2), 16) + "%3B"
                    });
                    for (var l = "", c = 0; c < a.length; ++c) {
                        var u = a.charCodeAt(c);
                        45 === u || 46 === u || 95 === u || 126 === u || u >= 48 && u <= 57 || u >= 65 && u <= 90 || u >= 97 && u <= 122 || i === s.RFC1738 && (40 === u || 41 === u) ? l += a.charAt(c) : u < 128 ? l += o[u] : u < 2048 ? l += o[192 | u >> 6] + o[128 | 63 & u] : u < 55296 || u >= 57344 ? l += o[224 | u >> 12] + o[128 | u >> 6 & 63] + o[128 | 63 & u] : (c += 1, u = 65536 + ((1023 & u) << 10 | 1023 & a.charCodeAt(c)), l += o[240 | u >> 18] + o[128 | u >> 12 & 63] + o[128 | u >> 6 & 63] + o[128 | 63 & u])
                    }
                    return l
                },
                isBuffer: function(e) {
                    return !(!e || "object" != typeof e) && !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e))
                },
                isRegExp: function(e) {
                    return "[object RegExp]" === Object.prototype.toString.call(e)
                },
                maybeMap: function(e, t) {
                    if (i(e)) {
                        for (var n = [], s = 0; s < e.length; s += 1) n.push(t(e[s]));
                        return n
                    }
                    return t(e)
                },
                merge: function e(t, n, s) {
                    if (!n) return t;
                    if ("object" != typeof n) {
                        if (i(t)) t.push(n);
                        else {
                            if (!t || "object" != typeof t) return [t, n];
                            (s && (s.plainObjects || s.allowPrototypes) || !r.call(Object.prototype, n)) && (t[n] = !0)
                        }
                        return t
                    }
                    if (!t || "object" != typeof t) return [t].concat(n);
                    var o = t;
                    return i(t) && !i(n) && (o = a(t, s)), i(t) && i(n) ? (n.forEach(function(n, i) {
                        if (r.call(t, i)) {
                            var o = t[i];
                            o && "object" == typeof o && n && "object" == typeof n ? t[i] = e(o, n, s) : t.push(n)
                        } else t[i] = n
                    }), t) : Object.keys(n).reduce(function(t, i) {
                        var o = n[i];
                        return r.call(t, i) ? t[i] = e(t[i], o, s) : t[i] = o, t
                    }, o)
                }
            }
        },
        1: function(e, t) {},
        "1uSB": function(e, t, n) {
            "use strict";
            (function(e) {
                /**
                 * @license Angular v11.0.7
                 * (c) 2010-2020 Google LLC. https://angular.io/
                 * License: MIT
                 */
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var s;

                function r(e) {
                    if (":" != e[0]) return [null, e];
                    const t = e.indexOf(":", 1);
                    if (-1 == t) throw new Error(`Unsupported format "${e}" expecting ":namespace:name"`);
                    return [e.slice(1, t), e.slice(t + 1)]
                }

                function i(e) {
                    return "ng-container" === r(e)[1]
                }

                function o(e) {
                    return "ng-content" === r(e)[1]
                }

                function a(e) {
                    return "ng-template" === r(e)[1]
                }

                function l(e) {
                    return null === e ? null : r(e)[0]
                }

                function c(e, t) {
                    return e ? `:${e}:${t}` : t
                }
                n.d(t, "a", function() {
                        return cp
                    }), n.d(t, "b", function() {
                        return ld
                    }), n.d(t, "c", function() {
                        return hh
                    }), n.d(t, "d", function() {
                        return dh
                    }), n.d(t, "e", function() {
                        return gh
                    }), n.d(t, "f", function() {
                        return Mc
                    }), n.d(t, "g", function() {
                        return Oc
                    }), n.d(t, "h", function() {
                        return Ha
                    }), n.d(t, "i", function() {
                        return ep
                    }), n.d(t, "j", function() {
                        return cn
                    }), n.d(t, "k", function() {
                        return rd
                    }), n.d(t, "l", function() {
                        return Zr
                    }), n.d(t, "m", function() {
                        return Zp
                    }), n.d(t, "n", function() {
                        return cc
                    }), n.d(t, "o", function() {
                        return Cp
                    }), n.d(t, "p", function() {
                        return Sp
                    }), n.d(t, "q", function() {
                        return Ec
                    }), n.d(t, "r", function() {
                        return Tp
                    }), n.d(t, "s", function() {
                        return In
                    }), n.d(t, "t", function() {
                        return Ku
                    }), n.d(t, "u", function() {
                        return dn
                    }), n.d(t, "v", function() {
                        return la
                    }), n.d(t, "w", function() {
                        return Qp
                    }), n.d(t, "x", function() {
                        return zl
                    }), n.d(t, "y", function() {
                        return cd
                    }), n.d(t, "z", function() {
                        return Op
                    }), n.d(t, "A", function() {
                        return ud
                    }), n.d(t, "B", function() {
                        return Bt
                    }),
                    function(e) {
                        e[e.RAW_TEXT = 0] = "RAW_TEXT", e[e.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", e[e.PARSABLE_DATA = 2] = "PARSABLE_DATA"
                    }(s || (s = {}));
                const u = {
                    Aacute: "\xc1",
                    aacute: "\xe1",
                    Acirc: "\xc2",
                    acirc: "\xe2",
                    acute: "\xb4",
                    AElig: "\xc6",
                    aelig: "\xe6",
                    Agrave: "\xc0",
                    agrave: "\xe0",
                    alefsym: "\u2135",
                    Alpha: "\u0391",
                    alpha: "\u03b1",
                    amp: "&",
                    and: "\u2227",
                    ang: "\u2220",
                    apos: "'",
                    Aring: "\xc5",
                    aring: "\xe5",
                    asymp: "\u2248",
                    Atilde: "\xc3",
                    atilde: "\xe3",
                    Auml: "\xc4",
                    auml: "\xe4",
                    bdquo: "\u201e",
                    Beta: "\u0392",
                    beta: "\u03b2",
                    brvbar: "\xa6",
                    bull: "\u2022",
                    cap: "\u2229",
                    Ccedil: "\xc7",
                    ccedil: "\xe7",
                    cedil: "\xb8",
                    cent: "\xa2",
                    Chi: "\u03a7",
                    chi: "\u03c7",
                    circ: "\u02c6",
                    clubs: "\u2663",
                    cong: "\u2245",
                    copy: "\xa9",
                    crarr: "\u21b5",
                    cup: "\u222a",
                    curren: "\xa4",
                    dagger: "\u2020",
                    Dagger: "\u2021",
                    darr: "\u2193",
                    dArr: "\u21d3",
                    deg: "\xb0",
                    Delta: "\u0394",
                    delta: "\u03b4",
                    diams: "\u2666",
                    divide: "\xf7",
                    Eacute: "\xc9",
                    eacute: "\xe9",
                    Ecirc: "\xca",
                    ecirc: "\xea",
                    Egrave: "\xc8",
                    egrave: "\xe8",
                    empty: "\u2205",
                    emsp: "\u2003",
                    ensp: "\u2002",
                    Epsilon: "\u0395",
                    epsilon: "\u03b5",
                    equiv: "\u2261",
                    Eta: "\u0397",
                    eta: "\u03b7",
                    ETH: "\xd0",
                    eth: "\xf0",
                    Euml: "\xcb",
                    euml: "\xeb",
                    euro: "\u20ac",
                    exist: "\u2203",
                    fnof: "\u0192",
                    forall: "\u2200",
                    frac12: "\xbd",
                    frac14: "\xbc",
                    frac34: "\xbe",
                    frasl: "\u2044",
                    Gamma: "\u0393",
                    gamma: "\u03b3",
                    ge: "\u2265",
                    gt: ">",
                    harr: "\u2194",
                    hArr: "\u21d4",
                    hearts: "\u2665",
                    hellip: "\u2026",
                    Iacute: "\xcd",
                    iacute: "\xed",
                    Icirc: "\xce",
                    icirc: "\xee",
                    iexcl: "\xa1",
                    Igrave: "\xcc",
                    igrave: "\xec",
                    image: "\u2111",
                    infin: "\u221e",
                    int: "\u222b",
                    Iota: "\u0399",
                    iota: "\u03b9",
                    iquest: "\xbf",
                    isin: "\u2208",
                    Iuml: "\xcf",
                    iuml: "\xef",
                    Kappa: "\u039a",
                    kappa: "\u03ba",
                    Lambda: "\u039b",
                    lambda: "\u03bb",
                    lang: "\u27e8",
                    laquo: "\xab",
                    larr: "\u2190",
                    lArr: "\u21d0",
                    lceil: "\u2308",
                    ldquo: "\u201c",
                    le: "\u2264",
                    lfloor: "\u230a",
                    lowast: "\u2217",
                    loz: "\u25ca",
                    lrm: "\u200e",
                    lsaquo: "\u2039",
                    lsquo: "\u2018",
                    lt: "<",
                    macr: "\xaf",
                    mdash: "\u2014",
                    micro: "\xb5",
                    middot: "\xb7",
                    minus: "\u2212",
                    Mu: "\u039c",
                    mu: "\u03bc",
                    nabla: "\u2207",
                    nbsp: "\xa0",
                    ndash: "\u2013",
                    ne: "\u2260",
                    ni: "\u220b",
                    not: "\xac",
                    notin: "\u2209",
                    nsub: "\u2284",
                    Ntilde: "\xd1",
                    ntilde: "\xf1",
                    Nu: "\u039d",
                    nu: "\u03bd",
                    Oacute: "\xd3",
                    oacute: "\xf3",
                    Ocirc: "\xd4",
                    ocirc: "\xf4",
                    OElig: "\u0152",
                    oelig: "\u0153",
                    Ograve: "\xd2",
                    ograve: "\xf2",
                    oline: "\u203e",
                    Omega: "\u03a9",
                    omega: "\u03c9",
                    Omicron: "\u039f",
                    omicron: "\u03bf",
                    oplus: "\u2295",
                    or: "\u2228",
                    ordf: "\xaa",
                    ordm: "\xba",
                    Oslash: "\xd8",
                    oslash: "\xf8",
                    Otilde: "\xd5",
                    otilde: "\xf5",
                    otimes: "\u2297",
                    Ouml: "\xd6",
                    ouml: "\xf6",
                    para: "\xb6",
                    permil: "\u2030",
                    perp: "\u22a5",
                    Phi: "\u03a6",
                    phi: "\u03c6",
                    Pi: "\u03a0",
                    pi: "\u03c0",
                    piv: "\u03d6",
                    plusmn: "\xb1",
                    pound: "\xa3",
                    prime: "\u2032",
                    Prime: "\u2033",
                    prod: "\u220f",
                    prop: "\u221d",
                    Psi: "\u03a8",
                    psi: "\u03c8",
                    quot: '"',
                    radic: "\u221a",
                    rang: "\u27e9",
                    raquo: "\xbb",
                    rarr: "\u2192",
                    rArr: "\u21d2",
                    rceil: "\u2309",
                    rdquo: "\u201d",
                    real: "\u211c",
                    reg: "\xae",
                    rfloor: "\u230b",
                    Rho: "\u03a1",
                    rho: "\u03c1",
                    rlm: "\u200f",
                    rsaquo: "\u203a",
                    rsquo: "\u2019",
                    sbquo: "\u201a",
                    Scaron: "\u0160",
                    scaron: "\u0161",
                    sdot: "\u22c5",
                    sect: "\xa7",
                    shy: "\xad",
                    Sigma: "\u03a3",
                    sigma: "\u03c3",
                    sigmaf: "\u03c2",
                    sim: "\u223c",
                    spades: "\u2660",
                    sub: "\u2282",
                    sube: "\u2286",
                    sum: "\u2211",
                    sup: "\u2283",
                    sup1: "\xb9",
                    sup2: "\xb2",
                    sup3: "\xb3",
                    supe: "\u2287",
                    szlig: "\xdf",
                    Tau: "\u03a4",
                    tau: "\u03c4",
                    there4: "\u2234",
                    Theta: "\u0398",
                    theta: "\u03b8",
                    thetasym: "\u03d1",
                    thinsp: "\u2009",
                    THORN: "\xde",
                    thorn: "\xfe",
                    tilde: "\u02dc",
                    times: "\xd7",
                    trade: "\u2122",
                    Uacute: "\xda",
                    uacute: "\xfa",
                    uarr: "\u2191",
                    uArr: "\u21d1",
                    Ucirc: "\xdb",
                    ucirc: "\xfb",
                    Ugrave: "\xd9",
                    ugrave: "\xf9",
                    uml: "\xa8",
                    upsih: "\u03d2",
                    Upsilon: "\u03a5",
                    upsilon: "\u03c5",
                    Uuml: "\xdc",
                    uuml: "\xfc",
                    weierp: "\u2118",
                    Xi: "\u039e",
                    xi: "\u03be",
                    Yacute: "\xdd",
                    yacute: "\xfd",
                    yen: "\xa5",
                    yuml: "\xff",
                    Yuml: "\u0178",
                    Zeta: "\u0396",
                    zeta: "\u03b6",
                    zwj: "\u200d",
                    zwnj: "\u200c"
                };
                u.ngsp = "\ue500";
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class h {
                    constructor({
                        closedByChildren: e,
                        implicitNamespacePrefix: t,
                        contentType: n = s.PARSABLE_DATA,
                        closedByParent: r = !1,
                        isVoid: i = !1,
                        ignoreFirstLf: o = !1,
                        preventNamespaceInheritance: a = !1
                    } = {}) {
                        this.closedByChildren = {}, this.closedByParent = !1, this.canSelfClose = !1, e && e.length > 0 && e.forEach(e => this.closedByChildren[e] = !0), this.isVoid = i, this.closedByParent = r || i, this.implicitNamespacePrefix = t || null, this.contentType = n, this.ignoreFirstLf = o, this.preventNamespaceInheritance = a
                    }
                    isClosedByChild(e) {
                        return this.isVoid || e.toLowerCase() in this.closedByChildren
                    }
                }
                let p, d;

                function f(e) {
                    var t, n;
                    return d || (p = new h, d = {
                        base: new h({
                            isVoid: !0
                        }),
                        meta: new h({
                            isVoid: !0
                        }),
                        area: new h({
                            isVoid: !0
                        }),
                        embed: new h({
                            isVoid: !0
                        }),
                        link: new h({
                            isVoid: !0
                        }),
                        img: new h({
                            isVoid: !0
                        }),
                        input: new h({
                            isVoid: !0
                        }),
                        param: new h({
                            isVoid: !0
                        }),
                        hr: new h({
                            isVoid: !0
                        }),
                        br: new h({
                            isVoid: !0
                        }),
                        source: new h({
                            isVoid: !0
                        }),
                        track: new h({
                            isVoid: !0
                        }),
                        wbr: new h({
                            isVoid: !0
                        }),
                        p: new h({
                            closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"],
                            closedByParent: !0
                        }),
                        thead: new h({
                            closedByChildren: ["tbody", "tfoot"]
                        }),
                        tbody: new h({
                            closedByChildren: ["tbody", "tfoot"],
                            closedByParent: !0
                        }),
                        tfoot: new h({
                            closedByChildren: ["tbody"],
                            closedByParent: !0
                        }),
                        tr: new h({
                            closedByChildren: ["tr"],
                            closedByParent: !0
                        }),
                        td: new h({
                            closedByChildren: ["td", "th"],
                            closedByParent: !0
                        }),
                        th: new h({
                            closedByChildren: ["td", "th"],
                            closedByParent: !0
                        }),
                        col: new h({
                            isVoid: !0
                        }),
                        svg: new h({
                            implicitNamespacePrefix: "svg"
                        }),
                        foreignObject: new h({
                            implicitNamespacePrefix: "svg",
                            preventNamespaceInheritance: !0
                        }),
                        math: new h({
                            implicitNamespacePrefix: "math"
                        }),
                        li: new h({
                            closedByChildren: ["li"],
                            closedByParent: !0
                        }),
                        dt: new h({
                            closedByChildren: ["dt", "dd"]
                        }),
                        dd: new h({
                            closedByChildren: ["dt", "dd"],
                            closedByParent: !0
                        }),
                        rb: new h({
                            closedByChildren: ["rb", "rt", "rtc", "rp"],
                            closedByParent: !0
                        }),
                        rt: new h({
                            closedByChildren: ["rb", "rt", "rtc", "rp"],
                            closedByParent: !0
                        }),
                        rtc: new h({
                            closedByChildren: ["rb", "rtc", "rp"],
                            closedByParent: !0
                        }),
                        rp: new h({
                            closedByChildren: ["rb", "rt", "rtc", "rp"],
                            closedByParent: !0
                        }),
                        optgroup: new h({
                            closedByChildren: ["optgroup"],
                            closedByParent: !0
                        }),
                        option: new h({
                            closedByChildren: ["option", "optgroup"],
                            closedByParent: !0
                        }),
                        pre: new h({
                            ignoreFirstLf: !0
                        }),
                        listing: new h({
                            ignoreFirstLf: !0
                        }),
                        style: new h({
                            contentType: s.RAW_TEXT
                        }),
                        script: new h({
                            contentType: s.RAW_TEXT
                        }),
                        title: new h({
                            contentType: s.ESCAPABLE_RAW_TEXT
                        }),
                        textarea: new h({
                            contentType: s.ESCAPABLE_RAW_TEXT,
                            ignoreFirstLf: !0
                        })
                    }), null !== (n = null !== (t = d[e]) && void 0 !== t ? t : d[e.toLowerCase()]) && void 0 !== n ? n : p
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const m = new RegExp("(\\:not\\()|(([\\.\\#]?)[-\\w]+)|(?:\\[([-.\\w*]+)(?:=([\"']?)([^\\]\"']*)\\5)?\\])|(\\))|(\\s*,\\s*)", "g");
                class g {
                    constructor() {
                        this.element = null, this.classNames = [], this.attrs = [], this.notSelectors = []
                    }
                    static parse(e) {
                        const t = [],
                            n = (e, t) => {
                                t.notSelectors.length > 0 && !t.element && 0 == t.classNames.length && 0 == t.attrs.length && (t.element = "*"), e.push(t)
                            };
                        let s, r = new g,
                            i = r,
                            o = !1;
                        for (m.lastIndex = 0; s = m.exec(e);) {
                            if (s[1]) {
                                if (o) throw new Error("Nesting :not in a selector is not allowed");
                                o = !0, i = new g, r.notSelectors.push(i)
                            }
                            const e = s[2];
                            if (e) {
                                const t = s[3];
                                "#" === t ? i.addAttribute("id", e.substr(1)) : "." === t ? i.addClassName(e.substr(1)) : i.setElement(e)
                            }
                            const a = s[4];
                            if (a && i.addAttribute(a, s[6]), s[7] && (o = !1, i = r), s[8]) {
                                if (o) throw new Error("Multiple selectors in :not are not supported");
                                n(t, r), r = i = new g
                            }
                        }
                        return n(t, r), t
                    }
                    isElementSelector() {
                        return this.hasElementSelector() && 0 == this.classNames.length && 0 == this.attrs.length && 0 === this.notSelectors.length
                    }
                    hasElementSelector() {
                        return !!this.element
                    }
                    setElement(e = null) {
                        this.element = e
                    }
                    getMatchingElementTemplate() {
                        const e = this.element || "div",
                            t = this.classNames.length > 0 ? ` class="${this.classNames.join(" ")}"` : "";
                        let n = "";
                        for (let s = 0; s < this.attrs.length; s += 2) {
                            n += ` ${this.attrs[s]}${""!==this.attrs[s+1]?`="${this.attrs[s+1]}"`:""}`
                        }
                        return f(e).isVoid ? `<${e}${t}${n}/>` : `<${e}${t}${n}></${e}>`
                    }
                    getAttrs() {
                        const e = [];
                        return this.classNames.length > 0 && e.push("class", this.classNames.join(" ")), e.concat(this.attrs)
                    }
                    addAttribute(e, t = "") {
                        this.attrs.push(e, t && t.toLowerCase() || "")
                    }
                    addClassName(e) {
                        this.classNames.push(e.toLowerCase())
                    }
                    toString() {
                        let e = this.element || "";
                        if (this.classNames && this.classNames.forEach(t => e += `.${t}`), this.attrs)
                            for (let t = 0; t < this.attrs.length; t += 2) {
                                const n = this.attrs[t],
                                    s = this.attrs[t + 1];
                                e += `[${n}${s?"="+s:""}]`
                            }
                        return this.notSelectors.forEach(t => e += `:not(${t})`), e
                    }
                }
                class y {
                    constructor() {
                        this._elementMap = new Map, this._elementPartialMap = new Map, this._classMap = new Map, this._classPartialMap = new Map, this._attrValueMap = new Map, this._attrValuePartialMap = new Map, this._listContexts = []
                    }
                    static createNotMatcher(e) {
                        const t = new y;
                        return t.addSelectables(e, null), t
                    }
                    addSelectables(e, t) {
                        let n = null;
                        e.length > 1 && (n = new v(e), this._listContexts.push(n));
                        for (let s = 0; s < e.length; s++) this._addSelectable(e[s], t, n)
                    }
                    _addSelectable(e, t, n) {
                        let s = this;
                        const r = e.element,
                            i = e.classNames,
                            o = e.attrs,
                            a = new _(e, t, n);
                        if (r) {
                            0 === o.length && 0 === i.length ? this._addTerminal(s._elementMap, r, a) : s = this._addPartial(s._elementPartialMap, r)
                        }
                        if (i)
                            for (let l = 0; l < i.length; l++) {
                                const e = 0 === o.length && l === i.length - 1,
                                    t = i[l];
                                e ? this._addTerminal(s._classMap, t, a) : s = this._addPartial(s._classPartialMap, t)
                            }
                        if (o)
                            for (let l = 0; l < o.length; l += 2) {
                                const e = l === o.length - 2,
                                    t = o[l],
                                    n = o[l + 1];
                                if (e) {
                                    const e = s._attrValueMap;
                                    let r = e.get(t);
                                    r || (r = new Map, e.set(t, r)), this._addTerminal(r, n, a)
                                } else {
                                    const e = s._attrValuePartialMap;
                                    let r = e.get(t);
                                    r || (r = new Map, e.set(t, r)), s = this._addPartial(r, n)
                                }
                            }
                    }
                    _addTerminal(e, t, n) {
                        let s = e.get(t);
                        s || (s = [], e.set(t, s)), s.push(n)
                    }
                    _addPartial(e, t) {
                        let n = e.get(t);
                        return n || (n = new y, e.set(t, n)), n
                    }
                    match(e, t) {
                        let n = !1;
                        const s = e.element,
                            r = e.classNames,
                            i = e.attrs;
                        for (let o = 0; o < this._listContexts.length; o++) this._listContexts[o].alreadyMatched = !1;
                        if (n = this._matchTerminal(this._elementMap, s, e, t) || n, n = this._matchPartial(this._elementPartialMap, s, e, t) || n, r)
                            for (let o = 0; o < r.length; o++) {
                                const s = r[o];
                                n = this._matchTerminal(this._classMap, s, e, t) || n, n = this._matchPartial(this._classPartialMap, s, e, t) || n
                            }
                        if (i)
                            for (let o = 0; o < i.length; o += 2) {
                                const s = i[o],
                                    r = i[o + 1],
                                    a = this._attrValueMap.get(s);
                                r && (n = this._matchTerminal(a, "", e, t) || n), n = this._matchTerminal(a, r, e, t) || n;
                                const l = this._attrValuePartialMap.get(s);
                                r && (n = this._matchPartial(l, "", e, t) || n), n = this._matchPartial(l, r, e, t) || n
                            }
                        return n
                    }
                    _matchTerminal(e, t, n, s) {
                        if (!e || "string" != typeof t) return !1;
                        let r = e.get(t) || [];
                        const i = e.get("*");
                        if (i && (r = r.concat(i)), 0 === r.length) return !1;
                        let o, a = !1;
                        for (let l = 0; l < r.length; l++) o = r[l], a = o.finalize(n, s) || a;
                        return a
                    }
                    _matchPartial(e, t, n, s) {
                        if (!e || "string" != typeof t) return !1;
                        const r = e.get(t);
                        return !!r && r.match(n, s)
                    }
                }
                class v {
                    constructor(e) {
                        this.selectors = e, this.alreadyMatched = !1
                    }
                }
                class _ {
                    constructor(e, t, n) {
                        this.selector = e, this.cbContext = t, this.listContext = n, this.notSelectors = e.notSelectors
                    }
                    finalize(e, t) {
                        let n = !0;
                        if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {
                            n = !y.createNotMatcher(this.notSelectors).match(e, null)
                        }
                        return !n || !t || this.listContext && this.listContext.alreadyMatched || (this.listContext && (this.listContext.alreadyMatched = !0), t(this.selector, this.cbContext)), n
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const b = G("Inject", e => ({
                        token: e
                    })),
                    w = G("InjectionToken", e => ({
                        _desc: e,
                        "\u0275prov": void 0
                    })),
                    E = G("Attribute", e => ({
                        attributeName: e
                    })),
                    C = G("ContentChildren", (e, t = {}) => Object.assign({
                        selector: e,
                        first: !1,
                        isViewQuery: !1,
                        descendants: !1
                    }, t)),
                    S = G("ContentChild", (e, t = {}) => Object.assign({
                        selector: e,
                        first: !0,
                        isViewQuery: !1,
                        descendants: !0
                    }, t)),
                    x = G("ViewChildren", (e, t = {}) => Object.assign({
                        selector: e,
                        first: !1,
                        isViewQuery: !0,
                        descendants: !0
                    }, t)),
                    T = G("ViewChild", (e, t) => Object.assign({
                        selector: e,
                        first: !0,
                        isViewQuery: !0,
                        descendants: !0
                    }, t)),
                    A = G("Directive", (e = {}) => e);
                var D, P;
                ! function(e) {
                    e[e.Emulated = 0] = "Emulated", e[e.None = 2] = "None", e[e.ShadowDom = 3] = "ShadowDom"
                }(D || (D = {})),
                function(e) {
                    e[e.OnPush = 0] = "OnPush", e[e.Default = 1] = "Default"
                }(P || (P = {}));
                const k = G("Component", (e = {}) => Object.assign({
                        changeDetection: P.Default
                    }, e)),
                    O = G("Pipe", e => Object.assign({
                        pure: !0
                    }, e)),
                    I = G("Input", e => ({
                        bindingPropertyName: e
                    })),
                    N = G("Output", e => ({
                        bindingPropertyName: e
                    })),
                    M = G("HostBinding", e => ({
                        hostPropertyName: e
                    })),
                    F = G("HostListener", (e, t) => ({
                        eventName: e,
                        args: t
                    })),
                    R = G("NgModule", e => e),
                    j = G("Injectable", (e = {}) => e),
                    L = {
                        name: "custom-elements"
                    },
                    V = {
                        name: "no-errors-schema"
                    },
                    $ = G("Optional"),
                    B = G("Self"),
                    H = G("SkipSelf"),
                    U = G("Host"),
                    q = Function;
                var z, W;

                function G(e, t) {
                    function n(...n) {
                        const s = t ? t(...n) : {};
                        return Object.assign({
                            ngMetadataName: e
                        }, s)
                    }
                    return n.isTypeOf = t => t && t.ngMetadataName === e, n.ngMetadataName = e, n
                }

                function K(e) {
                    const t = function(e) {
                            const t = e.classNames && e.classNames.length ? [8, ...e.classNames] : [];
                            return [e.element && "*" !== e.element ? e.element : "", ...e.attrs, ...t]
                        }(e),
                        n = e.notSelectors && e.notSelectors.length ? e.notSelectors.map(e => function(e) {
                            const t = e.classNames && e.classNames.length ? [8, ...e.classNames] : [];
                            return e.element ? [5, e.element, ...e.attrs, ...t] : e.attrs.length ? [3, ...e.attrs, ...t] : e.classNames && e.classNames.length ? [9, ...e.classNames] : []
                        }(e)) : [];
                    return t.concat(...n)
                }

                function Q(e) {
                    return e ? g.parse(e).map(K) : []
                }! function(e) {
                    e[e.NONE = 0] = "NONE", e[e.HTML = 1] = "HTML", e[e.STYLE = 2] = "STYLE", e[e.SCRIPT = 3] = "SCRIPT", e[e.URL = 4] = "URL", e[e.RESOURCE_URL = 5] = "RESOURCE_URL"
                }(z || (z = {})),
                function(e) {
                    e[e.Error = 0] = "Error", e[e.Warning = 1] = "Warning", e[e.Ignore = 2] = "Ignore"
                }(W || (W = {}));
                var Z, J;
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                ! function(e) {
                    e[e.Const = 0] = "Const"
                }(Z || (Z = {}));
                class X {
                    constructor(e = []) {
                        this.modifiers = e
                    }
                    hasModifier(e) {
                        return -1 !== this.modifiers.indexOf(e)
                    }
                }! function(e) {
                    e[e.Dynamic = 0] = "Dynamic", e[e.Bool = 1] = "Bool", e[e.String = 2] = "String", e[e.Int = 3] = "Int", e[e.Number = 4] = "Number", e[e.Function = 5] = "Function", e[e.Inferred = 6] = "Inferred", e[e.None = 7] = "None"
                }(J || (J = {}));
                class Y extends X {
                    constructor(e, t) {
                        super(t), this.name = e
                    }
                    visitType(e, t) {
                        return e.visitBuiltinType(this, t)
                    }
                }
                class ee extends X {
                    constructor(e, t, n = null) {
                        super(t), this.value = e, this.typeParams = n
                    }
                    visitType(e, t) {
                        return e.visitExpressionType(this, t)
                    }
                }
                class te extends X {
                    constructor(e, t) {
                        super(t), this.of = e
                    }
                    visitType(e, t) {
                        return e.visitArrayType(this, t)
                    }
                }
                class ne extends X {
                    constructor(e, t) {
                        super(t), this.valueType = e || null
                    }
                    visitType(e, t) {
                        return e.visitMapType(this, t)
                    }
                }
                const se = new Y(J.Dynamic),
                    re = new Y(J.Inferred),
                    ie = new Y(J.Bool),
                    oe = (new Y(J.Int), new Y(J.Number)),
                    ae = new Y(J.String),
                    le = (new Y(J.Function), new Y(J.None));
                var ce, ue, he, pe;

                function de(e, t) {
                    return null == e || null == t ? e == t : e.isEquivalent(t)
                }

                function fe(e, t) {
                    const n = e.length;
                    if (n !== t.length) return !1;
                    for (let s = 0; s < n; s++)
                        if (!e[s].isEquivalent(t[s])) return !1;
                    return !0
                }! function(e) {
                    e[e.Minus = 0] = "Minus", e[e.Plus = 1] = "Plus"
                }(ce || (ce = {})),
                function(e) {
                    e[e.Equals = 0] = "Equals", e[e.NotEquals = 1] = "NotEquals", e[e.Identical = 2] = "Identical", e[e.NotIdentical = 3] = "NotIdentical", e[e.Minus = 4] = "Minus", e[e.Plus = 5] = "Plus", e[e.Divide = 6] = "Divide", e[e.Multiply = 7] = "Multiply", e[e.Modulo = 8] = "Modulo", e[e.And = 9] = "And", e[e.Or = 10] = "Or", e[e.BitwiseAnd = 11] = "BitwiseAnd", e[e.Lower = 12] = "Lower", e[e.LowerEquals = 13] = "LowerEquals", e[e.Bigger = 14] = "Bigger", e[e.BiggerEquals = 15] = "BiggerEquals"
                }(ue || (ue = {}));
                class me {
                    constructor(e, t) {
                        this.type = e || null, this.sourceSpan = t || null
                    }
                    prop(e, t) {
                        return new Ue(this, e, null, t)
                    }
                    key(e, t, n) {
                        return new qe(this, e, t, n)
                    }
                    callMethod(e, t, n) {
                        return new Ee(this, e, t, null, n)
                    }
                    callFn(e, t, n) {
                        return new Ce(this, e, null, t, n)
                    }
                    instantiate(e, t, n) {
                        return new Se(this, e, t, n)
                    }
                    conditional(e, t = null, n) {
                        return new Fe(this, e, t, null, n)
                    }
                    equals(e, t) {
                        return new He(ue.Equals, this, e, null, t)
                    }
                    notEquals(e, t) {
                        return new He(ue.NotEquals, this, e, null, t)
                    }
                    identical(e, t) {
                        return new He(ue.Identical, this, e, null, t)
                    }
                    notIdentical(e, t) {
                        return new He(ue.NotIdentical, this, e, null, t)
                    }
                    minus(e, t) {
                        return new He(ue.Minus, this, e, null, t)
                    }
                    plus(e, t) {
                        return new He(ue.Plus, this, e, null, t)
                    }
                    divide(e, t) {
                        return new He(ue.Divide, this, e, null, t)
                    }
                    multiply(e, t) {
                        return new He(ue.Multiply, this, e, null, t)
                    }
                    modulo(e, t) {
                        return new He(ue.Modulo, this, e, null, t)
                    }
                    and(e, t) {
                        return new He(ue.And, this, e, null, t)
                    }
                    bitwiseAnd(e, t, n = !0) {
                        return new He(ue.BitwiseAnd, this, e, null, t, n)
                    }
                    or(e, t) {
                        return new He(ue.Or, this, e, null, t)
                    }
                    lower(e, t) {
                        return new He(ue.Lower, this, e, null, t)
                    }
                    lowerEquals(e, t) {
                        return new He(ue.LowerEquals, this, e, null, t)
                    }
                    bigger(e, t) {
                        return new He(ue.Bigger, this, e, null, t)
                    }
                    biggerEquals(e, t) {
                        return new He(ue.BiggerEquals, this, e, null, t)
                    }
                    isBlank(e) {
                        return this.equals(Ze, e)
                    }
                    cast(e, t) {
                        return new Le(this, e, t)
                    }
                    toStmt() {
                        return new st(this, null)
                    }
                }! function(e) {
                    e[e.This = 0] = "This", e[e.Super = 1] = "Super", e[e.CatchError = 2] = "CatchError", e[e.CatchStack = 3] = "CatchStack"
                }(he || (he = {}));
                class ge extends me {
                    constructor(e, t, n) {
                        super(t, n), "string" == typeof e ? (this.name = e, this.builtin = null) : (this.name = null, this.builtin = e)
                    }
                    isEquivalent(e) {
                        return e instanceof ge && this.name === e.name && this.builtin === e.builtin
                    }
                    isConstant() {
                        return !1
                    }
                    visitExpression(e, t) {
                        return e.visitReadVarExpr(this, t)
                    }
                    set(e) {
                        if (!this.name) throw new Error(`Built in variable ${this.builtin} can not be assigned to.`);
                        return new _e(this.name, e, null, this.sourceSpan)
                    }
                }
                class ye extends me {
                    constructor(e, t, n) {
                        super(t, n), this.expr = e
                    }
                    visitExpression(e, t) {
                        return e.visitTypeofExpr(this, t)
                    }
                    isEquivalent(e) {
                        return e instanceof ye && e.expr.isEquivalent(this.expr)
                    }
                    isConstant() {
                        return this.expr.isConstant()
                    }
                }
                class ve extends me {
                    constructor(e, t, n) {
                        super(t, n), this.node = e
                    }
                    isEquivalent(e) {
                        return e instanceof ve && this.node === e.node
                    }
                    isConstant() {
                        return !1
                    }
                    visitExpression(e, t) {
                        return e.visitWrappedNodeExpr(this, t)
                    }
                }
                class _e extends me {
                    constructor(e, t, n, s) {
                        super(n || t.type, s), this.name = e, this.value = t
                    }
                    isEquivalent(e) {
                        return e instanceof _e && this.name === e.name && this.value.isEquivalent(e.value)
                    }
                    isConstant() {
                        return !1
                    }
                    visitExpression(e, t) {
                        return e.visitWriteVarExpr(this, t)
                    }
                    toDeclStmt(e, t) {
                        return new tt(this.name, this.value, e, t, this.sourceSpan)
                    }
                    toConstDecl() {
                        return this.toDeclStmt(re, [Je.Final])
                    }
                }
                class be extends me {
                    constructor(e, t, n, s, r) {
                        super(s || n.type, r), this.receiver = e, this.index = t, this.value = n
                    }
                    isEquivalent(e) {
                        return e instanceof be && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value)
                    }
                    isConstant() {
                        return !1
                    }
                    visitExpression(e, t) {
                        return e.visitWriteKeyExpr(this, t)
                    }
                }
                class we extends me {
                    constructor(e, t, n, s, r) {
                        super(s || n.type, r), this.receiver = e, this.name = t, this.value = n
                    }
                    isEquivalent(e) {
                        return e instanceof we && this.receiver.isEquivalent(e.receiver) && this.name === e.name && this.value.isEquivalent(e.value)
                    }
                    isConstant() {
                        return !1
                    }
                    visitExpression(e, t) {
                        return e.visitWritePropExpr(this, t)
                    }
                }! function(e) {
                    e[e.ConcatArray = 0] = "ConcatArray", e[e.SubscribeObservable = 1] = "SubscribeObservable", e[e.Bind = 2] = "Bind"
                }(pe || (pe = {}));
                class Ee extends me {
                    constructor(e, t, n, s, r) {
                        super(s, r), this.receiver = e, this.args = n, "string" == typeof t ? (this.name = t, this.builtin = null) : (this.name = null, this.builtin = t)
                    }
                    isEquivalent(e) {
                        return e instanceof Ee && this.receiver.isEquivalent(e.receiver) && this.name === e.name && this.builtin === e.builtin && fe(this.args, e.args)
                    }
                    isConstant() {
                        return !1
                    }
                    visitExpression(e, t) {
                        return e.visitInvokeMethodExpr(this, t)
                    }
                }
                class Ce extends me {
                    constructor(e, t, n, s, r = !1) {
                        super(n, s), this.fn = e, this.args = t, this.pure = r
                    }
                    isEquivalent(e) {
                        return e instanceof Ce && this.fn.isEquivalent(e.fn) && fe(this.args, e.args) && this.pure === e.pure
                    }
                    isConstant() {
                        return !1
                    }
                    visitExpression(e, t) {
                        return e.visitInvokeFunctionExpr(this, t)
                    }
                }
                class Se extends me {
                    constructor(e, t, n, s) {
                        super(n, s), this.classExpr = e, this.args = t
                    }
                    isEquivalent(e) {
                        return e instanceof Se && this.classExpr.isEquivalent(e.classExpr) && fe(this.args, e.args)
                    }
                    isConstant() {
                        return !1
                    }
                    visitExpression(e, t) {
                        return e.visitInstantiateExpr(this, t)
                    }
                }
                class xe extends me {
                    constructor(e, t, n) {
                        super(t, n), this.value = e
                    }
                    isEquivalent(e) {
                        return e instanceof xe && this.value === e.value
                    }
                    isConstant() {
                        return !0
                    }
                    visitExpression(e, t) {
                        return e.visitLiteralExpr(this, t)
                    }
                }
                class Te {
                    constructor(e, t) {
                        this.text = e, this.sourceSpan = t
                    }
                }
                class Ae extends Te {}
                class De extends Te {}
                class Pe extends me {
                    constructor(e, t, n, s, r) {
                        super(ae, r), this.metaBlock = e, this.messageParts = t, this.placeHolderNames = n, this.expressions = s
                    }
                    isEquivalent(e) {
                        return !1
                    }
                    isConstant() {
                        return !1
                    }
                    visitExpression(e, t) {
                        return e.visitLocalizedString(this, t)
                    }
                    serializeI18nHead() {
                        let e = this.metaBlock.description || "";
                        return this.metaBlock.meaning && (e = `${this.metaBlock.meaning}|${e}`), this.metaBlock.customId && (e = `${e}@@${this.metaBlock.customId}`), this.metaBlock.legacyIds && this.metaBlock.legacyIds.forEach(t => {
                            e = `${e}\u241f${t}`
                        }), Ne(e, this.messageParts[0].text, this.getMessagePartSourceSpan(0))
                    }
                    getMessagePartSourceSpan(e) {
                        var t, n;
                        return null !== (n = null === (t = this.messageParts[e]) || void 0 === t ? void 0 : t.sourceSpan) && void 0 !== n ? n : this.sourceSpan
                    }
                    getPlaceholderSourceSpan(e) {
                        var t, n, s, r;
                        return null !== (r = null !== (n = null === (t = this.placeHolderNames[e]) || void 0 === t ? void 0 : t.sourceSpan) && void 0 !== n ? n : null === (s = this.expressions[e]) || void 0 === s ? void 0 : s.sourceSpan) && void 0 !== r ? r : this.sourceSpan
                    }
                    serializeI18nTemplatePart(e) {
                        return Ne(this.placeHolderNames[e - 1].text, this.messageParts[e].text, this.getMessagePartSourceSpan(e))
                    }
                }
                const ke = e => e.replace(/\\/g, "\\\\"),
                    Oe = e => e.replace(/:/g, "\\:"),
                    Ie = e => e.replace(/`/g, "\\`").replace(/\${/g, "$\\{");

                function Ne(e, t, n) {
                    return "" === e ? {
                        cooked: t,
                        raw: Ie((s = ke(t), s.replace(/^:/, "\\:"))),
                        range: n
                    } : {
                        cooked: `:${e}:${t}`,
                        raw: Ie(`:${Oe(ke(e))}:${ke(t)}`),
                        range: n
                    };
                    var s
                }
                class Me extends me {
                    constructor(e, t, n = null, s) {
                        super(t, s), this.value = e, this.typeParams = n
                    }
                    isEquivalent(e) {
                        return e instanceof Me && this.value.name === e.value.name && this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime
                    }
                    isConstant() {
                        return !1
                    }
                    visitExpression(e, t) {
                        return e.visitExternalExpr(this, t)
                    }
                }
                class Fe extends me {
                    constructor(e, t, n = null, s, r) {
                        super(s || t.type, r), this.condition = e, this.falseCase = n, this.trueCase = t
                    }
                    isEquivalent(e) {
                        return e instanceof Fe && this.condition.isEquivalent(e.condition) && this.trueCase.isEquivalent(e.trueCase) && de(this.falseCase, e.falseCase)
                    }
                    isConstant() {
                        return !1
                    }
                    visitExpression(e, t) {
                        return e.visitConditionalExpr(this, t)
                    }
                }
                class Re extends me {
                    constructor(e, t) {
                        super(ie, t), this.condition = e
                    }
                    isEquivalent(e) {
                        return e instanceof Re && this.condition.isEquivalent(e.condition)
                    }
                    isConstant() {
                        return !1
                    }
                    visitExpression(e, t) {
                        return e.visitNotExpr(this, t)
                    }
                }
                class je extends me {
                    constructor(e, t) {
                        super(e.type, t), this.condition = e
                    }
                    isEquivalent(e) {
                        return e instanceof je && this.condition.isEquivalent(e.condition)
                    }
                    isConstant() {
                        return !1
                    }
                    visitExpression(e, t) {
                        return e.visitAssertNotNullExpr(this, t)
                    }
                }
                class Le extends me {
                    constructor(e, t, n) {
                        super(t, n), this.value = e
                    }
                    isEquivalent(e) {
                        return e instanceof Le && this.value.isEquivalent(e.value)
                    }
                    isConstant() {
                        return !1
                    }
                    visitExpression(e, t) {
                        return e.visitCastExpr(this, t)
                    }
                }
                class Ve {
                    constructor(e, t = null) {
                        this.name = e, this.type = t
                    }
                    isEquivalent(e) {
                        return this.name === e.name
                    }
                }
                class $e extends me {
                    constructor(e, t, n, s, r) {
                        super(n, s), this.params = e, this.statements = t, this.name = r
                    }
                    isEquivalent(e) {
                        return e instanceof $e && fe(this.params, e.params) && fe(this.statements, e.statements)
                    }
                    isConstant() {
                        return !1
                    }
                    visitExpression(e, t) {
                        return e.visitFunctionExpr(this, t)
                    }
                    toDeclStmt(e, t) {
                        return new nt(e, this.params, this.statements, this.type, t, this.sourceSpan)
                    }
                }
                class Be extends me {
                    constructor(e, t, n, s, r = !0) {
                        super(n || oe, s), this.operator = e, this.expr = t, this.parens = r
                    }
                    isEquivalent(e) {
                        return e instanceof Be && this.operator === e.operator && this.expr.isEquivalent(e.expr)
                    }
                    isConstant() {
                        return !1
                    }
                    visitExpression(e, t) {
                        return e.visitUnaryOperatorExpr(this, t)
                    }
                }
                class He extends me {
                    constructor(e, t, n, s, r, i = !0) {
                        super(s || t.type, r), this.operator = e, this.rhs = n, this.parens = i, this.lhs = t
                    }
                    isEquivalent(e) {
                        return e instanceof He && this.operator === e.operator && this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs)
                    }
                    isConstant() {
                        return !1
                    }
                    visitExpression(e, t) {
                        return e.visitBinaryOperatorExpr(this, t)
                    }
                }
                class Ue extends me {
                    constructor(e, t, n, s) {
                        super(n, s), this.receiver = e, this.name = t
                    }
                    isEquivalent(e) {
                        return e instanceof Ue && this.receiver.isEquivalent(e.receiver) && this.name === e.name
                    }
                    isConstant() {
                        return !1
                    }
                    visitExpression(e, t) {
                        return e.visitReadPropExpr(this, t)
                    }
                    set(e) {
                        return new we(this.receiver, this.name, e, null, this.sourceSpan)
                    }
                }
                class qe extends me {
                    constructor(e, t, n, s) {
                        super(n, s), this.receiver = e, this.index = t
                    }
                    isEquivalent(e) {
                        return e instanceof qe && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index)
                    }
                    isConstant() {
                        return !1
                    }
                    visitExpression(e, t) {
                        return e.visitReadKeyExpr(this, t)
                    }
                    set(e) {
                        return new be(this.receiver, this.index, e, null, this.sourceSpan)
                    }
                }
                class ze extends me {
                    constructor(e, t, n) {
                        super(t, n), this.entries = e
                    }
                    isConstant() {
                        return this.entries.every(e => e.isConstant())
                    }
                    isEquivalent(e) {
                        return e instanceof ze && fe(this.entries, e.entries)
                    }
                    visitExpression(e, t) {
                        return e.visitLiteralArrayExpr(this, t)
                    }
                }
                class We {
                    constructor(e, t, n) {
                        this.key = e, this.value = t, this.quoted = n
                    }
                    isEquivalent(e) {
                        return this.key === e.key && this.value.isEquivalent(e.value)
                    }
                }
                class Ge extends me {
                    constructor(e, t, n) {
                        super(t, n), this.entries = e, this.valueType = null, t && (this.valueType = t.valueType)
                    }
                    isEquivalent(e) {
                        return e instanceof Ge && fe(this.entries, e.entries)
                    }
                    isConstant() {
                        return this.entries.every(e => e.value.isConstant())
                    }
                    visitExpression(e, t) {
                        return e.visitLiteralMapExpr(this, t)
                    }
                }
                class Ke extends me {
                    constructor(e, t) {
                        super(e[e.length - 1].type, t), this.parts = e
                    }
                    isEquivalent(e) {
                        return e instanceof Ke && fe(this.parts, e.parts)
                    }
                    isConstant() {
                        return !1
                    }
                    visitExpression(e, t) {
                        return e.visitCommaExpr(this, t)
                    }
                }
                new ge(he.This, null, null), new ge(he.Super, null, null), new ge(he.CatchError, null, null), new ge(he.CatchStack, null, null);
                const Qe = new xe(null, null, null),
                    Ze = new xe(null, re, null);
                var Je;
                ! function(e) {
                    e[e.Final = 0] = "Final", e[e.Private = 1] = "Private", e[e.Exported = 2] = "Exported", e[e.Static = 3] = "Static"
                }(Je || (Je = {}));
                class Xe {
                    constructor(e, t, n) {
                        this.text = e, this.multiline = t, this.trailingNewline = n
                    }
                    toString() {
                        return this.multiline ? ` ${this.text} ` : this.text
                    }
                }
                class Ye extends Xe {
                    constructor(e) {
                        super("", !0, !0), this.tags = e
                    }
                    toString() {
                        return function(e) {
                            if (0 === e.length) return "";
                            if (1 === e.length && e[0].tagName && !e[0].text) return `*${Pt(e[0])} `;
                            let t = "*\n";
                            for (const n of e) t += " *", t += Pt(n).replace(/\n/g, "\n * "), t += "\n";
                            return t += " ", t
                        }
                        /**
                         * @license
                         * Copyright Google LLC All Rights Reserved.
                         *
                         * Use of this source code is governed by an MIT-style license that can be
                         * found in the LICENSE file at https://angular.io/license
                         */
                        (this.tags)
                    }
                }
                class et {
                    constructor(e = [], t = null, n) {
                        this.modifiers = e, this.sourceSpan = t, this.leadingComments = n
                    }
                    hasModifier(e) {
                        return -1 !== this.modifiers.indexOf(e)
                    }
                    addLeadingComment(e) {
                        var t;
                        this.leadingComments = null !== (t = this.leadingComments) && void 0 !== t ? t : [], this.leadingComments.push(e)
                    }
                }
                class tt extends et {
                    constructor(e, t, n, s, r, i) {
                        super(s, r, i), this.name = e, this.value = t, this.type = n || t && t.type || null
                    }
                    isEquivalent(e) {
                        return e instanceof tt && this.name === e.name && (this.value ? !!e.value && this.value.isEquivalent(e.value) : !e.value)
                    }
                    visitStatement(e, t) {
                        return e.visitDeclareVarStmt(this, t)
                    }
                }
                class nt extends et {
                    constructor(e, t, n, s, r, i, o) {
                        super(r, i, o), this.name = e, this.params = t, this.statements = n, this.type = s || null
                    }
                    isEquivalent(e) {
                        return e instanceof nt && fe(this.params, e.params) && fe(this.statements, e.statements)
                    }
                    visitStatement(e, t) {
                        return e.visitDeclareFunctionStmt(this, t)
                    }
                }
                class st extends et {
                    constructor(e, t, n) {
                        super([], t, n), this.expr = e
                    }
                    isEquivalent(e) {
                        return e instanceof st && this.expr.isEquivalent(e.expr)
                    }
                    visitStatement(e, t) {
                        return e.visitExpressionStmt(this, t)
                    }
                }
                class rt extends et {
                    constructor(e, t = null, n) {
                        super([], t, n), this.value = e
                    }
                    isEquivalent(e) {
                        return e instanceof rt && this.value.isEquivalent(e.value)
                    }
                    visitStatement(e, t) {
                        return e.visitReturnStmt(this, t)
                    }
                }
                class it {
                    constructor(e = null, t = []) {
                        this.type = e, this.modifiers = t
                    }
                    hasModifier(e) {
                        return -1 !== this.modifiers.indexOf(e)
                    }
                }
                class ot extends it {
                    constructor(e, t, n, s, r) {
                        super(s, r), this.name = e, this.params = t, this.body = n
                    }
                    isEquivalent(e) {
                        return this.name === e.name && fe(this.body, e.body)
                    }
                }
                class at extends it {
                    constructor(e, t, n, s) {
                        super(n, s), this.name = e, this.body = t
                    }
                    isEquivalent(e) {
                        return this.name === e.name && fe(this.body, e.body)
                    }
                }
                class lt extends et {
                    constructor(e, t, n, s, r, i, o, a, l) {
                        super(o, a, l), this.name = e, this.parent = t, this.fields = n, this.getters = s, this.constructorMethod = r, this.methods = i
                    }
                    isEquivalent(e) {
                        return e instanceof lt && this.name === e.name && de(this.parent, e.parent) && fe(this.fields, e.fields) && fe(this.getters, e.getters) && this.constructorMethod.isEquivalent(e.constructorMethod) && fe(this.methods, e.methods)
                    }
                    visitStatement(e, t) {
                        return e.visitDeclareClassStmt(this, t)
                    }
                }
                class ct extends et {
                    constructor(e, t, n = [], s, r) {
                        super([], s, r), this.condition = e, this.trueCase = t, this.falseCase = n
                    }
                    isEquivalent(e) {
                        return e instanceof ct && this.condition.isEquivalent(e.condition) && fe(this.trueCase, e.trueCase) && fe(this.falseCase, e.falseCase)
                    }
                    visitStatement(e, t) {
                        return e.visitIfStmt(this, t)
                    }
                }
                class ut extends et {
                    constructor(e, t, n = null, s) {
                        super([], n, s), this.bodyStmts = e, this.catchStmts = t
                    }
                    isEquivalent(e) {
                        return e instanceof ut && fe(this.bodyStmts, e.bodyStmts) && fe(this.catchStmts, e.catchStmts)
                    }
                    visitStatement(e, t) {
                        return e.visitTryCatchStmt(this, t)
                    }
                }
                class ht extends et {
                    constructor(e, t = null, n) {
                        super([], t, n), this.error = e
                    }
                    isEquivalent(e) {
                        return e instanceof ut && this.error.isEquivalent(e.error)
                    }
                    visitStatement(e, t) {
                        return e.visitThrowStmt(this, t)
                    }
                }
                class pt {
                    visitType(e, t) {
                        return e
                    }
                    visitExpression(e, t) {
                        return e.type && e.type.visitType(this, t), e
                    }
                    visitBuiltinType(e, t) {
                        return this.visitType(e, t)
                    }
                    visitExpressionType(e, t) {
                        return e.value.visitExpression(this, t), null !== e.typeParams && e.typeParams.forEach(e => this.visitType(e, t)), this.visitType(e, t)
                    }
                    visitArrayType(e, t) {
                        return this.visitType(e, t)
                    }
                    visitMapType(e, t) {
                        return this.visitType(e, t)
                    }
                    visitWrappedNodeExpr(e, t) {
                        return e
                    }
                    visitTypeofExpr(e, t) {
                        return this.visitExpression(e, t)
                    }
                    visitReadVarExpr(e, t) {
                        return this.visitExpression(e, t)
                    }
                    visitWriteVarExpr(e, t) {
                        return e.value.visitExpression(this, t), this.visitExpression(e, t)
                    }
                    visitWriteKeyExpr(e, t) {
                        return e.receiver.visitExpression(this, t), e.index.visitExpression(this, t), e.value.visitExpression(this, t), this.visitExpression(e, t)
                    }
                    visitWritePropExpr(e, t) {
                        return e.receiver.visitExpression(this, t), e.value.visitExpression(this, t), this.visitExpression(e, t)
                    }
                    visitInvokeMethodExpr(e, t) {
                        return e.receiver.visitExpression(this, t), this.visitAllExpressions(e.args, t), this.visitExpression(e, t)
                    }
                    visitInvokeFunctionExpr(e, t) {
                        return e.fn.visitExpression(this, t), this.visitAllExpressions(e.args, t), this.visitExpression(e, t)
                    }
                    visitInstantiateExpr(e, t) {
                        return e.classExpr.visitExpression(this, t), this.visitAllExpressions(e.args, t), this.visitExpression(e, t)
                    }
                    visitLiteralExpr(e, t) {
                        return this.visitExpression(e, t)
                    }
                    visitLocalizedString(e, t) {
                        return this.visitExpression(e, t)
                    }
                    visitExternalExpr(e, t) {
                        return e.typeParams && e.typeParams.forEach(e => e.visitType(this, t)), this.visitExpression(e, t)
                    }
                    visitConditionalExpr(e, t) {
                        return e.condition.visitExpression(this, t), e.trueCase.visitExpression(this, t), e.falseCase.visitExpression(this, t), this.visitExpression(e, t)
                    }
                    visitNotExpr(e, t) {
                        return e.condition.visitExpression(this, t), this.visitExpression(e, t)
                    }
                    visitAssertNotNullExpr(e, t) {
                        return e.condition.visitExpression(this, t), this.visitExpression(e, t)
                    }
                    visitCastExpr(e, t) {
                        return e.value.visitExpression(this, t), this.visitExpression(e, t)
                    }
                    visitFunctionExpr(e, t) {
                        return this.visitAllStatements(e.statements, t), this.visitExpression(e, t)
                    }
                    visitUnaryOperatorExpr(e, t) {
                        return e.expr.visitExpression(this, t), this.visitExpression(e, t)
                    }
                    visitBinaryOperatorExpr(e, t) {
                        return e.lhs.visitExpression(this, t), e.rhs.visitExpression(this, t), this.visitExpression(e, t)
                    }
                    visitReadPropExpr(e, t) {
                        return e.receiver.visitExpression(this, t), this.visitExpression(e, t)
                    }
                    visitReadKeyExpr(e, t) {
                        return e.receiver.visitExpression(this, t), e.index.visitExpression(this, t), this.visitExpression(e, t)
                    }
                    visitLiteralArrayExpr(e, t) {
                        return this.visitAllExpressions(e.entries, t), this.visitExpression(e, t)
                    }
                    visitLiteralMapExpr(e, t) {
                        return e.entries.forEach(e => e.value.visitExpression(this, t)), this.visitExpression(e, t)
                    }
                    visitCommaExpr(e, t) {
                        return this.visitAllExpressions(e.parts, t), this.visitExpression(e, t)
                    }
                    visitAllExpressions(e, t) {
                        e.forEach(e => e.visitExpression(this, t))
                    }
                    visitDeclareVarStmt(e, t) {
                        return e.value && e.value.visitExpression(this, t), e.type && e.type.visitType(this, t), e
                    }
                    visitDeclareFunctionStmt(e, t) {
                        return this.visitAllStatements(e.statements, t), e.type && e.type.visitType(this, t), e
                    }
                    visitExpressionStmt(e, t) {
                        return e.expr.visitExpression(this, t), e
                    }
                    visitReturnStmt(e, t) {
                        return e.value.visitExpression(this, t), e
                    }
                    visitDeclareClassStmt(e, t) {
                        return e.parent.visitExpression(this, t), e.getters.forEach(e => this.visitAllStatements(e.body, t)), e.constructorMethod && this.visitAllStatements(e.constructorMethod.body, t), e.methods.forEach(e => this.visitAllStatements(e.body, t)), e
                    }
                    visitIfStmt(e, t) {
                        return e.condition.visitExpression(this, t), this.visitAllStatements(e.trueCase, t), this.visitAllStatements(e.falseCase, t), e
                    }
                    visitTryCatchStmt(e, t) {
                        return this.visitAllStatements(e.bodyStmts, t), this.visitAllStatements(e.catchStmts, t), e
                    }
                    visitThrowStmt(e, t) {
                        return e.error.visitExpression(this, t), e
                    }
                    visitAllStatements(e, t) {
                        e.forEach(e => e.visitStatement(this, t))
                    }
                }

                function dt(e) {
                    const t = new ft;
                    return t.visitAllStatements(e, null), t.varNames
                }
                class ft extends pt {
                    constructor() {
                        super(...arguments), this.varNames = new Set
                    }
                    visitDeclareFunctionStmt(e, t) {
                        return e
                    }
                    visitDeclareClassStmt(e, t) {
                        return e
                    }
                    visitReadVarExpr(e, t) {
                        return e.name && this.varNames.add(e.name), null
                    }
                }

                function mt(e, t) {
                    if (!t) return e;
                    const n = new yt(t);
                    return e.visitStatement(n, null)
                }

                function gt(e, t) {
                    if (!t) return e;
                    const n = new yt(t);
                    return e.visitExpression(n, null)
                }
                class yt extends class {
                    transformExpr(e, t) {
                        return e
                    }
                    transformStmt(e, t) {
                        return e
                    }
                    visitReadVarExpr(e, t) {
                        return this.transformExpr(e, t)
                    }
                    visitWrappedNodeExpr(e, t) {
                        return this.transformExpr(e, t)
                    }
                    visitTypeofExpr(e, t) {
                        return this.transformExpr(new ye(e.expr.visitExpression(this, t), e.type, e.sourceSpan), t)
                    }
                    visitWriteVarExpr(e, t) {
                        return this.transformExpr(new _e(e.name, e.value.visitExpression(this, t), e.type, e.sourceSpan), t)
                    }
                    visitWriteKeyExpr(e, t) {
                        return this.transformExpr(new be(e.receiver.visitExpression(this, t), e.index.visitExpression(this, t), e.value.visitExpression(this, t), e.type, e.sourceSpan), t)
                    }
                    visitWritePropExpr(e, t) {
                        return this.transformExpr(new we(e.receiver.visitExpression(this, t), e.name, e.value.visitExpression(this, t), e.type, e.sourceSpan), t)
                    }
                    visitInvokeMethodExpr(e, t) {
                        const n = e.builtin || e.name;
                        return this.transformExpr(new Ee(e.receiver.visitExpression(this, t), n, this.visitAllExpressions(e.args, t), e.type, e.sourceSpan), t)
                    }
                    visitInvokeFunctionExpr(e, t) {
                        return this.transformExpr(new Ce(e.fn.visitExpression(this, t), this.visitAllExpressions(e.args, t), e.type, e.sourceSpan), t)
                    }
                    visitInstantiateExpr(e, t) {
                        return this.transformExpr(new Se(e.classExpr.visitExpression(this, t), this.visitAllExpressions(e.args, t), e.type, e.sourceSpan), t)
                    }
                    visitLiteralExpr(e, t) {
                        return this.transformExpr(e, t)
                    }
                    visitLocalizedString(e, t) {
                        return this.transformExpr(new Pe(e.metaBlock, e.messageParts, e.placeHolderNames, this.visitAllExpressions(e.expressions, t), e.sourceSpan), t)
                    }
                    visitExternalExpr(e, t) {
                        return this.transformExpr(e, t)
                    }
                    visitConditionalExpr(e, t) {
                        return this.transformExpr(new Fe(e.condition.visitExpression(this, t), e.trueCase.visitExpression(this, t), e.falseCase.visitExpression(this, t), e.type, e.sourceSpan), t)
                    }
                    visitNotExpr(e, t) {
                        return this.transformExpr(new Re(e.condition.visitExpression(this, t), e.sourceSpan), t)
                    }
                    visitAssertNotNullExpr(e, t) {
                        return this.transformExpr(new je(e.condition.visitExpression(this, t), e.sourceSpan), t)
                    }
                    visitCastExpr(e, t) {
                        return this.transformExpr(new Le(e.value.visitExpression(this, t), e.type, e.sourceSpan), t)
                    }
                    visitFunctionExpr(e, t) {
                        return this.transformExpr(new $e(e.params, this.visitAllStatements(e.statements, t), e.type, e.sourceSpan), t)
                    }
                    visitUnaryOperatorExpr(e, t) {
                        return this.transformExpr(new Be(e.operator, e.expr.visitExpression(this, t), e.type, e.sourceSpan), t)
                    }
                    visitBinaryOperatorExpr(e, t) {
                        return this.transformExpr(new He(e.operator, e.lhs.visitExpression(this, t), e.rhs.visitExpression(this, t), e.type, e.sourceSpan), t)
                    }
                    visitReadPropExpr(e, t) {
                        return this.transformExpr(new Ue(e.receiver.visitExpression(this, t), e.name, e.type, e.sourceSpan), t)
                    }
                    visitReadKeyExpr(e, t) {
                        return this.transformExpr(new qe(e.receiver.visitExpression(this, t), e.index.visitExpression(this, t), e.type, e.sourceSpan), t)
                    }
                    visitLiteralArrayExpr(e, t) {
                        return this.transformExpr(new ze(this.visitAllExpressions(e.entries, t), e.type, e.sourceSpan), t)
                    }
                    visitLiteralMapExpr(e, t) {
                        const n = e.entries.map(e => new We(e.key, e.value.visitExpression(this, t), e.quoted)),
                            s = new ne(e.valueType);
                        return this.transformExpr(new Ge(n, s, e.sourceSpan), t)
                    }
                    visitCommaExpr(e, t) {
                        return this.transformExpr(new Ke(this.visitAllExpressions(e.parts, t), e.sourceSpan), t)
                    }
                    visitAllExpressions(e, t) {
                        return e.map(e => e.visitExpression(this, t))
                    }
                    visitDeclareVarStmt(e, t) {
                        const n = e.value && e.value.visitExpression(this, t);
                        return this.transformStmt(new tt(e.name, n, e.type, e.modifiers, e.sourceSpan, e.leadingComments), t)
                    }
                    visitDeclareFunctionStmt(e, t) {
                        return this.transformStmt(new nt(e.name, e.params, this.visitAllStatements(e.statements, t), e.type, e.modifiers, e.sourceSpan, e.leadingComments), t)
                    }
                    visitExpressionStmt(e, t) {
                        return this.transformStmt(new st(e.expr.visitExpression(this, t), e.sourceSpan, e.leadingComments), t)
                    }
                    visitReturnStmt(e, t) {
                        return this.transformStmt(new rt(e.value.visitExpression(this, t), e.sourceSpan, e.leadingComments), t)
                    }
                    visitDeclareClassStmt(e, t) {
                        const n = e.parent.visitExpression(this, t),
                            s = e.getters.map(e => new at(e.name, this.visitAllStatements(e.body, t), e.type, e.modifiers)),
                            r = e.constructorMethod && new ot(e.constructorMethod.name, e.constructorMethod.params, this.visitAllStatements(e.constructorMethod.body, t), e.constructorMethod.type, e.constructorMethod.modifiers),
                            i = e.methods.map(e => new ot(e.name, e.params, this.visitAllStatements(e.body, t), e.type, e.modifiers));
                        return this.transformStmt(new lt(e.name, n, e.fields, s, r, i, e.modifiers, e.sourceSpan), t)
                    }
                    visitIfStmt(e, t) {
                        return this.transformStmt(new ct(e.condition.visitExpression(this, t), this.visitAllStatements(e.trueCase, t), this.visitAllStatements(e.falseCase, t), e.sourceSpan, e.leadingComments), t)
                    }
                    visitTryCatchStmt(e, t) {
                        return this.transformStmt(new ut(this.visitAllStatements(e.bodyStmts, t), this.visitAllStatements(e.catchStmts, t), e.sourceSpan, e.leadingComments), t)
                    }
                    visitThrowStmt(e, t) {
                        return this.transformStmt(new ht(e.error.visitExpression(this, t), e.sourceSpan, e.leadingComments), t)
                    }
                    visitAllStatements(e, t) {
                        return e.map(e => e.visitStatement(this, t))
                    }
                } {
                    constructor(e) {
                        super(), this.sourceSpan = e
                    }
                    _clone(e) {
                        const t = Object.create(e.constructor.prototype);
                        for (let n of Object.keys(e)) t[n] = e[n];
                        return t
                    }
                    transformExpr(e, t) {
                        return e.sourceSpan || ((e = this._clone(e)).sourceSpan = this.sourceSpan), e
                    }
                    transformStmt(e, t) {
                        return e.sourceSpan || ((e = this._clone(e)).sourceSpan = this.sourceSpan), e
                    }
                }

                function vt(e, t, n) {
                    return new ge(e, t, n)
                }

                function _t(e, t = null, n) {
                    return new Me(e, null, t, n)
                }

                function bt(e, t, n) {
                    return null != e ? wt(_t(e, t, null), n) : null
                }

                function wt(e, t, n) {
                    return new ee(e, t, n)
                }

                function Et(e) {
                    return new ye(e)
                }

                function Ct(e, t, n) {
                    return new ze(e, t, n)
                }

                function St(e, t = null) {
                    return new Ge(e.map(e => new We(e.key, e.value, e.quoted)), t, null)
                }

                function xt(e, t, n, s, r) {
                    return new $e(e, t, n, s, r)
                }

                function Tt(e, t, n, s, r) {
                    return new ct(e, t, n, s, r)
                }

                function At(e, t, n) {
                    return new xe(e, t, n)
                }

                function Dt(e) {
                    return e instanceof xe && null === e.value
                }

                function Pt(e) {
                    let t = "";
                    if (e.tagName && (t += ` @${e.tagName}`), e.text) {
                        if (e.text.match(/\/\*|\*\//)) throw new Error('JSDoc text cannot contain "/*" and "*/"');
                        t += " " + e.text.replace(/@/g, "\\@")
                    }
                    return t
                }
                const kt = /-+([a-z0-9])/g;

                function Ot(e, t) {
                    return It(e, ":", t)
                }

                function It(e, t, n) {
                    const s = e.indexOf(t);
                    return -1 == s ? n : [e.slice(0, s).trim(), e.slice(s + 1).trim()]
                }

                function Nt(e, t, n) {
                    return Array.isArray(e) ? t.visitArray(e, n) : "object" == typeof(s = e) && null !== s && Object.getPrototypeOf(s) === qt ? t.visitStringMap(e, n) : null == e || "string" == typeof e || "number" == typeof e || "boolean" == typeof e ? t.visitPrimitive(e, n) : t.visitOther(e, n);
                    var s
                }

                function Mt(e) {
                    return null != e
                }

                function Ft(e) {
                    return void 0 === e ? null : e
                }
                class Rt {
                    visitArray(e, t) {
                        return e.map(e => Nt(e, this, t))
                    }
                    visitStringMap(e, t) {
                        const n = {};
                        return Object.keys(e).forEach(s => {
                            n[s] = Nt(e[s], this, t)
                        }), n
                    }
                    visitPrimitive(e, t) {
                        return e
                    }
                    visitOther(e, t) {
                        return e
                    }
                }
                const jt = e => {
                        if (Kt(e)) throw new Error("Illegal state: value cannot be a promise");
                        return e
                    },
                    Lt = (e, t) => Kt(e) ? e.then(t) : t(e),
                    Vt = e => e.some(Kt) ? Promise.all(e) : e;

                function $t(e) {
                    throw new Error(`Internal Error: ${e}`)
                }

                function Bt(e, t) {
                    const n = Error(e);
                    return n[Ht] = !0, t && (n[Ut] = t), n
                }
                const Ht = "ngSyntaxError",
                    Ut = "ngParseErrors";
                const qt = Object.getPrototypeOf({});

                function zt(e) {
                    let t = [];
                    for (let n = 0; n < e.length; n++) {
                        let s = e.charCodeAt(n);
                        if (s >= 55296 && s <= 56319 && e.length > n + 1) {
                            const t = e.charCodeAt(n + 1);
                            t >= 56320 && t <= 57343 && (n++, s = (s - 55296 << 10) + t - 56320 + 65536)
                        }
                        s <= 127 ? t.push(s) : s <= 2047 ? t.push(s >> 6 & 31 | 192, 63 & s | 128) : s <= 65535 ? t.push(s >> 12 | 224, s >> 6 & 63 | 128, 63 & s | 128) : s <= 2097151 && t.push(s >> 18 & 7 | 240, s >> 12 & 63 | 128, s >> 6 & 63 | 128, 63 & s | 128)
                    }
                    return t
                }

                function Wt(e) {
                    if ("string" == typeof e) return e;
                    if (Array.isArray(e)) return "[" + e.map(Wt).join(", ") + "]";
                    if (null == e) return "" + e;
                    if (e.overriddenName) return `${e.overriddenName}`;
                    if (e.name) return `${e.name}`;
                    if (!e.toString) return "object";
                    const t = e.toString();
                    if (null == t) return "" + t;
                    const n = t.indexOf("\n");
                    return -1 === n ? t : t.substring(0, n)
                }

                function Gt(e) {
                    return "function" == typeof e && e.hasOwnProperty("__forward_ref__") ? e() : e
                }

                function Kt(e) {
                    return !!e && "function" == typeof e.then
                }
                const Qt = "undefined" != typeof window && window,
                    Zt = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self,
                    Jt = void 0 !== e && e || Qt || Zt;

                function Xt(e, t) {
                    const n = [];
                    for (let s = 0; s < e; s++) n.push(t);
                    return n
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Yt = vt("<unknown>"),
                    en = {};
                class tn extends me {
                    constructor(e) {
                        super(e.type), this.resolved = e, this.original = e
                    }
                    visitExpression(e, t) {
                        return t === en ? this.original.visitExpression(e, t) : this.resolved.visitExpression(e, t)
                    }
                    isEquivalent(e) {
                        return e instanceof tn && this.resolved.isEquivalent(e.resolved)
                    }
                    isConstant() {
                        return !0
                    }
                    fixup(e) {
                        this.resolved = e, this.shared = !0
                    }
                }
                class nn {
                    constructor(e = !1) {
                        this.isClosureCompilerEnabled = e, this.statements = [], this.literals = new Map, this.literalFactories = new Map, this.injectorDefinitions = new Map, this.directiveDefinitions = new Map, this.componentDefinitions = new Map, this.pipeDefinitions = new Map, this.nextNameIndex = 0
                    }
                    getConstLiteral(e, t) {
                        if (e instanceof xe && !an(e) || e instanceof tn) return e;
                        const n = this.keyOf(e);
                        let s = this.literals.get(n),
                            r = !1;
                        if (s || (s = new tn(e), this.literals.set(n, s), r = !0), !r && !s.shared || r && t) {
                            const t = this.freshName();
                            let n, r;
                            this.isClosureCompilerEnabled && an(e) ? (n = vt(t).set(new $e([], [new rt(e)])), r = vt(t).callFn([])) : (n = vt(t).set(e), r = vt(t)), this.statements.push(n.toDeclStmt(re, [Je.Final])), s.fixup(r)
                        }
                        return s
                    }
                    getDefinition(e, t, n, s = !1) {
                        const r = this.definitionsOf(t);
                        let i = r.get(e),
                            o = !1;
                        if (!i) {
                            const s = this.propertyNameOf(t);
                            i = new tn(n.importExpr(e).prop(s)), r.set(e, i), o = !0
                        }
                        if (!o && !i.shared || o && s) {
                            const e = this.freshName();
                            this.statements.push(vt(e).set(i.resolved).toDeclStmt(re, [Je.Final])), i.fixup(vt(e))
                        }
                        return i
                    }
                    getLiteralFactory(e) {
                        if (e instanceof ze) {
                            const t = e.entries.map(e => e.isConstant() ? e : Yt),
                                n = this.keyOf(Ct(t));
                            return this._getLiteralFactory(n, e.entries, e => Ct(e))
                        } {
                            const t = St(e.entries.map(e => ({
                                    key: e.key,
                                    value: e.value.isConstant() ? e.value : Yt,
                                    quoted: e.quoted
                                }))),
                                n = this.keyOf(t);
                            return this._getLiteralFactory(n, e.entries.map(e => e.value), t => St(t.map((t, n) => ({
                                key: e.entries[n].key,
                                value: t,
                                quoted: e.entries[n].quoted
                            }))))
                        }
                    }
                    _getLiteralFactory(e, t, n) {
                        let s = this.literalFactories.get(e);
                        const r = t.filter(e => !e.isConstant());
                        if (!s) {
                            const r = t.map((e, t) => e.isConstant() ? this.getConstLiteral(e, !0) : vt(`a${t}`)),
                                i = xt(r.filter(on).map(e => new Ve(e.name, se)), [new rt(n(r))], re),
                                o = this.freshName();
                            this.statements.push(vt(o).set(i).toDeclStmt(re, [Je.Final])), s = vt(o), this.literalFactories.set(e, s)
                        }
                        return {
                            literalFactory: s,
                            literalFactoryArguments: r
                        }
                    }
                    uniqueName(e) {
                        return `${e}${this.nextNameIndex++}`
                    }
                    definitionsOf(e) {
                        switch (e) {
                            case 2:
                                return this.componentDefinitions;
                            case 1:
                                return this.directiveDefinitions;
                            case 0:
                                return this.injectorDefinitions;
                            case 3:
                                return this.pipeDefinitions
                        }
                        return $t(`Unknown definition kind ${e}`), this.componentDefinitions
                    }
                    propertyNameOf(e) {
                        switch (e) {
                            case 2:
                                return "\u0275cmp";
                            case 1:
                                return "\u0275dir";
                            case 0:
                                return "\u0275inj";
                            case 3:
                                return "\u0275pipe"
                        }
                        return $t(`Unknown definition kind ${e}`), "<unknown>"
                    }
                    freshName() {
                        return this.uniqueName("_c")
                    }
                    keyOf(e) {
                        return e.visitExpression(new sn, en)
                    }
                }
                class sn {
                    constructor() {
                        this.visitWrappedNodeExpr = rn, this.visitWriteVarExpr = rn, this.visitWriteKeyExpr = rn, this.visitWritePropExpr = rn, this.visitInvokeMethodExpr = rn, this.visitInvokeFunctionExpr = rn, this.visitInstantiateExpr = rn, this.visitConditionalExpr = rn, this.visitNotExpr = rn, this.visitAssertNotNullExpr = rn, this.visitCastExpr = rn, this.visitFunctionExpr = rn, this.visitUnaryOperatorExpr = rn, this.visitBinaryOperatorExpr = rn, this.visitReadPropExpr = rn, this.visitReadKeyExpr = rn, this.visitCommaExpr = rn, this.visitLocalizedString = rn
                    }
                    visitLiteralExpr(e) {
                        return `${"string"==typeof e.value?'"'+e.value+'"':e.value}`
                    }
                    visitLiteralArrayExpr(e, t) {
                        return `[${e.entries.map(e=>e.visitExpression(this,t)).join(",")}]`
                    }
                    visitLiteralMapExpr(e, t) {
                        return `{${e.entries.map(e=>`${(e=>{const t=e.quoted?'"':"";return`${t}${e.key}${t}`})(e)}:${e.value.visitExpression(this,t)}`).join(",")}`
                    }
                    visitExternalExpr(e) {
                        return e.value.moduleName ? `EX:${e.value.moduleName}:${e.value.name}` : `EX:${e.value.runtime.name}`
                    }
                    visitReadVarExpr(e) {
                        return `VAR:${e.name}`
                    }
                    visitTypeofExpr(e, t) {
                        return `TYPEOF:${e.expr.visitExpression(this,t)}`
                    }
                }

                function rn(e) {
                    throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${e.constructor.name}`)
                }

                function on(e) {
                    return e instanceof ge
                }

                function an(e) {
                    return e instanceof xe && "string" == typeof e.value && e.value.length >= 50
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const ln = "@angular/core";
                class cn {}

                function un(e) {
                    return {
                        identifier: {
                            reference: e
                        }
                    }
                }

                function hn(e, t) {
                    return un(e.resolveExternalReference(t))
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                cn.ANALYZE_FOR_ENTRY_COMPONENTS = {
                    name: "ANALYZE_FOR_ENTRY_COMPONENTS",
                    moduleName: ln
                }, cn.ElementRef = {
                    name: "ElementRef",
                    moduleName: ln
                }, cn.NgModuleRef = {
                    name: "NgModuleRef",
                    moduleName: ln
                }, cn.ViewContainerRef = {
                    name: "ViewContainerRef",
                    moduleName: ln
                }, cn.ChangeDetectorRef = {
                    name: "ChangeDetectorRef",
                    moduleName: ln
                }, cn.QueryList = {
                    name: "QueryList",
                    moduleName: ln
                }, cn.TemplateRef = {
                    name: "TemplateRef",
                    moduleName: ln
                }, cn.Renderer2 = {
                    name: "Renderer2",
                    moduleName: ln
                }, cn.CodegenComponentFactoryResolver = {
                    name: "\u0275CodegenComponentFactoryResolver",
                    moduleName: ln
                }, cn.ComponentFactoryResolver = {
                    name: "ComponentFactoryResolver",
                    moduleName: ln
                }, cn.ComponentFactory = {
                    name: "ComponentFactory",
                    moduleName: ln
                }, cn.ComponentRef = {
                    name: "ComponentRef",
                    moduleName: ln
                }, cn.NgModuleFactory = {
                    name: "NgModuleFactory",
                    moduleName: ln
                }, cn.createModuleFactory = {
                    name: "\u0275cmf",
                    moduleName: ln
                }, cn.moduleDef = {
                    name: "\u0275mod",
                    moduleName: ln
                }, cn.moduleProviderDef = {
                    name: "\u0275mpd",
                    moduleName: ln
                }, cn.RegisterModuleFactoryFn = {
                    name: "\u0275registerModuleFactory",
                    moduleName: ln
                }, cn.inject = {
                    name: "\u0275\u0275inject",
                    moduleName: ln
                }, cn.directiveInject = {
                    name: "\u0275\u0275directiveInject",
                    moduleName: ln
                }, cn.INJECTOR = {
                    name: "INJECTOR",
                    moduleName: ln
                }, cn.Injector = {
                    name: "Injector",
                    moduleName: ln
                }, cn.\u0275\ u0275defineInjectable = {
                    name: "\u0275\u0275defineInjectable",
                    moduleName: ln
                }, cn.InjectableDef = {
                    name: "\u0275\u0275InjectableDef",
                    moduleName: ln
                }, cn.ViewEncapsulation = {
                    name: "ViewEncapsulation",
                    moduleName: ln
                }, cn.ChangeDetectionStrategy = {
                    name: "ChangeDetectionStrategy",
                    moduleName: ln
                }, cn.SecurityContext = {
                    name: "SecurityContext",
                    moduleName: ln
                }, cn.LOCALE_ID = {
                    name: "LOCALE_ID",
                    moduleName: ln
                }, cn.TRANSLATIONS_FORMAT = {
                    name: "TRANSLATIONS_FORMAT",
                    moduleName: ln
                }, cn.inlineInterpolate = {
                    name: "\u0275inlineInterpolate",
                    moduleName: ln
                }, cn.interpolate = {
                    name: "\u0275interpolate",
                    moduleName: ln
                }, cn.EMPTY_ARRAY = {
                    name: "\u0275EMPTY_ARRAY",
                    moduleName: ln
                }, cn.EMPTY_MAP = {
                    name: "\u0275EMPTY_MAP",
                    moduleName: ln
                }, cn.Renderer = {
                    name: "Renderer",
                    moduleName: ln
                }, cn.viewDef = {
                    name: "\u0275vid",
                    moduleName: ln
                }, cn.elementDef = {
                    name: "\u0275eld",
                    moduleName: ln
                }, cn.anchorDef = {
                    name: "\u0275and",
                    moduleName: ln
                }, cn.textDef = {
                    name: "\u0275ted",
                    moduleName: ln
                }, cn.directiveDef = {
                    name: "\u0275did",
                    moduleName: ln
                }, cn.providerDef = {
                    name: "\u0275prd",
                    moduleName: ln
                }, cn.queryDef = {
                    name: "\u0275qud",
                    moduleName: ln
                }, cn.pureArrayDef = {
                    name: "\u0275pad",
                    moduleName: ln
                }, cn.pureObjectDef = {
                    name: "\u0275pod",
                    moduleName: ln
                }, cn.purePipeDef = {
                    name: "\u0275ppd",
                    moduleName: ln
                }, cn.pipeDef = {
                    name: "\u0275pid",
                    moduleName: ln
                }, cn.nodeValue = {
                    name: "\u0275nov",
                    moduleName: ln
                }, cn.ngContentDef = {
                    name: "\u0275ncd",
                    moduleName: ln
                }, cn.unwrapValue = {
                    name: "\u0275unv",
                    moduleName: ln
                }, cn.createRendererType2 = {
                    name: "\u0275crt",
                    moduleName: ln
                }, cn.RendererType2 = {
                    name: "RendererType2",
                    moduleName: ln
                }, cn.ViewDefinition = {
                    name: "\u0275ViewDefinition",
                    moduleName: ln
                }, cn.createComponentFactory = {
                    name: "\u0275ccf",
                    moduleName: ln
                }, cn.setClassMetadata = {
                    name: "\u0275setClassMetadata",
                    moduleName: ln
                };
                class pn {
                    constructor(e, t, n) {
                        this.filePath = e, this.name = t, this.members = n
                    }
                    assertNoMembers() {
                        if (this.members.length) throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`)
                    }
                }
                class dn {
                    constructor() {
                        this.cache = new Map
                    }
                    get(e, t, n) {
                        const s = `"${e}".${t}${(n=n||[]).length?`.${n.join(".")}`:""}`;
                        let r = this.cache.get(s);
                        return r || (r = new pn(e, t, n), this.cache.set(s, r)), r
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const fn = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;

                function mn(e) {
                    return e.replace(/\W/g, "_")
                }
                let gn = 0;

                function yn(e) {
                    if (!e || !e.reference) return null;
                    const t = e.reference;
                    if (t instanceof pn) return t.name;
                    if (t.__anonymousType) return t.__anonymousType;
                    let n = Wt(t);
                    return n.indexOf("(") >= 0 ? (n = "anonymous_" + gn++, t.__anonymousType = n) : n = mn(n), n
                }

                function vn(e) {
                    const t = e.reference;
                    return t instanceof pn ? t.filePath : `./${Wt(t)}`
                }

                function _n(e, t) {
                    return `View_${yn({reference:e})}_${t}`
                }

                function bn(e) {
                    return `RenderType_${yn({reference:e})}`
                }

                function wn(e) {
                    return `${yn({reference:e})}NgFactory`
                }
                var En;

                function Cn(e) {
                    return null != e.value ? mn(e.value) : yn(e.identifier)
                }

                function Sn(e) {
                    return null != e.identifier ? e.identifier.reference : e.value
                }! function(e) {
                    e[e.Pipe = 0] = "Pipe", e[e.Directive = 1] = "Directive", e[e.NgModule = 2] = "NgModule", e[e.Injectable = 3] = "Injectable"
                }(En || (En = {}));
                class xn {
                    constructor({
                        moduleUrl: e,
                        styles: t,
                        styleUrls: n
                    } = {}) {
                        this.moduleUrl = e || null, this.styles = On(t), this.styleUrls = On(n)
                    }
                }
                class Tn {
                    constructor({
                        encapsulation: e,
                        template: t,
                        templateUrl: n,
                        htmlAst: s,
                        styles: r,
                        styleUrls: i,
                        externalStylesheets: o,
                        animations: a,
                        ngContentSelectors: l,
                        interpolation: c,
                        isInline: u,
                        preserveWhitespaces: h
                    }) {
                        if (this.encapsulation = e, this.template = t, this.templateUrl = n, this.htmlAst = s, this.styles = On(r), this.styleUrls = On(i), this.externalStylesheets = On(o), this.animations = a ? Nn(a) : [], this.ngContentSelectors = l || [], c && 2 != c.length) throw new Error("'interpolation' should have a start and an end symbol.");
                        this.interpolation = c, this.isInline = u, this.preserveWhitespaces = h
                    }
                    toSummary() {
                        return {
                            ngContentSelectors: this.ngContentSelectors,
                            encapsulation: this.encapsulation,
                            styles: this.styles,
                            animations: this.animations
                        }
                    }
                }
                class An {
                    constructor({
                        isHost: e,
                        type: t,
                        isComponent: n,
                        selector: s,
                        exportAs: r,
                        changeDetection: i,
                        inputs: o,
                        outputs: a,
                        hostListeners: l,
                        hostProperties: c,
                        hostAttributes: u,
                        providers: h,
                        viewProviders: p,
                        queries: d,
                        guards: f,
                        viewQueries: m,
                        entryComponents: g,
                        template: y,
                        componentViewType: v,
                        rendererType: _,
                        componentFactory: b
                    }) {
                        this.isHost = !!e, this.type = t, this.isComponent = n, this.selector = s, this.exportAs = r, this.changeDetection = i, this.inputs = o, this.outputs = a, this.hostListeners = l, this.hostProperties = c, this.hostAttributes = u, this.providers = On(h), this.viewProviders = On(p), this.queries = On(d), this.guards = f, this.viewQueries = On(m), this.entryComponents = On(g), this.template = y, this.componentViewType = v, this.rendererType = _, this.componentFactory = b
                    }
                    static create({
                        isHost: e,
                        type: t,
                        isComponent: n,
                        selector: s,
                        exportAs: r,
                        changeDetection: i,
                        inputs: o,
                        outputs: a,
                        host: l,
                        providers: c,
                        viewProviders: u,
                        queries: h,
                        guards: p,
                        viewQueries: d,
                        entryComponents: f,
                        template: m,
                        componentViewType: g,
                        rendererType: y,
                        componentFactory: v
                    }) {
                        const _ = {},
                            b = {},
                            w = {};
                        null != l && Object.keys(l).forEach(e => {
                            const t = l[e],
                                n = e.match(fn);
                            null === n ? w[e] = t : null != n[1] ? b[n[1]] = t : null != n[2] && (_[n[2]] = t)
                        });
                        const E = {};
                        null != o && o.forEach(e => {
                            const t = Ot(e, [e, e]);
                            E[t[0]] = t[1]
                        });
                        const C = {};
                        return null != a && a.forEach(e => {
                            const t = Ot(e, [e, e]);
                            C[t[0]] = t[1]
                        }), new An({
                            isHost: e,
                            type: t,
                            isComponent: !!n,
                            selector: s,
                            exportAs: r,
                            changeDetection: i,
                            inputs: E,
                            outputs: C,
                            hostListeners: _,
                            hostProperties: b,
                            hostAttributes: w,
                            providers: c,
                            viewProviders: u,
                            queries: h,
                            guards: p,
                            viewQueries: d,
                            entryComponents: f,
                            template: m,
                            componentViewType: g,
                            rendererType: y,
                            componentFactory: v
                        })
                    }
                    toSummary() {
                        return {
                            summaryKind: En.Directive,
                            type: this.type,
                            isComponent: this.isComponent,
                            selector: this.selector,
                            exportAs: this.exportAs,
                            inputs: this.inputs,
                            outputs: this.outputs,
                            hostListeners: this.hostListeners,
                            hostProperties: this.hostProperties,
                            hostAttributes: this.hostAttributes,
                            providers: this.providers,
                            viewProviders: this.viewProviders,
                            queries: this.queries,
                            guards: this.guards,
                            viewQueries: this.viewQueries,
                            entryComponents: this.entryComponents,
                            changeDetection: this.changeDetection,
                            template: this.template && this.template.toSummary(),
                            componentViewType: this.componentViewType,
                            rendererType: this.rendererType,
                            componentFactory: this.componentFactory
                        }
                    }
                }
                class Dn {
                    constructor({
                        type: e,
                        name: t,
                        pure: n
                    }) {
                        this.type = e, this.name = t, this.pure = !!n
                    }
                    toSummary() {
                        return {
                            summaryKind: En.Pipe,
                            type: this.type,
                            name: this.name,
                            pure: this.pure
                        }
                    }
                }
                class Pn {
                    constructor({
                        type: e,
                        providers: t,
                        declaredDirectives: n,
                        exportedDirectives: s,
                        declaredPipes: r,
                        exportedPipes: i,
                        entryComponents: o,
                        bootstrapComponents: a,
                        importedModules: l,
                        exportedModules: c,
                        schemas: u,
                        transitiveModule: h,
                        id: p
                    }) {
                        this.type = e || null, this.declaredDirectives = On(n), this.exportedDirectives = On(s), this.declaredPipes = On(r), this.exportedPipes = On(i), this.providers = On(t), this.entryComponents = On(o), this.bootstrapComponents = On(a), this.importedModules = On(l), this.exportedModules = On(c), this.schemas = On(u), this.id = p || null, this.transitiveModule = h || null
                    }
                    toSummary() {
                        const e = this.transitiveModule;
                        return {
                            summaryKind: En.NgModule,
                            type: this.type,
                            entryComponents: e.entryComponents,
                            providers: e.providers,
                            modules: e.modules,
                            exportedDirectives: e.exportedDirectives,
                            exportedPipes: e.exportedPipes
                        }
                    }
                }
                class kn {
                    constructor() {
                        this.directivesSet = new Set, this.directives = [], this.exportedDirectivesSet = new Set, this.exportedDirectives = [], this.pipesSet = new Set, this.pipes = [], this.exportedPipesSet = new Set, this.exportedPipes = [], this.modulesSet = new Set, this.modules = [], this.entryComponentsSet = new Set, this.entryComponents = [], this.providers = []
                    }
                    addProvider(e, t) {
                        this.providers.push({
                            provider: e,
                            module: t
                        })
                    }
                    addDirective(e) {
                        this.directivesSet.has(e.reference) || (this.directivesSet.add(e.reference), this.directives.push(e))
                    }
                    addExportedDirective(e) {
                        this.exportedDirectivesSet.has(e.reference) || (this.exportedDirectivesSet.add(e.reference), this.exportedDirectives.push(e))
                    }
                    addPipe(e) {
                        this.pipesSet.has(e.reference) || (this.pipesSet.add(e.reference), this.pipes.push(e))
                    }
                    addExportedPipe(e) {
                        this.exportedPipesSet.has(e.reference) || (this.exportedPipesSet.add(e.reference), this.exportedPipes.push(e))
                    }
                    addModule(e) {
                        this.modulesSet.has(e.reference) || (this.modulesSet.add(e.reference), this.modules.push(e))
                    }
                    addEntryComponent(e) {
                        this.entryComponentsSet.has(e.componentType) || (this.entryComponentsSet.add(e.componentType), this.entryComponents.push(e))
                    }
                }

                function On(e) {
                    return e || []
                }
                class In {
                    constructor(e, {
                        useClass: t,
                        useValue: n,
                        useExisting: s,
                        useFactory: r,
                        deps: i,
                        multi: o
                    }) {
                        this.token = e, this.useClass = t || null, this.useValue = n, this.useExisting = s, this.useFactory = r || null, this.dependencies = i || null, this.multi = !!o
                    }
                }

                function Nn(e) {
                    return e.reduce((e, t) => {
                        const n = Array.isArray(t) ? Nn(t) : t;
                        return e.concat(n)
                    }, [])
                }

                function Mn(e) {
                    return e.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///")
                }

                function Fn(e, t, n) {
                    let s;
                    return s = n.isInline ? t.type.reference instanceof pn ? `${t.type.reference.filePath}.${t.type.reference.name}.html` : `${yn(e)}/${yn(t.type)}.html` : n.templateUrl, t.type.reference instanceof pn ? s : Mn(s)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Rn = "@angular/core";
                class jn {}
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function Ln(e) {
                    return St(Object.keys(e).map(t => ({
                        key: t,
                        value: e[t],
                        quoted: !1
                    })))
                }

                function Vn(e, t) {
                    if (0 === t) return wt(e);
                    const n = [];
                    for (let s = 0; s < t; s++) n.push(se);
                    return wt(e, void 0, n)
                }
                jn.NEW_METHOD = "factory", jn.TRANSFORM_METHOD = "transform", jn.PATCH_DEPS = "patchedDeps", jn.namespaceHTML = {
                    name: "\u0275\u0275namespaceHTML",
                    moduleName: Rn
                }, jn.namespaceMathML = {
                    name: "\u0275\u0275namespaceMathML",
                    moduleName: Rn
                }, jn.namespaceSVG = {
                    name: "\u0275\u0275namespaceSVG",
                    moduleName: Rn
                }, jn.element = {
                    name: "\u0275\u0275element",
                    moduleName: Rn
                }, jn.elementStart = {
                    name: "\u0275\u0275elementStart",
                    moduleName: Rn
                }, jn.elementEnd = {
                    name: "\u0275\u0275elementEnd",
                    moduleName: Rn
                }, jn.advance = {
                    name: "\u0275\u0275advance",
                    moduleName: Rn
                }, jn.syntheticHostProperty = {
                    name: "\u0275\u0275syntheticHostProperty",
                    moduleName: Rn
                }, jn.syntheticHostListener = {
                    name: "\u0275\u0275syntheticHostListener",
                    moduleName: Rn
                }, jn.attribute = {
                    name: "\u0275\u0275attribute",
                    moduleName: Rn
                }, jn.attributeInterpolate1 = {
                    name: "\u0275\u0275attributeInterpolate1",
                    moduleName: Rn
                }, jn.attributeInterpolate2 = {
                    name: "\u0275\u0275attributeInterpolate2",
                    moduleName: Rn
                }, jn.attributeInterpolate3 = {
                    name: "\u0275\u0275attributeInterpolate3",
                    moduleName: Rn
                }, jn.attributeInterpolate4 = {
                    name: "\u0275\u0275attributeInterpolate4",
                    moduleName: Rn
                }, jn.attributeInterpolate5 = {
                    name: "\u0275\u0275attributeInterpolate5",
                    moduleName: Rn
                }, jn.attributeInterpolate6 = {
                    name: "\u0275\u0275attributeInterpolate6",
                    moduleName: Rn
                }, jn.attributeInterpolate7 = {
                    name: "\u0275\u0275attributeInterpolate7",
                    moduleName: Rn
                }, jn.attributeInterpolate8 = {
                    name: "\u0275\u0275attributeInterpolate8",
                    moduleName: Rn
                }, jn.attributeInterpolateV = {
                    name: "\u0275\u0275attributeInterpolateV",
                    moduleName: Rn
                }, jn.classProp = {
                    name: "\u0275\u0275classProp",
                    moduleName: Rn
                }, jn.elementContainerStart = {
                    name: "\u0275\u0275elementContainerStart",
                    moduleName: Rn
                }, jn.elementContainerEnd = {
                    name: "\u0275\u0275elementContainerEnd",
                    moduleName: Rn
                }, jn.elementContainer = {
                    name: "\u0275\u0275elementContainer",
                    moduleName: Rn
                }, jn.styleMap = {
                    name: "\u0275\u0275styleMap",
                    moduleName: Rn
                }, jn.styleMapInterpolate1 = {
                    name: "\u0275\u0275styleMapInterpolate1",
                    moduleName: Rn
                }, jn.styleMapInterpolate2 = {
                    name: "\u0275\u0275styleMapInterpolate2",
                    moduleName: Rn
                }, jn.styleMapInterpolate3 = {
                    name: "\u0275\u0275styleMapInterpolate3",
                    moduleName: Rn
                }, jn.styleMapInterpolate4 = {
                    name: "\u0275\u0275styleMapInterpolate4",
                    moduleName: Rn
                }, jn.styleMapInterpolate5 = {
                    name: "\u0275\u0275styleMapInterpolate5",
                    moduleName: Rn
                }, jn.styleMapInterpolate6 = {
                    name: "\u0275\u0275styleMapInterpolate6",
                    moduleName: Rn
                }, jn.styleMapInterpolate7 = {
                    name: "\u0275\u0275styleMapInterpolate7",
                    moduleName: Rn
                }, jn.styleMapInterpolate8 = {
                    name: "\u0275\u0275styleMapInterpolate8",
                    moduleName: Rn
                }, jn.styleMapInterpolateV = {
                    name: "\u0275\u0275styleMapInterpolateV",
                    moduleName: Rn
                }, jn.classMap = {
                    name: "\u0275\u0275classMap",
                    moduleName: Rn
                }, jn.classMapInterpolate1 = {
                    name: "\u0275\u0275classMapInterpolate1",
                    moduleName: Rn
                }, jn.classMapInterpolate2 = {
                    name: "\u0275\u0275classMapInterpolate2",
                    moduleName: Rn
                }, jn.classMapInterpolate3 = {
                    name: "\u0275\u0275classMapInterpolate3",
                    moduleName: Rn
                }, jn.classMapInterpolate4 = {
                    name: "\u0275\u0275classMapInterpolate4",
                    moduleName: Rn
                }, jn.classMapInterpolate5 = {
                    name: "\u0275\u0275classMapInterpolate5",
                    moduleName: Rn
                }, jn.classMapInterpolate6 = {
                    name: "\u0275\u0275classMapInterpolate6",
                    moduleName: Rn
                }, jn.classMapInterpolate7 = {
                    name: "\u0275\u0275classMapInterpolate7",
                    moduleName: Rn
                }, jn.classMapInterpolate8 = {
                    name: "\u0275\u0275classMapInterpolate8",
                    moduleName: Rn
                }, jn.classMapInterpolateV = {
                    name: "\u0275\u0275classMapInterpolateV",
                    moduleName: Rn
                }, jn.styleProp = {
                    name: "\u0275\u0275styleProp",
                    moduleName: Rn
                }, jn.stylePropInterpolate1 = {
                    name: "\u0275\u0275stylePropInterpolate1",
                    moduleName: Rn
                }, jn.stylePropInterpolate2 = {
                    name: "\u0275\u0275stylePropInterpolate2",
                    moduleName: Rn
                }, jn.stylePropInterpolate3 = {
                    name: "\u0275\u0275stylePropInterpolate3",
                    moduleName: Rn
                }, jn.stylePropInterpolate4 = {
                    name: "\u0275\u0275stylePropInterpolate4",
                    moduleName: Rn
                }, jn.stylePropInterpolate5 = {
                    name: "\u0275\u0275stylePropInterpolate5",
                    moduleName: Rn
                }, jn.stylePropInterpolate6 = {
                    name: "\u0275\u0275stylePropInterpolate6",
                    moduleName: Rn
                }, jn.stylePropInterpolate7 = {
                    name: "\u0275\u0275stylePropInterpolate7",
                    moduleName: Rn
                }, jn.stylePropInterpolate8 = {
                    name: "\u0275\u0275stylePropInterpolate8",
                    moduleName: Rn
                }, jn.stylePropInterpolateV = {
                    name: "\u0275\u0275stylePropInterpolateV",
                    moduleName: Rn
                }, jn.nextContext = {
                    name: "\u0275\u0275nextContext",
                    moduleName: Rn
                }, jn.templateCreate = {
                    name: "\u0275\u0275template",
                    moduleName: Rn
                }, jn.text = {
                    name: "\u0275\u0275text",
                    moduleName: Rn
                }, jn.enableBindings = {
                    name: "\u0275\u0275enableBindings",
                    moduleName: Rn
                }, jn.disableBindings = {
                    name: "\u0275\u0275disableBindings",
                    moduleName: Rn
                }, jn.getCurrentView = {
                    name: "\u0275\u0275getCurrentView",
                    moduleName: Rn
                }, jn.textInterpolate = {
                    name: "\u0275\u0275textInterpolate",
                    moduleName: Rn
                }, jn.textInterpolate1 = {
                    name: "\u0275\u0275textInterpolate1",
                    moduleName: Rn
                }, jn.textInterpolate2 = {
                    name: "\u0275\u0275textInterpolate2",
                    moduleName: Rn
                }, jn.textInterpolate3 = {
                    name: "\u0275\u0275textInterpolate3",
                    moduleName: Rn
                }, jn.textInterpolate4 = {
                    name: "\u0275\u0275textInterpolate4",
                    moduleName: Rn
                }, jn.textInterpolate5 = {
                    name: "\u0275\u0275textInterpolate5",
                    moduleName: Rn
                }, jn.textInterpolate6 = {
                    name: "\u0275\u0275textInterpolate6",
                    moduleName: Rn
                }, jn.textInterpolate7 = {
                    name: "\u0275\u0275textInterpolate7",
                    moduleName: Rn
                }, jn.textInterpolate8 = {
                    name: "\u0275\u0275textInterpolate8",
                    moduleName: Rn
                }, jn.textInterpolateV = {
                    name: "\u0275\u0275textInterpolateV",
                    moduleName: Rn
                }, jn.restoreView = {
                    name: "\u0275\u0275restoreView",
                    moduleName: Rn
                }, jn.pureFunction0 = {
                    name: "\u0275\u0275pureFunction0",
                    moduleName: Rn
                }, jn.pureFunction1 = {
                    name: "\u0275\u0275pureFunction1",
                    moduleName: Rn
                }, jn.pureFunction2 = {
                    name: "\u0275\u0275pureFunction2",
                    moduleName: Rn
                }, jn.pureFunction3 = {
                    name: "\u0275\u0275pureFunction3",
                    moduleName: Rn
                }, jn.pureFunction4 = {
                    name: "\u0275\u0275pureFunction4",
                    moduleName: Rn
                }, jn.pureFunction5 = {
                    name: "\u0275\u0275pureFunction5",
                    moduleName: Rn
                }, jn.pureFunction6 = {
                    name: "\u0275\u0275pureFunction6",
                    moduleName: Rn
                }, jn.pureFunction7 = {
                    name: "\u0275\u0275pureFunction7",
                    moduleName: Rn
                }, jn.pureFunction8 = {
                    name: "\u0275\u0275pureFunction8",
                    moduleName: Rn
                }, jn.pureFunctionV = {
                    name: "\u0275\u0275pureFunctionV",
                    moduleName: Rn
                }, jn.pipeBind1 = {
                    name: "\u0275\u0275pipeBind1",
                    moduleName: Rn
                }, jn.pipeBind2 = {
                    name: "\u0275\u0275pipeBind2",
                    moduleName: Rn
                }, jn.pipeBind3 = {
                    name: "\u0275\u0275pipeBind3",
                    moduleName: Rn
                }, jn.pipeBind4 = {
                    name: "\u0275\u0275pipeBind4",
                    moduleName: Rn
                }, jn.pipeBindV = {
                    name: "\u0275\u0275pipeBindV",
                    moduleName: Rn
                }, jn.hostProperty = {
                    name: "\u0275\u0275hostProperty",
                    moduleName: Rn
                }, jn.property = {
                    name: "\u0275\u0275property",
                    moduleName: Rn
                }, jn.propertyInterpolate = {
                    name: "\u0275\u0275propertyInterpolate",
                    moduleName: Rn
                }, jn.propertyInterpolate1 = {
                    name: "\u0275\u0275propertyInterpolate1",
                    moduleName: Rn
                }, jn.propertyInterpolate2 = {
                    name: "\u0275\u0275propertyInterpolate2",
                    moduleName: Rn
                }, jn.propertyInterpolate3 = {
                    name: "\u0275\u0275propertyInterpolate3",
                    moduleName: Rn
                }, jn.propertyInterpolate4 = {
                    name: "\u0275\u0275propertyInterpolate4",
                    moduleName: Rn
                }, jn.propertyInterpolate5 = {
                    name: "\u0275\u0275propertyInterpolate5",
                    moduleName: Rn
                }, jn.propertyInterpolate6 = {
                    name: "\u0275\u0275propertyInterpolate6",
                    moduleName: Rn
                }, jn.propertyInterpolate7 = {
                    name: "\u0275\u0275propertyInterpolate7",
                    moduleName: Rn
                }, jn.propertyInterpolate8 = {
                    name: "\u0275\u0275propertyInterpolate8",
                    moduleName: Rn
                }, jn.propertyInterpolateV = {
                    name: "\u0275\u0275propertyInterpolateV",
                    moduleName: Rn
                }, jn.i18n = {
                    name: "\u0275\u0275i18n",
                    moduleName: Rn
                }, jn.i18nAttributes = {
                    name: "\u0275\u0275i18nAttributes",
                    moduleName: Rn
                }, jn.i18nExp = {
                    name: "\u0275\u0275i18nExp",
                    moduleName: Rn
                }, jn.i18nStart = {
                    name: "\u0275\u0275i18nStart",
                    moduleName: Rn
                }, jn.i18nEnd = {
                    name: "\u0275\u0275i18nEnd",
                    moduleName: Rn
                }, jn.i18nApply = {
                    name: "\u0275\u0275i18nApply",
                    moduleName: Rn
                }, jn.i18nPostprocess = {
                    name: "\u0275\u0275i18nPostprocess",
                    moduleName: Rn
                }, jn.pipe = {
                    name: "\u0275\u0275pipe",
                    moduleName: Rn
                }, jn.projection = {
                    name: "\u0275\u0275projection",
                    moduleName: Rn
                }, jn.projectionDef = {
                    name: "\u0275\u0275projectionDef",
                    moduleName: Rn
                }, jn.reference = {
                    name: "\u0275\u0275reference",
                    moduleName: Rn
                }, jn.inject = {
                    name: "\u0275\u0275inject",
                    moduleName: Rn
                }, jn.injectAttribute = {
                    name: "\u0275\u0275injectAttribute",
                    moduleName: Rn
                }, jn.injectPipeChangeDetectorRef = {
                    name: "\u0275\u0275injectPipeChangeDetectorRef",
                    moduleName: Rn
                }, jn.directiveInject = {
                    name: "\u0275\u0275directiveInject",
                    moduleName: Rn
                }, jn.invalidFactory = {
                    name: "\u0275\u0275invalidFactory",
                    moduleName: Rn
                }, jn.invalidFactoryDep = {
                    name: "\u0275\u0275invalidFactoryDep",
                    moduleName: Rn
                }, jn.templateRefExtractor = {
                    name: "\u0275\u0275templateRefExtractor",
                    moduleName: Rn
                }, jn.resolveWindow = {
                    name: "\u0275\u0275resolveWindow",
                    moduleName: Rn
                }, jn.resolveDocument = {
                    name: "\u0275\u0275resolveDocument",
                    moduleName: Rn
                }, jn.resolveBody = {
                    name: "\u0275\u0275resolveBody",
                    moduleName: Rn
                }, jn.defineComponent = {
                    name: "\u0275\u0275defineComponent",
                    moduleName: Rn
                }, jn.setComponentScope = {
                    name: "\u0275\u0275setComponentScope",
                    moduleName: Rn
                }, jn.ComponentDefWithMeta = {
                    name: "\u0275\u0275ComponentDefWithMeta",
                    moduleName: Rn
                }, jn.FactoryDef = {
                    name: "\u0275\u0275FactoryDef",
                    moduleName: Rn
                }, jn.defineDirective = {
                    name: "\u0275\u0275defineDirective",
                    moduleName: Rn
                }, jn.DirectiveDefWithMeta = {
                    name: "\u0275\u0275DirectiveDefWithMeta",
                    moduleName: Rn
                }, jn.InjectorDef = {
                    name: "\u0275\u0275InjectorDef",
                    moduleName: Rn
                }, jn.defineInjector = {
                    name: "\u0275\u0275defineInjector",
                    moduleName: Rn
                }, jn.NgModuleDefWithMeta = {
                    name: "\u0275\u0275NgModuleDefWithMeta",
                    moduleName: Rn
                }, jn.ModuleWithProviders = {
                    name: "ModuleWithProviders",
                    moduleName: Rn
                }, jn.defineNgModule = {
                    name: "\u0275\u0275defineNgModule",
                    moduleName: Rn
                }, jn.setNgModuleScope = {
                    name: "\u0275\u0275setNgModuleScope",
                    moduleName: Rn
                }, jn.PipeDefWithMeta = {
                    name: "\u0275\u0275PipeDefWithMeta",
                    moduleName: Rn
                }, jn.definePipe = {
                    name: "\u0275\u0275definePipe",
                    moduleName: Rn
                }, jn.queryRefresh = {
                    name: "\u0275\u0275queryRefresh",
                    moduleName: Rn
                }, jn.viewQuery = {
                    name: "\u0275\u0275viewQuery",
                    moduleName: Rn
                }, jn.staticViewQuery = {
                    name: "\u0275\u0275staticViewQuery",
                    moduleName: Rn
                }, jn.staticContentQuery = {
                    name: "\u0275\u0275staticContentQuery",
                    moduleName: Rn
                }, jn.loadQuery = {
                    name: "\u0275\u0275loadQuery",
                    moduleName: Rn
                }, jn.contentQuery = {
                    name: "\u0275\u0275contentQuery",
                    moduleName: Rn
                }, jn.NgOnChangesFeature = {
                    name: "\u0275\u0275NgOnChangesFeature",
                    moduleName: Rn
                }, jn.InheritDefinitionFeature = {
                    name: "\u0275\u0275InheritDefinitionFeature",
                    moduleName: Rn
                }, jn.CopyDefinitionFeature = {
                    name: "\u0275\u0275CopyDefinitionFeature",
                    moduleName: Rn
                }, jn.ProvidersFeature = {
                    name: "\u0275\u0275ProvidersFeature",
                    moduleName: Rn
                }, jn.listener = {
                    name: "\u0275\u0275listener",
                    moduleName: Rn
                }, jn.getFactoryOf = {
                    name: "\u0275\u0275getFactoryOf",
                    moduleName: Rn
                }, jn.getInheritedFactory = {
                    name: "\u0275\u0275getInheritedFactory",
                    moduleName: Rn
                }, jn.sanitizeHtml = {
                    name: "\u0275\u0275sanitizeHtml",
                    moduleName: Rn
                }, jn.sanitizeStyle = {
                    name: "\u0275\u0275sanitizeStyle",
                    moduleName: Rn
                }, jn.sanitizeResourceUrl = {
                    name: "\u0275\u0275sanitizeResourceUrl",
                    moduleName: Rn
                }, jn.sanitizeScript = {
                    name: "\u0275\u0275sanitizeScript",
                    moduleName: Rn
                }, jn.sanitizeUrl = {
                    name: "\u0275\u0275sanitizeUrl",
                    moduleName: Rn
                }, jn.sanitizeUrlOrResourceUrl = {
                    name: "\u0275\u0275sanitizeUrlOrResourceUrl",
                    moduleName: Rn
                }, jn.trustConstantHtml = {
                    name: "\u0275\u0275trustConstantHtml",
                    moduleName: Rn
                }, jn.trustConstantScript = {
                    name: "\u0275\u0275trustConstantScript",
                    moduleName: Rn
                }, jn.trustConstantResourceUrl = {
                    name: "\u0275\u0275trustConstantResourceUrl",
                    moduleName: Rn
                };

                function $n(e) {
                    return `@${e}`
                }

                function Bn(e, t) {
                    return `animation_${e}_${t}`
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Hn {
                    constructor(e, t) {
                        this.value = e, this.sourceSpan = t
                    }
                    visit(e) {
                        return e.visitText(this)
                    }
                }
                class Un {
                    constructor(e, t, n) {
                        this.value = e, this.sourceSpan = t, this.i18n = n
                    }
                    visit(e) {
                        return e.visitBoundText(this)
                    }
                }
                class qn {
                    constructor(e, t, n, s, r) {
                        this.name = e, this.value = t, this.sourceSpan = n, this.valueSpan = s, this.i18n = r
                    }
                    visit(e) {
                        return e.visitTextAttribute(this)
                    }
                }
                class zn {
                    constructor(e, t, n, s, r, i, o, a, l) {
                        this.name = e, this.type = t, this.securityContext = n, this.value = s, this.unit = r, this.sourceSpan = i, this.keySpan = o, this.valueSpan = a, this.i18n = l
                    }
                    static fromBoundElementProperty(e, t) {
                        if (void 0 === e.keySpan) throw new Error(`Unexpected state: keySpan must be defined for bound attributes but was not for ${e.name}: ${e.sourceSpan}`);
                        return new zn(e.name, e.type, e.securityContext, e.value, e.unit, e.sourceSpan, e.keySpan, e.valueSpan, t)
                    }
                    visit(e) {
                        return e.visitBoundAttribute(this)
                    }
                }
                class Wn {
                    constructor(e, t, n, s, r, i, o) {
                        this.name = e, this.type = t, this.handler = n, this.target = s, this.phase = r, this.sourceSpan = i, this.handlerSpan = o
                    }
                    static fromParsedEvent(e) {
                        const t = 0 === e.type ? e.targetOrPhase : null,
                            n = 1 === e.type ? e.targetOrPhase : null;
                        return new Wn(e.name, e.type, e.handler, t, n, e.sourceSpan, e.handlerSpan)
                    }
                    visit(e) {
                        return e.visitBoundEvent(this)
                    }
                }
                class Gn {
                    constructor(e, t, n, s, r, i, o, a, l, c) {
                        this.name = e, this.attributes = t, this.inputs = n, this.outputs = s, this.children = r, this.references = i, this.sourceSpan = o, this.startSourceSpan = a, this.endSourceSpan = l, this.i18n = c
                    }
                    visit(e) {
                        return e.visitElement(this)
                    }
                }
                class Kn {
                    constructor(e, t, n, s, r, i, o, a, l, c, u, h) {
                        this.tagName = e, this.attributes = t, this.inputs = n, this.outputs = s, this.templateAttrs = r, this.children = i, this.references = o, this.variables = a, this.sourceSpan = l, this.startSourceSpan = c, this.endSourceSpan = u, this.i18n = h
                    }
                    visit(e) {
                        return e.visitTemplate(this)
                    }
                }
                class Qn {
                    constructor(e, t, n, s) {
                        this.selector = e, this.attributes = t, this.sourceSpan = n, this.i18n = s, this.name = "ng-content"
                    }
                    visit(e) {
                        return e.visitContent(this)
                    }
                }
                class Zn {
                    constructor(e, t, n, s, r) {
                        this.name = e, this.value = t, this.sourceSpan = n, this.keySpan = s, this.valueSpan = r
                    }
                    visit(e) {
                        return e.visitVariable(this)
                    }
                }
                class Jn {
                    constructor(e, t, n, s) {
                        this.name = e, this.value = t, this.sourceSpan = n, this.valueSpan = s
                    }
                    visit(e) {
                        return e.visitReference(this)
                    }
                }
                class Xn {
                    constructor(e, t, n, s) {
                        this.vars = e, this.placeholders = t, this.sourceSpan = n, this.i18n = s
                    }
                    visit(e) {
                        return e.visitIcu(this)
                    }
                }

                function Yn(e, t) {
                    const n = [];
                    if (e.visit)
                        for (const s of t) {
                            e.visit(s) || s.visit(e)
                        } else
                            for (const s of t) {
                                const t = s.visit(e);
                                t && n.push(t)
                            }
                    return n
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class es {
                    constructor(e, t, n, s, r, i) {
                        this.nodes = e, this.placeholders = t, this.placeholderToMessage = n, this.meaning = s, this.description = r, this.customId = i, this.id = this.customId, this.legacyIds = [], e.length ? this.sources = [{
                            filePath: e[0].sourceSpan.start.file.url,
                            startLine: e[0].sourceSpan.start.line + 1,
                            startCol: e[0].sourceSpan.start.col + 1,
                            endLine: e[e.length - 1].sourceSpan.end.line + 1,
                            endCol: e[0].sourceSpan.start.col + 1
                        }] : this.sources = []
                    }
                }
                class ts {
                    constructor(e, t) {
                        this.value = e, this.sourceSpan = t
                    }
                    visit(e, t) {
                        return e.visitText(this, t)
                    }
                }
                class ns {
                    constructor(e, t) {
                        this.children = e, this.sourceSpan = t
                    }
                    visit(e, t) {
                        return e.visitContainer(this, t)
                    }
                }
                class ss {
                    constructor(e, t, n, s) {
                        this.expression = e, this.type = t, this.cases = n, this.sourceSpan = s
                    }
                    visit(e, t) {
                        return e.visitIcu(this, t)
                    }
                }
                class rs {
                    constructor(e, t, n, s, r, i, o, a, l) {
                        this.tag = e, this.attrs = t, this.startName = n, this.closeName = s, this.children = r, this.isVoid = i, this.sourceSpan = o, this.startSourceSpan = a, this.endSourceSpan = l
                    }
                    visit(e, t) {
                        return e.visitTagPlaceholder(this, t)
                    }
                }
                class is {
                    constructor(e, t, n) {
                        this.value = e, this.name = t, this.sourceSpan = n
                    }
                    visit(e, t) {
                        return e.visitPlaceholder(this, t)
                    }
                }
                class os {
                    constructor(e, t, n) {
                        this.value = e, this.name = t, this.sourceSpan = n
                    }
                    visit(e, t) {
                        return e.visitIcuPlaceholder(this, t)
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class as {
                    constructor(e) {
                        this.digits = e
                    }
                    static zero() {
                        return new as([0])
                    }
                    static one() {
                        return new as([1])
                    }
                    clone() {
                        return new as(this.digits.slice())
                    }
                    add(e) {
                        const t = this.clone();
                        return t.addToSelf(e), t
                    }
                    addToSelf(e) {
                        const t = Math.max(this.digits.length, e.digits.length);
                        let n = 0;
                        for (let s = 0; s < t; s++) {
                            let t = n;
                            s < this.digits.length && (t += this.digits[s]), s < e.digits.length && (t += e.digits[s]), t >= 10 ? (this.digits[s] = t - 10, n = 1) : (this.digits[s] = t, n = 0)
                        }
                        n > 0 && (this.digits[t] = 1)
                    }
                    toString() {
                        let e = "";
                        for (let t = this.digits.length - 1; t >= 0; t--) e += this.digits[t];
                        return e
                    }
                }
                class ls {
                    constructor(e) {
                        this.powerOfTwos = [e]
                    }
                    getValue() {
                        return this.powerOfTwos[0]
                    }
                    multiplyBy(e) {
                        const t = as.zero();
                        return this.multiplyByAndAddTo(e, t), t
                    }
                    multiplyByAndAddTo(e, t) {
                        for (let n = 0; 0 !== e; e >>>= 1, n++)
                            if (1 & e) {
                                const e = this.getMultipliedByPowerOfTwo(n);
                                t.addToSelf(e)
                            }
                    }
                    getMultipliedByPowerOfTwo(e) {
                        for (let t = this.powerOfTwos.length; t <= e; t++) {
                            const e = this.powerOfTwos[t - 1];
                            this.powerOfTwos[t] = e.add(e)
                        }
                        return this.powerOfTwos[e]
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function cs(e) {
                    return e.id || us(e)
                }

                function us(e) {
                    return function(e) {
                        const t = zt(e),
                            n = function(e, t) {
                                const n = e.length + 3 >>> 2,
                                    s = [];
                                for (let r = 0; r < n; r++) s[r] = Ts(e, 4 * r, t);
                                return s
                            }(t, bs.Big),
                            s = 8 * t.length,
                            r = Xt(80);
                        let i = 1732584193,
                            o = 4023233417,
                            a = 2562383102,
                            l = 271733878,
                            c = 3285377520;
                        n[s >> 5] |= 128 << 24 - s % 32, n[15 + (s + 64 >> 9 << 4)] = s;
                        for (let u = 0; u < n.length; u += 16) {
                            const e = i,
                                t = o,
                                s = a,
                                h = l,
                                p = c;
                            for (let d = 0; d < 80; d++) {
                                r[d] = d < 16 ? n[u + d] : Ss(r[d - 3] ^ r[d - 8] ^ r[d - 14] ^ r[d - 16], 1);
                                const e = gs(d, o, a, l),
                                    t = e[0],
                                    s = e[1],
                                    h = [Ss(i, 5), t, c, s, r[d]].reduce(ws);
                                c = l, l = a, a = Ss(o, 30), o = i, i = h
                            }
                            i = ws(i, e), o = ws(o, t), a = ws(a, s), l = ws(l, h), c = ws(c, p)
                        }
                        return function(e) {
                            let t = "";
                            for (let n = 0; n < e.length; n++) {
                                const s = xs(e, n);
                                t += (s >>> 4).toString(16) + (15 & s).toString(16)
                            }
                            return t.toLowerCase()
                        }(function(e) {
                            return e.reduce((e, t) => e.concat(function(e) {
                                let t = [];
                                for (let n = 0; n < 4; n++) t.push(e >>> 8 * (3 - n) & 255);
                                return t
                            }(t)), [])
                        }([i, o, a, l, c]))
                    }((t = e.nodes, t.map(e => e.visit(fs, null))).join("") + `[${e.meaning}]`);
                    var t
                }

                function hs(e) {
                    return e.id || ps(e)
                }

                function ps(e) {
                    const t = new ms;
                    return function(e, t = "") {
                        let n = ys(e);
                        if (t) {
                            const e = ys(t);
                            n = function(e, t) {
                                const n = e[0],
                                    s = e[1],
                                    r = t[0],
                                    i = t[1],
                                    o = Es(s, i),
                                    a = o[0],
                                    l = o[1];
                                return [ws(ws(n, r), a), l]
                            }(function(e, t) {
                                const n = e[0],
                                    s = e[1];
                                return [n << t | s >>> 32 - t, s << t | n >>> 32 - t]
                            }(n, 1), e)
                        }
                        const s = n[0],
                            r = n[1];
                        return function(e, t) {
                            const n = As.toThePowerOf(0).multiplyBy(t);
                            return As.toThePowerOf(4).multiplyByAndAddTo(e, n), n.toString()
                        }
                        /**
                         * @license
                         * Copyright Google LLC All Rights Reserved.
                         *
                         * Use of this source code is governed by an MIT-style license that can be
                         * found in the LICENSE file at https://angular.io/license
                         */
                        (2147483647 & s, r)
                    }(e.nodes.map(e => e.visit(t, null)).join(""), e.meaning)
                }
                class ds {
                    visitText(e, t) {
                        return e.value
                    }
                    visitContainer(e, t) {
                        return `[${e.children.map(e=>e.visit(this)).join(", ")}]`
                    }
                    visitIcu(e, t) {
                        const n = Object.keys(e.cases).map(t => `${t} {${e.cases[t].visit(this)}}`);
                        return `{${e.expression}, ${e.type}, ${n.join(", ")}}`
                    }
                    visitTagPlaceholder(e, t) {
                        return e.isVoid ? `<ph tag name="${e.startName}"/>` : `<ph tag name="${e.startName}">${e.children.map(e=>e.visit(this)).join(", ")}</ph name="${e.closeName}">`
                    }
                    visitPlaceholder(e, t) {
                        return e.value ? `<ph name="${e.name}">${e.value}</ph>` : `<ph name="${e.name}"/>`
                    }
                    visitIcuPlaceholder(e, t) {
                        return `<ph icu name="${e.name}">${e.value.visit(this)}</ph>`
                    }
                }
                const fs = new ds;
                class ms extends ds {
                    visitIcu(e, t) {
                        let n = Object.keys(e.cases).map(t => `${t} {${e.cases[t].visit(this)}}`);
                        return `{${e.type}, ${n.join(", ")}}`
                    }
                }

                function gs(e, t, n, s) {
                    return e < 20 ? [t & n | ~t & s, 1518500249] : e < 40 ? [t ^ n ^ s, 1859775393] : e < 60 ? [t & n | t & s | n & s, 2400959708] : [t ^ n ^ s, 3395469782]
                }

                function ys(e) {
                    const t = zt(e);
                    let n = vs(t, 0),
                        s = vs(t, 102072);
                    return 0 != n || 0 != s && 1 != s || (n ^= 319790063, s ^= -1801410264), [n, s]
                }

                function vs(e, t) {
                    let n, s = 2654435769,
                        r = 2654435769;
                    const i = e.length;
                    for (n = 0; n + 12 <= i; n += 12) {
                        s = ws(s, Ts(e, n, bs.Little)), r = ws(r, Ts(e, n + 4, bs.Little));
                        const i = _s(s, r, t = ws(t, Ts(e, n + 8, bs.Little)));
                        s = i[0], r = i[1], t = i[2]
                    }
                    return s = ws(s, Ts(e, n, bs.Little)), r = ws(r, Ts(e, n + 4, bs.Little)), t = ws(t, i), _s(s, r, t = ws(t, Ts(e, n + 8, bs.Little) << 8))[2]
                }

                function _s(e, t, n) {
                    return e = Cs(e, t), e = Cs(e, n), e ^= n >>> 13, t = Cs(t, n), t = Cs(t, e), t ^= e << 8, n = Cs(n, e), n = Cs(n, t), n ^= t >>> 13, e = Cs(e, t), e = Cs(e, n), e ^= n >>> 12, t = Cs(t, n), t = Cs(t, e), t ^= e << 16, n = Cs(n, e), n = Cs(n, t), n ^= t >>> 5, e = Cs(e, t), e = Cs(e, n), e ^= n >>> 3, t = Cs(t, n), t = Cs(t, e), t ^= e << 10, n = Cs(n, e), n = Cs(n, t), [e, t, n ^= t >>> 15]
                }
                var bs;

                function ws(e, t) {
                    return Es(e, t)[1]
                }

                function Es(e, t) {
                    const n = (65535 & e) + (65535 & t),
                        s = (e >>> 16) + (t >>> 16) + (n >>> 16);
                    return [s >>> 16, s << 16 | 65535 & n]
                }

                function Cs(e, t) {
                    const n = (65535 & e) - (65535 & t);
                    return (e >> 16) - (t >> 16) + (n >> 16) << 16 | 65535 & n
                }

                function Ss(e, t) {
                    return e << t | e >>> 32 - t
                }

                function xs(e, t) {
                    return t >= e.length ? 0 : e[t]
                }

                function Ts(e, t, n) {
                    let s = 0;
                    if (n === bs.Big)
                        for (let r = 0; r < 4; r++) s += xs(e, t + r) << 24 - 8 * r;
                    else
                        for (let r = 0; r < 4; r++) s += xs(e, t + r) << 8 * r;
                    return s
                }! function(e) {
                    e[e.Little = 0] = "Little", e[e.Big = 1] = "Big"
                }(bs || (bs = {}));
                const As = new class {
                    constructor(e) {
                        this.base = e, this.exponents = [new ls(as.one())]
                    }
                    toThePowerOf(e) {
                        for (let t = this.exponents.length; t <= e; t++) {
                            const e = this.exponents[t - 1].multiplyBy(this.base);
                            this.exponents[t] = new ls(e)
                        }
                        return this.exponents[e]
                    }
                }(256);
                class Ds {
                    createNameMapper(e) {
                        return null
                    }
                }
                class Ps extends class {
                    visitText(e, t) {}
                    visitContainer(e, t) {
                        e.children.forEach(e => e.visit(this))
                    }
                    visitIcu(e, t) {
                        Object.keys(e.cases).forEach(t => {
                            e.cases[t].visit(this)
                        })
                    }
                    visitTagPlaceholder(e, t) {
                        e.children.forEach(e => e.visit(this))
                    }
                    visitPlaceholder(e, t) {}
                    visitIcuPlaceholder(e, t) {}
                } {
                    constructor(e, t) {
                        super(), this.mapName = t, this.internalToPublic = {}, this.publicToNextId = {}, this.publicToInternal = {}, e.nodes.forEach(e => e.visit(this))
                    }
                    toPublicName(e) {
                        return this.internalToPublic.hasOwnProperty(e) ? this.internalToPublic[e] : null
                    }
                    toInternalName(e) {
                        return this.publicToInternal.hasOwnProperty(e) ? this.publicToInternal[e] : null
                    }
                    visitText(e, t) {
                        return null
                    }
                    visitTagPlaceholder(e, t) {
                        this.visitPlaceholderName(e.startName), super.visitTagPlaceholder(e, t), this.visitPlaceholderName(e.closeName)
                    }
                    visitPlaceholder(e, t) {
                        this.visitPlaceholderName(e.name)
                    }
                    visitIcuPlaceholder(e, t) {
                        this.visitPlaceholderName(e.name)
                    }
                    visitPlaceholderName(e) {
                        if (!e || this.internalToPublic.hasOwnProperty(e)) return;
                        let t = this.mapName(e);
                        if (this.publicToInternal.hasOwnProperty(t)) {
                            const e = this.publicToNextId[t];
                            this.publicToNextId[t] = e + 1, t = `${t}_${e}`
                        } else this.publicToNextId[t] = 1;
                        this.internalToPublic[e] = t, this.publicToInternal[t] = e
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const ks = new class {
                    visitTag(e) {
                        const t = this._serializeAttributes(e.attrs);
                        if (0 == e.children.length) return `<${e.name}${t}/>`;
                        const n = e.children.map(e => e.visit(this));
                        return `<${e.name}${t}>${n.join("")}</${e.name}>`
                    }
                    visitText(e) {
                        return e.value
                    }
                    visitDeclaration(e) {
                        return `<?xml${this._serializeAttributes(e.attrs)} ?>`
                    }
                    _serializeAttributes(e) {
                        const t = Object.keys(e).map(t => `${t}="${e[t]}"`).join(" ");
                        return t.length > 0 ? " " + t : ""
                    }
                    visitDoctype(e) {
                        return `<!DOCTYPE ${e.rootTag} [\n${e.dtd}\n]>`
                    }
                };

                function Os(e) {
                    return e.map(e => e.visit(ks)).join("")
                }
                class Is {
                    constructor(e) {
                        this.attrs = {}, Object.keys(e).forEach(t => {
                            this.attrs[t] = Ls(e[t])
                        })
                    }
                    visit(e) {
                        return e.visitDeclaration(this)
                    }
                }
                class Ns {
                    constructor(e, t) {
                        this.rootTag = e, this.dtd = t
                    }
                    visit(e) {
                        return e.visitDoctype(this)
                    }
                }
                class Ms {
                    constructor(e, t = {}, n = []) {
                        this.name = e, this.children = n, this.attrs = {}, Object.keys(t).forEach(e => {
                            this.attrs[e] = Ls(t[e])
                        })
                    }
                    visit(e) {
                        return e.visitTag(this)
                    }
                }
                class Fs {
                    constructor(e) {
                        this.value = Ls(e)
                    }
                    visit(e) {
                        return e.visitText(this)
                    }
                }
                class Rs extends Fs {
                    constructor(e = 0) {
                        super(`\n${new Array(e+1).join(" ")}`)
                    }
                }
                const js = [
                    [/&/g, "&amp;"],
                    [/"/g, "&quot;"],
                    [/'/g, "&apos;"],
                    [/</g, "&lt;"],
                    [/>/g, "&gt;"]
                ];

                function Ls(e) {
                    return js.reduce((e, t) => e.replace(t[0], t[1]), e)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Vs = "messagebundle",
                    $s = "ph",
                    Bs = "ex";
                class Hs extends Ds {
                    write(e, t) {
                        const n = new zs,
                            s = new Us;
                        let r = new Ms(Vs);
                        return e.forEach(e => {
                            const t = {
                                id: e.id
                            };
                            e.description && (t.desc = e.description), e.meaning && (t.meaning = e.meaning);
                            let n = [];
                            e.sources.forEach(e => {
                                n.push(new Ms("source", {}, [new Fs(`${e.filePath}:${e.startLine}${e.endLine!==e.startLine?","+e.endLine:""}`)]))
                            }), r.children.push(new Rs(2), new Ms("msg", t, [...n, ...s.serialize(e.nodes)]))
                        }), r.children.push(new Rs), Os([new Is({
                            version: "1.0",
                            encoding: "UTF-8"
                        }), new Rs, new Ns(Vs, '<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) "default">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>'), new Rs, n.addDefaultExamples(r), new Rs])
                    }
                    load(e, t) {
                        throw new Error("Unsupported")
                    }
                    digest(e) {
                        return qs(e)
                    }
                    createNameMapper(e) {
                        return new Ps(e, Ws)
                    }
                }
                class Us {
                    visitText(e, t) {
                        return [new Fs(e.value)]
                    }
                    visitContainer(e, t) {
                        const n = [];
                        return e.children.forEach(e => n.push(...e.visit(this))), n
                    }
                    visitIcu(e, t) {
                        const n = [new Fs(`{${e.expressionPlaceholder}, ${e.type}, `)];
                        return Object.keys(e.cases).forEach(t => {
                            n.push(new Fs(`${t} {`), ...e.cases[t].visit(this), new Fs("} "))
                        }), n.push(new Fs("}")), n
                    }
                    visitTagPlaceholder(e, t) {
                        const n = new Fs(`<${e.tag}>`),
                            s = new Ms(Bs, {}, [n]),
                            r = new Ms($s, {
                                name: e.startName
                            }, [s, n]);
                        if (e.isVoid) return [r];
                        const i = new Fs(`</${e.tag}>`),
                            o = new Ms(Bs, {}, [i]),
                            a = new Ms($s, {
                                name: e.closeName
                            }, [o, i]);
                        return [r, ...this.serialize(e.children), a]
                    }
                    visitPlaceholder(e, t) {
                        const n = new Fs(`{{${e.value}}}`),
                            s = new Ms(Bs, {}, [n]);
                        return [new Ms($s, {
                            name: e.name
                        }, [s, n])]
                    }
                    visitIcuPlaceholder(e, t) {
                        const n = e.value.expression,
                            s = e.value.type,
                            r = Object.keys(e.value.cases).map(e => e + " {...}").join(" "),
                            i = new Fs(`{${n}, ${s}, ${r}}`),
                            o = new Ms(Bs, {}, [i]);
                        return [new Ms($s, {
                            name: e.name
                        }, [o, i])]
                    }
                    serialize(e) {
                        return [].concat(...e.map(e => e.visit(this)))
                    }
                }

                function qs(e) {
                    return hs(e)
                }
                class zs {
                    addDefaultExamples(e) {
                        return e.visit(this), e
                    }
                    visitTag(e) {
                        if (e.name === $s) {
                            if (!e.children || 0 == e.children.length) {
                                const t = new Fs(e.attrs.name || "...");
                                e.children = [new Ms(Bs, {}, [t])]
                            }
                        } else e.children && e.children.forEach(e => e.visit(this))
                    }
                    visitText(e) {}
                    visitDeclaration(e) {}
                    visitDoctype(e) {}
                }

                function Ws(e) {
                    return e.toUpperCase().replace(/[^A-Z0-9_]/g, "_")
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Gs = "i18n",
                    Ks = "i18n-";

                function Qs(e) {
                    return e === Gs || e.startsWith(Ks)
                }

                function Zs(e) {
                    return e instanceof es
                }

                function Js(e) {
                    return Zs(e) && 1 === e.nodes.length && e.nodes[0] instanceof ss
                }

                function Xs(e) {
                    return !!e.i18n
                }

                function Ys(e) {
                    return e.nodes[0]
                }

                function er(e, t = 0) {
                    return `\ufffd${e}${t>0?`:${t}`:""}\ufffd`
                }

                function tr(e = 0) {
                    let t = e;
                    return () => t++
                }

                function nr(e) {
                    const t = {};
                    return e.forEach((e, n) => {
                        t[n] = At(e.length > 1 ? `[${e.join("|")}]` : e[0])
                    }), t
                }

                function sr(e, t, ...n) {
                    const s = e.get(t) || [];
                    s.push(...n), e.set(t, s)
                }

                function rr(e, t = 0, n = 0) {
                    const s = t,
                        r = new Map,
                        i = e instanceof es ? e.nodes.find(e => e instanceof ns) : e;
                    return i && i.children.filter(e => e instanceof is).forEach((e, t) => {
                        const i = er(s + t, n);
                        sr(r, e.name, i)
                    }), r
                }

                function ir(e = {}, t) {
                    const n = {};
                    return e && Object.keys(e).length && Object.keys(e).forEach(s => n[or(s, t)] = e[s]), n
                }

                function or(e, t = !0) {
                    const n = Ws(e);
                    if (!t) return n;
                    const s = n.split("_");
                    if (1 === s.length) return e.toLowerCase();
                    let r;
                    /^\d+$/.test(s[s.length - 1]) && (r = s.pop());
                    let i = s.shift().toLowerCase();
                    return s.length && (i += s.map(e => e.charAt(0).toUpperCase() + e.slice(1).toLowerCase()).join("")), r ? `${i}_${r}` : i
                }

                function ar(e) {
                    return `MSG_${e}`.toUpperCase()
                }

                function lr(e) {
                    return new tt(e.name, void 0, re, void 0, e.sourceSpan)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const cr = /[-.]/,
                    ur = "_t",
                    hr = "ctx",
                    pr = "rf";

                function dr(e, t) {
                    let n = null;
                    return () => (n || (e.push(new tt(ur, void 0, se)), n = vt(t)), n)
                }

                function fr(e) {
                    if (this) throw new Error(`Builder ${this.constructor.name} doesn't support ${e} yet`);
                    throw new Error(`Feature ${e} is not supported yet`)
                }

                function mr(e) {
                    throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${e.constructor.name}`)
                }

                function gr(e) {
                    return Array.isArray(e) ? Ct(e.map(gr)) : At(e, re)
                }

                function yr(e, t) {
                    return Object.getOwnPropertyNames(e).length > 0 ? function(e, t) {
                        return St(Object.getOwnPropertyNames(e).map(n => {
                            const s = e[n];
                            let r, i, o;
                            return Array.isArray(s) ? [i, r] = s : [r, i] = Ot(n, [n, s]), o = r, {
                                key: o,
                                quoted: cr.test(o),
                                value: t && i !== r ? Ct([gr(i), gr(r)]) : gr(i)
                            }
                        }))
                    }(e, t) : null
                }

                function vr(e) {
                    for (; Dt(e[e.length - 1]);) e.pop();
                    return e
                }

                function _r(e, t) {
                    if (Array.isArray(e.predicate)) {
                        let n = [];
                        return e.predicate.forEach(e => {
                            const t = e.split(",").map(e => At(e.trim()));
                            n.push(...t)
                        }), t.getConstLiteral(Ct(n), !0)
                    }
                    return e.predicate
                }
                class br {
                    constructor() {
                        this.values = []
                    }
                    set(e, t) {
                        t && this.values.push({
                            key: e,
                            value: t,
                            quoted: !1
                        })
                    }
                    toLiteralMap() {
                        return St(this.values)
                    }
                }

                function wr(e) {
                    const t = {};
                    return e instanceof Kn && "ng-template" !== e.tagName ? e.templateAttrs.forEach(e => t[e.name] = "") : (e.attributes.forEach(e => {
                        Qs(e.name) || (t[e.name] = e.value)
                    }), e.inputs.forEach(e => {
                        t[e.name] = ""
                    }), e.outputs.forEach(e => {
                        t[e.name] = ""
                    })), t
                }

                function Er(e, t, n) {
                    let s = _t(e, null, n);
                    if (t.length > 0)
                        for (let r = 0; r < t.length; r++) s = s.callFn(t[r], n);
                    else s = s.callFn([], n);
                    return s
                }

                function Cr(e) {
                    const {
                        expressions: t,
                        strings: n
                    } = e;
                    return 1 === t.length && 2 === n.length && "" === n[0] && "" === n[1] ? 1 : t.length + n.length
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var Sr, xr, Tr;

                function Ar(e) {
                    const t = vt("t"),
                        n = [];
                    let s = le;
                    const r = Pr(e) ? t : new He(ue.Or, t, e.internalType);
                    let i = null;
                    if (null !== e.deps) "invalid" !== e.deps && (i = new Se(r, Dr(e.deps, e.injectFn, e.target === xr.Pipe)), s = function(e) {
                        let t = !1;
                        const n = e.map(e => {
                            const n = function(e) {
                                const t = [];
                                e.resolved === Tr.Attribute && null !== e.attribute && t.push({
                                    key: "attribute",
                                    value: e.attribute,
                                    quoted: !1
                                });
                                e.optional && t.push({
                                    key: "optional",
                                    value: At(!0),
                                    quoted: !1
                                });
                                e.host && t.push({
                                    key: "host",
                                    value: At(!0),
                                    quoted: !1
                                });
                                e.self && t.push({
                                    key: "self",
                                    value: At(!0),
                                    quoted: !1
                                });
                                e.skipSelf && t.push({
                                    key: "skipSelf",
                                    value: At(!0),
                                    quoted: !1
                                });
                                return t.length > 0 ? St(t) : null
                            }(e);
                            return null !== n ? (t = !0, n) : At(null)
                        });
                        return t ? wt(Ct(n)) : le
                    }(e.deps));
                    else {
                        const t = vt(`\u0275${e.name}_BaseFactory`),
                            s = _t(jn.getInheritedFactory),
                            o = t.set(s.callFn([e.internalType], void 0, !0)).toDeclStmt(re, [Je.Exported, Je.Final]);
                        n.push(o), i = t.callFn([r])
                    }
                    const o = i,
                        a = [];
                    let l = null;

                    function c(e) {
                        const n = vt("r");
                        a.push(n.set(Qe).toDeclStmt());
                        let s = null;
                        return s = null !== o ? n.set(o).toStmt() : _t(jn.invalidFactory).callFn([]).toStmt(), a.push(Tt(t, [s], [n.set(e).toStmt()])), n
                    }
                    if (Pr(e) && e.delegateType === Sr.Factory) {
                        const t = vt(`\u0275${e.name}_BaseFactory`),
                            s = _t(jn.getFactoryOf);
                        if (e.delegate.isEquivalent(e.internalType)) throw new Error("Illegal state: compiling factory that delegates to itself");
                        const r = t.set(s.callFn([e.delegate])).toDeclStmt(re, [Je.Exported, Je.Final]);
                        n.push(r), l = c(t.callFn([]))
                    } else if (Pr(e)) {
                        const t = Dr(e.delegateDeps, e.injectFn, e.target === xr.Pipe);
                        l = c(new(e.delegateType === Sr.Class ? Se : Ce)(e.delegate, t))
                    } else l = function(e) {
                        return void 0 !== e.expression
                    }
                    /**
                     * @license
                     * Copyright Google LLC All Rights Reserved.
                     *
                     * Use of this source code is governed by an MIT-style license that can be
                     * found in the LICENSE file at https://angular.io/license
                     */
                    (e) ? c(e.expression): i;
                    return null !== l ? a.push(new rt(l)) : a.push(_t(jn.invalidFactory).callFn([]).toStmt()), {
                        factory: xt([new Ve("t", se)], a, re, void 0, `${e.name}_Factory`),
                        statements: n,
                        type: wt(_t(jn.FactoryDef, [Vn(e.type.type, e.typeArgumentCount), s]))
                    }
                }

                function Dr(e, t, n) {
                    return e.map((e, s) => function(e, t, n, s) {
                        switch (e.resolved) {
                            case Tr.Token:
                            case Tr.ChangeDetectorRef:
                                const r = 0 | (e.self ? 2 : 0) | (e.skipSelf ? 4 : 0) | (e.host ? 1 : 0) | (e.optional ? 8 : 0);
                                let i = 0 !== r || e.optional ? At(r) : null;
                                if (n && e.resolved === Tr.ChangeDetectorRef) return _t(jn.injectPipeChangeDetectorRef).callFn(i ? [i] : []);
                                const o = [e.token];
                                return i && o.push(i), _t(t).callFn(o);
                            case Tr.Attribute:
                                return _t(jn.injectAttribute).callFn([e.token]);
                            case Tr.Invalid:
                                return _t(jn.invalidFactoryDep).callFn([At(s)]);
                            default:
                                return fr(`Unknown R3ResolvedDependencyType: ${Tr[e.resolved]}`)
                        }
                    }(e, t, n, s))
                }

                function Pr(e) {
                    return void 0 !== e.delegateType
                }

                function kr(e, t) {
                    return {
                        statements: [],
                        factory: e.node === t.node ? t.prop("\u0275fac") : xt([new Ve("t", se)], [new rt(t.callMethod("\u0275fac", [vt("t")]))])
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function Or(e, t) {
                    if (null != t) {
                        if (!Array.isArray(t)) throw new Error(`Expected '${e}' to be an array of strings.`);
                        for (let n = 0; n < t.length; n += 1)
                            if ("string" != typeof t[n]) throw new Error(`Expected '${e}' to be an array of strings.`)
                    }
                }! function(e) {
                    e[e.Class = 0] = "Class", e[e.Function = 1] = "Function", e[e.Factory = 2] = "Factory"
                }(Sr || (Sr = {})),
                function(e) {
                    e[e.Directive = 0] = "Directive", e[e.Component = 1] = "Component", e[e.Injectable = 2] = "Injectable", e[e.Pipe = 3] = "Pipe", e[e.NgModule = 4] = "NgModule"
                }(xr || (xr = {})),
                function(e) {
                    e[e.Token = 0] = "Token", e[e.Attribute = 1] = "Attribute", e[e.ChangeDetectorRef = 2] = "ChangeDetectorRef", e[e.Invalid = 3] = "Invalid"
                }(Tr || (Tr = {}));
                const Ir = [/^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];

                function Nr(e, t) {
                    if (!(null == t || Array.isArray(t) && 2 == t.length)) throw new Error(`Expected '${e}' to be an array, [start, end].`);
                    if (null != t) {
                        const e = t[0],
                            n = t[1];
                        Ir.forEach(t => {
                            if (t.test(e) || t.test(n)) throw new Error(`['${e}', '${n}'] contains unusable interpolation symbol.`)
                        })
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Mr {
                    constructor(e, t) {
                        this.start = e, this.end = t
                    }
                    static fromArray(e) {
                        return e ? (Nr("interpolation", e), new Mr(e[0], e[1])) : Fr
                    }
                }
                const Fr = new Mr("{{", "}}");
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Rr {
                    constructor(e = null) {
                        this.file = e, this.sourcesContent = new Map, this.lines = [], this.lastCol0 = 0, this.hasMappings = !1
                    }
                    addSource(e, t = null) {
                        return this.sourcesContent.has(e) || this.sourcesContent.set(e, t), this
                    }
                    addLine() {
                        return this.lines.push([]), this.lastCol0 = 0, this
                    }
                    addMapping(e, t, n, s) {
                        if (!this.currentLine) throw new Error("A line must be added before mappings can be added");
                        if (null != t && !this.sourcesContent.has(t)) throw new Error(`Unknown source file "${t}"`);
                        if (null == e) throw new Error("The column in the generated code must be provided");
                        if (e < this.lastCol0) throw new Error("Mapping should be added in output order");
                        if (t && (null == n || null == s)) throw new Error("The source location must be provided when a source url is provided");
                        return this.hasMappings = !0, this.lastCol0 = e, this.currentLine.push({
                            col0: e,
                            sourceUrl: t,
                            sourceLine0: n,
                            sourceCol0: s
                        }), this
                    }
                    get currentLine() {
                        return this.lines.slice(-1)[0]
                    }
                    toJSON() {
                        if (!this.hasMappings) return null;
                        const e = new Map,
                            t = [],
                            n = [];
                        Array.from(this.sourcesContent.keys()).forEach((s, r) => {
                            e.set(s, r), t.push(s), n.push(this.sourcesContent.get(s) || null)
                        });
                        let s = "",
                            r = 0,
                            i = 0,
                            o = 0,
                            a = 0;
                        return this.lines.forEach(t => {
                            r = 0, s += t.map(t => {
                                let n = jr(t.col0 - r);
                                return r = t.col0, null != t.sourceUrl && (n += jr(e.get(t.sourceUrl) - i), i = e.get(t.sourceUrl), n += jr(t.sourceLine0 - o), o = t.sourceLine0, n += jr(t.sourceCol0 - a), a = t.sourceCol0), n
                            }).join(","), s += ";"
                        }), s = s.slice(0, -1), {
                            file: this.file || "",
                            version: 3,
                            sourceRoot: "",
                            sources: t,
                            sourcesContent: n,
                            mappings: s
                        }
                    }
                    toJsComment() {
                        return this.hasMappings ? "//# sourceMappingURL=data:application/json;base64," + function(e) {
                            let t = "";
                            const n = zt(e);
                            for (let s = 0; s < n.length;) {
                                const e = n[s++],
                                    r = s < n.length ? n[s++] : null,
                                    i = s < n.length ? n[s++] : null;
                                t += Lr(e >> 2), t += Lr((3 & e) << 4 | (null === r ? 0 : r >> 4)), t += null === r ? "=" : Lr((15 & r) << 2 | (null === i ? 0 : i >> 6)), t += null === r || null === i ? "=" : Lr(63 & i)
                            }
                            return t
                        }(JSON.stringify(this, null, 0)) : ""
                    }
                }

                function jr(e) {
                    e = e < 0 ? 1 + (-e << 1) : e << 1;
                    let t = "";
                    do {
                        let n = 31 & e;
                        (e >>= 5) > 0 && (n |= 32), t += Lr(n)
                    } while (e > 0);
                    return t
                }

                function Lr(e) {
                    if (e < 0 || e >= 64) throw new Error("Can only encode value in the range [0, 63]");
                    return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" [e]
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Vr = /'|\\|\n|\r|\$/g,
                    $r = /^[$A-Z_][0-9A-Z_$]*$/i,
                    Br = "  ",
                    Hr = vt("error", null, null),
                    Ur = vt("stack", null, null);
                class qr {
                    constructor(e) {
                        this.indent = e, this.partsLength = 0, this.parts = [], this.srcSpans = []
                    }
                }
                class zr {
                    constructor(e) {
                        this._indent = e, this._classes = [], this._preambleLineCount = 0, this._lines = [new qr(e)]
                    }
                    static createRoot() {
                        return new zr(0)
                    }
                    get _currentLine() {
                        return this._lines[this._lines.length - 1]
                    }
                    println(e, t = "") {
                        this.print(e || null, t, !0)
                    }
                    lineIsEmpty() {
                        return 0 === this._currentLine.parts.length
                    }
                    lineLength() {
                        return this._currentLine.indent * Br.length + this._currentLine.partsLength
                    }
                    print(e, t, n = !1) {
                        t.length > 0 && (this._currentLine.parts.push(t), this._currentLine.partsLength += t.length, this._currentLine.srcSpans.push(e && e.sourceSpan || null)), n && this._lines.push(new qr(this._indent))
                    }
                    removeEmptyLastLine() {
                        this.lineIsEmpty() && this._lines.pop()
                    }
                    incIndent() {
                        this._indent++, this.lineIsEmpty() && (this._currentLine.indent = this._indent)
                    }
                    decIndent() {
                        this._indent--, this.lineIsEmpty() && (this._currentLine.indent = this._indent)
                    }
                    pushClass(e) {
                        this._classes.push(e)
                    }
                    popClass() {
                        return this._classes.pop()
                    }
                    get currentClass() {
                        return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null
                    }
                    toSource() {
                        return this.sourceLines.map(e => e.parts.length > 0 ? Kr(e.indent) + e.parts.join("") : "").join("\n")
                    }
                    toSourceMapGenerator(e, t = 0) {
                        const n = new Rr(e);
                        let s = !1;
                        const r = () => {
                            s || (n.addSource(e, " ").addMapping(0, e, 0, 0), s = !0)
                        };
                        for (let i = 0; i < t; i++) n.addLine(), r();
                        return this.sourceLines.forEach((e, t) => {
                            n.addLine();
                            const i = e.srcSpans,
                                o = e.parts;
                            let a = e.indent * Br.length,
                                l = 0;
                            for (; l < i.length && !i[l];) a += o[l].length, l++;
                            for (l < i.length && 0 === t && 0 === a ? s = !0 : r(); l < i.length;) {
                                const e = i[l],
                                    t = e.start.file,
                                    s = e.start.line,
                                    r = e.start.col;
                                for (n.addSource(t.url, t.content).addMapping(a, t.url, s, r), a += o[l].length, l++; l < i.length && (e === i[l] || !i[l]);) a += o[l].length, l++
                            }
                        }), n
                    }
                    setPreambleLineCount(e) {
                        return this._preambleLineCount = e
                    }
                    spanOf(e, t) {
                        const n = this._lines[e - this._preambleLineCount];
                        if (n) {
                            let e = t - Kr(n.indent).length;
                            for (let t = 0; t < n.parts.length; t++) {
                                const s = n.parts[t];
                                if (s.length > e) return n.srcSpans[t];
                                e -= s.length
                            }
                        }
                        return null
                    }
                    get sourceLines() {
                        return this._lines.length && 0 === this._lines[this._lines.length - 1].parts.length ? this._lines.slice(0, -1) : this._lines
                    }
                }
                class Wr {
                    constructor(e) {
                        this._escapeDollarInStrings = e
                    }
                    printLeadingComments(e, t) {
                        if (void 0 !== e.leadingComments)
                            for (const n of e.leadingComments) n instanceof Ye ? t.print(e, `/*${n.toString()}*/`, n.trailingNewline) : n.multiline ? t.print(e, `/* ${n.text} */`, n.trailingNewline) : n.text.split("\n").forEach(n => {
                                t.println(e, `// ${n}`)
                            })
                    }
                    visitExpressionStmt(e, t) {
                        return this.printLeadingComments(e, t), e.expr.visitExpression(this, t), t.println(e, ";"), null
                    }
                    visitReturnStmt(e, t) {
                        return this.printLeadingComments(e, t), t.print(e, "return "), e.value.visitExpression(this, t), t.println(e, ";"), null
                    }
                    visitIfStmt(e, t) {
                        this.printLeadingComments(e, t), t.print(e, "if ("), e.condition.visitExpression(this, t), t.print(e, ") {");
                        const n = null != e.falseCase && e.falseCase.length > 0;
                        return e.trueCase.length <= 1 && !n ? (t.print(e, " "), this.visitAllStatements(e.trueCase, t), t.removeEmptyLastLine(), t.print(e, " ")) : (t.println(), t.incIndent(), this.visitAllStatements(e.trueCase, t), t.decIndent(), n && (t.println(e, "} else {"), t.incIndent(), this.visitAllStatements(e.falseCase, t), t.decIndent())), t.println(e, "}"), null
                    }
                    visitThrowStmt(e, t) {
                        return this.printLeadingComments(e, t), t.print(e, "throw "), e.error.visitExpression(this, t), t.println(e, ";"), null
                    }
                    visitWriteVarExpr(e, t) {
                        const n = t.lineIsEmpty();
                        return n || t.print(e, "("), t.print(e, `${e.name} = `), e.value.visitExpression(this, t), n || t.print(e, ")"), null
                    }
                    visitWriteKeyExpr(e, t) {
                        const n = t.lineIsEmpty();
                        return n || t.print(e, "("), e.receiver.visitExpression(this, t), t.print(e, "["), e.index.visitExpression(this, t), t.print(e, "] = "), e.value.visitExpression(this, t), n || t.print(e, ")"), null
                    }
                    visitWritePropExpr(e, t) {
                        const n = t.lineIsEmpty();
                        return n || t.print(e, "("), e.receiver.visitExpression(this, t), t.print(e, `.${e.name} = `), e.value.visitExpression(this, t), n || t.print(e, ")"), null
                    }
                    visitInvokeMethodExpr(e, t) {
                        e.receiver.visitExpression(this, t);
                        let n = e.name;
                        return null != e.builtin && (n = this.getBuiltinMethodName(e.builtin), null == n) || (t.print(e, `.${n}(`), this.visitAllExpressions(e.args, t, ","), t.print(e, ")")), null
                    }
                    visitInvokeFunctionExpr(e, t) {
                        return e.fn.visitExpression(this, t), t.print(e, "("), this.visitAllExpressions(e.args, t, ","), t.print(e, ")"), null
                    }
                    visitWrappedNodeExpr(e, t) {
                        throw new Error("Abstract emitter cannot visit WrappedNodeExpr.")
                    }
                    visitTypeofExpr(e, t) {
                        t.print(e, "typeof "), e.expr.visitExpression(this, t)
                    }
                    visitReadVarExpr(e, t) {
                        let n = e.name;
                        if (null != e.builtin) switch (e.builtin) {
                            case he.Super:
                                n = "super";
                                break;
                            case he.This:
                                n = "this";
                                break;
                            case he.CatchError:
                                n = Hr.name;
                                break;
                            case he.CatchStack:
                                n = Ur.name;
                                break;
                            default:
                                throw new Error(`Unknown builtin variable ${e.builtin}`)
                        }
                        return t.print(e, n), null
                    }
                    visitInstantiateExpr(e, t) {
                        return t.print(e, "new "), e.classExpr.visitExpression(this, t), t.print(e, "("), this.visitAllExpressions(e.args, t, ","), t.print(e, ")"), null
                    }
                    visitLiteralExpr(e, t) {
                        const n = e.value;
                        return "string" == typeof n ? t.print(e, Gr(n, this._escapeDollarInStrings)) : t.print(e, `${n}`), null
                    }
                    visitLocalizedString(e, t) {
                        const n = e.serializeI18nHead();
                        t.print(e, "$localize `" + n.raw);
                        for (let s = 1; s < e.messageParts.length; s++) t.print(e, "${"), e.expressions[s - 1].visitExpression(this, t), t.print(e, `}${e.serializeI18nTemplatePart(s).raw}`);
                        return t.print(e, "`"), null
                    }
                    visitConditionalExpr(e, t) {
                        return t.print(e, "("), e.condition.visitExpression(this, t), t.print(e, "? "), e.trueCase.visitExpression(this, t), t.print(e, ": "), e.falseCase.visitExpression(this, t), t.print(e, ")"), null
                    }
                    visitNotExpr(e, t) {
                        return t.print(e, "!"), e.condition.visitExpression(this, t), null
                    }
                    visitAssertNotNullExpr(e, t) {
                        return e.condition.visitExpression(this, t), null
                    }
                    visitUnaryOperatorExpr(e, t) {
                        let n;
                        switch (e.operator) {
                            case ce.Plus:
                                n = "+";
                                break;
                            case ce.Minus:
                                n = "-";
                                break;
                            default:
                                throw new Error(`Unknown operator ${e.operator}`)
                        }
                        return e.parens && t.print(e, "("), t.print(e, n), e.expr.visitExpression(this, t), e.parens && t.print(e, ")"), null
                    }
                    visitBinaryOperatorExpr(e, t) {
                        let n;
                        switch (e.operator) {
                            case ue.Equals:
                                n = "==";
                                break;
                            case ue.Identical:
                                n = "===";
                                break;
                            case ue.NotEquals:
                                n = "!=";
                                break;
                            case ue.NotIdentical:
                                n = "!==";
                                break;
                            case ue.And:
                                n = "&&";
                                break;
                            case ue.BitwiseAnd:
                                n = "&";
                                break;
                            case ue.Or:
                                n = "||";
                                break;
                            case ue.Plus:
                                n = "+";
                                break;
                            case ue.Minus:
                                n = "-";
                                break;
                            case ue.Divide:
                                n = "/";
                                break;
                            case ue.Multiply:
                                n = "*";
                                break;
                            case ue.Modulo:
                                n = "%";
                                break;
                            case ue.Lower:
                                n = "<";
                                break;
                            case ue.LowerEquals:
                                n = "<=";
                                break;
                            case ue.Bigger:
                                n = ">";
                                break;
                            case ue.BiggerEquals:
                                n = ">=";
                                break;
                            default:
                                throw new Error(`Unknown operator ${e.operator}`)
                        }
                        return e.parens && t.print(e, "("), e.lhs.visitExpression(this, t), t.print(e, ` ${n} `), e.rhs.visitExpression(this, t), e.parens && t.print(e, ")"), null
                    }
                    visitReadPropExpr(e, t) {
                        return e.receiver.visitExpression(this, t), t.print(e, "."), t.print(e, e.name), null
                    }
                    visitReadKeyExpr(e, t) {
                        return e.receiver.visitExpression(this, t), t.print(e, "["), e.index.visitExpression(this, t), t.print(e, "]"), null
                    }
                    visitLiteralArrayExpr(e, t) {
                        return t.print(e, "["), this.visitAllExpressions(e.entries, t, ","), t.print(e, "]"), null
                    }
                    visitLiteralMapExpr(e, t) {
                        return t.print(e, "{"), this.visitAllObjects(n => {
                            t.print(e, `${Gr(n.key,this._escapeDollarInStrings,n.quoted)}:`), n.value.visitExpression(this, t)
                        }, e.entries, t, ","), t.print(e, "}"), null
                    }
                    visitCommaExpr(e, t) {
                        return t.print(e, "("), this.visitAllExpressions(e.parts, t, ","), t.print(e, ")"), null
                    }
                    visitAllExpressions(e, t, n) {
                        this.visitAllObjects(e => e.visitExpression(this, t), e, t, n)
                    }
                    visitAllObjects(e, t, n, s) {
                        let r = !1;
                        for (let i = 0; i < t.length; i++) i > 0 && (n.lineLength() > 80 ? (n.print(null, s, !0), r || (n.incIndent(), n.incIndent(), r = !0)) : n.print(null, s, !1)), e(t[i]);
                        r && (n.decIndent(), n.decIndent())
                    }
                    visitAllStatements(e, t) {
                        e.forEach(e => e.visitStatement(this, t))
                    }
                }

                function Gr(e, t, n = !0) {
                    if (null == e) return null;
                    const s = e.replace(Vr, (...e) => "$" == e[0] ? t ? "\\$" : "$" : "\n" == e[0] ? "\\n" : "\r" == e[0] ? "\\r" : `\\${e[0]}`);
                    return n || !$r.test(s) ? `'${s}'` : s
                }

                function Kr(e) {
                    let t = "";
                    for (let n = 0; n < e; n++) t += Br;
                    return t
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Qr extends Wr {
                    constructor() {
                        super(!1)
                    }
                    visitDeclareClassStmt(e, t) {
                        return t.pushClass(e), this._visitClassConstructor(e, t), null != e.parent && (t.print(e, `${e.name}.prototype = Object.create(`), e.parent.visitExpression(this, t), t.println(e, ".prototype);")), e.getters.forEach(n => this._visitClassGetter(e, n, t)), e.methods.forEach(n => this._visitClassMethod(e, n, t)), t.popClass(), null
                    }
                    _visitClassConstructor(e, t) {
                        t.print(e, `function ${e.name}(`), null != e.constructorMethod && this._visitParams(e.constructorMethod.params, t), t.println(e, ") {"), t.incIndent(), null != e.constructorMethod && e.constructorMethod.body.length > 0 && (t.println(e, "var self = this;"), this.visitAllStatements(e.constructorMethod.body, t)), t.decIndent(), t.println(e, "}")
                    }
                    _visitClassGetter(e, t, n) {
                        n.println(e, `Object.defineProperty(${e.name}.prototype, '${t.name}', { get: function() {`), n.incIndent(), t.body.length > 0 && (n.println(e, "var self = this;"), this.visitAllStatements(t.body, n)), n.decIndent(), n.println(e, "}});")
                    }
                    _visitClassMethod(e, t, n) {
                        n.print(e, `${e.name}.prototype.${t.name} = function(`), this._visitParams(t.params, n), n.println(e, ") {"), n.incIndent(), t.body.length > 0 && (n.println(e, "var self = this;"), this.visitAllStatements(t.body, n)), n.decIndent(), n.println(e, "};")
                    }
                    visitWrappedNodeExpr(e, t) {
                        throw new Error("Cannot emit a WrappedNodeExpr in Javascript.")
                    }
                    visitReadVarExpr(e, t) {
                        if (e.builtin === he.This) t.print(e, "self");
                        else {
                            if (e.builtin === he.Super) throw new Error("'super' needs to be handled at a parent ast node, not at the variable level!");
                            super.visitReadVarExpr(e, t)
                        }
                        return null
                    }
                    visitDeclareVarStmt(e, t) {
                        return t.print(e, `var ${e.name}`), e.value && (t.print(e, " = "), e.value.visitExpression(this, t)), t.println(e, ";"), null
                    }
                    visitCastExpr(e, t) {
                        return e.value.visitExpression(this, t), null
                    }
                    visitInvokeFunctionExpr(e, t) {
                        const n = e.fn;
                        return n instanceof ge && n.builtin === he.Super ? (t.currentClass.parent.visitExpression(this, t), t.print(e, ".call(this"), e.args.length > 0 && (t.print(e, ", "), this.visitAllExpressions(e.args, t, ",")), t.print(e, ")")) : super.visitInvokeFunctionExpr(e, t), null
                    }
                    visitFunctionExpr(e, t) {
                        return t.print(e, `function${e.name?" "+e.name:""}(`), this._visitParams(e.params, t), t.println(e, ") {"), t.incIndent(), this.visitAllStatements(e.statements, t), t.decIndent(), t.print(e, "}"), null
                    }
                    visitDeclareFunctionStmt(e, t) {
                        return t.print(e, `function ${e.name}(`), this._visitParams(e.params, t), t.println(e, ") {"), t.incIndent(), this.visitAllStatements(e.statements, t), t.decIndent(), t.println(e, "}"), null
                    }
                    visitTryCatchStmt(e, t) {
                        t.println(e, "try {"), t.incIndent(), this.visitAllStatements(e.bodyStmts, t), t.decIndent(), t.println(e, `} catch (${Hr.name}) {`), t.incIndent();
                        const n = [Ur.set(Hr.prop("stack")).toDeclStmt(null, [Je.Final])].concat(e.catchStmts);
                        return this.visitAllStatements(n, t), t.decIndent(), t.println(e, "}"), null
                    }
                    visitLocalizedString(e, t) {
                        t.print(e, '$localize((this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,"raw",{value:t}):e.raw=t,e})(');
                        const n = [e.serializeI18nHead()];
                        for (let s = 1; s < e.messageParts.length; s++) n.push(e.serializeI18nTemplatePart(s));
                        return t.print(e, `[${n.map(e=>Gr(e.cooked,!1)).join(", ")}], `), t.print(e, `[${n.map(e=>Gr(e.raw,!1)).join(", ")}])`), e.expressions.forEach(n => {
                            t.print(e, ", "), n.visitExpression(this, t)
                        }), t.print(e, ")"), null
                    }
                    _visitParams(e, t) {
                        this.visitAllObjects(e => t.print(null, e.name), e, t, ",")
                    }
                    getBuiltinMethodName(e) {
                        let t;
                        switch (e) {
                            case pe.ConcatArray:
                                t = "concat";
                                break;
                            case pe.SubscribeObservable:
                                t = "subscribe";
                                break;
                            case pe.Bind:
                                t = "bind";
                                break;
                            default:
                                throw new Error(`Unknown builtin method: ${e}`)
                        }
                        return t
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Zr {
                    evaluateStatements(e, t, n, s) {
                        const r = new Jr(n),
                            i = zr.createRoot();
                        return t.length > 0 && !t[0].isEquivalent(At("use strict").toStmt()) && (t = [At("use strict").toStmt(), ...t]), r.visitAllStatements(t, i), r.createReturnStmt(i), this.evaluateCode(e, i, r.getArgs(), s)
                    }
                    evaluateCode(e, t, n, s) {
                        let r = `"use strict";${t.toSource()}\n//# sourceURL=${e}`;
                        const i = [],
                            o = [];
                        for (const l in n) o.push(n[l]), i.push(l);
                        if (s) {
                            const n = new Function(...i.concat("return null;")).toString(),
                                s = n.slice(0, n.indexOf("return null;")).split("\n").length - 1;
                            r += `\n${t.toSourceMapGenerator(e,s).toJsComment()}`
                        }
                        const a = new Function(...i.concat(r));
                        return this.executeFunction(a, o)
                    }
                    executeFunction(e, t) {
                        return e(...t)
                    }
                }
                class Jr extends Qr {
                    constructor(e) {
                        super(), this.reflector = e, this._evalArgNames = [], this._evalArgValues = [], this._evalExportedVars = []
                    }
                    createReturnStmt(e) {
                        new rt(new Ge(this._evalExportedVars.map(e => new We(e, vt(e), !1)))).visitStatement(this, e)
                    }
                    getArgs() {
                        const e = {};
                        for (let t = 0; t < this._evalArgNames.length; t++) e[this._evalArgNames[t]] = this._evalArgValues[t];
                        return e
                    }
                    visitExternalExpr(e, t) {
                        return this._emitReferenceToExternal(e, this.reflector.resolveExternalReference(e.value), t), null
                    }
                    visitWrappedNodeExpr(e, t) {
                        return this._emitReferenceToExternal(e, e.node, t), null
                    }
                    visitDeclareVarStmt(e, t) {
                        return e.hasModifier(Je.Exported) && this._evalExportedVars.push(e.name), super.visitDeclareVarStmt(e, t)
                    }
                    visitDeclareFunctionStmt(e, t) {
                        return e.hasModifier(Je.Exported) && this._evalExportedVars.push(e.name), super.visitDeclareFunctionStmt(e, t)
                    }
                    visitDeclareClassStmt(e, t) {
                        return e.hasModifier(Je.Exported) && this._evalExportedVars.push(e.name), super.visitDeclareClassStmt(e, t)
                    }
                    _emitReferenceToExternal(e, t, n) {
                        let s = this._evalArgValues.indexOf(t);
                        if (-1 === s) {
                            s = this._evalArgValues.length, this._evalArgValues.push(t);
                            const e = yn({
                                reference: t
                            }) || "val";
                            this._evalArgNames.push(`jit_${e}_${s}`)
                        }
                        n.print(e, this._evalArgNames[s])
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Xr = 10,
                    Yr = 41,
                    ei = 44,
                    ti = 47,
                    ni = 58,
                    si = 59,
                    ri = 60,
                    ii = 61,
                    oi = 62,
                    ai = 97,
                    li = 122,
                    ci = 123,
                    ui = 125;

                function hi(e) {
                    return e >= 9 && e <= 32 || 160 == e
                }

                function pi(e) {
                    return 48 <= e && e <= 57
                }

                function di(e) {
                    return e >= ai && e <= li || e >= 65 && e <= 90
                }

                function fi(e) {
                    return e === Xr || 13 === e
                }

                function mi(e) {
                    return 48 <= e && e <= 55
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class gi {
                    constructor(e, t, n, s) {
                        this.file = e, this.offset = t, this.line = n, this.col = s
                    }
                    toString() {
                        return null != this.offset ? `${this.file.url}@${this.line}:${this.col}` : this.file.url
                    }
                    moveBy(e) {
                        const t = this.file.content,
                            n = t.length;
                        let s = this.offset,
                            r = this.line,
                            i = this.col;
                        for (; s > 0 && e < 0;) {
                            s--, e++;
                            if (t.charCodeAt(s) == Xr) {
                                r--;
                                const e = t.substr(0, s - 1).lastIndexOf(String.fromCharCode(Xr));
                                i = e > 0 ? s - e : s
                            } else i--
                        }
                        for (; s < n && e > 0;) {
                            const n = t.charCodeAt(s);
                            s++, e--, n == Xr ? (r++, i = 0) : i++
                        }
                        return new gi(this.file, s, r, i)
                    }
                    getContext(e, t) {
                        const n = this.file.content;
                        let s = this.offset;
                        if (null != s) {
                            s > n.length - 1 && (s = n.length - 1);
                            let r = s,
                                i = 0,
                                o = 0;
                            for (; i < e && s > 0 && (s--, i++, "\n" != n[s] || ++o != t););
                            for (i = 0, o = 0; i < e && r < n.length - 1 && (r++, i++, "\n" != n[r] || ++o != t););
                            return {
                                before: n.substring(s, this.offset),
                                after: n.substring(this.offset, r + 1)
                            }
                        }
                        return null
                    }
                }
                class yi {
                    constructor(e, t) {
                        this.content = e, this.url = t
                    }
                }
                class vi {
                    constructor(e, t, n = e, s = null) {
                        this.start = e, this.end = t, this.fullStart = n, this.details = s
                    }
                    toString() {
                        return this.start.file.content.substring(this.start.offset, this.end.offset)
                    }
                }
                var _i, bi, wi, Ei;
                ! function(e) {
                    e[e.WARNING = 0] = "WARNING", e[e.ERROR = 1] = "ERROR"
                }(_i || (_i = {}));
                class Ci {
                    constructor(e, t, n = _i.ERROR) {
                        this.span = e, this.msg = t, this.level = n
                    }
                    contextualMessage() {
                        const e = this.span.start.getContext(100, 3);
                        return e ? `${this.msg} ("${e.before}[${_i[this.level]} ->]${e.after}")` : this.msg
                    }
                    toString() {
                        const e = this.span.details ? `, ${this.span.details}` : "";
                        return `${this.contextualMessage()}: ${this.span.start}${e}`
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Si {
                    constructor(e) {
                        this.context = e
                    }
                    resolveExternalReference(e) {
                        if ("@angular/core" !== e.moduleName) throw new Error(`Cannot resolve external reference to ${e.moduleName}, only references to @angular/core are supported.`);
                        if (!this.context.hasOwnProperty(e.name)) throw new Error(`No value provided for @angular/core symbol '${e.name}'.`);
                        return this.context[e.name]
                    }
                    parameters(e) {
                        throw new Error("Not implemented.")
                    }
                    annotations(e) {
                        throw new Error("Not implemented.")
                    }
                    shallowAnnotations(e) {
                        throw new Error("Not implemented.")
                    }
                    tryAnnotations(e) {
                        throw new Error("Not implemented.")
                    }
                    propMetadata(e) {
                        throw new Error("Not implemented.")
                    }
                    hasLifecycleHook(e, t) {
                        throw new Error("Not implemented.")
                    }
                    guards(e) {
                        throw new Error("Not implemented.")
                    }
                    componentModuleUrl(e, t) {
                        throw new Error("Not implemented.")
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function xi(e, t = !1) {
                    return St(Object.keys(e).map(n => ({
                        key: n,
                        quoted: t,
                        value: e[n]
                    })))
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function Ti(e) {
                    const {
                        internalType: t,
                        type: n,
                        bootstrap: s,
                        declarations: r,
                        imports: i,
                        exports: o,
                        schemas: a,
                        containsForwardDecls: l,
                        emitInline: c,
                        id: u
                    } = e, h = [], p = {
                        type: t
                    };
                    if (s.length && (p.bootstrap = Di(s, l)), c) r.length && (p.declarations = Di(r, l)), i.length && (p.imports = Di(i, l)), o.length && (p.exports = Di(o, l));
                    else {
                        const t = function(e) {
                            const {
                                adjacentType: t,
                                declarations: n,
                                imports: s,
                                exports: r,
                                containsForwardDecls: i
                            } = e, o = {};
                            n.length && (o.declarations = Di(n, i));
                            s.length && (o.imports = Di(s, i));
                            r.length && (o.exports = Di(r, i));
                            if (0 === Object.keys(o).length) return null;
                            const a = function(e) {
                                    const t = new Me({
                                            name: "ngJitMode",
                                            moduleName: null
                                        }),
                                        n = new He(ue.Identical, new ye(t), At("undefined")),
                                        s = new He(ue.Or, n, t, void 0, void 0, !0);
                                    return new He(ue.And, s, e)
                                }(new Ce(_t(jn.setNgModuleScope), [t, Ln(o)])),
                                l = new $e([], [a.toStmt()]);
                            return new Ce(l, []).toStmt()
                        }(e);
                        null !== t && h.push(t)
                    }
                    a && a.length && (p.schemas = Ct(a.map(e => e.value))), u && (p.id = u);
                    return {
                        expression: _t(jn.defineNgModule).callFn([Ln(p)]),
                        type: new ee(_t(jn.NgModuleDefWithMeta, [new ee(n.type), Ai(r), Ai(i), Ai(o)])),
                        additionalStatements: h
                    }
                }

                function Ai(e) {
                    const t = e.map(e => Et(e.type));
                    return e.length > 0 ? wt(Ct(t)) : le
                }

                function Di(e, t) {
                    const n = Ct(e.map(e => e.value));
                    return t ? xt([], [new rt(n)]) : n
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function Pi(e) {
                    const t = [];
                    t.push({
                        key: "name",
                        value: At(e.pipeName),
                        quoted: !1
                    }), t.push({
                        key: "type",
                        value: e.type.value,
                        quoted: !1
                    }), t.push({
                        key: "pure",
                        value: At(e.pure),
                        quoted: !1
                    });
                    return {
                        expression: _t(jn.definePipe).callFn([St(t)]),
                        type: new ee(_t(jn.PipeDefWithMeta, [Vn(e.type.type, e.typeArgumentCount), new ee(new xe(e.pipeName))]))
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class ki {
                    constructor(e, t, n, s) {
                        this.input = t, this.errLocation = n, this.ctxLocation = s, this.message = `Parser Error: ${e} ${n} [${t}] in ${s}`
                    }
                }
                class Oi {
                    constructor(e, t) {
                        this.start = e, this.end = t
                    }
                    toAbsolute(e) {
                        return new so(e + this.start, e + this.end)
                    }
                }
                class Ii {
                    constructor(e, t) {
                        this.span = e, this.sourceSpan = t
                    }
                    visit(e, t = null) {
                        return null
                    }
                    toString() {
                        return "AST"
                    }
                }
                class Ni extends Ii {
                    constructor(e, t, n) {
                        super(e, t), this.nameSpan = n
                    }
                }
                class Mi extends Ii {
                    constructor(e, t, n, s, r) {
                        super(e, t), this.prefix = n, this.uninterpretedExpression = s, this.location = r
                    }
                    visit(e, t = null) {
                        return e.visitQuote(this, t)
                    }
                    toString() {
                        return "Quote"
                    }
                }
                class Fi extends Ii {
                    visit(e, t = null) {}
                }
                class Ri extends Ii {
                    visit(e, t = null) {
                        return e.visitImplicitReceiver(this, t)
                    }
                }
                class ji extends Ri {
                    visit(e, t = null) {
                        var n;
                        return null === (n = e.visitThisReceiver) || void 0 === n ? void 0 : n.call(e, this, t)
                    }
                }
                class Li extends Ii {
                    constructor(e, t, n) {
                        super(e, t), this.expressions = n
                    }
                    visit(e, t = null) {
                        return e.visitChain(this, t)
                    }
                }
                class Vi extends Ii {
                    constructor(e, t, n, s, r) {
                        super(e, t), this.condition = n, this.trueExp = s, this.falseExp = r
                    }
                    visit(e, t = null) {
                        return e.visitConditional(this, t)
                    }
                }
                class $i extends Ni {
                    constructor(e, t, n, s, r) {
                        super(e, t, n), this.receiver = s, this.name = r
                    }
                    visit(e, t = null) {
                        return e.visitPropertyRead(this, t)
                    }
                }
                class Bi extends Ni {
                    constructor(e, t, n, s, r, i) {
                        super(e, t, n), this.receiver = s, this.name = r, this.value = i
                    }
                    visit(e, t = null) {
                        return e.visitPropertyWrite(this, t)
                    }
                }
                class Hi extends Ni {
                    constructor(e, t, n, s, r) {
                        super(e, t, n), this.receiver = s, this.name = r
                    }
                    visit(e, t = null) {
                        return e.visitSafePropertyRead(this, t)
                    }
                }
                class Ui extends Ii {
                    constructor(e, t, n, s) {
                        super(e, t), this.obj = n, this.key = s
                    }
                    visit(e, t = null) {
                        return e.visitKeyedRead(this, t)
                    }
                }
                class qi extends Ii {
                    constructor(e, t, n, s, r) {
                        super(e, t), this.obj = n, this.key = s, this.value = r
                    }
                    visit(e, t = null) {
                        return e.visitKeyedWrite(this, t)
                    }
                }
                class zi extends Ni {
                    constructor(e, t, n, s, r, i) {
                        super(e, t, i), this.exp = n, this.name = s, this.args = r
                    }
                    visit(e, t = null) {
                        return e.visitPipe(this, t)
                    }
                }
                class Wi extends Ii {
                    constructor(e, t, n) {
                        super(e, t), this.value = n
                    }
                    visit(e, t = null) {
                        return e.visitLiteralPrimitive(this, t)
                    }
                }
                class Gi extends Ii {
                    constructor(e, t, n) {
                        super(e, t), this.expressions = n
                    }
                    visit(e, t = null) {
                        return e.visitLiteralArray(this, t)
                    }
                }
                class Ki extends Ii {
                    constructor(e, t, n, s) {
                        super(e, t), this.keys = n, this.values = s
                    }
                    visit(e, t = null) {
                        return e.visitLiteralMap(this, t)
                    }
                }
                class Qi extends Ii {
                    constructor(e, t, n, s) {
                        super(e, t), this.strings = n, this.expressions = s
                    }
                    visit(e, t = null) {
                        return e.visitInterpolation(this, t)
                    }
                }
                class Zi extends Ii {
                    constructor(e, t, n, s, r) {
                        super(e, t), this.operation = n, this.left = s, this.right = r
                    }
                    visit(e, t = null) {
                        return e.visitBinary(this, t)
                    }
                }
                class Ji extends Zi {
                    constructor(e, t, n, s, r, i, o) {
                        super(e, t, r, i, o), this.operator = n, this.expr = s
                    }
                    static createMinus(e, t, n) {
                        return new Ji(e, t, "-", n, "-", new Wi(e, t, 0), n)
                    }
                    static createPlus(e, t, n) {
                        return new Ji(e, t, "+", n, "-", n, new Wi(e, t, 0))
                    }
                    visit(e, t = null) {
                        return void 0 !== e.visitUnary ? e.visitUnary(this, t) : e.visitBinary(this, t)
                    }
                }
                class Xi extends Ii {
                    constructor(e, t, n) {
                        super(e, t), this.expression = n
                    }
                    visit(e, t = null) {
                        return e.visitPrefixNot(this, t)
                    }
                }
                class Yi extends Ii {
                    constructor(e, t, n) {
                        super(e, t), this.expression = n
                    }
                    visit(e, t = null) {
                        return e.visitNonNullAssert(this, t)
                    }
                }
                class eo extends Ni {
                    constructor(e, t, n, s, r, i) {
                        super(e, t, n), this.receiver = s, this.name = r, this.args = i
                    }
                    visit(e, t = null) {
                        return e.visitMethodCall(this, t)
                    }
                }
                class to extends Ni {
                    constructor(e, t, n, s, r, i) {
                        super(e, t, n), this.receiver = s, this.name = r, this.args = i
                    }
                    visit(e, t = null) {
                        return e.visitSafeMethodCall(this, t)
                    }
                }
                class no extends Ii {
                    constructor(e, t, n, s) {
                        super(e, t), this.target = n, this.args = s
                    }
                    visit(e, t = null) {
                        return e.visitFunctionCall(this, t)
                    }
                }
                class so {
                    constructor(e, t) {
                        this.start = e, this.end = t
                    }
                }
                class ro extends Ii {
                    constructor(e, t, n, s, r) {
                        super(new Oi(0, null === t ? 0 : t.length), new so(s, null === t ? s : s + t.length)), this.ast = e, this.source = t, this.location = n, this.errors = r
                    }
                    visit(e, t = null) {
                        return e.visitASTWithSource ? e.visitASTWithSource(this, t) : this.ast.visit(e, t)
                    }
                    toString() {
                        return `${this.source} in ${this.location}`
                    }
                }
                class io {
                    constructor(e, t, n) {
                        this.sourceSpan = e, this.key = t, this.value = n
                    }
                }
                class oo {
                    constructor(e, t, n) {
                        this.sourceSpan = e, this.key = t, this.value = n
                    }
                }
                class ao {
                    visit(e, t) {
                        e.visit(this, t)
                    }
                    visitUnary(e, t) {
                        this.visit(e.expr, t)
                    }
                    visitBinary(e, t) {
                        this.visit(e.left, t), this.visit(e.right, t)
                    }
                    visitChain(e, t) {
                        this.visitAll(e.expressions, t)
                    }
                    visitConditional(e, t) {
                        this.visit(e.condition, t), this.visit(e.trueExp, t), this.visit(e.falseExp, t)
                    }
                    visitPipe(e, t) {
                        this.visit(e.exp, t), this.visitAll(e.args, t)
                    }
                    visitFunctionCall(e, t) {
                        e.target && this.visit(e.target, t), this.visitAll(e.args, t)
                    }
                    visitImplicitReceiver(e, t) {}
                    visitThisReceiver(e, t) {}
                    visitInterpolation(e, t) {
                        this.visitAll(e.expressions, t)
                    }
                    visitKeyedRead(e, t) {
                        this.visit(e.obj, t), this.visit(e.key, t)
                    }
                    visitKeyedWrite(e, t) {
                        this.visit(e.obj, t), this.visit(e.key, t), this.visit(e.value, t)
                    }
                    visitLiteralArray(e, t) {
                        this.visitAll(e.expressions, t)
                    }
                    visitLiteralMap(e, t) {
                        this.visitAll(e.values, t)
                    }
                    visitLiteralPrimitive(e, t) {}
                    visitMethodCall(e, t) {
                        this.visit(e.receiver, t), this.visitAll(e.args, t)
                    }
                    visitPrefixNot(e, t) {
                        this.visit(e.expression, t)
                    }
                    visitNonNullAssert(e, t) {
                        this.visit(e.expression, t)
                    }
                    visitPropertyRead(e, t) {
                        this.visit(e.receiver, t)
                    }
                    visitPropertyWrite(e, t) {
                        this.visit(e.receiver, t), this.visit(e.value, t)
                    }
                    visitSafePropertyRead(e, t) {
                        this.visit(e.receiver, t)
                    }
                    visitSafeMethodCall(e, t) {
                        this.visit(e.receiver, t), this.visitAll(e.args, t)
                    }
                    visitQuote(e, t) {}
                    visitAll(e, t) {
                        for (const n of e) this.visit(n, t)
                    }
                }
                class lo {
                    constructor(e, t, n, s, r, i) {
                        this.name = e, this.expression = t, this.type = n, this.sourceSpan = s, this.keySpan = r, this.valueSpan = i, this.isLiteral = this.type === bi.LITERAL_ATTR, this.isAnimation = this.type === bi.ANIMATION
                    }
                }! function(e) {
                    e[e.DEFAULT = 0] = "DEFAULT", e[e.LITERAL_ATTR = 1] = "LITERAL_ATTR", e[e.ANIMATION = 2] = "ANIMATION"
                }(bi || (bi = {}));
                class co {
                    constructor(e, t, n, s, r, i) {
                        this.name = e, this.targetOrPhase = t, this.type = n, this.handler = s, this.sourceSpan = r, this.handlerSpan = i
                    }
                }
                class uo {
                    constructor(e, t, n, s, r) {
                        this.name = e, this.value = t, this.sourceSpan = n, this.keySpan = s, this.valueSpan = r
                    }
                }
                class ho {
                    constructor(e, t, n, s, r, i, o, a) {
                        this.name = e, this.type = t, this.securityContext = n, this.value = s, this.unit = r, this.sourceSpan = i, this.keySpan = o, this.valueSpan = a
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class po {}
                po.event = vt("$event");
                class fo {
                    constructor(e, t) {
                        this.stmts = e, this.allowDefault = t, this.render3Stmts = e.map(e => {
                            if (e instanceof tt && e.name == t.name && e.value instanceof He) {
                                const t = e.value.lhs;
                                return new rt(t.value)
                            }
                            return e
                        })
                    }
                }

                function mo(e, t, n, s, r, i, o, a) {
                    e || (e = new Ao(a));
                    const l = go({
                            createLiteralArrayConverter: e => e => Ct(e),
                            createLiteralMapConverter: e => t => St(e.map((e, n) => ({
                                key: e.key,
                                value: t[n],
                                quoted: e.quoted
                            }))),
                            createPipeConverter: e => {
                                throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${e}`)
                            }
                        }, n),
                        c = new xo(e, t, s, r, i, o),
                        u = [];
                    To(l.visit(c, Ei.Statement), u),
                        function(e, t, n) {
                            for (let s = e - 1; s >= 0; s--) n.unshift(wo(t, s))
                        }(c.temporaryCount, s, u), c.usesImplicitReceiver && e.notifyImplicitReceiverUse();
                    const h = u.length - 1;
                    let p = null;
                    if (h >= 0) {
                        const e = function(e) {
                            if (e instanceof st) return e.expr;
                            if (e instanceof rt) return e.value;
                            return null
                        }(u[h]);
                        e && (p = function(e) {
                            return vt(`pd_${e}`)
                        }(s), u[h] = p.set(e.cast(se).notIdentical(At(!1))).toDeclStmt(null, [Je.Final]))
                    }
                    return new fo(u, p)
                }

                function go(e, t) {
                    return function(e, t) {
                        const n = new So(e);
                        return t.visit(n)
                    }(e, t)
                }
                class yo {
                    constructor(e, t) {
                        this.stmts = e, this.currValExpr = t
                    }
                }

                function vo(e, t, n, s, r, i) {
                    e || (e = new Ao);
                    const o = new xo(e, t, s, i),
                        a = n.visit(o, Ei.Expression),
                        l = _o(o, s);
                    if (o.usesImplicitReceiver && e.notifyImplicitReceiverUse(), 0 === o.temporaryCount && r == wi.TrySimple) return new yo([], a);
                    if (r === wi.Expression) return new yo(l, a);
                    const c = function(e) {
                        return vt(`currVal_${e}`)
                    }(s);
                    return l.push(c.set(a).toDeclStmt(se, [Je.Final])), new yo(l, c)
                }

                function _o(e, t) {
                    const n = [];
                    for (let s = 0; s < e.temporaryCount; s++) n.push(wo(t, s));
                    return n
                }

                function bo(e, t) {
                    return `tmp_${e}_${t}`
                }

                function wo(e, t) {
                    return new tt(bo(e, t), Qe)
                }

                function Eo(e, t) {
                    if (e !== Ei.Expression) throw new Error(`Expected an expression, but saw ${t}`)
                }

                function Co(e, t) {
                    return e === Ei.Statement ? t.toStmt() : t
                }! function(e) {
                    e[e.General = 0] = "General", e[e.TrySimple = 1] = "TrySimple", e[e.Expression = 2] = "Expression"
                }(wi || (wi = {})),
                function(e) {
                    e[e.Statement = 0] = "Statement", e[e.Expression = 1] = "Expression"
                }(Ei || (Ei = {}));
                class So extends class {
                    visitImplicitReceiver(e, t) {
                        return e
                    }
                    visitThisReceiver(e, t) {
                        return e
                    }
                    visitInterpolation(e, t) {
                        return new Qi(e.span, e.sourceSpan, e.strings, this.visitAll(e.expressions))
                    }
                    visitLiteralPrimitive(e, t) {
                        return new Wi(e.span, e.sourceSpan, e.value)
                    }
                    visitPropertyRead(e, t) {
                        return new $i(e.span, e.sourceSpan, e.nameSpan, e.receiver.visit(this), e.name)
                    }
                    visitPropertyWrite(e, t) {
                        return new Bi(e.span, e.sourceSpan, e.nameSpan, e.receiver.visit(this), e.name, e.value.visit(this))
                    }
                    visitSafePropertyRead(e, t) {
                        return new Hi(e.span, e.sourceSpan, e.nameSpan, e.receiver.visit(this), e.name)
                    }
                    visitMethodCall(e, t) {
                        return new eo(e.span, e.sourceSpan, e.nameSpan, e.receiver.visit(this), e.name, this.visitAll(e.args))
                    }
                    visitSafeMethodCall(e, t) {
                        return new to(e.span, e.sourceSpan, e.nameSpan, e.receiver.visit(this), e.name, this.visitAll(e.args))
                    }
                    visitFunctionCall(e, t) {
                        return new no(e.span, e.sourceSpan, e.target.visit(this), this.visitAll(e.args))
                    }
                    visitLiteralArray(e, t) {
                        return new Gi(e.span, e.sourceSpan, this.visitAll(e.expressions))
                    }
                    visitLiteralMap(e, t) {
                        return new Ki(e.span, e.sourceSpan, e.keys, this.visitAll(e.values))
                    }
                    visitUnary(e, t) {
                        switch (e.operator) {
                            case "+":
                                return Ji.createPlus(e.span, e.sourceSpan, e.expr.visit(this));
                            case "-":
                                return Ji.createMinus(e.span, e.sourceSpan, e.expr.visit(this));
                            default:
                                throw new Error(`Unknown unary operator ${e.operator}`)
                        }
                    }
                    visitBinary(e, t) {
                        return new Zi(e.span, e.sourceSpan, e.operation, e.left.visit(this), e.right.visit(this))
                    }
                    visitPrefixNot(e, t) {
                        return new Xi(e.span, e.sourceSpan, e.expression.visit(this))
                    }
                    visitNonNullAssert(e, t) {
                        return new Yi(e.span, e.sourceSpan, e.expression.visit(this))
                    }
                    visitConditional(e, t) {
                        return new Vi(e.span, e.sourceSpan, e.condition.visit(this), e.trueExp.visit(this), e.falseExp.visit(this))
                    }
                    visitPipe(e, t) {
                        return new zi(e.span, e.sourceSpan, e.exp.visit(this), e.name, this.visitAll(e.args), e.nameSpan)
                    }
                    visitKeyedRead(e, t) {
                        return new Ui(e.span, e.sourceSpan, e.obj.visit(this), e.key.visit(this))
                    }
                    visitKeyedWrite(e, t) {
                        return new qi(e.span, e.sourceSpan, e.obj.visit(this), e.key.visit(this), e.value.visit(this))
                    }
                    visitAll(e) {
                        const t = [];
                        for (let n = 0; n < e.length; ++n) t[n] = e[n].visit(this);
                        return t
                    }
                    visitChain(e, t) {
                        return new Li(e.span, e.sourceSpan, this.visitAll(e.expressions))
                    }
                    visitQuote(e, t) {
                        return new Mi(e.span, e.sourceSpan, e.prefix, e.uninterpretedExpression, e.location)
                    }
                } {
                    constructor(e) {
                        super(), this._converterFactory = e
                    }
                    visitPipe(e, t) {
                        const n = [e.exp, ...e.args].map(e => e.visit(this, t));
                        return new Do(e.span, e.sourceSpan, n, this._converterFactory.createPipeConverter(e.name, n.length))
                    }
                    visitLiteralArray(e, t) {
                        const n = e.expressions.map(e => e.visit(this, t));
                        return new Do(e.span, e.sourceSpan, n, this._converterFactory.createLiteralArrayConverter(e.expressions.length))
                    }
                    visitLiteralMap(e, t) {
                        const n = e.values.map(e => e.visit(this, t));
                        return new Do(e.span, e.sourceSpan, n, this._converterFactory.createLiteralMapConverter(e.keys))
                    }
                }
                class xo {
                    constructor(e, t, n, s, r, i) {
                        this._localResolver = e, this._implicitReceiver = t, this.bindingId = n, this.interpolationFunction = s, this.baseSourceSpan = r, this.implicitReceiverAccesses = i, this._nodeMap = new Map, this._resultMap = new Map, this._currentTemporary = 0, this.temporaryCount = 0, this.usesImplicitReceiver = !1
                    }
                    visitUnary(e, t) {
                        let n;
                        switch (e.operator) {
                            case "+":
                                n = ce.Plus;
                                break;
                            case "-":
                                n = ce.Minus;
                                break;
                            default:
                                throw new Error(`Unsupported operator ${e.operator}`)
                        }
                        return Co(t, new Be(n, this._visit(e.expr, Ei.Expression), void 0, this.convertSourceSpan(e.span)))
                    }
                    visitBinary(e, t) {
                        let n;
                        switch (e.operation) {
                            case "+":
                                n = ue.Plus;
                                break;
                            case "-":
                                n = ue.Minus;
                                break;
                            case "*":
                                n = ue.Multiply;
                                break;
                            case "/":
                                n = ue.Divide;
                                break;
                            case "%":
                                n = ue.Modulo;
                                break;
                            case "&&":
                                n = ue.And;
                                break;
                            case "||":
                                n = ue.Or;
                                break;
                            case "==":
                                n = ue.Equals;
                                break;
                            case "!=":
                                n = ue.NotEquals;
                                break;
                            case "===":
                                n = ue.Identical;
                                break;
                            case "!==":
                                n = ue.NotIdentical;
                                break;
                            case "<":
                                n = ue.Lower;
                                break;
                            case ">":
                                n = ue.Bigger;
                                break;
                            case "<=":
                                n = ue.LowerEquals;
                                break;
                            case ">=":
                                n = ue.BiggerEquals;
                                break;
                            default:
                                throw new Error(`Unsupported operation ${e.operation}`)
                        }
                        return Co(t, new He(n, this._visit(e.left, Ei.Expression), this._visit(e.right, Ei.Expression), void 0, this.convertSourceSpan(e.span)))
                    }
                    visitChain(e, t) {
                        return function(e, t) {
                            if (e !== Ei.Statement) throw new Error(`Expected a statement, but saw ${t}`)
                        }(t, e), this.visitAll(e.expressions, t)
                    }
                    visitConditional(e, t) {
                        return Co(t, this._visit(e.condition, Ei.Expression).conditional(this._visit(e.trueExp, Ei.Expression), this._visit(e.falseExp, Ei.Expression), this.convertSourceSpan(e.span)))
                    }
                    visitPipe(e, t) {
                        throw new Error(`Illegal state: Pipes should have been converted into functions. Pipe: ${e.name}`)
                    }
                    visitFunctionCall(e, t) {
                        const n = this.visitAll(e.args, Ei.Expression);
                        let s;
                        return s = e instanceof Do ? e.converter(n) : this._visit(e.target, Ei.Expression).callFn(n, this.convertSourceSpan(e.span)), Co(t, s)
                    }
                    visitImplicitReceiver(e, t) {
                        return Eo(t, e), this.usesImplicitReceiver = !0, this._implicitReceiver
                    }
                    visitThisReceiver(e, t) {
                        return this.visitImplicitReceiver(e, t)
                    }
                    visitInterpolation(e, t) {
                        Eo(t, e);
                        const n = [At(e.expressions.length)];
                        for (let s = 0; s < e.strings.length - 1; s++) n.push(At(e.strings[s])), n.push(this._visit(e.expressions[s], Ei.Expression));
                        return n.push(At(e.strings[e.strings.length - 1])), this.interpolationFunction ? this.interpolationFunction(n) : e.expressions.length <= 9 ? _t(cn.inlineInterpolate).callFn(n) : _t(cn.interpolate).callFn([n[0], Ct(n.slice(1), void 0, this.convertSourceSpan(e.span))])
                    }
                    visitKeyedRead(e, t) {
                        const n = this.leftMostSafeNode(e);
                        return n ? this.convertSafeAccess(e, n, t) : Co(t, this._visit(e.obj, Ei.Expression).key(this._visit(e.key, Ei.Expression)))
                    }
                    visitKeyedWrite(e, t) {
                        const n = this._visit(e.obj, Ei.Expression),
                            s = this._visit(e.key, Ei.Expression),
                            r = this._visit(e.value, Ei.Expression);
                        return Co(t, n.key(s).set(r))
                    }
                    visitLiteralArray(e, t) {
                        throw new Error("Illegal State: literal arrays should have been converted into functions")
                    }
                    visitLiteralMap(e, t) {
                        throw new Error("Illegal State: literal maps should have been converted into functions")
                    }
                    visitLiteralPrimitive(e, t) {
                        const n = null === e.value || void 0 === e.value || !0 === e.value || !0 === e.value ? re : void 0;
                        return Co(t, At(e.value, n, this.convertSourceSpan(e.span)))
                    }
                    _getLocal(e, t) {
                        var n;
                        return (null === (n = this._localResolver.globals) || void 0 === n ? void 0 : n.has(e)) && t instanceof ji ? null : this._localResolver.getLocal(e)
                    }
                    visitMethodCall(e, t) {
                        if (e.receiver instanceof Ri && !(e.receiver instanceof ji) && "$any" === e.name) {
                            const t = this.visitAll(e.args, Ei.Expression);
                            if (1 != t.length) throw new Error(`Invalid call to $any, expected 1 argument but received ${t.length||"none"}`);
                            return t[0].cast(se, this.convertSourceSpan(e.span))
                        }
                        const n = this.leftMostSafeNode(e);
                        if (n) return this.convertSafeAccess(e, n, t); {
                            const n = this.visitAll(e.args, Ei.Expression),
                                s = this.usesImplicitReceiver;
                            let r = null;
                            const i = this._visit(e.receiver, Ei.Expression);
                            if (i === this._implicitReceiver) {
                                const t = this._getLocal(e.name, e.receiver);
                                t && (this.usesImplicitReceiver = s, r = t.callFn(n), this.addImplicitReceiverAccess(e.name))
                            }
                            return null == r && (r = i.callMethod(e.name, n, this.convertSourceSpan(e.span))), Co(t, r)
                        }
                    }
                    visitPrefixNot(e, t) {
                        return Co(t, (n = this._visit(e.expression, Ei.Expression), new Re(n, s)));
                        var n, s
                    }
                    visitNonNullAssert(e, t) {
                        return Co(t, (n = this._visit(e.expression, Ei.Expression), new je(n, s)));
                        var n, s
                    }
                    visitPropertyRead(e, t) {
                        const n = this.leftMostSafeNode(e);
                        if (n) return this.convertSafeAccess(e, n, t); {
                            let n = null;
                            const s = this.usesImplicitReceiver,
                                r = this._visit(e.receiver, Ei.Expression);
                            return r === this._implicitReceiver && (n = this._getLocal(e.name, e.receiver), n && (this.usesImplicitReceiver = s, this.addImplicitReceiverAccess(e.name))), null == n && (n = r.prop(e.name)), Co(t, n)
                        }
                    }
                    visitPropertyWrite(e, t) {
                        const n = this._visit(e.receiver, Ei.Expression),
                            s = this.usesImplicitReceiver;
                        let r = null;
                        if (n === this._implicitReceiver) {
                            const t = this._getLocal(e.name, e.receiver);
                            if (t) {
                                if (!(t instanceof Ue)) {
                                    const t = e.name,
                                        n = e.value instanceof $i ? e.value.name : void 0;
                                    throw new Error(`Cannot assign value "${n}" to template variable "${t}". Template variables are read-only.`)
                                }
                                r = t, this.usesImplicitReceiver = s, this.addImplicitReceiverAccess(e.name)
                            }
                        }
                        return null === r && (r = n.prop(e.name)), Co(t, r.set(this._visit(e.value, Ei.Expression)))
                    }
                    visitSafePropertyRead(e, t) {
                        return this.convertSafeAccess(e, this.leftMostSafeNode(e), t)
                    }
                    visitSafeMethodCall(e, t) {
                        return this.convertSafeAccess(e, this.leftMostSafeNode(e), t)
                    }
                    visitAll(e, t) {
                        return e.map(e => this._visit(e, t))
                    }
                    visitQuote(e, t) {
                        throw new Error(`Quotes are not supported for evaluation!\n        Statement: ${e.uninterpretedExpression} located at ${e.location}`)
                    }
                    _visit(e, t) {
                        const n = this._resultMap.get(e);
                        return n || (this._nodeMap.get(e) || e).visit(this, t)
                    }
                    convertSafeAccess(e, t, n) {
                        let s, r = this._visit(t.receiver, Ei.Expression);
                        this.needsTemporary(t.receiver) && (s = this.allocateTemporary(), r = s.set(r), this._resultMap.set(t.receiver, s));
                        const i = r.isBlank();
                        t instanceof to ? this._nodeMap.set(t, new eo(t.span, t.sourceSpan, t.nameSpan, t.receiver, t.name, t.args)) : this._nodeMap.set(t, new $i(t.span, t.sourceSpan, t.nameSpan, t.receiver, t.name));
                        const o = this._visit(e, Ei.Expression);
                        return this._nodeMap.delete(t), s && this.releaseTemporary(s), Co(n, i.conditional(At(null), o))
                    }
                    leftMostSafeNode(e) {
                        const t = (e, t) => (this._nodeMap.get(t) || t).visit(e);
                        return e.visit({
                            visitUnary: e => null,
                            visitBinary: e => null,
                            visitChain: e => null,
                            visitConditional: e => null,
                            visitFunctionCall: e => null,
                            visitImplicitReceiver: e => null,
                            visitThisReceiver: e => null,
                            visitInterpolation: e => null,
                            visitKeyedRead(e) {
                                return t(this, e.obj)
                            },
                            visitKeyedWrite: e => null,
                            visitLiteralArray: e => null,
                            visitLiteralMap: e => null,
                            visitLiteralPrimitive: e => null,
                            visitMethodCall(e) {
                                return t(this, e.receiver)
                            },
                            visitPipe: e => null,
                            visitPrefixNot: e => null,
                            visitNonNullAssert: e => null,
                            visitPropertyRead(e) {
                                return t(this, e.receiver)
                            },
                            visitPropertyWrite: e => null,
                            visitQuote: e => null,
                            visitSafeMethodCall(e) {
                                return t(this, e.receiver) || e
                            },
                            visitSafePropertyRead(e) {
                                return t(this, e.receiver) || e
                            }
                        })
                    }
                    needsTemporary(e) {
                        const t = (e, t) => t && (this._nodeMap.get(t) || t).visit(e);
                        return e.visit({
                            visitUnary(e) {
                                return t(this, e.expr)
                            },
                            visitBinary(e) {
                                return t(this, e.left) || t(this, e.right)
                            },
                            visitChain: e => !1,
                            visitConditional(e) {
                                return t(this, e.condition) || t(this, e.trueExp) || t(this, e.falseExp)
                            },
                            visitFunctionCall: e => !0,
                            visitImplicitReceiver: e => !1,
                            visitThisReceiver: e => !1,
                            visitInterpolation(e) {
                                return ((e, n) => n.some(n => t(e, n)))(this, e.expressions)
                            },
                            visitKeyedRead: e => !1,
                            visitKeyedWrite: e => !1,
                            visitLiteralArray: e => !0,
                            visitLiteralMap: e => !0,
                            visitLiteralPrimitive: e => !1,
                            visitMethodCall: e => !0,
                            visitPipe: e => !0,
                            visitPrefixNot(e) {
                                return t(this, e.expression)
                            },
                            visitNonNullAssert(e) {
                                return t(this, e.expression)
                            },
                            visitPropertyRead: e => !1,
                            visitPropertyWrite: e => !1,
                            visitQuote: e => !1,
                            visitSafeMethodCall: e => !0,
                            visitSafePropertyRead: e => !1
                        })
                    }
                    allocateTemporary() {
                        const e = this._currentTemporary++;
                        return this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount), new ge(bo(this.bindingId, e))
                    }
                    releaseTemporary(e) {
                        if (this._currentTemporary--, e.name != bo(this.bindingId, this._currentTemporary)) throw new Error(`Temporary ${e.name} released out of order`)
                    }
                    convertSourceSpan(e) {
                        if (this.baseSourceSpan) {
                            const t = this.baseSourceSpan.start.moveBy(e.start),
                                n = this.baseSourceSpan.start.moveBy(e.end),
                                s = this.baseSourceSpan.fullStart.moveBy(e.start);
                            return new vi(t, n, s)
                        }
                        return null
                    }
                    addImplicitReceiverAccess(e) {
                        this.implicitReceiverAccesses && this.implicitReceiverAccesses.add(e)
                    }
                }

                function To(e, t) {
                    Array.isArray(e) ? e.forEach(e => To(e, t)) : t.push(e)
                }
                class Ao {
                    constructor(e) {
                        this.globals = e
                    }
                    notifyImplicitReceiverUse() {}
                    getLocal(e) {
                        return e === po.event.name ? po.event : null
                    }
                }
                class Do extends no {
                    constructor(e, t, n, s) {
                        super(e, t, null, n), this.args = n, this.converter = s
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Po {
                    constructor() {
                        this.strictStyling = !0
                    }
                    shimCssText(e, t, n = "") {
                        const s = e.match(Ko) || [];
                        e = function(e) {
                            return e.replace(Go, "")
                        }(e), e = this._insertDirectives(e);
                        return [this._scopeCssText(e, t, n), ...s].join("\n")
                    }
                    _insertDirectives(e) {
                        return e = this._insertPolyfillDirectivesInCssText(e), this._insertPolyfillRulesInCssText(e)
                    }
                    _insertPolyfillDirectivesInCssText(e) {
                        return e.replace(Oo, function(...e) {
                            return e[2] + "{"
                        })
                    }
                    _insertPolyfillRulesInCssText(e) {
                        return e.replace(Io, (...e) => {
                            const t = e[0].replace(e[1], "").replace(e[2], "");
                            return e[4] + t
                        })
                    }
                    _scopeCssText(e, t, n) {
                        const s = this._extractUnscopedRulesFromCssText(e);
                        return e = this._insertPolyfillHostInCssText(e), e = this._convertColonHost(e), e = this._convertColonHostContext(e), e = this._convertShadowDOMSelectors(e), t && (e = this._scopeSelectors(e, t, n)), (e = e + "\n" + s).trim()
                    }
                    _extractUnscopedRulesFromCssText(e) {
                        let t, n = "";
                        for (No.lastIndex = 0; null !== (t = No.exec(e));) {
                            n += t[0].replace(t[2], "").replace(t[1], t[4]) + "\n\n"
                        }
                        return n
                    }
                    _convertColonHost(e) {
                        return this._convertColonRule(e, jo, this._colonHostPartReplacer)
                    }
                    _convertColonHostContext(e) {
                        return this._convertColonRule(e, Lo, this._colonHostContextPartReplacer)
                    }
                    _convertColonRule(e, t, n) {
                        return e.replace(t, function(...e) {
                            if (e[2]) {
                                const t = e[2].split(","),
                                    s = [];
                                for (let r = 0; r < t.length; r++) {
                                    const i = t[r].trim();
                                    if (!i) break;
                                    s.push(n(Vo, i, e[3]))
                                }
                                return s.join(",")
                            }
                            return Vo + e[3]
                        })
                    }
                    _colonHostContextPartReplacer(e, t, n) {
                        return t.indexOf(Mo) > -1 ? this._colonHostPartReplacer(e, t, n) : e + t + n + ", " + t + " " + e + n
                    }
                    _colonHostPartReplacer(e, t, n) {
                        return e + t.replace(Mo, "") + n
                    }
                    _convertShadowDOMSelectors(e) {
                        return Bo.reduce((e, t) => e.replace(t, " "), e)
                    }
                    _scopeSelectors(e, t, n) {
                        return function(e, t) {
                            const n = sa(e, ea, Zo),
                                s = sa(n.escapedString, Yo, Qo);
                            let r = 0,
                                i = 0;
                            return s.escapedString.replace(Jo, (...e) => {
                                const n = e[2];
                                let i = "",
                                    o = e[4],
                                    a = "";
                                o && o.startsWith("{%BLOCK%") && (i = s.blocks[r++], o = o.substring(Qo.length + 1), a = "{");
                                const l = t(new ta(n, i));
                                return `${e[1]}${l.selector}${e[3]}${a}${l.content}${o}`
                            }).replace(Xo, () => n.blocks[i++])
                        }(e, e => {
                            let s = e.selector,
                                r = e.content;
                            return "@" != e.selector[0] ? s = this._scopeSelector(e.selector, t, n, this.strictStyling) : (e.selector.startsWith("@media") || e.selector.startsWith("@supports") || e.selector.startsWith("@page") || e.selector.startsWith("@document")) && (r = this._scopeSelectors(e.content, t, n)), new ta(s, r)
                        })
                    }
                    _scopeSelector(e, t, n, s) {
                        return e.split(",").map(e => e.trim().split(Ho)).map(e => {
                            const [r, ...i] = e;
                            return [(e => this._selectorNeedsScoping(e, t) ? s ? this._applyStrictSelectorScope(e, t, n) : this._applySelectorScope(e, t, n) : e)(r), ...i].join(" ")
                        }).join(", ")
                    }
                    _selectorNeedsScoping(e, t) {
                        return !this._makeScopeMatcher(t).test(e)
                    }
                    _makeScopeMatcher(e) {
                        return e = e.replace(/\[/g, "\\[").replace(/\]/g, "\\]"), new RegExp("^(" + e + ")" + Uo, "m")
                    }
                    _applySelectorScope(e, t, n) {
                        return this._applySimpleSelectorScope(e, t, n)
                    }
                    _applySimpleSelectorScope(e, t, n) {
                        if (qo.lastIndex = 0, qo.test(e)) {
                            const s = this.strictStyling ? `[${n}]` : t;
                            return e.replace($o, (e, t) => t.replace(/([^:]*)(:*)(.*)/, (e, t, n, r) => t + s + n + r)).replace(qo, s + " ")
                        }
                        return t + " " + e
                    }
                    _applyStrictSelectorScope(e, t, n) {
                        const s = "[" + (t = t.replace(/\[is=([^\]]*)\]/g, (e, ...t) => t[0])) + "]",
                            r = e => {
                                let r = e.trim();
                                if (!r) return "";
                                if (e.indexOf(Vo) > -1) r = this._applySimpleSelectorScope(e, t, n);
                                else {
                                    const t = e.replace(qo, "");
                                    if (t.length > 0) {
                                        const e = t.match(/([^:]*)(:*)(.*)/);
                                        e && (r = e[1] + s + e[2] + e[3])
                                    }
                                }
                                return r
                            },
                            i = new ko(e);
                        let o, a = "",
                            l = 0;
                        const c = /( |>|\+|~(?!=))\s*/g;
                        let u = !((e = i.content()).indexOf(Vo) > -1);
                        for (; null !== (o = c.exec(e));) {
                            const t = o[1],
                                n = e.slice(l, o.index).trim();
                            u = u || n.indexOf(Vo) > -1;
                            a += `${u?r(n):n} ${t} `, l = c.lastIndex
                        }
                        const h = e.substring(l);
                        return u = u || h.indexOf(Vo) > -1, a += u ? r(h) : h, i.restore(a)
                    }
                    _insertPolyfillHostInCssText(e) {
                        return e.replace(Wo, Fo).replace(zo, Mo)
                    }
                }
                class ko {
                    constructor(e) {
                        this.placeholders = [], this.index = 0, e = this._escapeRegexMatches(e, /(\[[^\]]*\])/g), e = this._escapeRegexMatches(e, /(\\.)/g), this._content = e.replace(/(:nth-[-\w]+)(\([^)]+\))/g, (e, t, n) => {
                            const s = `__ph-${this.index}__`;
                            return this.placeholders.push(n), this.index++, t + s
                        })
                    }
                    restore(e) {
                        return e.replace(/__ph-(\d+)__/g, (e, t) => this.placeholders[+t])
                    }
                    content() {
                        return this._content
                    }
                    _escapeRegexMatches(e, t) {
                        return e.replace(t, (e, t) => {
                            const n = `__ph-${this.index}__`;
                            return this.placeholders.push(t), this.index++, n
                        })
                    }
                }
                const Oo = /polyfill-next-selector[^}]*content:[\s]*?(['"])(.*?)\1[;\s]*}([^{]*?){/gim,
                    Io = /(polyfill-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim,
                    No = /(polyfill-unscoped-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim,
                    Mo = "-shadowcsshost",
                    Fo = "-shadowcsscontext",
                    Ro = ")(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))?([^,{]*)",
                    jo = new RegExp("(" + Mo + Ro, "gim"),
                    Lo = new RegExp("(" + Fo + Ro, "gim"),
                    Vo = Mo + "-no-combinator",
                    $o = /-shadowcsshost-no-combinator([^\s]*)/,
                    Bo = [/::shadow/g, /::content/g, /\/shadow-deep\//g, /\/shadow\//g],
                    Ho = /(?:>>>)|(?:\/deep\/)|(?:::ng-deep)/g,
                    Uo = "([>\\s~+[.,{:][\\s\\S]*)?$",
                    qo = /-shadowcsshost/gim,
                    zo = /:host/gim,
                    Wo = /:host-context/gim,
                    Go = /\/\*\s*[\s\S]*?\*\//g;
                const Ko = /\/\*\s*#\s*source(Mapping)?URL=[\s\S]+?\*\//g;
                const Qo = "%BLOCK%",
                    Zo = "%QUOTED%",
                    Jo = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g,
                    Xo = /%QUOTED%/g,
                    Yo = new Map([
                        ["{", "}"]
                    ]),
                    ea = new Map([
                        ['"', '"'],
                        ["'", "'"]
                    ]);
                class ta {
                    constructor(e, t) {
                        this.selector = e, this.content = t
                    }
                }
                class na {
                    constructor(e, t) {
                        this.escapedString = e, this.blocks = t
                    }
                }

                function sa(e, t, n) {
                    const s = [],
                        r = [];
                    let i, o, a = 0,
                        l = 0,
                        c = -1;
                    for (let u = 0; u < e.length; u++) {
                        const h = e[u];
                        "\\" === h ? u++ : h === o ? (a--, 0 === a && (r.push(e.substring(c, u)), s.push(n), l = u, c = -1, i = o = void 0)) : h === i ? a++ : 0 === a && t.has(h) && (i = h, o = t.get(h), a = 1, c = u + 1, s.push(e.substring(l, c)))
                    }
                    return -1 !== c ? (r.push(e.substring(c)), s.push(n)) : s.push(e.substring(l)), new na(s.join(""), r)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const ra = "_nghost-%COMP%",
                    ia = "_ngcontent-%COMP%";
                class oa {
                    constructor(e, t, n) {
                        this.name = e, this.moduleUrl = t, this.setValue = n
                    }
                }
                class aa {
                    constructor(e, t, n, s, r) {
                        this.outputCtx = e, this.stylesVar = t, this.dependencies = n, this.isShimmed = s, this.meta = r
                    }
                }
                class la {
                    constructor(e) {
                        this._urlResolver = e, this._shadowCss = new Po
                    }
                    compileComponent(e, t) {
                        const n = t.template;
                        return this._compileStyles(e, t, new xn({
                            styles: n.styles,
                            styleUrls: n.styleUrls,
                            moduleUrl: vn(t.type)
                        }), this.needsStyleShim(t), !0)
                    }
                    compileStyles(e, t, n, s = this.needsStyleShim(t)) {
                        return this._compileStyles(e, t, n, s, !1)
                    }
                    needsStyleShim(e) {
                        return e.template.encapsulation === D.Emulated
                    }
                    _compileStyles(e, t, n, s, r) {
                        const i = n.styles.map(e => At(this._shimIfNeeded(e, s))),
                            o = [];
                        n.styleUrls.forEach(t => {
                            const n = i.length;
                            i.push(null), o.push(new oa(ca(null), t, t => i[n] = e.importExpr(t)))
                        });
                        const a = ca(r ? t : null),
                            l = vt(a).set(Ct(i, new te(se, [Z.Const]))).toDeclStmt(null, r ? [Je.Final] : [Je.Final, Je.Exported]);
                        return e.statements.push(l), new aa(e, a, o, s, n)
                    }
                    _shimIfNeeded(e, t) {
                        return t ? this._shadowCss.shimCssText(e, ia, ra) : e
                    }
                }

                function ca(e) {
                    let t = "styles";
                    return e && (t += `_${yn(e.type)}`), t
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class ua {
                    constructor(e, t) {
                        this.sourceSpan = e, this.i18n = t
                    }
                }
                class ha extends ua {
                    constructor(e, t, n) {
                        super(t, n), this.value = e
                    }
                    visit(e, t) {
                        return e.visitText(this, t)
                    }
                }
                class pa extends ua {
                    constructor(e, t, n, s, r, i) {
                        super(s, i), this.switchValue = e, this.type = t, this.cases = n, this.switchValueSourceSpan = r
                    }
                    visit(e, t) {
                        return e.visitExpansion(this, t)
                    }
                }
                class da {
                    constructor(e, t, n, s, r) {
                        this.value = e, this.expression = t, this.sourceSpan = n, this.valueSourceSpan = s, this.expSourceSpan = r
                    }
                    visit(e, t) {
                        return e.visitExpansionCase(this, t)
                    }
                }
                class fa extends ua {
                    constructor(e, t, n, s, r) {
                        super(n, r), this.name = e, this.value = t, this.valueSpan = s
                    }
                    visit(e, t) {
                        return e.visitAttribute(this, t)
                    }
                }
                class ma extends ua {
                    constructor(e, t, n, s, r, i = null, o) {
                        super(s, o), this.name = e, this.attrs = t, this.children = n, this.startSourceSpan = r, this.endSourceSpan = i
                    }
                    visit(e, t) {
                        return e.visitElement(this, t)
                    }
                }
                class ga {
                    constructor(e, t) {
                        this.value = e, this.sourceSpan = t
                    }
                    visit(e, t) {
                        return e.visitComment(this, t)
                    }
                }

                function ya(e, t, n = null) {
                    const s = [],
                        r = e.visit ? t => e.visit(t, n) || t.visit(e, n) : t => t.visit(e, n);
                    return t.forEach(e => {
                        const t = r(e);
                        t && s.push(t)
                    }), s
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var va;
                ! function(e) {
                    e[e.TAG_OPEN_START = 0] = "TAG_OPEN_START", e[e.TAG_OPEN_END = 1] = "TAG_OPEN_END", e[e.TAG_OPEN_END_VOID = 2] = "TAG_OPEN_END_VOID", e[e.TAG_CLOSE = 3] = "TAG_CLOSE", e[e.INCOMPLETE_TAG_OPEN = 4] = "INCOMPLETE_TAG_OPEN", e[e.TEXT = 5] = "TEXT", e[e.ESCAPABLE_RAW_TEXT = 6] = "ESCAPABLE_RAW_TEXT", e[e.RAW_TEXT = 7] = "RAW_TEXT", e[e.COMMENT_START = 8] = "COMMENT_START", e[e.COMMENT_END = 9] = "COMMENT_END", e[e.CDATA_START = 10] = "CDATA_START", e[e.CDATA_END = 11] = "CDATA_END", e[e.ATTR_NAME = 12] = "ATTR_NAME", e[e.ATTR_QUOTE = 13] = "ATTR_QUOTE", e[e.ATTR_VALUE = 14] = "ATTR_VALUE", e[e.DOC_TYPE = 15] = "DOC_TYPE", e[e.EXPANSION_FORM_START = 16] = "EXPANSION_FORM_START", e[e.EXPANSION_CASE_VALUE = 17] = "EXPANSION_CASE_VALUE", e[e.EXPANSION_CASE_EXP_START = 18] = "EXPANSION_CASE_EXP_START", e[e.EXPANSION_CASE_EXP_END = 19] = "EXPANSION_CASE_EXP_END", e[e.EXPANSION_FORM_END = 20] = "EXPANSION_FORM_END", e[e.EOF = 21] = "EOF"
                }(va || (va = {}));
                class _a {
                    constructor(e, t, n) {
                        this.type = e, this.parts = t, this.sourceSpan = n
                    }
                }
                class ba extends Ci {
                    constructor(e, t, n) {
                        super(n, e), this.tokenType = t
                    }
                }
                class wa {
                    constructor(e, t, n) {
                        this.tokens = e, this.errors = t, this.nonNormalizedIcuExpressions = n
                    }
                }

                function Ea(e, t, n, s = {}) {
                    const r = new Da(new yi(e, t), n, s);
                    return r.tokenize(), new wa(function(e) {
                        const t = [];
                        let n;
                        for (let s = 0; s < e.length; s++) {
                            const r = e[s];
                            n && n.type == va.TEXT && r.type == va.TEXT ? (n.parts[0] += r.parts[0], n.sourceSpan.end = r.sourceSpan.end) : (n = r, t.push(n))
                        }
                        return t
                    }(r.tokens), r.errors, r.nonNormalizedIcuExpressions)
                }
                const Ca = /\r\n?/g;

                function Sa(e) {
                    return `Unexpected character "${0===e?"EOF":String.fromCharCode(e)}"`
                }

                function xa(e) {
                    return `Unknown entity "${e}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`
                }
                var Ta;
                ! function(e) {
                    e.HEX = "hexadecimal", e.DEC = "decimal"
                }(Ta || (Ta = {}));
                class Aa {
                    constructor(e) {
                        this.error = e
                    }
                }
                class Da {
                    constructor(e, t, n) {
                        this._getTagDefinition = t, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = !1, this.tokens = [], this.errors = [], this.nonNormalizedIcuExpressions = [], this._tokenizeIcu = n.tokenizeExpansionForms || !1, this._interpolationConfig = n.interpolationConfig || Fr, this._leadingTriviaCodePoints = n.leadingTriviaChars && n.leadingTriviaChars.map(e => e.codePointAt(0) || 0);
                        const s = n.range || {
                            endPos: e.content.length,
                            startPos: 0,
                            startLine: 0,
                            startCol: 0
                        };
                        this._cursor = n.escapedString ? new Fa(e, s) : new Ma(e, s), this._preserveLineEndings = n.preserveLineEndings || !1, this._escapedString = n.escapedString || !1, this._i18nNormalizeLineEndingsInICUs = n.i18nNormalizeLineEndingsInICUs || !1;
                        try {
                            this._cursor.init()
                        } catch (r) {
                            this.handleError(r)
                        }
                    }
                    _processCarriageReturns(e) {
                        return this._preserveLineEndings ? e : e.replace(Ca, "\n")
                    }
                    tokenize() {
                        for (; 0 !== this._cursor.peek();) {
                            const t = this._cursor.clone();
                            try {
                                this._attemptCharCode(ri) ? this._attemptCharCode(33) ? this._attemptCharCode(91) ? this._consumeCdata(t) : this._attemptCharCode(45) ? this._consumeComment(t) : this._consumeDocType(t) : this._attemptCharCode(ti) ? this._consumeTagClose(t) : this._consumeTagOpen(t) : this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeText()
                            } catch (e) {
                                this.handleError(e)
                            }
                        }
                        this._beginToken(va.EOF), this._endToken([])
                    }
                    _tokenizeExpansionForm() {
                        if (this.isExpansionFormStart()) return this._consumeExpansionFormStart(), !0;
                        if (this._cursor.peek() !== ui && this._isInExpansionForm()) return this._consumeExpansionCaseStart(), !0;
                        if (this._cursor.peek() === ui) {
                            if (this._isInExpansionCase()) return this._consumeExpansionCaseEnd(), !0;
                            if (this._isInExpansionForm()) return this._consumeExpansionFormEnd(), !0
                        }
                        return !1
                    }
                    _beginToken(e, t = this._cursor.clone()) {
                        this._currentTokenStart = t, this._currentTokenType = e
                    }
                    _endToken(e, t) {
                        if (null === this._currentTokenStart) throw new ba("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(t));
                        if (null === this._currentTokenType) throw new ba("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
                        const n = new _a(this._currentTokenType, e, this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));
                        return this.tokens.push(n), this._currentTokenStart = null, this._currentTokenType = null, n
                    }
                    _createError(e, t) {
                        this._isInExpansionForm() && (e += ' (Do you have an unescaped "{" in your template? Use "{{ \'{\' }}") to escape it.)');
                        const n = new ba(e, this._currentTokenType, t);
                        return this._currentTokenStart = null, this._currentTokenType = null, new Aa(n)
                    }
                    handleError(e) {
                        if (e instanceof Ra && (e = this._createError(e.msg, this._cursor.getSpan(e.cursor))), !(e instanceof Aa)) throw e;
                        this.errors.push(e.error)
                    }
                    _attemptCharCode(e) {
                        return this._cursor.peek() === e && (this._cursor.advance(), !0)
                    }
                    _attemptCharCodeCaseInsensitive(e) {
                        return t = this._cursor.peek(), n = e, Na(t) == Na(n) && (this._cursor.advance(), !0);
                        var t, n
                    }
                    _requireCharCode(e) {
                        const t = this._cursor.clone();
                        if (!this._attemptCharCode(e)) throw this._createError(Sa(this._cursor.peek()), this._cursor.getSpan(t))
                    }
                    _attemptStr(e) {
                        const t = e.length;
                        if (this._cursor.charsLeft() < t) return !1;
                        const n = this._cursor.clone();
                        for (let s = 0; s < t; s++)
                            if (!this._attemptCharCode(e.charCodeAt(s))) return this._cursor = n, !1;
                        return !0
                    }
                    _attemptStrCaseInsensitive(e) {
                        for (let t = 0; t < e.length; t++)
                            if (!this._attemptCharCodeCaseInsensitive(e.charCodeAt(t))) return !1;
                        return !0
                    }
                    _requireStr(e) {
                        const t = this._cursor.clone();
                        if (!this._attemptStr(e)) throw this._createError(Sa(this._cursor.peek()), this._cursor.getSpan(t))
                    }
                    _attemptCharCodeUntilFn(e) {
                        for (; !e(this._cursor.peek());) this._cursor.advance()
                    }
                    _requireCharCodeUntilFn(e, t) {
                        const n = this._cursor.clone();
                        if (this._attemptCharCodeUntilFn(e), this._cursor.diff(n) < t) throw this._createError(Sa(this._cursor.peek()), this._cursor.getSpan(n))
                    }
                    _attemptUntilChar(e) {
                        for (; this._cursor.peek() !== e;) this._cursor.advance()
                    }
                    _readChar(e) {
                        if (e && 38 === this._cursor.peek()) return this._decodeEntity(); {
                            const e = String.fromCodePoint(this._cursor.peek());
                            return this._cursor.advance(), e
                        }
                    }
                    _decodeEntity() {
                        const e = this._cursor.clone();
                        if (this._cursor.advance(), !this._attemptCharCode(35)) {
                            const t = this._cursor.clone();
                            if (this._attemptCharCodeUntilFn(Ia), this._cursor.peek() != si) return this._cursor = t, "&";
                            const n = this._cursor.getChars(t);
                            this._cursor.advance();
                            const s = u[n];
                            if (!s) throw this._createError(xa(n), this._cursor.getSpan(e));
                            return s
                        } {
                            const s = this._attemptCharCode(120) || this._attemptCharCode(88),
                                r = this._cursor.clone();
                            if (this._attemptCharCodeUntilFn(Oa), this._cursor.peek() != si) {
                                this._cursor.advance();
                                const n = s ? Ta.HEX : Ta.DEC;
                                throw this._createError((t = n, `Unable to parse entity "${this._cursor.getChars(e)}" - ${t} character reference entities must end with ";"`), this._cursor.getSpan())
                            }
                            const i = this._cursor.getChars(r);
                            this._cursor.advance();
                            try {
                                const e = parseInt(i, s ? 16 : 10);
                                return String.fromCharCode(e)
                            } catch (n) {
                                throw this._createError(xa(this._cursor.getChars(e)), this._cursor.getSpan())
                            }
                        }
                        var t
                    }
                    _consumeRawText(e, t) {
                        this._beginToken(e ? va.ESCAPABLE_RAW_TEXT : va.RAW_TEXT);
                        const n = [];
                        for (;;) {
                            const s = this._cursor.clone(),
                                r = t();
                            if (this._cursor = s, r) break;
                            n.push(this._readChar(e))
                        }
                        return this._endToken([this._processCarriageReturns(n.join(""))])
                    }
                    _consumeComment(e) {
                        this._beginToken(va.COMMENT_START, e), this._requireCharCode(45), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr("--\x3e")), this._beginToken(va.COMMENT_END), this._requireStr("--\x3e"), this._endToken([])
                    }
                    _consumeCdata(e) {
                        this._beginToken(va.CDATA_START, e), this._requireStr("CDATA["), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr("]]>")), this._beginToken(va.CDATA_END), this._requireStr("]]>"), this._endToken([])
                    }
                    _consumeDocType(e) {
                        this._beginToken(va.DOC_TYPE, e);
                        const t = this._cursor.clone();
                        this._attemptUntilChar(oi);
                        const n = this._cursor.getChars(t);
                        this._cursor.advance(), this._endToken([n])
                    }
                    _consumePrefixAndName() {
                        const e = this._cursor.clone();
                        let t = "";
                        for (; this._cursor.peek() !== ni && !(((n = this._cursor.peek()) < ai || li < n) && (n < 65 || 90 < n) && (n < 48 || n > 57));) this._cursor.advance();
                        var n;
                        let s;
                        this._cursor.peek() === ni ? (t = this._cursor.getChars(e), this._cursor.advance(), s = this._cursor.clone()) : s = e, this._requireCharCodeUntilFn(ka, "" === t ? 0 : 1);
                        return [t, this._cursor.getChars(s)]
                    }
                    _consumeTagOpen(e) {
                        let t, n, r;
                        try {
                            if (!di(this._cursor.peek())) throw this._createError(Sa(this._cursor.peek()), this._cursor.getSpan(e));
                            for (r = this._consumeTagOpenStart(e), n = r.parts[0], t = r.parts[1], this._attemptCharCodeUntilFn(Pa); this._cursor.peek() !== ti && this._cursor.peek() !== oi && this._cursor.peek() !== ri;) this._consumeAttributeName(), this._attemptCharCodeUntilFn(Pa), this._attemptCharCode(ii) && (this._attemptCharCodeUntilFn(Pa), this._consumeAttributeValue()), this._attemptCharCodeUntilFn(Pa);
                            this._consumeTagOpenEnd()
                        } catch (o) {
                            if (o instanceof Aa) return void(r ? r.type = va.INCOMPLETE_TAG_OPEN : (this._beginToken(va.TEXT, e), this._endToken(["<"])));
                            throw o
                        }
                        const i = this._getTagDefinition(t).contentType;
                        i === s.RAW_TEXT ? this._consumeRawTextWithTagClose(n, t, !1) : i === s.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(n, t, !0)
                    }
                    _consumeRawTextWithTagClose(e, t, n) {
                        this._consumeRawText(n, () => !!this._attemptCharCode(ri) && (!!this._attemptCharCode(ti) && (this._attemptCharCodeUntilFn(Pa), !!this._attemptStrCaseInsensitive(t) && (this._attemptCharCodeUntilFn(Pa), this._attemptCharCode(oi)))));
                        this._beginToken(va.TAG_CLOSE), this._requireCharCodeUntilFn(e => e === oi, 3), this._cursor.advance(), this._endToken([e, t])
                    }
                    _consumeTagOpenStart(e) {
                        this._beginToken(va.TAG_OPEN_START, e);
                        const t = this._consumePrefixAndName();
                        return this._endToken(t)
                    }
                    _consumeAttributeName() {
                        const e = this._cursor.peek();
                        if (39 === e || 34 === e) throw this._createError(Sa(e), this._cursor.getSpan());
                        this._beginToken(va.ATTR_NAME);
                        const t = this._consumePrefixAndName();
                        this._endToken(t)
                    }
                    _consumeAttributeValue() {
                        let e;
                        if (39 === this._cursor.peek() || 34 === this._cursor.peek()) {
                            this._beginToken(va.ATTR_QUOTE);
                            const t = this._cursor.peek();
                            this._cursor.advance(), this._endToken([String.fromCodePoint(t)]), this._beginToken(va.ATTR_VALUE);
                            const n = [];
                            for (; this._cursor.peek() !== t;) n.push(this._readChar(!0));
                            e = n.join(""), this._endToken([this._processCarriageReturns(e)]), this._beginToken(va.ATTR_QUOTE), this._cursor.advance(), this._endToken([String.fromCodePoint(t)])
                        } else {
                            this._beginToken(va.ATTR_VALUE);
                            const t = this._cursor.clone();
                            this._requireCharCodeUntilFn(ka, 1), e = this._cursor.getChars(t), this._endToken([this._processCarriageReturns(e)])
                        }
                    }
                    _consumeTagOpenEnd() {
                        const e = this._attemptCharCode(ti) ? va.TAG_OPEN_END_VOID : va.TAG_OPEN_END;
                        this._beginToken(e), this._requireCharCode(oi), this._endToken([])
                    }
                    _consumeTagClose(e) {
                        this._beginToken(va.TAG_CLOSE, e), this._attemptCharCodeUntilFn(Pa);
                        const t = this._consumePrefixAndName();
                        this._attemptCharCodeUntilFn(Pa), this._requireCharCode(oi), this._endToken(t)
                    }
                    _consumeExpansionFormStart() {
                        this._beginToken(va.EXPANSION_FORM_START), this._requireCharCode(ci), this._endToken([]), this._expansionCaseStack.push(va.EXPANSION_FORM_START), this._beginToken(va.RAW_TEXT);
                        const e = this._readUntil(ei),
                            t = this._processCarriageReturns(e);
                        if (this._i18nNormalizeLineEndingsInICUs) this._endToken([t]);
                        else {
                            const n = this._endToken([e]);
                            t !== e && this.nonNormalizedIcuExpressions.push(n)
                        }
                        this._requireCharCode(ei), this._attemptCharCodeUntilFn(Pa), this._beginToken(va.RAW_TEXT);
                        const n = this._readUntil(ei);
                        this._endToken([n]), this._requireCharCode(ei), this._attemptCharCodeUntilFn(Pa)
                    }
                    _consumeExpansionCaseStart() {
                        this._beginToken(va.EXPANSION_CASE_VALUE);
                        const e = this._readUntil(ci).trim();
                        this._endToken([e]), this._attemptCharCodeUntilFn(Pa), this._beginToken(va.EXPANSION_CASE_EXP_START), this._requireCharCode(ci), this._endToken([]), this._attemptCharCodeUntilFn(Pa), this._expansionCaseStack.push(va.EXPANSION_CASE_EXP_START)
                    }
                    _consumeExpansionCaseEnd() {
                        this._beginToken(va.EXPANSION_CASE_EXP_END), this._requireCharCode(ui), this._endToken([]), this._attemptCharCodeUntilFn(Pa), this._expansionCaseStack.pop()
                    }
                    _consumeExpansionFormEnd() {
                        this._beginToken(va.EXPANSION_FORM_END), this._requireCharCode(ui), this._endToken([]), this._expansionCaseStack.pop()
                    }
                    _consumeText() {
                        const e = this._cursor.clone();
                        this._beginToken(va.TEXT, e);
                        const t = [];
                        do {
                            this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (t.push(this._interpolationConfig.start), this._inInterpolation = !0) : this._interpolationConfig && this._inInterpolation && this._attemptStr(this._interpolationConfig.end) ? (t.push(this._interpolationConfig.end), this._inInterpolation = !1) : t.push(this._readChar(!0))
                        } while (!this._isTextEnd());
                        this._endToken([this._processCarriageReturns(t.join(""))])
                    }
                    _isTextEnd() {
                        if (this._cursor.peek() === ri || 0 === this._cursor.peek()) return !0;
                        if (this._tokenizeIcu && !this._inInterpolation) {
                            if (this.isExpansionFormStart()) return !0;
                            if (this._cursor.peek() === ui && this._isInExpansionCase()) return !0
                        }
                        return !1
                    }
                    _readUntil(e) {
                        const t = this._cursor.clone();
                        return this._attemptUntilChar(e), this._cursor.getChars(t)
                    }
                    _isInExpansionCase() {
                        return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === va.EXPANSION_CASE_EXP_START
                    }
                    _isInExpansionForm() {
                        return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === va.EXPANSION_FORM_START
                    }
                    isExpansionFormStart() {
                        if (this._cursor.peek() !== ci) return !1;
                        if (this._interpolationConfig) {
                            const e = this._cursor.clone(),
                                t = this._attemptStr(this._interpolationConfig.start);
                            return this._cursor = e, !t
                        }
                        return !0
                    }
                }

                function Pa(e) {
                    return !hi(e) || 0 === e
                }

                function ka(e) {
                    return hi(e) || e === oi || e === ri || e === ti || 39 === e || 34 === e || e === ii
                }

                function Oa(e) {
                    return e == si || 0 == e || ! function(e) {
                        return e >= ai && e <= 102 || e >= 65 && e <= 70 || pi(e)
                    }(e)
                }

                function Ia(e) {
                    return e == si || 0 == e || !di(e)
                }

                function Na(e) {
                    return e >= ai && e <= li ? e - ai + 65 : e
                }
                class Ma {
                    constructor(e, t) {
                        if (e instanceof Ma) {
                            this.file = e.file, this.input = e.input, this.end = e.end;
                            const t = e.state;
                            this.state = {
                                peek: t.peek,
                                offset: t.offset,
                                line: t.line,
                                column: t.column
                            }
                        } else {
                            if (!t) throw new Error("Programming error: the range argument must be provided with a file argument.");
                            this.file = e, this.input = e.content, this.end = t.endPos, this.state = {
                                peek: -1,
                                offset: t.startPos,
                                line: t.startLine,
                                column: t.startCol
                            }
                        }
                    }
                    clone() {
                        return new Ma(this)
                    }
                    peek() {
                        return this.state.peek
                    }
                    charsLeft() {
                        return this.end - this.state.offset
                    }
                    diff(e) {
                        return this.state.offset - e.state.offset
                    }
                    advance() {
                        this.advanceState(this.state)
                    }
                    init() {
                        this.updatePeek(this.state)
                    }
                    getSpan(e, t) {
                        let n = e = e || this;
                        if (t)
                            for (; this.diff(e) > 0 && -1 !== t.indexOf(e.peek());) n === e && (e = e.clone()), e.advance();
                        const s = this.locationFromCursor(e),
                            r = this.locationFromCursor(this),
                            i = n !== e ? this.locationFromCursor(n) : s;
                        return new vi(s, r, i)
                    }
                    getChars(e) {
                        return this.input.substring(e.state.offset, this.state.offset)
                    }
                    charAt(e) {
                        return this.input.charCodeAt(e)
                    }
                    advanceState(e) {
                        if (e.offset >= this.end) throw this.state = e, new Ra('Unexpected character "EOF"', this);
                        const t = this.charAt(e.offset);
                        t === Xr ? (e.line++, e.column = 0) : fi(t) || e.column++, e.offset++, this.updatePeek(e)
                    }
                    updatePeek(e) {
                        e.peek = e.offset >= this.end ? 0 : this.charAt(e.offset)
                    }
                    locationFromCursor(e) {
                        return new gi(e.file, e.state.offset, e.state.line, e.state.column)
                    }
                }
                class Fa extends Ma {
                    constructor(e, t) {
                        e instanceof Fa ? (super(e), this.internalState = Object.assign({}, e.internalState)) : (super(e, t), this.internalState = this.state)
                    }
                    advance() {
                        this.state = this.internalState, super.advance(), this.processEscapeSequence()
                    }
                    init() {
                        super.init(), this.processEscapeSequence()
                    }
                    clone() {
                        return new Fa(this)
                    }
                    getChars(e) {
                        const t = e.clone();
                        let n = "";
                        for (; t.internalState.offset < this.internalState.offset;) n += String.fromCodePoint(t.peek()), t.advance();
                        return n
                    }
                    processEscapeSequence() {
                        const e = () => this.internalState.peek;
                        if (92 === e())
                            if (this.internalState = Object.assign({}, this.state), this.advanceState(this.internalState), 110 === e()) this.state.peek = Xr;
                            else if (114 === e()) this.state.peek = 13;
                        else if (118 === e()) this.state.peek = 11;
                        else if (116 === e()) this.state.peek = 9;
                        else if (98 === e()) this.state.peek = 8;
                        else if (102 === e()) this.state.peek = 12;
                        else if (117 === e())
                            if (this.advanceState(this.internalState), e() === ci) {
                                this.advanceState(this.internalState);
                                const t = this.clone();
                                let n = 0;
                                for (; e() !== ui;) this.advanceState(this.internalState), n++;
                                this.state.peek = this.decodeHexDigits(t, n)
                            } else {
                                const e = this.clone();
                                this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(e, 4)
                            }
                        else if (120 === e()) {
                            this.advanceState(this.internalState);
                            const e = this.clone();
                            this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(e, 2)
                        } else if (mi(e())) {
                            let t = "",
                                n = 0,
                                s = this.clone();
                            for (; mi(e()) && n < 3;) s = this.clone(), t += String.fromCodePoint(e()), this.advanceState(this.internalState), n++;
                            this.state.peek = parseInt(t, 8), this.internalState = s.internalState
                        } else fi(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek
                    }
                    decodeHexDigits(e, t) {
                        const n = this.input.substr(e.internalState.offset, t),
                            s = parseInt(n, 16);
                        if (isNaN(s)) throw e.state = e.internalState, new Ra("Invalid hexadecimal escape sequence", e);
                        return s
                    }
                }
                class Ra {
                    constructor(e, t) {
                        this.msg = e, this.cursor = t
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class ja extends Ci {
                    constructor(e, t, n) {
                        super(t, n), this.elementName = e
                    }
                    static create(e, t, n) {
                        return new ja(e, t, n)
                    }
                }
                class La {
                    constructor(e, t) {
                        this.rootNodes = e, this.errors = t
                    }
                }
                class Va {
                    constructor(e) {
                        this.getTagDefinition = e
                    }
                    parse(e, t, n) {
                        const s = Ea(e, t, this.getTagDefinition, n),
                            r = new $a(s.tokens, this.getTagDefinition);
                        return r.build(), new La(r.rootNodes, s.errors.concat(r.errors))
                    }
                }
                class $a {
                    constructor(e, t) {
                        this.tokens = e, this.getTagDefinition = t, this._index = -1, this._elementStack = [], this.rootNodes = [], this.errors = [], this._advance()
                    }
                    build() {
                        for (; this._peek.type !== va.EOF;) this._peek.type === va.TAG_OPEN_START || this._peek.type === va.INCOMPLETE_TAG_OPEN ? this._consumeStartTag(this._advance()) : this._peek.type === va.TAG_CLOSE ? this._consumeEndTag(this._advance()) : this._peek.type === va.CDATA_START ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === va.COMMENT_START ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === va.TEXT || this._peek.type === va.RAW_TEXT || this._peek.type === va.ESCAPABLE_RAW_TEXT ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === va.EXPANSION_FORM_START ? this._consumeExpansion(this._advance()) : this._advance()
                    }
                    _advance() {
                        const e = this._peek;
                        return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], e
                    }
                    _advanceIf(e) {
                        return this._peek.type === e ? this._advance() : null
                    }
                    _consumeCdata(e) {
                        this._consumeText(this._advance()), this._advanceIf(va.CDATA_END)
                    }
                    _consumeComment(e) {
                        const t = this._advanceIf(va.RAW_TEXT);
                        this._advanceIf(va.COMMENT_END);
                        const n = null != t ? t.parts[0].trim() : null;
                        this._addToParent(new ga(n, e.sourceSpan))
                    }
                    _consumeExpansion(e) {
                        const t = this._advance(),
                            n = this._advance(),
                            s = [];
                        for (; this._peek.type === va.EXPANSION_CASE_VALUE;) {
                            const e = this._parseExpansionCase();
                            if (!e) return;
                            s.push(e)
                        }
                        if (this._peek.type !== va.EXPANSION_FORM_END) return void this.errors.push(ja.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
                        const r = new vi(e.sourceSpan.start, this._peek.sourceSpan.end, e.sourceSpan.fullStart);
                        this._addToParent(new pa(t.parts[0], n.parts[0], s, r, t.sourceSpan)), this._advance()
                    }
                    _parseExpansionCase() {
                        const e = this._advance();
                        if (this._peek.type !== va.EXPANSION_CASE_EXP_START) return this.errors.push(ja.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
                        const t = this._advance(),
                            n = this._collectExpansionExpTokens(t);
                        if (!n) return null;
                        const s = this._advance();
                        n.push(new _a(va.EOF, [], s.sourceSpan));
                        const r = new $a(n, this.getTagDefinition);
                        if (r.build(), r.errors.length > 0) return this.errors = this.errors.concat(r.errors), null;
                        const i = new vi(e.sourceSpan.start, s.sourceSpan.end, e.sourceSpan.fullStart),
                            o = new vi(t.sourceSpan.start, s.sourceSpan.end, t.sourceSpan.fullStart);
                        return new da(e.parts[0], r.rootNodes, i, e.sourceSpan, o)
                    }
                    _collectExpansionExpTokens(e) {
                        const t = [],
                            n = [va.EXPANSION_CASE_EXP_START];
                        for (;;) {
                            if (this._peek.type !== va.EXPANSION_FORM_START && this._peek.type !== va.EXPANSION_CASE_EXP_START || n.push(this._peek.type), this._peek.type === va.EXPANSION_CASE_EXP_END) {
                                if (!Ba(n, va.EXPANSION_CASE_EXP_START)) return this.errors.push(ja.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
                                if (n.pop(), 0 == n.length) return t
                            }
                            if (this._peek.type === va.EXPANSION_FORM_END) {
                                if (!Ba(n, va.EXPANSION_FORM_START)) return this.errors.push(ja.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
                                n.pop()
                            }
                            if (this._peek.type === va.EOF) return this.errors.push(ja.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
                            t.push(this._advance())
                        }
                    }
                    _consumeText(e) {
                        let t = e.parts[0];
                        if (t.length > 0 && "\n" == t[0]) {
                            const e = this._getParentElement();
                            null != e && 0 == e.children.length && this.getTagDefinition(e.name).ignoreFirstLf && (t = t.substring(1))
                        }
                        t.length > 0 && this._addToParent(new ha(t, e.sourceSpan))
                    }
                    _closeVoidElement() {
                        const e = this._getParentElement();
                        e && this.getTagDefinition(e.name).isVoid && this._elementStack.pop()
                    }
                    _consumeStartTag(e) {
                        const [t, n] = e.parts, s = [];
                        for (; this._peek.type === va.ATTR_NAME;) s.push(this._consumeAttr(this._advance()));
                        const r = this._getElementFullName(t, n, this._getParentElement());
                        let i = !1;
                        if (this._peek.type === va.TAG_OPEN_END_VOID) {
                            this._advance(), i = !0;
                            const t = this.getTagDefinition(r);
                            t.canSelfClose || null !== l(r) || t.isVoid || this.errors.push(ja.create(r, e.sourceSpan, `Only void and foreign elements can be self closed "${e.parts[1]}"`))
                        } else this._peek.type === va.TAG_OPEN_END && (this._advance(), i = !1);
                        const o = this._peek.sourceSpan.start,
                            a = new vi(e.sourceSpan.start, o, e.sourceSpan.fullStart),
                            c = new vi(e.sourceSpan.start, o, e.sourceSpan.fullStart),
                            u = new ma(r, s, [], a, c, void 0);
                        this._pushElement(u), i ? this._popElement(r, a) : e.type === va.INCOMPLETE_TAG_OPEN && (this._popElement(r, null), this.errors.push(ja.create(r, a, `Opening tag "${r}" not terminated.`)))
                    }
                    _pushElement(e) {
                        const t = this._getParentElement();
                        t && this.getTagDefinition(t.name).isClosedByChild(e.name) && this._elementStack.pop(), this._addToParent(e), this._elementStack.push(e)
                    }
                    _consumeEndTag(e) {
                        const t = this._getElementFullName(e.parts[0], e.parts[1], this._getParentElement());
                        if (this.getTagDefinition(t).isVoid) this.errors.push(ja.create(t, e.sourceSpan, `Void elements do not have end tags "${e.parts[1]}"`));
                        else if (!this._popElement(t, e.sourceSpan)) {
                            const n = `Unexpected closing tag "${t}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
                            this.errors.push(ja.create(t, e.sourceSpan, n))
                        }
                    }
                    _popElement(e, t) {
                        for (let n = this._elementStack.length - 1; n >= 0; n--) {
                            const s = this._elementStack[n];
                            if (s.name == e) return s.endSourceSpan = t, s.sourceSpan.end = null !== t ? t.end : s.sourceSpan.end, this._elementStack.splice(n, this._elementStack.length - n), !0;
                            if (!this.getTagDefinition(s.name).closedByParent) return !1
                        }
                        return !1
                    }
                    _consumeAttr(e) {
                        const t = c(e.parts[0], e.parts[1]);
                        let n, s = e.sourceSpan.end,
                            r = "";
                        if (this._peek.type === va.ATTR_QUOTE && this._advance(), this._peek.type === va.ATTR_VALUE) {
                            const e = this._advance();
                            r = e.parts[0], s = e.sourceSpan.end, n = e.sourceSpan
                        }
                        if (this._peek.type === va.ATTR_QUOTE) {
                            s = this._advance().sourceSpan.end
                        }
                        return new fa(t, r, new vi(e.sourceSpan.start, s, e.sourceSpan.fullStart), n)
                    }
                    _getParentElement() {
                        return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null
                    }
                    _addToParent(e) {
                        const t = this._getParentElement();
                        null != t ? t.children.push(e) : this.rootNodes.push(e)
                    }
                    _getElementFullName(e, t, n) {
                        if ("" === e && "" === (e = this.getTagDefinition(t).implicitNamespacePrefix || "") && null != n) {
                            const t = r(n.name)[1];
                            this.getTagDefinition(t).preventNamespaceInheritance || (e = l(n.name))
                        }
                        return c(e, t)
                    }
                }

                function Ba(e, t) {
                    return e.length > 0 && e[e.length - 1] === t
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Ha extends Va {
                    constructor() {
                        super(f)
                    }
                    parse(e, t, n) {
                        return super.parse(e, t, n)
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Ua = "ngPreserveWhitespaces",
                    qa = new Set(["pre", "template", "textarea", "script", "style"]),
                    za = " \f\n\r\t\v\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff",
                    Wa = new RegExp(`[^${za}]`),
                    Ga = new RegExp(`[${za}]{2,}`, "g");

                function Ka(e) {
                    return e.replace(new RegExp("\ue500", "g"), " ")
                }
                class Qa {
                    visitElement(e, t) {
                        return qa.has(e.name) || e.attrs.some(e => e.name === Ua) ? new ma(e.name, ya(this, e.attrs), e.children, e.sourceSpan, e.startSourceSpan, e.endSourceSpan, e.i18n) : new ma(e.name, e.attrs, function(e, t) {
                                const n = [];
                                return t.forEach((s, r) => {
                                    const i = {
                                            prev: t[r - 1],
                                            next: t[r + 1]
                                        },
                                        o = s.visit(e, i);
                                    o && n.push(o)
                                }), n
                            }
                            /**
                             * @license
                             * Copyright Google LLC All Rights Reserved.
                             *
                             * Use of this source code is governed by an MIT-style license that can be
                             * found in the LICENSE file at https://angular.io/license
                             */
                            (this, e.children), e.sourceSpan, e.startSourceSpan, e.endSourceSpan, e.i18n)
                    }
                    visitAttribute(e, t) {
                        return e.name !== Ua ? e : null
                    }
                    visitText(e, t) {
                        const n = e.value.match(Wa),
                            s = t && (t.prev instanceof pa || t.next instanceof pa);
                        return n || s ? new ha(Ka(e.value).replace(Ga, " "), e.sourceSpan, e.i18n) : null
                    }
                    visitComment(e, t) {
                        return e
                    }
                    visitExpansion(e, t) {
                        return e
                    }
                    visitExpansionCase(e, t) {
                        return e
                    }
                }

                function Za(e) {
                    return new La(ya(new Qa, e.rootNodes), e.errors)
                }
                const Ja = ["zero", "one", "two", "few", "many", "other"];

                function Xa(e) {
                    const t = new tl;
                    return new Ya(ya(t, e), t.isExpanded, t.errors)
                }
                class Ya {
                    constructor(e, t, n) {
                        this.nodes = e, this.expanded = t, this.errors = n
                    }
                }
                class el extends Ci {
                    constructor(e, t) {
                        super(e, t)
                    }
                }
                class tl {
                    constructor() {
                        this.isExpanded = !1, this.errors = []
                    }
                    visitElement(e, t) {
                        return new ma(e.name, e.attrs, ya(this, e.children), e.sourceSpan, e.startSourceSpan, e.endSourceSpan)
                    }
                    visitAttribute(e, t) {
                        return e
                    }
                    visitText(e, t) {
                        return e
                    }
                    visitComment(e, t) {
                        return e
                    }
                    visitExpansion(e, t) {
                        return this.isExpanded = !0, "plural" == e.type ? function(e, t) {
                            const n = e.cases.map(e => {
                                    -1 != Ja.indexOf(e.value) || e.value.match(/^=\d+$/) || t.push(new el(e.valueSourceSpan, `Plural cases should be "=<number>" or one of ${Ja.join(", ")}`));
                                    const n = Xa(e.expression);
                                    return t.push(...n.errors), new ma("ng-template", [new fa("ngPluralCase", `${e.value}`, e.valueSourceSpan)], n.nodes, e.sourceSpan, e.sourceSpan, e.sourceSpan)
                                }),
                                s = new fa("[ngPlural]", e.switchValue, e.switchValueSourceSpan);
                            return new ma("ng-container", [s], n, e.sourceSpan, e.sourceSpan, e.sourceSpan)
                        }(e, this.errors) : function(e, t) {
                            const n = e.cases.map(e => {
                                    const n = Xa(e.expression);
                                    return t.push(...n.errors), "other" === e.value ? new ma("ng-template", [new fa("ngSwitchDefault", "", e.valueSourceSpan)], n.nodes, e.sourceSpan, e.sourceSpan, e.sourceSpan) : new ma("ng-template", [new fa("ngSwitchCase", `${e.value}`, e.valueSourceSpan)], n.nodes, e.sourceSpan, e.sourceSpan, e.sourceSpan)
                                }),
                                s = new fa("[ngSwitch]", e.switchValue, e.switchValueSourceSpan);
                            return new ma("ng-container", [s], n, e.sourceSpan, e.sourceSpan, e.sourceSpan)
                        }
                        /**
                         * @license
                         * Copyright Google LLC All Rights Reserved.
                         *
                         * Use of this source code is governed by an MIT-style license that can be
                         * found in the LICENSE file at https://angular.io/license
                         */
                        (e, this.errors)
                    }
                    visitExpansionCase(e, t) {
                        throw new Error("Should not be reached")
                    }
                }
                class nl {
                    constructor(e, t, n) {
                        this.value = e, this.ngContentIndex = t, this.sourceSpan = n
                    }
                    visit(e, t) {
                        return e.visitText(this, t)
                    }
                }
                class sl {
                    constructor(e, t, n) {
                        this.value = e, this.ngContentIndex = t, this.sourceSpan = n
                    }
                    visit(e, t) {
                        return e.visitBoundText(this, t)
                    }
                }
                class rl {
                    constructor(e, t, n) {
                        this.name = e, this.value = t, this.sourceSpan = n
                    }
                    visit(e, t) {
                        return e.visitAttr(this, t)
                    }
                }
                const il = {
                    4: 4,
                    1: 1,
                    2: 2,
                    0: 0,
                    3: 3
                };
                class ol {
                    constructor(e, t, n, s, r, i) {
                        this.name = e, this.type = t, this.securityContext = n, this.value = s, this.unit = r, this.sourceSpan = i, this.isAnimation = 4 === this.type
                    }
                    static fromBoundProperty(e) {
                        const t = il[e.type];
                        return new ol(e.name, t, e.securityContext, e.value, e.unit, e.sourceSpan)
                    }
                    visit(e, t) {
                        return e.visitElementProperty(this, t)
                    }
                }
                class al {
                    constructor(e, t, n, s, r, i) {
                        this.name = e, this.target = t, this.phase = n, this.handler = s, this.sourceSpan = r, this.handlerSpan = i, this.fullName = al.calcFullName(this.name, this.target, this.phase), this.isAnimation = !!this.phase
                    }
                    static calcFullName(e, t, n) {
                        return t ? `${t}:${e}` : n ? `@${e}.${n}` : e
                    }
                    static fromParsedEvent(e) {
                        const t = 0 === e.type ? e.targetOrPhase : null,
                            n = 1 === e.type ? e.targetOrPhase : null;
                        return new al(e.name, t, n, e.handler, e.sourceSpan, e.handlerSpan)
                    }
                    visit(e, t) {
                        return e.visitEvent(this, t)
                    }
                }
                class ll {
                    constructor(e, t, n, s) {
                        this.name = e, this.value = t, this.originalValue = n, this.sourceSpan = s
                    }
                    visit(e, t) {
                        return e.visitReference(this, t)
                    }
                }
                class cl {
                    constructor(e, t, n, s) {
                        this.name = e, this.value = t, this.sourceSpan = n, this.valueSpan = s
                    }
                    static fromParsedVariable(e) {
                        return new cl(e.name, e.value, e.sourceSpan, e.valueSpan)
                    }
                    visit(e, t) {
                        return e.visitVariable(this, t)
                    }
                }
                class ul {
                    constructor(e, t, n, s, r, i, o, a, l, c, u, h, p) {
                        this.name = e, this.attrs = t, this.inputs = n, this.outputs = s, this.references = r, this.directives = i, this.providers = o, this.hasViewContainer = a, this.queryMatches = l, this.children = c, this.ngContentIndex = u, this.sourceSpan = h, this.endSourceSpan = p
                    }
                    visit(e, t) {
                        return e.visitElement(this, t)
                    }
                }
                class hl {
                    constructor(e, t, n, s, r, i, o, a, l, c, u) {
                        this.attrs = e, this.outputs = t, this.references = n, this.variables = s, this.directives = r, this.providers = i, this.hasViewContainer = o, this.queryMatches = a, this.children = l, this.ngContentIndex = c, this.sourceSpan = u
                    }
                    visit(e, t) {
                        return e.visitEmbeddedTemplate(this, t)
                    }
                }
                class pl {
                    constructor(e, t, n, s) {
                        this.directiveName = e, this.templateName = t, this.value = n, this.sourceSpan = s
                    }
                    visit(e, t) {
                        return e.visitDirectiveProperty(this, t)
                    }
                }
                class dl {
                    constructor(e, t, n, s, r, i) {
                        this.directive = e, this.inputs = t, this.hostProperties = n, this.hostEvents = s, this.contentQueryStartId = r, this.sourceSpan = i
                    }
                    visit(e, t) {
                        return e.visitDirective(this, t)
                    }
                }
                class fl {
                    constructor(e, t, n, s, r, i, o, a) {
                        this.token = e, this.multiProvider = t, this.eager = n, this.providers = s, this.providerType = r, this.lifecycleHooks = i, this.sourceSpan = o, this.isModule = a
                    }
                    visit(e, t) {
                        return null
                    }
                }
                var ml;
                ! function(e) {
                    e[e.PublicService = 0] = "PublicService", e[e.PrivateService = 1] = "PrivateService", e[e.Component = 2] = "Component", e[e.Directive = 3] = "Directive", e[e.Builtin = 4] = "Builtin"
                }(ml || (ml = {}));
                class gl {
                    constructor(e, t, n) {
                        this.index = e, this.ngContentIndex = t, this.sourceSpan = n
                    }
                    visit(e, t) {
                        return e.visitNgContent(this, t)
                    }
                }

                function yl(e, t, n = null) {
                    const s = [],
                        r = e.visit ? t => e.visit(t, n) || t.visit(e, n) : t => t.visit(e, n);
                    return t.forEach(e => {
                        const t = r(e);
                        t && s.push(t)
                    }), s
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class vl extends Ci {
                    constructor(e, t) {
                        super(t, e)
                    }
                }
                class _l {
                    constructor(e, t) {
                        this.reflector = e, this.component = t, this.errors = [], this.viewQueries = function(e) {
                            let t = 1;
                            const n = new Map;
                            e.viewQueries && e.viewQueries.forEach(e => xl(n, {
                                meta: e,
                                queryId: t++
                            }));
                            return n
                        }(t), this.viewProviders = new Map, t.viewProviders.forEach(e => {
                            null == this.viewProviders.get(Sn(e.token)) && this.viewProviders.set(Sn(e.token), !0)
                        })
                    }
                }
                class bl {
                    constructor(e, t, n, s, r, i, o, a, l) {
                        this.viewContext = e, this._parent = t, this._isViewRoot = n, this._directiveAsts = s, this._sourceSpan = l, this._transformedProviders = new Map, this._seenProviders = new Map, this._queriedTokens = new Map, this.transformedHasViewContainer = !1, this._attrs = {}, r.forEach(e => this._attrs[e.name] = e.value);
                        const c = s.map(e => e.directive);
                        if (this._allProviders = function(e, t, n) {
                                const s = new Map;
                                e.forEach(e => {
                                    Sl([{
                                        token: {
                                            identifier: e.type
                                        },
                                        useClass: e.type
                                    }], e.isComponent ? ml.Component : ml.Directive, !0, t, n, s, !1)
                                });
                                return e.filter(e => e.isComponent).concat(e.filter(e => !e.isComponent)).forEach(e => {
                                    Sl(e.providers, ml.PublicService, !1, t, n, s, !1), Sl(e.viewProviders, ml.PrivateService, !1, t, n, s, !1)
                                }), s
                            }(c, l, e.errors), this._contentQueries = function(e, t) {
                                let n = e;
                                const s = new Map;
                                return t.forEach((e, t) => {
                                    e.queries && e.queries.forEach(e => xl(s, {
                                        meta: e,
                                        queryId: n++
                                    }))
                                }), s
                            }(a, c), Array.from(this._allProviders.values()).forEach(e => {
                                this._addQueryReadsTo(e.token, e.token, this._queriedTokens)
                            }), o) {
                            const e = hn(this.viewContext.reflector, cn.TemplateRef);
                            this._addQueryReadsTo(e, e, this._queriedTokens)
                        }
                        i.forEach(e => {
                            let t = e.value || hn(this.viewContext.reflector, cn.ElementRef);
                            this._addQueryReadsTo({
                                value: e.name
                            }, t, this._queriedTokens)
                        }), this._queriedTokens.get(this.viewContext.reflector.resolveExternalReference(cn.ViewContainerRef)) && (this.transformedHasViewContainer = !0), Array.from(this._allProviders.values()).forEach(e => {
                            (e.eager || this._queriedTokens.get(Sn(e.token))) && this._getOrCreateLocalProvider(e.providerType, e.token, !0)
                        })
                    }
                    afterElement() {
                        Array.from(this._allProviders.values()).forEach(e => {
                            this._getOrCreateLocalProvider(e.providerType, e.token, !1)
                        })
                    }
                    get transformProviders() {
                        const e = [],
                            t = [];
                        return this._transformedProviders.forEach(n => {
                            n.eager ? t.push(n) : e.push(n)
                        }), e.concat(t)
                    }
                    get transformedDirectiveAsts() {
                        const e = this.transformProviders.map(e => e.token.identifier),
                            t = this._directiveAsts.slice();
                        return t.sort((t, n) => e.indexOf(t.directive.type) - e.indexOf(n.directive.type)), t
                    }
                    get queryMatches() {
                        const e = [];
                        return this._queriedTokens.forEach(t => {
                            e.push(...t)
                        }), e
                    }
                    _addQueryReadsTo(e, t, n) {
                        this._getQueriesFor(e).forEach(e => {
                            const s = e.meta.read || t,
                                r = Sn(s);
                            let i = n.get(r);
                            i || (i = [], n.set(r, i)), i.push({
                                queryId: e.queryId,
                                value: s
                            })
                        })
                    }
                    _getQueriesFor(e) {
                        const t = [];
                        let n, s = this,
                            r = 0;
                        for (; null !== s;) n = s._contentQueries.get(Sn(e)), n && t.push(...n.filter(e => e.meta.descendants || r <= 1)), s._directiveAsts.length > 0 && r++, s = s._parent;
                        return n = this.viewContext.viewQueries.get(Sn(e)), n && t.push(...n), t
                    }
                    _getOrCreateLocalProvider(e, t, n) {
                        const s = this._allProviders.get(Sn(t));
                        if (!s || (e === ml.Directive || e === ml.PublicService) && s.providerType === ml.PrivateService || (e === ml.PrivateService || e === ml.PublicService) && s.providerType === ml.Builtin) return null;
                        let r = this._transformedProviders.get(Sn(t));
                        if (r) return r;
                        if (null != this._seenProviders.get(Sn(t))) return this.viewContext.errors.push(new vl(`Cannot instantiate cyclic dependency! ${Cn(t)}`, this._sourceSpan)), null;
                        this._seenProviders.set(Sn(t), !0);
                        const i = s.providers.map(e => {
                            let t, r = e.useValue,
                                i = e.useExisting;
                            if (null != e.useExisting) {
                                const t = this._getDependency(s.providerType, {
                                    token: e.useExisting
                                }, n);
                                null != t.token ? i = t.token : (i = null, r = t.value)
                            } else if (e.useFactory) {
                                t = (e.deps || e.useFactory.diDeps).map(e => this._getDependency(s.providerType, e, n))
                            } else if (e.useClass) {
                                t = (e.deps || e.useClass.diDeps).map(e => this._getDependency(s.providerType, e, n))
                            }
                            return El(e, {
                                useExisting: i,
                                useValue: r,
                                deps: t
                            })
                        });
                        return r = Cl(s, {
                            eager: n,
                            providers: i
                        }), this._transformedProviders.set(Sn(t), r), r
                    }
                    _getLocalDependency(e, t, n = !1) {
                        if (t.isAttribute) {
                            const e = this._attrs[t.token.value];
                            return {
                                isValue: !0,
                                value: null == e ? null : e
                            }
                        }
                        if (null != t.token) {
                            if (e === ml.Directive || e === ml.Component) {
                                if (Sn(t.token) === this.viewContext.reflector.resolveExternalReference(cn.Renderer) || Sn(t.token) === this.viewContext.reflector.resolveExternalReference(cn.ElementRef) || Sn(t.token) === this.viewContext.reflector.resolveExternalReference(cn.ChangeDetectorRef) || Sn(t.token) === this.viewContext.reflector.resolveExternalReference(cn.TemplateRef)) return t;
                                Sn(t.token) === this.viewContext.reflector.resolveExternalReference(cn.ViewContainerRef) && (this.transformedHasViewContainer = !0)
                            }
                            if (Sn(t.token) === this.viewContext.reflector.resolveExternalReference(cn.Injector)) return t;
                            if (null != this._getOrCreateLocalProvider(e, t.token, n)) return t
                        }
                        return null
                    }
                    _getDependency(e, t, n = !1) {
                        let s = this,
                            r = n,
                            i = null;
                        if (t.isSkipSelf || (i = this._getLocalDependency(e, t, n)), t.isSelf) !i && t.isOptional && (i = {
                            isValue: !0,
                            value: null
                        });
                        else {
                            for (; !i && s._parent;) {
                                const e = s;
                                s = s._parent, e._isViewRoot && (r = !1), i = s._getLocalDependency(ml.PublicService, t, r)
                            }
                            i || (i = !t.isHost || this.viewContext.component.isHost || this.viewContext.component.type.reference === Sn(t.token) || null != this.viewContext.viewProviders.get(Sn(t.token)) ? t : t.isOptional ? {
                                isValue: !0,
                                value: null
                            } : null)
                        }
                        return i || this.viewContext.errors.push(new vl(`No provider for ${Cn(t.token)}`, this._sourceSpan)), i
                    }
                }
                class wl {
                    constructor(e, t, n, s) {
                        this.reflector = e, this._transformedProviders = new Map, this._seenProviders = new Map, this._errors = [], this._allProviders = new Map, t.transitiveModule.modules.forEach(e => {
                            Sl([{
                                token: {
                                    identifier: e
                                },
                                useClass: e
                            }], ml.PublicService, !0, s, this._errors, this._allProviders, !0)
                        }), Sl(t.transitiveModule.providers.map(e => e.provider).concat(n), ml.PublicService, !1, s, this._errors, this._allProviders, !1)
                    }
                    parse() {
                        if (Array.from(this._allProviders.values()).forEach(e => {
                                this._getOrCreateLocalProvider(e.token, e.eager)
                            }), this._errors.length > 0) {
                            const e = this._errors.join("\n");
                            throw new Error(`Provider parse errors:\n${e}`)
                        }
                        const e = [],
                            t = [];
                        return this._transformedProviders.forEach(n => {
                            n.eager ? t.push(n) : e.push(n)
                        }), e.concat(t)
                    }
                    _getOrCreateLocalProvider(e, t) {
                        const n = this._allProviders.get(Sn(e));
                        if (!n) return null;
                        let s = this._transformedProviders.get(Sn(e));
                        if (s) return s;
                        if (null != this._seenProviders.get(Sn(e))) return this._errors.push(new vl(`Cannot instantiate cyclic dependency! ${Cn(e)}`, n.sourceSpan)), null;
                        this._seenProviders.set(Sn(e), !0);
                        const r = n.providers.map(e => {
                            let s, r = e.useValue,
                                i = e.useExisting;
                            if (null != e.useExisting) {
                                const s = this._getDependency({
                                    token: e.useExisting
                                }, t, n.sourceSpan);
                                null != s.token ? i = s.token : (i = null, r = s.value)
                            } else if (e.useFactory) {
                                s = (e.deps || e.useFactory.diDeps).map(e => this._getDependency(e, t, n.sourceSpan))
                            } else if (e.useClass) {
                                s = (e.deps || e.useClass.diDeps).map(e => this._getDependency(e, t, n.sourceSpan))
                            }
                            return El(e, {
                                useExisting: i,
                                useValue: r,
                                deps: s
                            })
                        });
                        return s = Cl(n, {
                            eager: t,
                            providers: r
                        }), this._transformedProviders.set(Sn(e), s), s
                    }
                    _getDependency(e, t = !1, n) {
                        let s = !1;
                        return e.isSkipSelf || null == e.token || (Sn(e.token) === this.reflector.resolveExternalReference(cn.Injector) || Sn(e.token) === this.reflector.resolveExternalReference(cn.ComponentFactoryResolver) || null != this._getOrCreateLocalProvider(e.token, t)) && (s = !0), e
                    }
                }

                function El(e, {
                    useExisting: t,
                    useValue: n,
                    deps: s
                }) {
                    return {
                        token: e.token,
                        useClass: e.useClass,
                        useExisting: t,
                        useFactory: e.useFactory,
                        useValue: n,
                        deps: s,
                        multi: e.multi
                    }
                }

                function Cl(e, {
                    eager: t,
                    providers: n
                }) {
                    return new fl(e.token, e.multiProvider, e.eager || t, n, e.providerType, e.lifecycleHooks, e.sourceSpan, e.isModule)
                }

                function Sl(e, t, n, s, r, i, o) {
                    e.forEach(e => {
                        let a = i.get(Sn(e.token));
                        if (null != a && !!a.multiProvider != !!e.multi && r.push(new vl(`Mixing multi and non multi provider is not possible for token ${Cn(a.token)}`, s)), a) e.multi || (a.providers.length = 0), a.providers.push(e);
                        else {
                            const r = e.token.identifier && e.token.identifier.lifecycleHooks ? e.token.identifier.lifecycleHooks : [],
                                l = !(e.useClass || e.useExisting || e.useFactory);
                            a = new fl(e.token, !!e.multi, n || l, [e], t, r, s, o), i.set(Sn(e.token), a)
                        }
                    })
                }

                function xl(e, t) {
                    t.meta.selectors.forEach(n => {
                        let s = e.get(Sn(n));
                        s || (s = [], e.set(Sn(n), s)), s.push(t)
                    })
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Tl {
                    constructor(e, t) {
                        this.style = e, this.styleUrls = t
                    }
                }

                function Al(e) {
                    if (null == e || 0 === e.length || "/" == e[0]) return !1;
                    const t = e.match(kl);
                    return null === t || "package" == t[1] || "asset" == t[1]
                }
                const Dl = /@import\s+(?:url\()?\s*(?:(?:['"]([^'"]*))|([^;\)\s]*))[^;]*;?/g,
                    Pl = /\/\*(?!#\s*(?:sourceURL|sourceMappingURL)=)[\s\S]+?\*\//g,
                    kl = /^([^:/?#]+):/,
                    Ol = "animate-";
                class Il {
                    constructor(e, t, n, s, r) {
                        if (this._exprParser = e, this._interpolationConfig = t, this._schemaRegistry = n, this.errors = r, this.pipesByName = null, this._usedPipes = new Map, s) {
                            const e = new Map;
                            s.forEach(t => e.set(t.name, t)), this.pipesByName = e
                        }
                    }
                    get interpolationConfig() {
                        return this._interpolationConfig
                    }
                    getUsedPipes() {
                        return Array.from(this._usedPipes.values())
                    }
                    createBoundHostProperties(e, t) {
                        if (e.hostProperties) {
                            const n = [];
                            return Object.keys(e.hostProperties).forEach(s => {
                                const r = e.hostProperties[s];
                                "string" == typeof r ? this.parsePropertyBinding(s, r, !0, t, t.start.offset, void 0, [], n, t) : this._reportError(`Value of the host property binding "${s}" needs to be a string representing an expression but got "${r}" (${typeof r})`, t)
                            }), n
                        }
                        return null
                    }
                    createDirectiveHostPropertyAsts(e, t, n) {
                        const s = this.createBoundHostProperties(e, n);
                        return s && s.map(e => this.createBoundElementProperty(t, e))
                    }
                    createDirectiveHostEventAsts(e, t) {
                        if (e.hostListeners) {
                            const n = [];
                            return Object.keys(e.hostListeners).forEach(s => {
                                const r = e.hostListeners[s];
                                "string" == typeof r ? this.parseEvent(s, r, t, t, [], n) : this._reportError(`Value of the host listener "${s}" needs to be a string representing an expression but got "${r}" (${typeof r})`, t)
                            }), n
                        }
                        return null
                    }
                    parseInterpolation(e, t) {
                        const n = t.start.toString();
                        try {
                            const s = this._exprParser.parseInterpolation(e, n, t.start.offset, this._interpolationConfig);
                            return s && this._reportExpressionParserErrors(s.errors, t), this._checkPipes(s, t), s
                        } catch (s) {
                            return this._reportError(`${s}`, t), this._exprParser.wrapLiteralPrimitive("ERROR", n, t.start.offset)
                        }
                    }
                    parseInterpolationExpression(e, t) {
                        const n = t.start.toString();
                        try {
                            const s = this._exprParser.parseInterpolationExpression(e, n, t.start.offset);
                            return s && this._reportExpressionParserErrors(s.errors, t), this._checkPipes(s, t), s
                        } catch (s) {
                            return this._reportError(`${s}`, t), this._exprParser.wrapLiteralPrimitive("ERROR", n, t.start.offset)
                        }
                    }
                    parseInlineTemplateBinding(e, t, n, s, r, i, o, a) {
                        const l = n.start.offset + "*".length,
                            c = this._parseTemplateBindings(e, t, n, l, s);
                        for (const u of c) {
                            const e = Rl(n, u.sourceSpan),
                                t = u.key.source,
                                l = Rl(n, u.key.span);
                            if (u instanceof io) {
                                const s = u.value ? u.value.source : "$implicit",
                                    r = u.value ? Rl(n, u.value.span) : void 0;
                                o.push(new uo(t, s, e, l, r))
                            } else if (u.value) {
                                const s = a ? e : n,
                                    o = Rl(n, u.value.ast.sourceSpan);
                                this._parsePropertyAst(t, u.value, s, l, o, r, i)
                            } else r.push([t, ""]), this.parseLiteralAttr(t, null, l, s, void 0, r, i, l)
                        }
                    }
                    _parseTemplateBindings(e, t, n, s, r) {
                        const i = n.start.toString();
                        try {
                            const o = this._exprParser.parseTemplateBindings(e, t, i, s, r);
                            return this._reportExpressionParserErrors(o.errors, n), o.templateBindings.forEach(e => {
                                e.value instanceof ro && this._checkPipes(e.value, n)
                            }), o.warnings.forEach(e => {
                                this._reportError(e, n, _i.WARNING)
                            }), o.templateBindings
                        } catch (o) {
                            return this._reportError(`${o}`, n), []
                        }
                    }
                    parseLiteralAttr(e, t, n, s, r, i, o, a) {
                        Ml(e) ? (e = e.substring(1), t && this._reportError('Assigning animation triggers via @prop="exp" attributes with an expression is invalid. Use property bindings (e.g. [@prop]="exp") or use an attribute without a value (e.g. @prop) instead.', n, _i.ERROR), this._parseAnimation(e, t, n, s, a, r, i, o)) : o.push(new lo(e, this._exprParser.wrapLiteralPrimitive(t, "", s), bi.LITERAL_ATTR, n, a, r))
                    }
                    parsePropertyBinding(e, t, n, s, r, i, o, a, l) {
                        0 === e.length && this._reportError("Property name is missing in binding", s);
                        let c = !1;
                        e.startsWith(Ol) ? (c = !0, e = e.substring(Ol.length)) : Ml(e) && (c = !0, e = e.substring(1)), c ? this._parseAnimation(e, t, s, r, l, i, o, a) : this._parsePropertyAst(e, this._parseBinding(t, n, i || s, r), s, l, i, o, a)
                    }
                    parsePropertyInterpolation(e, t, n, s, r, i, o) {
                        const a = this.parseInterpolation(t, s || n);
                        return !!a && (this._parsePropertyAst(e, a, n, o, s, r, i), !0)
                    }
                    _parsePropertyAst(e, t, n, s, r, i, o) {
                        i.push([e, t.source]), o.push(new lo(e, t, bi.DEFAULT, n, s, r))
                    }
                    _parseAnimation(e, t, n, s, r, i, o, a) {
                        0 === e.length && this._reportError("Animation trigger is missing", n);
                        const l = this._parseBinding(t || "undefined", !1, i || n, s);
                        o.push([e, l.source]), a.push(new lo(e, l, bi.ANIMATION, n, r, i))
                    }
                    _parseBinding(e, t, n, s) {
                        const r = (n && n.start || "(unknown)").toString();
                        try {
                            const i = t ? this._exprParser.parseSimpleBinding(e, r, s, this._interpolationConfig) : this._exprParser.parseBinding(e, r, s, this._interpolationConfig);
                            return i && this._reportExpressionParserErrors(i.errors, n), this._checkPipes(i, n), i
                        } catch (i) {
                            return this._reportError(`${i}`, n), this._exprParser.wrapLiteralPrimitive("ERROR", r, s)
                        }
                    }
                    createBoundElementProperty(e, t, n = !1, s = !0) {
                        if (t.isAnimation) return new ho(t.name, 4, z.NONE, t.expression, null, t.sourceSpan, t.keySpan, t.valueSpan);
                        let r, i = null,
                            o = null;
                        const a = t.name.split(".");
                        let l;
                        if (a.length > 1)
                            if ("attr" == a[0]) {
                                o = a.slice(1).join("."), n || this._validatePropertyOrAttributeName(o, t.sourceSpan, !0), l = Fl(this._schemaRegistry, e, o, !0);
                                const s = o.indexOf(":");
                                if (s > -1) {
                                    const e = o.substring(0, s),
                                        t = o.substring(s + 1);
                                    o = c(e, t)
                                }
                                r = 1
                            } else "class" == a[0] ? (o = a[1], r = 2, l = [z.NONE]) : "style" == a[0] && (i = a.length > 2 ? a[2] : null, o = a[1], r = 3, l = [z.STYLE]);
                        if (null === o) {
                            const i = this._schemaRegistry.getMappedPropName(t.name);
                            o = s ? i : t.name, l = Fl(this._schemaRegistry, e, i, !1), r = 0, n || this._validatePropertyOrAttributeName(i, t.sourceSpan, !1)
                        }
                        return new ho(o, r, l[0], t.expression, i, t.sourceSpan, t.keySpan, t.valueSpan)
                    }
                    parseEvent(e, t, n, s, r, i) {
                        0 === e.length && this._reportError("Event name is missing in binding", n), Ml(e) ? (e = e.substr(1), this._parseAnimationEvent(e, t, n, s, i)) : this._parseRegularEvent(e, t, n, s, r, i)
                    }
                    calcPossibleSecurityContexts(e, t, n) {
                        const s = this._schemaRegistry.getMappedPropName(t);
                        return Fl(this._schemaRegistry, e, s, n)
                    }
                    _parseAnimationEvent(e, t, n, s, r) {
                        const i = It(e, ".", [e, ""]);
                        const o = i[0],
                            a = i[1].toLowerCase();
                        if (a) switch (a) {
                            case "start":
                            case "done":
                                const e = this._parseAction(t, s);
                                r.push(new co(o, a, 1, e, n, s));
                                break;
                            default:
                                this._reportError(`The provided animation output phase value "${a}" for "@${o}" is not supported (use start or done)`, n)
                        } else this._reportError(`The animation trigger output event (@${o}) is missing its phase value name (start or done are currently supported)`, n)
                    }
                    _parseRegularEvent(e, t, n, s, r, i) {
                        const [o, a] = Ot(e, [null, e]), l = this._parseAction(t, s);
                        r.push([e, l.source]), i.push(new co(a, o, 0, l, n, s))
                    }
                    _parseAction(e, t) {
                        const n = (t && t.start || "(unknown").toString(),
                            s = t && t.start ? t.start.offset : 0;
                        try {
                            const r = this._exprParser.parseAction(e, n, s, this._interpolationConfig);
                            return r && this._reportExpressionParserErrors(r.errors, t), !r || r.ast instanceof Fi ? (this._reportError("Empty expressions are not allowed", t), this._exprParser.wrapLiteralPrimitive("ERROR", n, s)) : (this._checkPipes(r, t), r)
                        } catch (r) {
                            return this._reportError(`${r}`, t), this._exprParser.wrapLiteralPrimitive("ERROR", n, s)
                        }
                    }
                    _reportError(e, t, n = _i.ERROR) {
                        this.errors.push(new Ci(t, e, n))
                    }
                    _reportExpressionParserErrors(e, t) {
                        for (const n of e) this._reportError(n.message, t)
                    }
                    _checkPipes(e, t) {
                        if (e && this.pipesByName) {
                            const n = new Nl;
                            e.visit(n), n.pipes.forEach((e, n) => {
                                const s = this.pipesByName.get(n);
                                s ? this._usedPipes.set(n, s) : this._reportError(`The pipe '${n}' could not be found`, new vi(t.start.moveBy(e.span.start), t.start.moveBy(e.span.end)))
                            })
                        }
                    }
                    _validatePropertyOrAttributeName(e, t, n) {
                        const s = n ? this._schemaRegistry.validateAttribute(e) : this._schemaRegistry.validateProperty(e);
                        s.error && this._reportError(s.msg, t, _i.ERROR)
                    }
                }
                class Nl extends ao {
                    constructor() {
                        super(...arguments), this.pipes = new Map
                    }
                    visitPipe(e, t) {
                        return this.pipes.set(e.name, e), e.exp.visit(this), this.visitAll(e.args, t), null
                    }
                }

                function Ml(e) {
                    return "@" == e[0]
                }

                function Fl(e, t, n, s) {
                    const r = [];
                    return g.parse(t).forEach(t => {
                        const i = t.element ? [t.element] : e.allKnownElementNames(),
                            o = new Set(t.notSelectors.filter(e => e.isElementSelector()).map(e => e.element)),
                            a = i.filter(e => !o.has(e));
                        r.push(...a.map(t => e.securityContext(t, n, s)))
                    }), 0 === r.length ? [z.NONE] : Array.from(new Set(r)).sort()
                }

                function Rl(e, t) {
                    const n = t.start - e.start.offset,
                        s = t.end - e.end.offset;
                    return new vi(e.start.moveBy(n), e.end.moveBy(s), e.fullStart.moveBy(n), e.details)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function jl(e) {
                    let t = null,
                        n = null,
                        s = null,
                        r = !1,
                        i = "";
                    e.attrs.forEach(e => {
                        const o = e.name.toLowerCase();
                        "select" == o ? t = e.value : "href" == o ? n = e.value : "rel" == o ? s = e.value : "ngNonBindable" == e.name ? r = !0 : "ngProjectAs" == e.name && e.value.length > 0 && (i = e.value)
                    }), t = function(e) {
                        if (null === e || 0 === e.length) return "*";
                        return e
                    }
                    /**
                     * @license
                     * Copyright Google LLC All Rights Reserved.
                     *
                     * Use of this source code is governed by an MIT-style license that can be
                     * found in the LICENSE file at https://angular.io/license
                     */
                    (t);
                    const a = e.name.toLowerCase();
                    let l = Ll.OTHER;
                    return o(a) ? l = Ll.NG_CONTENT : "style" == a ? l = Ll.STYLE : "script" == a ? l = Ll.SCRIPT : "link" == a && "stylesheet" == s && (l = Ll.STYLESHEET), new Vl(l, t, n, r, i)
                }
                var Ll;
                ! function(e) {
                    e[e.NG_CONTENT = 0] = "NG_CONTENT", e[e.STYLE = 1] = "STYLE", e[e.STYLESHEET = 2] = "STYLESHEET", e[e.SCRIPT = 3] = "SCRIPT", e[e.OTHER = 4] = "OTHER"
                }(Ll || (Ll = {}));
                class Vl {
                    constructor(e, t, n, s, r) {
                        this.type = e, this.selectAttr = t, this.hrefAttr = n, this.nonBindable = s, this.projectAs = r
                    }
                }
                const $l = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/;
                let Bl;

                function Hl() {
                    return Bl || (Bl = g.parse("*")[0]), Bl
                }
                class Ul extends Ci {
                    constructor(e, t, n) {
                        super(t, e, n)
                    }
                }
                class ql {
                    constructor(e, t, n) {
                        this.templateAst = e, this.usedPipes = t, this.errors = n
                    }
                }
                class zl {
                    constructor(e, t, n, s, r, i, o) {
                        this._config = e, this._reflector = t, this._exprParser = n, this._schemaRegistry = s, this._htmlParser = r, this._console = i, this.transforms = o
                    }
                    get expressionParser() {
                        return this._exprParser
                    }
                    parse(e, t, n, s, r, i, o) {
                        var a;
                        const l = this.tryParse(e, t, n, s, r, i, o),
                            c = l.errors.filter(e => e.level === _i.WARNING),
                            u = l.errors.filter(e => e.level === _i.ERROR);
                        if (c.length > 0 && (null === (a = this._console) || void 0 === a || a.warn(`Template parse warnings:\n${c.join("\n")}`)), u.length > 0) {
                            throw Bt(`Template parse errors:\n${u.join("\n")}`, u)
                        }
                        return {
                            template: l.templateAst,
                            pipes: l.usedPipes
                        }
                    }
                    tryParse(e, t, n, s, r, i, o) {
                        let a = "string" == typeof t ? this._htmlParser.parse(t, i, {
                            tokenizeExpansionForms: !0,
                            interpolationConfig: this.getInterpolationConfig(e)
                        }) : t;
                        return o || (a = Za(a)), this.tryParseHtml(this.expandHtml(a), e, n, s, r)
                    }
                    tryParseHtml(e, t, n, s, r) {
                        let i;
                        const o = e.errors,
                            a = [];
                        if (e.rootNodes.length > 0) {
                            const l = Yl(n),
                                c = Yl(s),
                                u = new _l(this._reflector, t);
                            let h;
                            t.template && t.template.interpolation && (h = {
                                start: t.template.interpolation[0],
                                end: t.template.interpolation[1]
                            });
                            const p = new Il(this._exprParser, h, this._schemaRegistry, c, o),
                                d = new Wl(this._reflector, this._config, u, l, p, this._schemaRegistry, r, o);
                            i = ya(d, e.rootNodes, Zl), o.push(...u.errors), a.push(...p.getUsedPipes())
                        } else i = [];
                        return this._assertNoReferenceDuplicationOnTemplate(i, o), o.length > 0 || this.transforms && this.transforms.forEach(e => {
                            i = yl(e, i)
                        }), new ql(i, a, o)
                    }
                    expandHtml(e, t = !1) {
                        const n = e.errors;
                        if (0 == n.length || t) {
                            const t = Xa(e.rootNodes);
                            n.push(...t.errors), e = new La(t.nodes, n)
                        }
                        return e
                    }
                    getInterpolationConfig(e) {
                        if (e.template) return Mr.fromArray(e.template.interpolation)
                    }
                    _assertNoReferenceDuplicationOnTemplate(e, t) {
                        const n = [];
                        e.filter(e => !!e.references).forEach(e => e.references.forEach(e => {
                            const s = e.name;
                            if (n.indexOf(s) < 0) n.push(s);
                            else {
                                const n = new Ul(`Reference "#${s}" is defined several times`, e.sourceSpan, _i.ERROR);
                                t.push(n)
                            }
                        }))
                    }
                }
                class Wl {
                    constructor(e, t, n, s, r, i, o, a) {
                        this.reflector = e, this.config = t, this.providerViewContext = n, this._bindingParser = r, this._schemaRegistry = i, this._schemas = o, this._targetErrors = a, this.selectorMatcher = new y, this.directivesIndex = new Map, this.ngContentCount = 0, this.contentQueryStartId = n.component.viewQueries.length + 1, s.forEach((e, t) => {
                            const n = g.parse(e.selector);
                            this.selectorMatcher.addSelectables(n, e), this.directivesIndex.set(e, t)
                        })
                    }
                    visitExpansion(e, t) {
                        return null
                    }
                    visitExpansionCase(e, t) {
                        return null
                    }
                    visitText(e, t) {
                        const n = t.findNgContentIndex(Hl()),
                            s = Ka(e.value),
                            r = this._bindingParser.parseInterpolation(s, e.sourceSpan);
                        return r ? new sl(r, n, e.sourceSpan) : new nl(s, n, e.sourceSpan)
                    }
                    visitAttribute(e, t) {
                        return new rl(e.name, e.value, e.sourceSpan)
                    }
                    visitComment(e, t) {
                        return null
                    }
                    visitElement(e, t) {
                        const n = this.contentQueryStartId,
                            s = e.name,
                            r = jl(e);
                        if (r.type === Ll.SCRIPT || r.type === Ll.STYLE) return null;
                        if (r.type === Ll.STYLESHEET && Al(r.hrefAttr)) return null;
                        const i = [],
                            o = [],
                            l = [],
                            c = [],
                            u = [],
                            h = [],
                            p = [],
                            d = [];
                        let f = !1;
                        const m = [],
                            y = a(e.name);
                        e.attrs.forEach(e => {
                            const t = this._parseAttr(y, e, i, o, u, l, c);
                            let n, s;
                            c.push(...[].map(e => cl.fromParsedVariable(e)));
                            const r = this._normalizeAttributeName(e.name);
                            r.startsWith("*") && (n = e.value, s = r.substring("*".length));
                            const a = null != n;
                            if (a) {
                                f && this._reportError("Can't have multiple template bindings on one element. Use only one attribute prefixed with *", e.sourceSpan), f = !0;
                                const t = [],
                                    r = (e.valueSpan || e.sourceSpan).start.offset;
                                this._bindingParser.parseInlineTemplateBinding(s, n, e.sourceSpan, r, p, h, t, !1), d.push(...t.map(e => cl.fromParsedVariable(e)))
                            }
                            t || a || (m.push(this.visitAttribute(e, null)), i.push([e.name, e.value]))
                        });
                        const v = Ql(s, i),
                            {
                                directives: _,
                                matchElement: b
                            } = this._parseDirectives(this.selectorMatcher, v),
                            w = [],
                            E = new Set,
                            C = this._createDirectiveAsts(y, e.name, _, o, l, e.sourceSpan, w, E),
                            S = this._createElementPropertyAsts(e.name, o, E),
                            x = t.isTemplateElement || f,
                            T = new bl(this.providerViewContext, t.providerContext, x, C, m, w, y, n, e.sourceSpan),
                            A = ya(r.nonBindable ? Jl : this, e.children, Kl.create(y, C, y ? t.providerContext : T));
                        T.afterElement();
                        const D = "" != r.projectAs ? g.parse(r.projectAs)[0] : v,
                            P = t.findNgContentIndex(D);
                        let k;
                        if (r.type === Ll.NG_CONTENT) e.children && !e.children.every(Xl) && this._reportError("<ng-content> element cannot have content.", e.sourceSpan), k = new gl(this.ngContentCount++, f ? null : P, e.sourceSpan);
                        else if (y) this._assertAllEventsPublishedByDirectives(C, u), this._assertNoComponentsNorElementBindingsOnTemplate(C, S, e.sourceSpan), k = new hl(m, u, w, c, T.transformedDirectiveAsts, T.transformProviders, T.transformedHasViewContainer, T.queryMatches, A, f ? null : P, e.sourceSpan);
                        else {
                            this._assertElementExists(b, e), this._assertOnlyOneComponent(C, e.sourceSpan);
                            const n = f ? null : t.findNgContentIndex(D);
                            k = new ul(s, m, S, u, w, T.transformedDirectiveAsts, T.transformProviders, T.transformedHasViewContainer, T.queryMatches, A, f ? null : n, e.sourceSpan, e.endSourceSpan || null)
                        }
                        if (f) {
                            const n = this.contentQueryStartId,
                                r = Ql("ng-template", p),
                                {
                                    directives: i
                                } = this._parseDirectives(this.selectorMatcher, r),
                                o = new Set,
                                a = this._createDirectiveAsts(!0, s, i, h, [], e.sourceSpan, [], o),
                                l = this._createElementPropertyAsts(s, h, o);
                            this._assertNoComponentsNorElementBindingsOnTemplate(a, l, e.sourceSpan);
                            const c = new bl(this.providerViewContext, t.providerContext, t.isTemplateElement, a, [], [], !0, n, e.sourceSpan);
                            c.afterElement(), k = new hl([], [], [], d, c.transformedDirectiveAsts, c.transformProviders, c.transformedHasViewContainer, c.queryMatches, [k], P, e.sourceSpan)
                        }
                        return k
                    }
                    _parseAttr(e, t, n, s, r, i, o) {
                        const a = this._normalizeAttributeName(t.name),
                            l = t.value,
                            c = t.sourceSpan,
                            u = t.valueSpan ? t.valueSpan.start.offset : c.start.offset,
                            h = [],
                            p = a.match($l);
                        let d = !1;
                        if (null !== p)
                            if (d = !0, null != p[1]) this._bindingParser.parsePropertyBinding(p[7], l, !1, c, u, t.valueSpan, n, s);
                            else if (p[2])
                            if (e) {
                                const e = p[7];
                                this._parseVariable(e, l, c, o)
                            } else this._reportError('"let-" is only supported on ng-template elements.', c);
                        else if (p[3]) {
                            const e = p[7];
                            this._parseReference(e, l, c, i)
                        } else p[4] ? this._bindingParser.parseEvent(p[7], l, c, t.valueSpan || c, n, h) : p[5] ? (this._bindingParser.parsePropertyBinding(p[7], l, !1, c, u, t.valueSpan, n, s), this._parseAssignmentEvent(p[7], l, c, t.valueSpan || c, n, h)) : p[6] ? this._bindingParser.parseLiteralAttr(a, l, c, u, t.valueSpan, n, s) : p[8] ? (this._bindingParser.parsePropertyBinding(p[8], l, !1, c, u, t.valueSpan, n, s), this._parseAssignmentEvent(p[8], l, c, t.valueSpan || c, n, h)) : p[9] ? this._bindingParser.parsePropertyBinding(p[9], l, !1, c, u, t.valueSpan, n, s) : p[10] && this._bindingParser.parseEvent(p[10], l, c, t.valueSpan || c, n, h);
                        else d = this._bindingParser.parsePropertyInterpolation(a, l, c, t.valueSpan, n, s);
                        return d || this._bindingParser.parseLiteralAttr(a, l, c, u, t.valueSpan, n, s), r.push(...h.map(e => al.fromParsedEvent(e))), d
                    }
                    _normalizeAttributeName(e) {
                        return /^data-/i.test(e) ? e.substring(5) : e
                    }
                    _parseVariable(e, t, n, s) {
                        e.indexOf("-") > -1 ? this._reportError('"-" is not allowed in variable names', n) : 0 === e.length && this._reportError("Variable does not have a name", n), s.push(new cl(e, t, n))
                    }
                    _parseReference(e, t, n, s) {
                        e.indexOf("-") > -1 ? this._reportError('"-" is not allowed in reference names', n) : 0 === e.length && this._reportError("Reference does not have a name", n), s.push(new Gl(e, t, n))
                    }
                    _parseAssignmentEvent(e, t, n, s, r, i) {
                        this._bindingParser.parseEvent(`${e}Change`, `${t}=$event`, n, s, r, i)
                    }
                    _parseDirectives(e, t) {
                        const n = Xt(this.directivesIndex.size);
                        let s = !1;
                        return e.match(t, (e, t) => {
                            n[this.directivesIndex.get(t)] = t, s = s || e.hasElementSelector()
                        }), {
                            directives: n.filter(e => !!e),
                            matchElement: s
                        }
                    }
                    _createDirectiveAsts(e, t, n, s, r, i, o, a) {
                        const l = new Set;
                        let c = null;
                        const u = n.map(e => {
                            const n = new vi(i.start, i.end, i.fullStart, `Directive ${yn(e.type)}`);
                            e.isComponent && (c = e);
                            const u = [];
                            let h = this._bindingParser.createDirectiveHostPropertyAsts(e, t, n).map(e => ol.fromBoundProperty(e));
                            h = this._checkPropertiesInSchema(t, h);
                            const p = this._bindingParser.createDirectiveHostEventAsts(e, n);
                            this._createDirectivePropertyAsts(e.inputs, s, u, a), r.forEach(t => {
                                (0 === t.value.length && e.isComponent || t.isReferenceToDirective(e)) && (o.push(new ll(t.name, un(e.type.reference), t.value, t.sourceSpan)), l.add(t.name))
                            });
                            const d = p.map(e => al.fromParsedEvent(e)),
                                f = this.contentQueryStartId;
                            return this.contentQueryStartId += e.queries.length, new dl(e, u, h, d, f, n)
                        });
                        return r.forEach(t => {
                            if (t.value.length > 0) l.has(t.name) || this._reportError(`There is no directive with "exportAs" set to "${t.value}"`, t.sourceSpan);
                            else if (!c) {
                                let n = null;
                                e && (n = hn(this.reflector, cn.TemplateRef)), o.push(new ll(t.name, n, t.value, t.sourceSpan))
                            }
                        }), u
                    }
                    _createDirectivePropertyAsts(e, t, n, s) {
                        if (e) {
                            const r = new Map;
                            t.forEach(e => {
                                const t = r.get(e.name);
                                t && !t.isLiteral || r.set(e.name, e)
                            }), Object.keys(e).forEach(t => {
                                const i = e[t],
                                    o = r.get(i);
                                o && (s.add(o.name), ec(o.expression) || n.push(new pl(t, o.name, o.expression, o.sourceSpan)))
                            })
                        }
                    }
                    _createElementPropertyAsts(e, t, n) {
                        const s = [];
                        return t.forEach(t => {
                            if (!t.isLiteral && !n.has(t.name)) {
                                const n = this._bindingParser.createBoundElementProperty(e, t);
                                s.push(ol.fromBoundProperty(n))
                            }
                        }), this._checkPropertiesInSchema(e, s)
                    }
                    _findComponentDirectives(e) {
                        return e.filter(e => e.directive.isComponent)
                    }
                    _findComponentDirectiveNames(e) {
                        return this._findComponentDirectives(e).map(e => yn(e.directive.type))
                    }
                    _assertOnlyOneComponent(e, t) {
                        const n = this._findComponentDirectiveNames(e);
                        n.length > 1 && this._reportError(`More than one component matched on this element.\nMake sure that only one component's selector can match a given element.\nConflicting components: ${n.join(",")}`, t)
                    }
                    _assertElementExists(e, t) {
                        const n = t.name.replace(/^:xhtml:/, "");
                        if (!e && !this._schemaRegistry.hasElement(n, this._schemas)) {
                            let e = `'${n}' is not a known element:\n`;
                            e += `1. If '${n}' is an Angular component, then verify that it is part of this module.\n`, n.indexOf("-") > -1 ? e += `2. If '${n}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.` : e += "2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.", this._reportError(e, t.sourceSpan)
                        }
                    }
                    _assertNoComponentsNorElementBindingsOnTemplate(e, t, n) {
                        const s = this._findComponentDirectiveNames(e);
                        s.length > 0 && this._reportError(`Components on an embedded template: ${s.join(",")}`, n), t.forEach(e => {
                            this._reportError(`Property binding ${e.name} not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the "@NgModule.declarations".`, n)
                        })
                    }
                    _assertAllEventsPublishedByDirectives(e, t) {
                        const n = new Set;
                        e.forEach(e => {
                            Object.keys(e.directive.outputs).forEach(t => {
                                const s = e.directive.outputs[t];
                                n.add(s)
                            })
                        }), t.forEach(e => {
                            null == e.target && n.has(e.name) || this._reportError(`Event binding ${e.fullName} not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the "@NgModule.declarations".`, e.sourceSpan)
                        })
                    }
                    _checkPropertiesInSchema(e, t) {
                        return t.filter(t => {
                            if (0 === t.type && !this._schemaRegistry.hasProperty(e, t.name, this._schemas)) {
                                let n = `Can't bind to '${t.name}' since it isn't a known property of '${e}'.`;
                                e.startsWith("ng-") ? n += `\n1. If '${t.name}' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.` : e.indexOf("-") > -1 && (n += `\n1. If '${e}' is an Angular component and it has '${t.name}' input, then verify that it is part of this module.\n2. If '${e}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`), this._reportError(n, t.sourceSpan)
                            }
                            return !ec(t.value)
                        })
                    }
                    _reportError(e, t, n = _i.ERROR) {
                        this._targetErrors.push(new Ci(t, e, n))
                    }
                }
                class Gl {
                    constructor(e, t, n) {
                        this.name = e, this.value = t, this.sourceSpan = n
                    }
                    isReferenceToDirective(e) {
                        return -1 !== (t = e.exportAs, t ? t.split(",").map(e => e.trim()) : []).indexOf(this.value);
                        var t
                    }
                }
                class Kl {
                    constructor(e, t, n, s) {
                        this.isTemplateElement = e, this._ngContentIndexMatcher = t, this._wildcardNgContentIndex = n, this.providerContext = s
                    }
                    static create(e, t, n) {
                        const s = new y;
                        let r = null;
                        const i = t.find(e => e.directive.isComponent);
                        if (i) {
                            const e = i.directive.template.ngContentSelectors;
                            for (let t = 0; t < e.length; t++) {
                                "*" === e[t] ? r = t : s.addSelectables(g.parse(e[t]), t)
                            }
                        }
                        return new Kl(e, s, r, n)
                    }
                    findNgContentIndex(e) {
                        const t = [];
                        return this._ngContentIndexMatcher.match(e, (e, n) => {
                            t.push(n)
                        }), t.sort(), null != this._wildcardNgContentIndex && t.push(this._wildcardNgContentIndex), t.length > 0 ? t[0] : null
                    }
                }

                function Ql(e, t) {
                    const n = new g,
                        s = r(e)[1];
                    n.setElement(s);
                    for (let i = 0; i < t.length; i++) {
                        const e = t[i][0],
                            s = r(e)[1],
                            o = t[i][1];
                        if (n.addAttribute(s, o), "class" == e.toLowerCase()) {
                            o.trim().split(/\s+/g).forEach(e => n.addClassName(e))
                        }
                    }
                    return n
                }
                const Zl = new Kl(!0, new y, null, null),
                    Jl = new class {
                        visitElement(e, t) {
                            const n = jl(e);
                            if (n.type === Ll.SCRIPT || n.type === Ll.STYLE || n.type === Ll.STYLESHEET) return null;
                            const s = e.attrs.map(e => [e.name, e.value]),
                                r = Ql(e.name, s),
                                i = t.findNgContentIndex(r),
                                o = ya(this, e.children, Zl);
                            return new ul(e.name, ya(this, e.attrs), [], [], [], [], [], !1, [], o, i, e.sourceSpan, e.endSourceSpan)
                        }
                        visitComment(e, t) {
                            return null
                        }
                        visitAttribute(e, t) {
                            return new rl(e.name, e.value, e.sourceSpan)
                        }
                        visitText(e, t) {
                            const n = t.findNgContentIndex(Hl());
                            return new nl(e.value, n, e.sourceSpan)
                        }
                        visitExpansion(e, t) {
                            return e
                        }
                        visitExpansionCase(e, t) {
                            return e
                        }
                    };

                function Xl(e) {
                    return e instanceof ha && 0 == e.value.trim().length
                }

                function Yl(e) {
                    const t = new Map;
                    return e.forEach(e => {
                        t.get(e.type.reference) || t.set(e.type.reference, e)
                    }), Array.from(t.values())
                }

                function ec(e) {
                    return e instanceof ro && (e = e.ast), e instanceof Fi
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function tc(e) {
                    const t = e.charCodeAt(0);
                    if (t == e.charCodeAt(e.length - 1) && (39 == t || 34 == t)) {
                        const t = e.substring(1, e.length - 1); - 1 == t.indexOf("'") && -1 == t.indexOf('"') && (e = t)
                    }
                    return e
                }

                function nc(e) {
                    return e.replace(/[a-z][A-Z]/g, e => e.charAt(0) + "-" + e.charAt(1)).toLowerCase()
                }
                class sc {
                    constructor(e) {
                        this._directiveExpr = e, this._hasInitialValues = !1, this.hasBindings = !1, this.hasBindingsWithPipes = !1, this._classMapInput = null, this._styleMapInput = null, this._singleStyleInputs = null, this._singleClassInputs = null, this._lastStylingInput = null, this._firstStylingInput = null, this._stylesIndex = new Map, this._classesIndex = new Map, this._initialStyleValues = [], this._initialClassValues = []
                    }
                    registerBoundInput(e) {
                        let t = null,
                            n = e.name;
                        switch (e.type) {
                            case 0:
                                t = this.registerInputBasedOnName(n, e.value, e.sourceSpan);
                                break;
                            case 3:
                                t = this.registerStyleInput(n, !1, e.value, e.sourceSpan, e.unit);
                                break;
                            case 2:
                                t = this.registerClassInput(n, !1, e.value, e.sourceSpan)
                        }
                        return !!t
                    }
                    registerInputBasedOnName(e, t, n) {
                        let s = null;
                        const r = e.substring(0, 6),
                            i = "style" === e || "style." === r || "style!" === r;
                        if (i || !i && ("class" === e || "class." === r || "class!" === r)) {
                            const r = "." !== e.charAt(5),
                                o = e.substr(r ? 5 : 6);
                            s = i ? this.registerStyleInput(o, r, t, n) : this.registerClassInput(o, r, t, n)
                        }
                        return s
                    }
                    registerStyleInput(e, t, n, s, r) {
                        if (ec(n)) return null;
                        e = nc(e);
                        const {
                            property: i,
                            hasOverrideFlag: o,
                            suffix: a
                        } = ic(e), l = {
                            name: i,
                            suffix: r = "string" == typeof r && 0 !== r.length ? r : a,
                            value: n,
                            sourceSpan: s,
                            hasOverrideFlag: o
                        };
                        return t ? this._styleMapInput = l : ((this._singleStyleInputs = this._singleStyleInputs || []).push(l), rc(this._stylesIndex, i)), this._lastStylingInput = l, this._firstStylingInput = this._firstStylingInput || l, this._checkForPipes(n), this.hasBindings = !0, l
                    }
                    registerClassInput(e, t, n, s) {
                        if (ec(n)) return null;
                        const {
                            property: r,
                            hasOverrideFlag: i
                        } = ic(e), o = {
                            name: r,
                            value: n,
                            sourceSpan: s,
                            hasOverrideFlag: i,
                            suffix: null
                        };
                        if (t) {
                            if (this._classMapInput) throw new Error("[class] and [className] bindings cannot be used on the same element simultaneously");
                            this._classMapInput = o
                        } else(this._singleClassInputs = this._singleClassInputs || []).push(o), rc(this._classesIndex, r);
                        return this._lastStylingInput = o, this._firstStylingInput = this._firstStylingInput || o, this._checkForPipes(n), this.hasBindings = !0, o
                    }
                    _checkForPipes(e) {
                        e instanceof ro && e.ast instanceof zi && (this.hasBindingsWithPipes = !0)
                    }
                    registerStyleAttr(e) {
                        this._initialStyleValues = function(e) {
                            const t = [];
                            let n = 0,
                                s = 0,
                                r = 0,
                                i = 0,
                                o = 0,
                                a = null,
                                l = !1;
                            for (; n < e.length;) switch (e.charCodeAt(n++)) {
                                case 40:
                                    s++;
                                    break;
                                case 41:
                                    s--;
                                    break;
                                case 39:
                                    l = l || i > 0, 0 === r ? r = 39 : 39 === r && 92 !== e.charCodeAt(n - 1) && (r = 0);
                                    break;
                                case 34:
                                    l = l || i > 0, 0 === r ? r = 34 : 34 === r && 92 !== e.charCodeAt(n - 1) && (r = 0);
                                    break;
                                case 58:
                                    a || 0 !== s || 0 !== r || (a = nc(e.substring(o, n - 1).trim()), i = n);
                                    break;
                                case 59:
                                    if (a && i > 0 && 0 === s && 0 === r) {
                                        const s = e.substring(i, n - 1).trim();
                                        t.push(a, l ? tc(s) : s), o = n, i = 0, a = null, l = !1
                                    }
                            }
                            if (a && i) {
                                const n = e.substr(i).trim();
                                t.push(a, l ? tc(n) : n)
                            }
                            return t
                        }(e), this._hasInitialValues = !0
                    }
                    registerClassAttr(e) {
                        this._initialClassValues = e.trim().split(/\s+/g), this._hasInitialValues = !0
                    }
                    populateInitialStylingAttrs(e) {
                        if (this._initialClassValues.length) {
                            e.push(At(1));
                            for (let t = 0; t < this._initialClassValues.length; t++) e.push(At(this._initialClassValues[t]))
                        }
                        if (this._initialStyleValues.length) {
                            e.push(At(2));
                            for (let t = 0; t < this._initialStyleValues.length; t += 2) e.push(At(this._initialStyleValues[t]), At(this._initialStyleValues[t + 1]))
                        }
                    }
                    assignHostAttrs(e, t) {
                        this._directiveExpr && (e.length || this._hasInitialValues) && (this.populateInitialStylingAttrs(e), t.set("hostAttrs", Ct(e)))
                    }
                    buildClassMapInstruction(e) {
                        return this._classMapInput ? this._buildMapBasedInstruction(e, !0, this._classMapInput) : null
                    }
                    buildStyleMapInstruction(e) {
                        return this._styleMapInput ? this._buildMapBasedInstruction(e, !1, this._styleMapInput) : null
                    }
                    _buildMapBasedInstruction(e, t, n) {
                        let s = 2;
                        const r = n.value.visit(e);
                        let i;
                        return r instanceof Qi ? (s += r.expressions.length, i = t ? function(e) {
                            switch (Cr(e)) {
                                case 1:
                                    return jn.classMap;
                                case 3:
                                    return jn.classMapInterpolate1;
                                case 5:
                                    return jn.classMapInterpolate2;
                                case 7:
                                    return jn.classMapInterpolate3;
                                case 9:
                                    return jn.classMapInterpolate4;
                                case 11:
                                    return jn.classMapInterpolate5;
                                case 13:
                                    return jn.classMapInterpolate6;
                                case 15:
                                    return jn.classMapInterpolate7;
                                case 17:
                                    return jn.classMapInterpolate8;
                                default:
                                    return jn.classMapInterpolateV
                            }
                        }(r) : function(e) {
                            switch (Cr(e)) {
                                case 1:
                                    return jn.styleMap;
                                case 3:
                                    return jn.styleMapInterpolate1;
                                case 5:
                                    return jn.styleMapInterpolate2;
                                case 7:
                                    return jn.styleMapInterpolate3;
                                case 9:
                                    return jn.styleMapInterpolate4;
                                case 11:
                                    return jn.styleMapInterpolate5;
                                case 13:
                                    return jn.styleMapInterpolate6;
                                case 15:
                                    return jn.styleMapInterpolate7;
                                case 17:
                                    return jn.styleMapInterpolate8;
                                default:
                                    return jn.styleMapInterpolateV
                            }
                        }(r)) : i = t ? jn.classMap : jn.styleMap, {
                            reference: i,
                            calls: [{
                                supportsInterpolation: !0,
                                sourceSpan: n.sourceSpan,
                                allocateBindingSlots: s,
                                params: e => {
                                    const t = e(r);
                                    return Array.isArray(t) ? t : [t]
                                }
                            }]
                        }
                    }
                    _buildSingleInputs(e, t, n, s, r) {
                        const i = [];
                        return t.forEach(t => {
                            const o = i[i.length - 1],
                                a = t.value.visit(n);
                            let l = e,
                                c = 2;
                            a instanceof Qi && (c += a.expressions.length, s && (l = s(a)));
                            const u = {
                                sourceSpan: t.sourceSpan,
                                allocateBindingSlots: c,
                                supportsInterpolation: !!s,
                                params: e => {
                                    const n = [];
                                    n.push(At(t.name));
                                    const s = e(a);
                                    return Array.isArray(s) ? n.push(...s) : n.push(s), r || null === t.suffix || n.push(At(t.suffix)), n
                                }
                            };
                            o && o.reference === l ? o.calls.push(u) : i.push({
                                reference: l,
                                calls: [u]
                            })
                        }), i
                    }
                    _buildClassInputs(e) {
                        return this._singleClassInputs ? this._buildSingleInputs(jn.classProp, this._singleClassInputs, e, null, !0) : []
                    }
                    _buildStyleInputs(e) {
                        return this._singleStyleInputs ? this._buildSingleInputs(jn.styleProp, this._singleStyleInputs, e, oc, !1) : []
                    }
                    buildUpdateLevelInstructions(e) {
                        const t = [];
                        if (this.hasBindings) {
                            const n = this.buildStyleMapInstruction(e);
                            n && t.push(n);
                            const s = this.buildClassMapInstruction(e);
                            s && t.push(s), t.push(...this._buildStyleInputs(e)), t.push(...this._buildClassInputs(e))
                        }
                        return t
                    }
                }

                function rc(e, t) {
                    e.has(t) || e.set(t, e.size)
                }

                function ic(e) {
                    let t = !1;
                    const n = e.indexOf("!important"); - 1 !== n && (e = n > 0 ? e.substring(0, n) : "", t = !0);
                    let s = null,
                        r = e;
                    const i = e.lastIndexOf(".");
                    return i > 0 && (s = e.substr(i + 1), r = e.substring(0, i)), {
                        property: r,
                        suffix: s,
                        hasOverrideFlag: t
                    }
                }

                function oc(e) {
                    switch (Cr(e)) {
                        case 1:
                            return jn.styleProp;
                        case 3:
                            return jn.stylePropInterpolate1;
                        case 5:
                            return jn.stylePropInterpolate2;
                        case 7:
                            return jn.stylePropInterpolate3;
                        case 9:
                            return jn.stylePropInterpolate4;
                        case 11:
                            return jn.stylePropInterpolate5;
                        case 13:
                            return jn.stylePropInterpolate6;
                        case 15:
                            return jn.stylePropInterpolate7;
                        case 17:
                            return jn.stylePropInterpolate8;
                        default:
                            return jn.stylePropInterpolateV
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var ac;
                ! function(e) {
                    e[e.Character = 0] = "Character", e[e.Identifier = 1] = "Identifier", e[e.Keyword = 2] = "Keyword", e[e.String = 3] = "String", e[e.Operator = 4] = "Operator", e[e.Number = 5] = "Number", e[e.Error = 6] = "Error"
                }(ac || (ac = {}));
                const lc = ["var", "let", "as", "null", "undefined", "true", "false", "if", "else", "this"];
                class cc {
                    tokenize(e) {
                        const t = new fc(e),
                            n = [];
                        let s = t.scanToken();
                        for (; null != s;) n.push(s), s = t.scanToken();
                        return n
                    }
                }
                class uc {
                    constructor(e, t, n, s, r) {
                        this.index = e, this.end = t, this.type = n, this.numValue = s, this.strValue = r
                    }
                    isCharacter(e) {
                        return this.type == ac.Character && this.numValue == e
                    }
                    isNumber() {
                        return this.type == ac.Number
                    }
                    isString() {
                        return this.type == ac.String
                    }
                    isOperator(e) {
                        return this.type == ac.Operator && this.strValue == e
                    }
                    isIdentifier() {
                        return this.type == ac.Identifier
                    }
                    isKeyword() {
                        return this.type == ac.Keyword
                    }
                    isKeywordLet() {
                        return this.type == ac.Keyword && "let" == this.strValue
                    }
                    isKeywordAs() {
                        return this.type == ac.Keyword && "as" == this.strValue
                    }
                    isKeywordNull() {
                        return this.type == ac.Keyword && "null" == this.strValue
                    }
                    isKeywordUndefined() {
                        return this.type == ac.Keyword && "undefined" == this.strValue
                    }
                    isKeywordTrue() {
                        return this.type == ac.Keyword && "true" == this.strValue
                    }
                    isKeywordFalse() {
                        return this.type == ac.Keyword && "false" == this.strValue
                    }
                    isKeywordThis() {
                        return this.type == ac.Keyword && "this" == this.strValue
                    }
                    isError() {
                        return this.type == ac.Error
                    }
                    toNumber() {
                        return this.type == ac.Number ? this.numValue : -1
                    }
                    toString() {
                        switch (this.type) {
                            case ac.Character:
                            case ac.Identifier:
                            case ac.Keyword:
                            case ac.Operator:
                            case ac.String:
                            case ac.Error:
                                return this.strValue;
                            case ac.Number:
                                return this.numValue.toString();
                            default:
                                return null
                        }
                    }
                }

                function hc(e, t, n) {
                    return new uc(e, t, ac.Character, n, String.fromCharCode(n))
                }

                function pc(e, t, n) {
                    return new uc(e, t, ac.Operator, 0, n)
                }
                const dc = new uc(-1, -1, ac.Character, 0, "");
                class fc {
                    constructor(e) {
                        this.input = e, this.peek = 0, this.index = -1, this.length = e.length, this.advance()
                    }
                    advance() {
                        this.peek = ++this.index >= this.length ? 0 : this.input.charCodeAt(this.index)
                    }
                    scanToken() {
                        const e = this.input,
                            t = this.length;
                        let n = this.peek,
                            s = this.index;
                        for (; n <= 32;) {
                            if (++s >= t) {
                                n = 0;
                                break
                            }
                            n = e.charCodeAt(s)
                        }
                        if (this.peek = n, this.index = s, s >= t) return null;
                        if (mc(n)) return this.scanIdentifier();
                        if (pi(n)) return this.scanNumber(s);
                        const r = s;
                        switch (n) {
                            case 46:
                                return this.advance(), pi(this.peek) ? this.scanNumber(r) : hc(r, this.index, 46);
                            case 40:
                            case Yr:
                            case ci:
                            case ui:
                            case 91:
                            case 93:
                            case ei:
                            case ni:
                            case si:
                                return this.scanCharacter(r, n);
                            case 39:
                            case 34:
                                return this.scanString();
                            case 35:
                            case 43:
                            case 45:
                            case 42:
                            case ti:
                            case 37:
                            case 94:
                                return this.scanOperator(r, String.fromCharCode(n));
                            case 63:
                                return this.scanComplexOperator(r, "?", 46, ".");
                            case ri:
                            case oi:
                                return this.scanComplexOperator(r, String.fromCharCode(n), ii, "=");
                            case 33:
                            case ii:
                                return this.scanComplexOperator(r, String.fromCharCode(n), ii, "=", ii, "=");
                            case 38:
                                return this.scanComplexOperator(r, "&", 38, "&");
                            case 124:
                                return this.scanComplexOperator(r, "|", 124, "|");
                            case 160:
                                for (; hi(this.peek);) this.advance();
                                return this.scanToken()
                        }
                        return this.advance(), this.error(`Unexpected character [${String.fromCharCode(n)}]`, 0)
                    }
                    scanCharacter(e, t) {
                        return this.advance(), hc(e, this.index, t)
                    }
                    scanOperator(e, t) {
                        return this.advance(), pc(e, this.index, t)
                    }
                    scanComplexOperator(e, t, n, s, r, i) {
                        this.advance();
                        let o = t;
                        return this.peek == n && (this.advance(), o += s), null != r && this.peek == r && (this.advance(), o += i), pc(e, this.index, o)
                    }
                    scanIdentifier() {
                        const e = this.index;
                        for (this.advance(); gc(this.peek);) this.advance();
                        const t = this.input.substring(e, this.index);
                        return lc.indexOf(t) > -1 ? (n = e, s = this.index, r = t, new uc(n, s, ac.Keyword, 0, r)) : function(e, t, n) {
                            return new uc(e, t, ac.Identifier, 0, n)
                        }(e, this.index, t);
                        var n, s, r
                    }
                    scanNumber(e) {
                        let t = this.index === e;
                        for (this.advance();;) {
                            if (pi(this.peek));
                            else if (46 == this.peek) t = !1;
                            else {
                                if (101 != (n = this.peek) && 69 != n) break;
                                if (this.advance(), yc(this.peek) && this.advance(), !pi(this.peek)) return this.error("Invalid exponent", -1);
                                t = !1
                            }
                            this.advance()
                        }
                        var n;
                        const s = this.input.substring(e, this.index),
                            r = t ? function(e) {
                                const t = parseInt(e);
                                if (isNaN(t)) throw new Error("Invalid integer literal when parsing " + e);
                                return t
                            }
                        /**
                         * @license
                         * Copyright Google LLC All Rights Reserved.
                         *
                         * Use of this source code is governed by an MIT-style license that can be
                         * found in the LICENSE file at https://angular.io/license
                         */
                        (s): parseFloat(s);
                        return i = e, o = this.index, a = r, new uc(i, o, ac.Number, a, "");
                        var i, o, a
                    }
                    scanString() {
                        const e = this.index,
                            t = this.peek;
                        this.advance();
                        let n = "",
                            s = this.index;
                        const r = this.input;
                        for (; this.peek != t;)
                            if (92 == this.peek) {
                                let e;
                                if (n += r.substring(s, this.index), this.advance(), this.peek = this.peek, 117 == this.peek) {
                                    const t = r.substring(this.index + 1, this.index + 5);
                                    if (!/^[0-9a-f]+$/i.test(t)) return this.error(`Invalid unicode escape [\\u${t}]`, 0);
                                    e = parseInt(t, 16);
                                    for (let e = 0; e < 5; e++) this.advance()
                                } else e = _c(this.peek), this.advance();
                                n += String.fromCharCode(e), s = this.index
                            } else {
                                if (0 == this.peek) return this.error("Unterminated quote", 0);
                                this.advance()
                            }
                        const i = r.substring(s, this.index);
                        return this.advance(), o = e, a = this.index, l = n + i, new uc(o, a, ac.String, 0, l);
                        var o, a, l
                    }
                    error(e, t) {
                        const n = this.index + t;
                        return function(e, t, n) {
                            return new uc(e, t, ac.Error, 0, n)
                        }(n, this.index, `Lexer Error: ${e} at column ${n} in expression [${this.input}]`)
                    }
                }

                function mc(e) {
                    return ai <= e && e <= li || 65 <= e && e <= 90 || 95 == e || 36 == e
                }

                function gc(e) {
                    return di(e) || pi(e) || 95 == e || 36 == e
                }

                function yc(e) {
                    return 45 == e || 43 == e
                }

                function vc(e) {
                    return 39 === e || 34 === e || 96 === e
                }

                function _c(e) {
                    switch (e) {
                        case 110:
                            return Xr;
                        case 102:
                            return 12;
                        case 114:
                            return 13;
                        case 116:
                            return 9;
                        case 118:
                            return 11;
                        default:
                            return e
                    }
                }
                class bc {
                    constructor(e, t, n) {
                        this.strings = e, this.expressions = t, this.offsets = n
                    }
                }
                class wc {
                    constructor(e, t, n) {
                        this.templateBindings = e, this.warnings = t, this.errors = n
                    }
                }
                class Ec {
                    constructor(e) {
                        this._lexer = e, this.errors = [], this.simpleExpressionChecker = Tc
                    }
                    parseAction(e, t, n, s = Fr) {
                        this._checkNoInterpolation(e, t, s);
                        const r = this._stripComments(e),
                            i = this._lexer.tokenize(this._stripComments(e)),
                            o = new xc(e, t, n, i, r.length, !0, this.errors, e.length - r.length).parseChain();
                        return new ro(o, e, t, n, this.errors)
                    }
                    parseBinding(e, t, n, s = Fr) {
                        const r = this._parseBindingAst(e, t, n, s);
                        return new ro(r, e, t, n, this.errors)
                    }
                    checkSimpleExpression(e) {
                        const t = new this.simpleExpressionChecker;
                        return e.visit(t), t.errors
                    }
                    parseSimpleBinding(e, t, n, s = Fr) {
                        const r = this._parseBindingAst(e, t, n, s),
                            i = this.checkSimpleExpression(r);
                        return i.length > 0 && this._reportError(`Host binding expression cannot contain ${i.join(" ")}`, e, t), new ro(r, e, t, n, this.errors)
                    }
                    _reportError(e, t, n, s) {
                        this.errors.push(new ki(e, t, n, s))
                    }
                    _parseBindingAst(e, t, n, s) {
                        const r = this._parseQuote(e, t, n);
                        if (null != r) return r;
                        this._checkNoInterpolation(e, t, s);
                        const i = this._stripComments(e),
                            o = this._lexer.tokenize(i);
                        return new xc(e, t, n, o, i.length, !1, this.errors, e.length - i.length).parseChain()
                    }
                    _parseQuote(e, t, n) {
                        if (null == e) return null;
                        const s = e.indexOf(":");
                        if (-1 == s) return null;
                        const r = e.substring(0, s).trim();
                        if (! function(e) {
                                if (0 == e.length) return !1;
                                const t = new fc(e);
                                if (!mc(t.peek)) return !1;
                                for (t.advance(); 0 !== t.peek;) {
                                    if (!gc(t.peek)) return !1;
                                    t.advance()
                                }
                                return !0
                            }(r)) return null;
                        const i = e.substring(s + 1),
                            o = new Oi(0, e.length);
                        return new Mi(o, o.toAbsolute(n), r, i, t)
                    }
                    parseTemplateBindings(e, t, n, s, r) {
                        const i = this._lexer.tokenize(t);
                        return new xc(t, n, r, i, t.length, !1, this.errors, 0).parseTemplateBindings({
                            source: e,
                            span: new so(s, s + e.length)
                        })
                    }
                    parseInterpolation(e, t, n, s = Fr) {
                        const {
                            strings: r,
                            expressions: i,
                            offsets: o
                        } = this.splitInterpolation(e, t, s);
                        if (0 === i.length) return null;
                        const a = [];
                        for (let l = 0; l < i.length; ++l) {
                            const s = i[l].text,
                                r = this._stripComments(s),
                                c = this._lexer.tokenize(r),
                                u = new xc(e, t, n, c, r.length, !1, this.errors, o[l] + (s.length - r.length)).parseChain();
                            a.push(u)
                        }
                        return this.createInterpolationAst(r.map(e => e.text), a, e, t, n)
                    }
                    parseInterpolationExpression(e, t, n) {
                        const s = this._stripComments(e),
                            r = this._lexer.tokenize(s),
                            i = new xc(e, t, n, r, s.length, !1, this.errors, 0).parseChain();
                        return this.createInterpolationAst(["", ""], [i], e, t, n)
                    }
                    createInterpolationAst(e, t, n, s, r) {
                        const i = new Oi(0, n.length),
                            o = new Qi(i, i.toAbsolute(r), e, t);
                        return new ro(o, n, s, r, this.errors)
                    }
                    splitInterpolation(e, t, n = Fr) {
                        const s = [],
                            r = [],
                            i = [];
                        let o = 0,
                            a = !1,
                            l = !1,
                            {
                                start: c,
                                end: u
                            } = n;
                        for (; o < e.length;)
                            if (a) {
                                const n = o,
                                    s = n + c.length,
                                    h = this._getInterpolationEndIndex(e, u, s);
                                if (-1 === h) {
                                    a = !1, l = !0;
                                    break
                                }
                                const p = h + u.length,
                                    d = e.substring(s, h);
                                d.trim().length > 0 ? r.push({
                                    text: d,
                                    start: n,
                                    end: p
                                }) : (this._reportError("Blank expressions are not allowed in interpolated strings", e, `at column ${o} in`, t), r.push({
                                    text: "$implicit",
                                    start: n,
                                    end: p
                                })), i.push(s), o = p, a = !1
                            } else {
                                const t = o;
                                o = e.indexOf(c, o), -1 === o && (o = e.length);
                                const n = e.substring(t, o);
                                s.push({
                                    text: n,
                                    start: t,
                                    end: o
                                }), a = !0
                            }
                        if (!a)
                            if (l) {
                                const t = s[s.length - 1];
                                t.text += e.substring(o), t.end = e.length
                            } else s.push({
                                text: e.substring(o),
                                start: o,
                                end: e.length
                            });
                        return new bc(s, r, i)
                    }
                    wrapLiteralPrimitive(e, t, n) {
                        const s = new Oi(0, null == e ? 0 : e.length);
                        return new ro(new Wi(s, s.toAbsolute(n), e), e, t, n, this.errors)
                    }
                    _stripComments(e) {
                        const t = this._commentStart(e);
                        return null != t ? e.substring(0, t).trim() : e
                    }
                    _commentStart(e) {
                        let t = null;
                        for (let n = 0; n < e.length - 1; n++) {
                            const s = e.charCodeAt(n),
                                r = e.charCodeAt(n + 1);
                            if (s === ti && r == ti && null == t) return n;
                            t === s ? t = null : null == t && vc(s) && (t = s)
                        }
                        return null
                    }
                    _checkNoInterpolation(e, t, {
                        start: n,
                        end: s
                    }) {
                        let r = -1,
                            i = -1;
                        for (const o of this._forEachUnquotedChar(e, 0))
                            if (-1 === r) e.startsWith(n) && (r = o);
                            else if (i = this._getInterpolationEndIndex(e, s, o), i > -1) break;
                        r > -1 && i > -1 && this._reportError(`Got interpolation (${n}${s}) where expression was expected`, e, `at column ${r} in`, t)
                    }
                    _getInterpolationEndIndex(e, t, n) {
                        for (const s of this._forEachUnquotedChar(e, n)) {
                            if (e.startsWith(t, s)) return s;
                            if (e.startsWith("//", s)) return e.indexOf(t, s)
                        }
                        return -1
                    }* _forEachUnquotedChar(e, t) {
                        let n = null,
                            s = 0;
                        for (let r = t; r < e.length; r++) {
                            const t = e[r];
                            !vc(e.charCodeAt(r)) || null !== n && n !== t || s % 2 != 0 ? null === n && (yield r) : n = null === n ? t : null, s = "\\" === t ? s + 1 : 0
                        }
                    }
                }
                class Cc extends Ec {
                    constructor() {
                        super(...arguments), this.simpleExpressionChecker = Ac
                    }
                }
                var Sc;
                ! function(e) {
                    e[e.None = 0] = "None", e[e.Writable = 1] = "Writable"
                }(Sc || (Sc = {}));
                class xc {
                    constructor(e, t, n, s, r, i, o, a) {
                        this.input = e, this.location = t, this.absoluteOffset = n, this.tokens = s, this.inputLength = r, this.parseAction = i, this.errors = o, this.offset = a, this.rparensExpected = 0, this.rbracketsExpected = 0, this.rbracesExpected = 0, this.context = Sc.None, this.sourceSpanCache = new Map, this.index = 0
                    }
                    peek(e) {
                        const t = this.index + e;
                        return t < this.tokens.length ? this.tokens[t] : dc
                    }
                    get next() {
                        return this.peek(0)
                    }
                    get atEOF() {
                        return this.index >= this.tokens.length
                    }
                    get inputIndex() {
                        return this.atEOF ? this.currentEndIndex : this.next.index + this.offset
                    }
                    get currentEndIndex() {
                        if (this.index > 0) {
                            return this.peek(-1).end + this.offset
                        }
                        return 0 === this.tokens.length ? this.inputLength + this.offset : this.next.index + this.offset
                    }
                    get currentAbsoluteOffset() {
                        return this.absoluteOffset + this.inputIndex
                    }
                    span(e) {
                        return new Oi(e, this.currentEndIndex)
                    }
                    sourceSpan(e) {
                        const t = `${e}@${this.inputIndex}`;
                        return this.sourceSpanCache.has(t) || this.sourceSpanCache.set(t, this.span(e).toAbsolute(this.absoluteOffset)), this.sourceSpanCache.get(t)
                    }
                    advance() {
                        this.index++
                    }
                    withContext(e, t) {
                        this.context |= e;
                        const n = t();
                        return this.context ^= e, n
                    }
                    consumeOptionalCharacter(e) {
                        return !!this.next.isCharacter(e) && (this.advance(), !0)
                    }
                    peekKeywordLet() {
                        return this.next.isKeywordLet()
                    }
                    peekKeywordAs() {
                        return this.next.isKeywordAs()
                    }
                    expectCharacter(e) {
                        this.consumeOptionalCharacter(e) || this.error(`Missing expected ${String.fromCharCode(e)}`)
                    }
                    consumeOptionalOperator(e) {
                        return !!this.next.isOperator(e) && (this.advance(), !0)
                    }
                    expectOperator(e) {
                        this.consumeOptionalOperator(e) || this.error(`Missing expected operator ${e}`)
                    }
                    prettyPrintToken(e) {
                        return e === dc ? "end of input" : `token ${e}`
                    }
                    expectIdentifierOrKeyword() {
                        const e = this.next;
                        return e.isIdentifier() || e.isKeyword() ? (this.advance(), e.toString()) : (this.error(`Unexpected ${this.prettyPrintToken(e)}, expected identifier or keyword`), "")
                    }
                    expectIdentifierOrKeywordOrString() {
                        const e = this.next;
                        return e.isIdentifier() || e.isKeyword() || e.isString() ? (this.advance(), e.toString()) : (this.error(`Unexpected ${this.prettyPrintToken(e)}, expected identifier, keyword, or string`), "")
                    }
                    parseChain() {
                        const e = [],
                            t = this.inputIndex;
                        for (; this.index < this.tokens.length;) {
                            const t = this.parsePipe();
                            if (e.push(t), this.consumeOptionalCharacter(si))
                                for (this.parseAction || this.error("Binding expression cannot contain chained expression"); this.consumeOptionalCharacter(si););
                            else this.index < this.tokens.length && this.error(`Unexpected token '${this.next}'`)
                        }
                        return 0 == e.length ? new Fi(this.span(t), this.sourceSpan(t)) : 1 == e.length ? e[0] : new Li(this.span(t), this.sourceSpan(t), e)
                    }
                    parsePipe() {
                        let e = this.parseExpression();
                        if (this.consumeOptionalOperator("|")) {
                            this.parseAction && this.error("Cannot have a pipe in an action expression");
                            do {
                                const t = this.inputIndex,
                                    n = this.expectIdentifierOrKeyword(),
                                    s = this.sourceSpan(t),
                                    r = [];
                                for (; this.consumeOptionalCharacter(ni);) r.push(this.parseExpression());
                                const {
                                    start: i
                                } = e.span;
                                e = new zi(this.span(i), this.sourceSpan(i), e, n, r, s)
                            } while (this.consumeOptionalOperator("|"))
                        }
                        return e
                    }
                    parseExpression() {
                        return this.parseConditional()
                    }
                    parseConditional() {
                        const e = this.inputIndex,
                            t = this.parseLogicalOr();
                        if (this.consumeOptionalOperator("?")) {
                            const n = this.parsePipe();
                            let s;
                            if (this.consumeOptionalCharacter(ni)) s = this.parsePipe();
                            else {
                                const t = this.inputIndex,
                                    n = this.input.substring(e, t);
                                this.error(`Conditional expression ${n} requires all 3 expressions`), s = new Fi(this.span(e), this.sourceSpan(e))
                            }
                            return new Vi(this.span(e), this.sourceSpan(e), t, n, s)
                        }
                        return t
                    }
                    parseLogicalOr() {
                        let e = this.parseLogicalAnd();
                        for (; this.consumeOptionalOperator("||");) {
                            const t = this.parseLogicalAnd(),
                                {
                                    start: n
                                } = e.span;
                            e = new Zi(this.span(n), this.sourceSpan(n), "||", e, t)
                        }
                        return e
                    }
                    parseLogicalAnd() {
                        let e = this.parseEquality();
                        for (; this.consumeOptionalOperator("&&");) {
                            const t = this.parseEquality(),
                                {
                                    start: n
                                } = e.span;
                            e = new Zi(this.span(n), this.sourceSpan(n), "&&", e, t)
                        }
                        return e
                    }
                    parseEquality() {
                        let e = this.parseRelational();
                        for (; this.next.type == ac.Operator;) {
                            const t = this.next.strValue;
                            switch (t) {
                                case "==":
                                case "===":
                                case "!=":
                                case "!==":
                                    this.advance();
                                    const n = this.parseRelational(),
                                        {
                                            start: s
                                        } = e.span;
                                    e = new Zi(this.span(s), this.sourceSpan(s), t, e, n);
                                    continue
                            }
                            break
                        }
                        return e
                    }
                    parseRelational() {
                        let e = this.parseAdditive();
                        for (; this.next.type == ac.Operator;) {
                            const t = this.next.strValue;
                            switch (t) {
                                case "<":
                                case ">":
                                case "<=":
                                case ">=":
                                    this.advance();
                                    const n = this.parseAdditive(),
                                        {
                                            start: s
                                        } = e.span;
                                    e = new Zi(this.span(s), this.sourceSpan(s), t, e, n);
                                    continue
                            }
                            break
                        }
                        return e
                    }
                    parseAdditive() {
                        let e = this.parseMultiplicative();
                        for (; this.next.type == ac.Operator;) {
                            const t = this.next.strValue;
                            switch (t) {
                                case "+":
                                case "-":
                                    this.advance();
                                    let n = this.parseMultiplicative();
                                    const {
                                        start: s
                                    } = e.span;
                                    e = new Zi(this.span(s), this.sourceSpan(s), t, e, n);
                                    continue
                            }
                            break
                        }
                        return e
                    }
                    parseMultiplicative() {
                        let e = this.parsePrefix();
                        for (; this.next.type == ac.Operator;) {
                            const t = this.next.strValue;
                            switch (t) {
                                case "*":
                                case "%":
                                case "/":
                                    this.advance();
                                    let n = this.parsePrefix();
                                    const {
                                        start: s
                                    } = e.span;
                                    e = new Zi(this.span(s), this.sourceSpan(s), t, e, n);
                                    continue
                            }
                            break
                        }
                        return e
                    }
                    parsePrefix() {
                        if (this.next.type == ac.Operator) {
                            const e = this.inputIndex;
                            let t;
                            switch (this.next.strValue) {
                                case "+":
                                    return this.advance(), t = this.parsePrefix(), Ji.createPlus(this.span(e), this.sourceSpan(e), t);
                                case "-":
                                    return this.advance(), t = this.parsePrefix(), Ji.createMinus(this.span(e), this.sourceSpan(e), t);
                                case "!":
                                    return this.advance(), t = this.parsePrefix(), new Xi(this.span(e), this.sourceSpan(e), t)
                            }
                        }
                        return this.parseCallChain()
                    }
                    parseCallChain() {
                        let e = this.parsePrimary();
                        const t = e.span.start;
                        for (;;)
                            if (this.consumeOptionalCharacter(46)) e = this.parseAccessMemberOrMethodCall(e, !1);
                            else if (this.consumeOptionalOperator("?.")) e = this.parseAccessMemberOrMethodCall(e, !0);
                        else if (this.consumeOptionalCharacter(91)) this.withContext(Sc.Writable, () => {
                            this.rbracketsExpected++;
                            const n = this.parsePipe();
                            if (n instanceof Fi && this.error("Key access cannot be empty"), this.rbracketsExpected--, this.expectCharacter(93), this.consumeOptionalOperator("=")) {
                                const s = this.parseConditional();
                                e = new qi(this.span(t), this.sourceSpan(t), e, n, s)
                            } else e = new Ui(this.span(t), this.sourceSpan(t), e, n)
                        });
                        else if (this.consumeOptionalCharacter(40)) {
                            this.rparensExpected++;
                            const n = this.parseCallArguments();
                            this.rparensExpected--, this.expectCharacter(Yr), e = new no(this.span(t), this.sourceSpan(t), e, n)
                        } else {
                            if (!this.consumeOptionalOperator("!")) return e;
                            e = new Yi(this.span(t), this.sourceSpan(t), e)
                        }
                    }
                    parsePrimary() {
                        const e = this.inputIndex;
                        if (this.consumeOptionalCharacter(40)) {
                            this.rparensExpected++;
                            const e = this.parsePipe();
                            return this.rparensExpected--, this.expectCharacter(Yr), e
                        }
                        if (this.next.isKeywordNull()) return this.advance(), new Wi(this.span(e), this.sourceSpan(e), null);
                        if (this.next.isKeywordUndefined()) return this.advance(), new Wi(this.span(e), this.sourceSpan(e), void 0);
                        if (this.next.isKeywordTrue()) return this.advance(), new Wi(this.span(e), this.sourceSpan(e), !0);
                        if (this.next.isKeywordFalse()) return this.advance(), new Wi(this.span(e), this.sourceSpan(e), !1);
                        if (this.next.isKeywordThis()) return this.advance(), new ji(this.span(e), this.sourceSpan(e));
                        if (this.consumeOptionalCharacter(91)) {
                            this.rbracketsExpected++;
                            const t = this.parseExpressionList(93);
                            return this.rbracketsExpected--, this.expectCharacter(93), new Gi(this.span(e), this.sourceSpan(e), t)
                        }
                        if (this.next.isCharacter(ci)) return this.parseLiteralMap();
                        if (this.next.isIdentifier()) return this.parseAccessMemberOrMethodCall(new Ri(this.span(e), this.sourceSpan(e)), !1);
                        if (this.next.isNumber()) {
                            const t = this.next.toNumber();
                            return this.advance(), new Wi(this.span(e), this.sourceSpan(e), t)
                        }
                        if (this.next.isString()) {
                            const t = this.next.toString();
                            return this.advance(), new Wi(this.span(e), this.sourceSpan(e), t)
                        }
                        return this.index >= this.tokens.length ? (this.error(`Unexpected end of expression: ${this.input}`), new Fi(this.span(e), this.sourceSpan(e))) : (this.error(`Unexpected token ${this.next}`), new Fi(this.span(e), this.sourceSpan(e)))
                    }
                    parseExpressionList(e) {
                        const t = [];
                        if (!this.next.isCharacter(e))
                            do {
                                t.push(this.parsePipe())
                            } while (this.consumeOptionalCharacter(ei));
                        return t
                    }
                    parseLiteralMap() {
                        const e = [],
                            t = [],
                            n = this.inputIndex;
                        if (this.expectCharacter(ci), !this.consumeOptionalCharacter(ui)) {
                            this.rbracesExpected++;
                            do {
                                const n = this.next.isString(),
                                    s = this.expectIdentifierOrKeywordOrString();
                                e.push({
                                    key: s,
                                    quoted: n
                                }), this.expectCharacter(ni), t.push(this.parsePipe())
                            } while (this.consumeOptionalCharacter(ei));
                            this.rbracesExpected--, this.expectCharacter(ui)
                        }
                        return new Ki(this.span(n), this.sourceSpan(n), e, t)
                    }
                    parseAccessMemberOrMethodCall(e, t = !1) {
                        const n = e.span.start,
                            s = this.inputIndex,
                            r = this.expectIdentifierOrKeyword(),
                            i = this.sourceSpan(s);
                        if (this.consumeOptionalCharacter(40)) {
                            this.rparensExpected++;
                            const s = this.parseCallArguments();
                            this.expectCharacter(Yr), this.rparensExpected--;
                            const o = this.span(n),
                                a = this.sourceSpan(n);
                            return t ? new to(o, a, i, e, r, s) : new eo(o, a, i, e, r, s)
                        }
                        if (t) return this.consumeOptionalOperator("=") ? (this.error("The '?.' operator cannot be used in the assignment"), new Fi(this.span(n), this.sourceSpan(n))) : new Hi(this.span(n), this.sourceSpan(n), i, e, r);
                        if (this.consumeOptionalOperator("=")) {
                            if (!this.parseAction) return this.error("Bindings cannot contain assignments"), new Fi(this.span(n), this.sourceSpan(n));
                            const t = this.parseConditional();
                            return new Bi(this.span(n), this.sourceSpan(n), i, e, r, t)
                        }
                        return new $i(this.span(n), this.sourceSpan(n), i, e, r)
                    }
                    parseCallArguments() {
                        if (this.next.isCharacter(Yr)) return [];
                        const e = [];
                        do {
                            e.push(this.parsePipe())
                        } while (this.consumeOptionalCharacter(ei));
                        return e
                    }
                    expectTemplateBindingKey() {
                        let e = "",
                            t = !1;
                        const n = this.currentAbsoluteOffset;
                        do {
                            e += this.expectIdentifierOrKeywordOrString(), t = this.consumeOptionalOperator("-"), t && (e += "-")
                        } while (t);
                        return {
                            source: e,
                            span: new so(n, n + e.length)
                        }
                    }
                    parseTemplateBindings(e) {
                        const t = [];
                        for (t.push(...this.parseDirectiveKeywordBindings(e)); this.index < this.tokens.length;) {
                            const n = this.parseLetBinding();
                            if (n) t.push(n);
                            else {
                                const n = this.expectTemplateBindingKey(),
                                    s = this.parseAsBinding(n);
                                s ? t.push(s) : (n.source = e.source + n.source.charAt(0).toUpperCase() + n.source.substring(1), t.push(...this.parseDirectiveKeywordBindings(n)))
                            }
                            this.consumeStatementTerminator()
                        }
                        return new wc(t, [], this.errors)
                    }
                    parseDirectiveKeywordBindings(e) {
                        const t = [];
                        this.consumeOptionalCharacter(ni);
                        const n = this.getDirectiveBoundTarget();
                        let s = this.currentAbsoluteOffset;
                        const r = this.parseAsBinding(e);
                        r || (this.consumeStatementTerminator(), s = this.currentAbsoluteOffset);
                        const i = new so(e.span.start, s);
                        return t.push(new oo(i, e, n)), r && t.push(r), t
                    }
                    getDirectiveBoundTarget() {
                        if (this.next === dc || this.peekKeywordAs() || this.peekKeywordLet()) return null;
                        const e = this.parsePipe(),
                            {
                                start: t,
                                end: n
                            } = e.span,
                            s = this.input.substring(t, n);
                        return new ro(e, s, this.location, this.absoluteOffset + t, this.errors)
                    }
                    parseAsBinding(e) {
                        if (!this.peekKeywordAs()) return null;
                        this.advance();
                        const t = this.expectTemplateBindingKey();
                        this.consumeStatementTerminator();
                        const n = new so(e.span.start, this.currentAbsoluteOffset);
                        return new io(n, t, e)
                    }
                    parseLetBinding() {
                        if (!this.peekKeywordLet()) return null;
                        const e = this.currentAbsoluteOffset;
                        this.advance();
                        const t = this.expectTemplateBindingKey();
                        let n = null;
                        this.consumeOptionalOperator("=") && (n = this.expectTemplateBindingKey()), this.consumeStatementTerminator();
                        const s = new so(e, this.currentAbsoluteOffset);
                        return new io(s, t, n)
                    }
                    consumeStatementTerminator() {
                        this.consumeOptionalCharacter(si) || this.consumeOptionalCharacter(ei)
                    }
                    error(e, t = null) {
                        this.errors.push(new ki(e, this.input, this.locationText(t), this.location)), this.skip()
                    }
                    locationText(e = null) {
                        return null == e && (e = this.index), e < this.tokens.length ? `at column ${this.tokens[e].index+1} in` : "at the end of the expression"
                    }
                    skip() {
                        let e = this.next;
                        for (; !(!(this.index < this.tokens.length) || e.isCharacter(si) || !(this.rparensExpected <= 0) && e.isCharacter(Yr) || !(this.rbracesExpected <= 0) && e.isCharacter(ui) || !(this.rbracketsExpected <= 0) && e.isCharacter(93) || this.context & Sc.Writable && e.isOperator("="));) this.next.isError() && this.errors.push(new ki(this.next.toString(), this.input, this.locationText(), this.location)), this.advance(), e = this.next
                    }
                }
                class Tc {
                    constructor() {
                        this.errors = []
                    }
                    visitImplicitReceiver(e, t) {}
                    visitThisReceiver(e, t) {}
                    visitInterpolation(e, t) {}
                    visitLiteralPrimitive(e, t) {}
                    visitPropertyRead(e, t) {}
                    visitPropertyWrite(e, t) {}
                    visitSafePropertyRead(e, t) {}
                    visitMethodCall(e, t) {}
                    visitSafeMethodCall(e, t) {}
                    visitFunctionCall(e, t) {}
                    visitLiteralArray(e, t) {
                        this.visitAll(e.expressions, t)
                    }
                    visitLiteralMap(e, t) {
                        this.visitAll(e.values, t)
                    }
                    visitUnary(e, t) {}
                    visitBinary(e, t) {}
                    visitPrefixNot(e, t) {}
                    visitNonNullAssert(e, t) {}
                    visitConditional(e, t) {}
                    visitPipe(e, t) {
                        this.errors.push("pipes")
                    }
                    visitKeyedRead(e, t) {}
                    visitKeyedWrite(e, t) {}
                    visitAll(e, t) {
                        return e.map(e => e.visit(this, t))
                    }
                    visitChain(e, t) {}
                    visitQuote(e, t) {}
                }
                class Ac extends ao {
                    constructor() {
                        super(...arguments), this.errors = []
                    }
                    visitPipe() {
                        this.errors.push("pipes")
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                let Dc;

                function Pc() {
                    return Dc || (Dc = {}, kc(z.HTML, ["iframe|srcdoc", "*|innerHTML", "*|outerHTML"]), kc(z.STYLE, ["*|style"]), kc(z.URL, ["*|formAction", "area|href", "area|ping", "audio|src", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "form|action", "img|src", "img|srcset", "input|src", "ins|cite", "q|cite", "source|src", "source|srcset", "track|src", "video|poster", "video|src"]), kc(z.RESOURCE_URL, ["applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src"])), Dc
                }

                function kc(e, t) {
                    for (const n of t) Dc[n.toLowerCase()] = e
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Oc {}
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Ic = ["[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored", "[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate", "abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate", "media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,src,%srcObject,#volume", ":svg:^[HTMLElement]|*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex", ":svg:graphics^:svg:|", ":svg:animation^:svg:|*begin,*end,*repeat", ":svg:geometry^:svg:|", ":svg:componentTransferFunction^:svg:|", ":svg:gradient^:svg:|", ":svg:textContent^:svg:graphics|", ":svg:textPositioning^:svg:textContent|", "a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username", "area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,search,shape,target,username", "audio^media|", "br^[HTMLElement]|clear", "base^[HTMLElement]|href,target", "body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink", "button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value", "canvas^[HTMLElement]|#height,#width", "content^[HTMLElement]|select", "dl^[HTMLElement]|!compact", "datalist^[HTMLElement]|", "details^[HTMLElement]|!open", "dialog^[HTMLElement]|!open,returnValue", "dir^[HTMLElement]|!compact", "div^[HTMLElement]|align", "embed^[HTMLElement]|align,height,name,src,type,width", "fieldset^[HTMLElement]|!disabled,name", "font^[HTMLElement]|color,face,size", "form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target", "frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src", "frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows", "hr^[HTMLElement]|align,color,!noShade,size,width", "head^[HTMLElement]|", "h1,h2,h3,h4,h5,h6^[HTMLElement]|align", "html^[HTMLElement]|version", "iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width", "img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width", "input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width", "li^[HTMLElement]|type,#value", "label^[HTMLElement]|htmlFor", "legend^[HTMLElement]|align", "link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type", "map^[HTMLElement]|name", "marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width", "menu^[HTMLElement]|!compact", "meta^[HTMLElement]|content,httpEquiv,name,scheme", "meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value", "ins,del^[HTMLElement]|cite,dateTime", "ol^[HTMLElement]|!compact,!reversed,#start,type", "object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width", "optgroup^[HTMLElement]|!disabled,label", "option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value", "output^[HTMLElement]|defaultValue,%htmlFor,name,value", "p^[HTMLElement]|align", "param^[HTMLElement]|name,type,value,valueType", "picture^[HTMLElement]|", "pre^[HTMLElement]|#width", "progress^[HTMLElement]|#max,#value", "q,blockquote,cite^[HTMLElement]|", "script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type", "select^[HTMLElement]|!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value", "shadow^[HTMLElement]|", "slot^[HTMLElement]|name", "source^[HTMLElement]|media,sizes,src,srcset,type", "span^[HTMLElement]|", "style^[HTMLElement]|!disabled,media,type", "caption^[HTMLElement]|align", "th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width", "col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width", "table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width", "tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign", "tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign", "template^[HTMLElement]|", "textarea^[HTMLElement]|autocapitalize,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap", "title^[HTMLElement]|text", "track^[HTMLElement]|!default,kind,label,src,srclang", "ul^[HTMLElement]|!compact,type", "unknown^[HTMLElement]|", "video^media|#height,poster,#width", ":svg:a^:svg:graphics|", ":svg:animate^:svg:animation|", ":svg:animateMotion^:svg:animation|", ":svg:animateTransform^:svg:animation|", ":svg:circle^:svg:geometry|", ":svg:clipPath^:svg:graphics|", ":svg:defs^:svg:graphics|", ":svg:desc^:svg:|", ":svg:discard^:svg:|", ":svg:ellipse^:svg:geometry|", ":svg:feBlend^:svg:|", ":svg:feColorMatrix^:svg:|", ":svg:feComponentTransfer^:svg:|", ":svg:feComposite^:svg:|", ":svg:feConvolveMatrix^:svg:|", ":svg:feDiffuseLighting^:svg:|", ":svg:feDisplacementMap^:svg:|", ":svg:feDistantLight^:svg:|", ":svg:feDropShadow^:svg:|", ":svg:feFlood^:svg:|", ":svg:feFuncA^:svg:componentTransferFunction|", ":svg:feFuncB^:svg:componentTransferFunction|", ":svg:feFuncG^:svg:componentTransferFunction|", ":svg:feFuncR^:svg:componentTransferFunction|", ":svg:feGaussianBlur^:svg:|", ":svg:feImage^:svg:|", ":svg:feMerge^:svg:|", ":svg:feMergeNode^:svg:|", ":svg:feMorphology^:svg:|", ":svg:feOffset^:svg:|", ":svg:fePointLight^:svg:|", ":svg:feSpecularLighting^:svg:|", ":svg:feSpotLight^:svg:|", ":svg:feTile^:svg:|", ":svg:feTurbulence^:svg:|", ":svg:filter^:svg:|", ":svg:foreignObject^:svg:graphics|", ":svg:g^:svg:graphics|", ":svg:image^:svg:graphics|", ":svg:line^:svg:geometry|", ":svg:linearGradient^:svg:gradient|", ":svg:mpath^:svg:|", ":svg:marker^:svg:|", ":svg:mask^:svg:|", ":svg:metadata^:svg:|", ":svg:path^:svg:geometry|", ":svg:pattern^:svg:|", ":svg:polygon^:svg:geometry|", ":svg:polyline^:svg:geometry|", ":svg:radialGradient^:svg:gradient|", ":svg:rect^:svg:geometry|", ":svg:svg^:svg:graphics|#currentScale,#zoomAndPan", ":svg:script^:svg:|type", ":svg:set^:svg:animation|", ":svg:stop^:svg:|", ":svg:style^:svg:|!disabled,media,title,type", ":svg:switch^:svg:graphics|", ":svg:symbol^:svg:|", ":svg:tspan^:svg:textPositioning|", ":svg:text^:svg:textPositioning|", ":svg:textPath^:svg:textContent|", ":svg:title^:svg:|", ":svg:use^:svg:graphics|", ":svg:view^:svg:|#zoomAndPan", "data^[HTMLElement]|value", "keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name", "menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default", "summary^[HTMLElement]|", "time^[HTMLElement]|dateTime", ":svg:cursor^:svg:|"],
                    Nc = {
                        class: "className",
                        for: "htmlFor",
                        formaction: "formAction",
                        innerHtml: "innerHTML",
                        readonly: "readOnly",
                        tabindex: "tabIndex"
                    };
                class Mc extends Oc {
                    constructor() {
                        super(), this._schema = {}, Ic.forEach(e => {
                            const t = {},
                                [n, s] = e.split("|"),
                                r = s.split(","),
                                [i, o] = n.split("^");
                            i.split(",").forEach(e => this._schema[e.toLowerCase()] = t);
                            const a = o && this._schema[o.toLowerCase()];
                            a && Object.keys(a).forEach(e => {
                                t[e] = a[e]
                            }), r.forEach(e => {
                                if (e.length > 0) switch (e[0]) {
                                    case "*":
                                        break;
                                    case "!":
                                        t[e.substring(1)] = "boolean";
                                        break;
                                    case "#":
                                        t[e.substring(1)] = "number";
                                        break;
                                    case "%":
                                        t[e.substring(1)] = "object";
                                        break;
                                    default:
                                        t[e] = "string"
                                }
                            })
                        })
                    }
                    hasProperty(e, t, n) {
                        if (n.some(e => e.name === V.name)) return !0;
                        if (e.indexOf("-") > -1) {
                            if (i(e) || o(e)) return !1;
                            if (n.some(e => e.name === L.name)) return !0
                        }
                        return !!(this._schema[e.toLowerCase()] || this._schema.unknown)[t]
                    }
                    hasElement(e, t) {
                        if (t.some(e => e.name === V.name)) return !0;
                        if (e.indexOf("-") > -1) {
                            if (i(e) || o(e)) return !0;
                            if (t.some(e => e.name === L.name)) return !0
                        }
                        return !!this._schema[e.toLowerCase()]
                    }
                    securityContext(e, t, n) {
                        n && (t = this.getMappedPropName(t)), e = e.toLowerCase(), t = t.toLowerCase();
                        let s = Pc()[e + "|" + t];
                        return s || (s = Pc()["*|" + t], s || z.NONE)
                    }
                    getMappedPropName(e) {
                        return Nc[e] || e
                    }
                    getDefaultComponentElementName() {
                        return "ng-component"
                    }
                    validateProperty(e) {
                        if (e.toLowerCase().startsWith("on")) {
                            return {
                                error: !0,
                                msg: `Binding to event property '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...\nIf '${e}' is a directive input, make sure the directive is imported by the current module.`
                            }
                        }
                        return {
                            error: !1
                        }
                    }
                    validateAttribute(e) {
                        if (e.toLowerCase().startsWith("on")) {
                            return {
                                error: !0,
                                msg: `Binding to event attribute '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...`
                            }
                        }
                        return {
                            error: !1
                        }
                    }
                    allKnownElementNames() {
                        return Object.keys(this._schema)
                    }
                    normalizeAnimationStyleProperty(e) {
                        return e.replace(kt, (...e) => e[1].toUpperCase())
                    }
                    normalizeAnimationStyleValue(e, t, n) {
                        let s = "";
                        const r = n.toString().trim();
                        let i = null;
                        if (function(e) {
                                switch (e) {
                                    case "width":
                                    case "height":
                                    case "minWidth":
                                    case "minHeight":
                                    case "maxWidth":
                                    case "maxHeight":
                                    case "left":
                                    case "top":
                                    case "bottom":
                                    case "right":
                                    case "fontSize":
                                    case "outlineWidth":
                                    case "outlineOffset":
                                    case "paddingTop":
                                    case "paddingLeft":
                                    case "paddingBottom":
                                    case "paddingRight":
                                    case "marginTop":
                                    case "marginLeft":
                                    case "marginBottom":
                                    case "marginRight":
                                    case "borderRadius":
                                    case "borderWidth":
                                    case "borderTopWidth":
                                    case "borderLeftWidth":
                                    case "borderRightWidth":
                                    case "borderBottomWidth":
                                    case "textIndent":
                                        return !0;
                                    default:
                                        return !1
                                }
                            }
                            /**
                             * @license
                             * Copyright Google LLC All Rights Reserved.
                             *
                             * Use of this source code is governed by an MIT-style license that can be
                             * found in the LICENSE file at https://angular.io/license
                             */
                            (e) && 0 !== n && "0" !== n)
                            if ("number" == typeof n) s = "px";
                            else {
                                const e = n.match(/^[+-]?[\d\.]+([a-z]*)$/);
                                e && 0 == e[1].length && (i = `Please provide a CSS unit value for ${t}:${n}`)
                            }
                        return {
                            error: i,
                            value: r + s
                        }
                    }
                }
                const Fc = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/;

                function Rc(e, t) {
                    const n = new jc(t);
                    return {
                        nodes: ya(n, e),
                        errors: t.errors.concat(n.errors),
                        styleUrls: n.styleUrls,
                        styles: n.styles,
                        ngContentSelectors: n.ngContentSelectors
                    }
                }
                class jc {
                    constructor(e) {
                        this.bindingParser = e, this.errors = [], this.styles = [], this.styleUrls = [], this.ngContentSelectors = [], this.inI18nBlock = !1
                    }
                    visitElement(e) {
                        const t = Zs(e.i18n);
                        t && (this.inI18nBlock && this.reportError("Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.", e.sourceSpan), this.inI18nBlock = !0);
                        const n = jl(e);
                        if (n.type === Ll.SCRIPT) return null;
                        if (n.type === Ll.STYLE) {
                            const t = 1 === (s = e).children.length && s.children[0] instanceof ha ? s.children[0].value : null;
                            return null !== t && this.styles.push(t), null
                        }
                        if (n.type === Ll.STYLESHEET && Al(n.hrefAttr)) return this.styleUrls.push(n.hrefAttr), null;
                        var s;
                        /**
                         * @license
                         * Copyright Google LLC All Rights Reserved.
                         *
                         * Use of this source code is governed by an MIT-style license that can be
                         * found in the LICENSE file at https://angular.io/license
                         */
                        const r = a(e.name),
                            i = [],
                            o = [],
                            l = [],
                            c = [],
                            u = [],
                            h = {},
                            p = [],
                            d = [];
                        let f = !1;
                        for (const a of e.attrs) {
                            let e = !1;
                            const t = Vc(a.name);
                            let n = !1;
                            if (a.i18n && (h[a.name] = a.i18n), t.startsWith("*")) {
                                f && this.reportError("Can't have multiple template bindings on one element. Use only one attribute prefixed with *", a.sourceSpan), n = !0, f = !0;
                                const e = a.value,
                                    s = t.substring("*".length),
                                    r = [],
                                    i = a.valueSpan ? a.valueSpan.start.offset : a.sourceSpan.start.offset + a.name.length;
                                this.bindingParser.parseInlineTemplateBinding(s, e, a.sourceSpan, i, [], p, r, !0), d.push(...r.map(e => new Zn(e.name, e.value, e.sourceSpan, e.keySpan, e.valueSpan)))
                            } else e = this.parseAttribute(r, a, [], i, o, l, c);
                            e || n || u.push(this.visitAttribute(a))
                        }
                        const m = ya(n.nonBindable ? Lc : this, e.children);
                        let g;
                        if (n.type === Ll.NG_CONTENT) {
                            e.children && !e.children.every(e => function(e) {
                                return e instanceof ha && 0 == e.value.trim().length
                            }(e) || function(e) {
                                return e instanceof ga
                            }(e)) && this.reportError("<ng-content> element cannot have content.", e.sourceSpan);
                            const t = n.selectAttr,
                                s = e.attrs.map(e => this.visitAttribute(e));
                            g = new Qn(t, s, e.sourceSpan, e.i18n), this.ngContentSelectors.push(t)
                        } else if (r) {
                            const t = this.extractAttributes(e.name, i, h);
                            g = new Kn(e.name, u, t.bound, o, [], m, c, l, e.sourceSpan, e.startSourceSpan, e.endSourceSpan, e.i18n)
                        } else {
                            const t = this.extractAttributes(e.name, i, h);
                            g = new Gn(e.name, u, t.bound, o, m, c, e.sourceSpan, e.startSourceSpan, e.endSourceSpan, e.i18n)
                        }
                        if (f) {
                            const n = this.extractAttributes("ng-template", p, h),
                                s = [];
                            n.literal.forEach(e => s.push(e)), n.bound.forEach(e => s.push(e));
                            const i = g instanceof Gn ? {
                                    attributes: g.attributes,
                                    inputs: g.inputs,
                                    outputs: g.outputs
                                } : {
                                    attributes: [],
                                    inputs: [],
                                    outputs: []
                                },
                                o = r && t ? void 0 : e.i18n;
                            g = new Kn(g.name, i.attributes, i.inputs, i.outputs, s, [g], [], d, e.sourceSpan, e.startSourceSpan, e.endSourceSpan, o)
                        }
                        return t && (this.inI18nBlock = !1), g
                    }
                    visitAttribute(e) {
                        return new qn(e.name, e.value, e.sourceSpan, e.valueSpan, e.i18n)
                    }
                    visitText(e) {
                        return this._visitTextWithInterpolation(e.value, e.sourceSpan, e.i18n)
                    }
                    visitExpansion(e) {
                        if (!e.i18n) return null;
                        if (!Zs(e.i18n)) throw new Error(`Invalid type "${e.i18n.constructor}" for "i18n" property of ${e.sourceSpan.toString()}. Expected a "Message"`);
                        const t = e.i18n,
                            n = {},
                            s = {};
                        return Object.keys(t.placeholders).forEach(e => {
                            const r = t.placeholders[e];
                            if (e.startsWith("VAR_")) {
                                const t = e.trim(),
                                    s = this.bindingParser.parseInterpolationExpression(r.text, r.sourceSpan);
                                n[t] = new Un(s, r.sourceSpan)
                            } else s[e] = this._visitTextWithInterpolation(r.text, r.sourceSpan)
                        }), new Xn(n, s, e.sourceSpan, t)
                    }
                    visitExpansionCase(e) {
                        return null
                    }
                    visitComment(e) {
                        return null
                    }
                    extractAttributes(e, t, n) {
                        const s = [],
                            r = [];
                        return t.forEach(t => {
                            const i = n[t.name];
                            if (t.isLiteral) r.push(new qn(t.name, t.expression.source || "", t.sourceSpan, void 0, i));
                            else {
                                const n = this.bindingParser.createBoundElementProperty(e, t, !0, !1);
                                s.push(zn.fromBoundElementProperty(n, i))
                            }
                        }), {
                            bound: s,
                            literal: r
                        }
                    }
                    parseAttribute(e, t, n, s, r, i, o) {
                        const a = Vc(t.name),
                            l = t.value,
                            c = t.sourceSpan,
                            u = t.valueSpan ? t.valueSpan.start.offset : c.start.offset;

                        function h(e, n, s) {
                            const r = t.name.length - a.length,
                                i = e.start.moveBy(n.length + r),
                                o = i.moveBy(s.length);
                            return new vi(i, o, i, s)
                        }
                        const p = a.match(Fc);
                        let d = !1;
                        if (p) {
                            if (d = !0, null != p[1]) {
                                const e = p[7],
                                    r = h(c, p[1], e);
                                this.bindingParser.parsePropertyBinding(e, l, !1, c, u, t.valueSpan, n, s, r)
                            } else if (p[2])
                                if (e) {
                                    const e = p[7],
                                        n = h(c, p[2], e);
                                    this.parseVariable(e, l, c, n, t.valueSpan, i)
                                } else this.reportError('"let-" is only supported on ng-template elements.', c);
                            else if (p[3]) {
                                const e = p[7];
                                this.parseReference(e, l, c, t.valueSpan, o)
                            } else if (p[4]) {
                                const e = [],
                                    s = p[7];
                                this.bindingParser.parseEvent(s, l, c, t.valueSpan || c, n, e), $c(e, r)
                            } else if (p[5]) {
                                const e = p[7],
                                    i = h(c, p[5], e);
                                this.bindingParser.parsePropertyBinding(e, l, !1, c, u, t.valueSpan, n, s, i), this.parseAssignmentEvent(e, l, c, t.valueSpan, n, r)
                            } else if (p[6]) {
                                const e = h(c, "", a);
                                this.bindingParser.parseLiteralAttr(a, l, c, u, t.valueSpan, n, s, e)
                            } else if (p[8]) {
                                const e = h(c, "[(", p[8]);
                                this.bindingParser.parsePropertyBinding(p[8], l, !1, c, u, t.valueSpan, n, s, e), this.parseAssignmentEvent(p[8], l, c, t.valueSpan, n, r)
                            } else if (p[9]) {
                                const e = h(c, "[", p[9]);
                                this.bindingParser.parsePropertyBinding(p[9], l, !1, c, u, t.valueSpan, n, s, e)
                            } else if (p[10]) {
                                const e = [];
                                this.bindingParser.parseEvent(p[10], l, c, t.valueSpan || c, n, e), $c(e, r)
                            }
                        } else {
                            const e = h(c, "", a);
                            d = this.bindingParser.parsePropertyInterpolation(a, l, c, t.valueSpan, n, s, e)
                        }
                        return d
                    }
                    _visitTextWithInterpolation(e, t, n) {
                        const s = Ka(e),
                            r = this.bindingParser.parseInterpolation(s, t);
                        return r ? new Un(r, t, n) : new Hn(s, t)
                    }
                    parseVariable(e, t, n, s, r, i) {
                        e.indexOf("-") > -1 ? this.reportError('"-" is not allowed in variable names', n) : 0 === e.length && this.reportError("Variable does not have a name", n), i.push(new Zn(e, t, n, s, r))
                    }
                    parseReference(e, t, n, s, r) {
                        e.indexOf("-") > -1 ? this.reportError('"-" is not allowed in reference names', n) : 0 === e.length && this.reportError("Reference does not have a name", n), r.push(new Jn(e, t, n, s))
                    }
                    parseAssignmentEvent(e, t, n, s, r, i) {
                        const o = [];
                        this.bindingParser.parseEvent(`${e}Change`, `${t}=$event`, n, s || n, r, o), $c(o, i)
                    }
                    reportError(e, t, n = _i.ERROR) {
                        this.errors.push(new Ci(t, e, n))
                    }
                }
                const Lc = new class {
                    visitElement(e) {
                        const t = jl(e);
                        if (t.type === Ll.SCRIPT || t.type === Ll.STYLE || t.type === Ll.STYLESHEET) return null;
                        const n = ya(this, e.children, null);
                        return new Gn(e.name, ya(this, e.attrs), [], [], n, [], e.sourceSpan, e.startSourceSpan, e.endSourceSpan)
                    }
                    visitComment(e) {
                        return null
                    }
                    visitAttribute(e) {
                        return new qn(e.name, e.value, e.sourceSpan, void 0, e.i18n)
                    }
                    visitText(e) {
                        return new Hn(e.value, e.sourceSpan)
                    }
                    visitExpansion(e) {
                        return null
                    }
                    visitExpansionCase(e) {
                        return null
                    }
                };

                function Vc(e) {
                    return /^data-/i.test(e) ? e.substring(5) : e
                }

                function $c(e, t) {
                    t.push(...e.map(e => Wn.fromParsedEvent(e)))
                }
                var Bc;
                ! function(e) {
                    e[e.ELEMENT = 0] = "ELEMENT", e[e.TEMPLATE = 1] = "TEMPLATE"
                }(Bc || (Bc = {}));
                class Hc {
                    constructor(e, t, n = 0, s = null, r, i) {
                        this.index = e, this.ref = t, this.level = n, this.templateIndex = s, this.meta = r, this.registry = i, this.bindings = new Set, this.placeholders = new Map, this.isEmitted = !1, this._unresolvedCtxCount = 0, this._registry = i || {
                            getUniqueId: tr(),
                            icus: new Map
                        }, this.id = this._registry.getUniqueId()
                    }
                    appendTag(e, t, n, s) {
                        if (t.isVoid && s) return;
                        const r = t.isVoid || !s ? t.startName : t.closeName,
                            i = {
                                type: e,
                                index: n,
                                ctx: this.id,
                                isVoid: t.isVoid,
                                closed: s
                            };
                        sr(this.placeholders, r, i)
                    }
                    get icus() {
                        return this._registry.icus
                    }
                    get isRoot() {
                        return 0 === this.level
                    }
                    get isResolved() {
                        return 0 === this._unresolvedCtxCount
                    }
                    getSerializedPlaceholders() {
                        const e = new Map;
                        return this.placeholders.forEach((t, n) => e.set(n, t.map(Wc))), e
                    }
                    appendBinding(e) {
                        this.bindings.add(e)
                    }
                    appendIcu(e, t) {
                        sr(this._registry.icus, e, t)
                    }
                    appendBoundText(e) {
                        rr(e, this.bindings.size, this.id).forEach((e, t) => sr(this.placeholders, t, ...e))
                    }
                    appendTemplate(e, t) {
                        this.appendTag(Bc.TEMPLATE, e, t, !1), this.appendTag(Bc.TEMPLATE, e, t, !0), this._unresolvedCtxCount++
                    }
                    appendElement(e, t, n) {
                        this.appendTag(Bc.ELEMENT, e, t, n)
                    }
                    appendProjection(e, t) {
                        this.appendTag(Bc.ELEMENT, e, t, !1), this.appendTag(Bc.ELEMENT, e, t, !0)
                    }
                    forkChildContext(e, t, n) {
                        return new Hc(e, this.ref, this.level + 1, t, n, this._registry)
                    }
                    reconcileChildContext(e) {
                        ["start", "close"].forEach(t => {
                            const n = e.meta[`${t}Name`],
                                s = (this.placeholders.get(n) || []).find(zc(this.id, e.templateIndex));
                            s && (s.ctx = e.id)
                        });
                        e.placeholders.forEach((t, n) => {
                            const s = this.placeholders.get(n);
                            if (!s) return void this.placeholders.set(n, t);
                            const r = s.findIndex(zc(e.id, e.templateIndex));
                            if (r >= 0) {
                                const e = n.startsWith("CLOSE");
                                if (n.endsWith("NG-TEMPLATE")) s.splice(r + (e ? 0 : 1), 0, ...t);
                                else {
                                    t[e ? t.length - 1 : 0].tmpl = s[r], s.splice(r, 1, ...t)
                                }
                            } else s.push(...t);
                            this.placeholders.set(n, s)
                        }), this._unresolvedCtxCount--
                    }
                }

                function Uc(e, t, n, s) {
                    return er(`${s?"/":""}${e}${t}`, n)
                }

                function qc(e, {
                    index: t,
                    ctx: n,
                    isVoid: s
                }, r) {
                    return s ? Uc(e, t, n) + Uc(e, t, n, !0) : Uc(e, t, n, r)
                }

                function zc(e, t) {
                    return n => "object" == typeof n && n.type === Bc.TEMPLATE && n.index === t && n.ctx === e
                }

                function Wc(e) {
                    const t = (e, t) => qc("#", e, t),
                        n = (e, t) => qc("*", e, t);
                    switch (e.type) {
                        case Bc.ELEMENT:
                            return e.closed ? t(e, !0) + (e.tmpl ? n(e.tmpl, !0) : "") : e.tmpl ? n(e.tmpl) + t(e) + (e.isVoid ? n(e.tmpl, !0) : "") : t(e);
                        case Bc.TEMPLATE:
                            return n(e, e.closed);
                        default:
                            return e
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Gc = new class {
                    visitText(e) {
                        return e.value
                    }
                    visitContainer(e) {
                        return e.children.map(e => e.visit(this)).join("")
                    }
                    visitIcu(e) {
                        const t = Object.keys(e.cases).map(t => `${t} {${e.cases[t].visit(this)}}`);
                        return `{${e.expressionPlaceholder}, ${e.type}, ${t.join(" ")}}`
                    }
                    visitTagPlaceholder(e) {
                        return e.isVoid ? this.formatPh(e.startName) : `${this.formatPh(e.startName)}${e.children.map(e=>e.visit(this)).join("")}${this.formatPh(e.closeName)}`
                    }
                    visitPlaceholder(e) {
                        return this.formatPh(e.name)
                    }
                    visitIcuPlaceholder(e, t) {
                        return this.formatPh(e.name)
                    }
                    formatPh(e) {
                        return `{${or(e,!1)}}`
                    }
                };

                function Kc(e) {
                    return e.visit(Gc)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Qc = {
                    A: "LINK",
                    B: "BOLD_TEXT",
                    BR: "LINE_BREAK",
                    EM: "EMPHASISED_TEXT",
                    H1: "HEADING_LEVEL1",
                    H2: "HEADING_LEVEL2",
                    H3: "HEADING_LEVEL3",
                    H4: "HEADING_LEVEL4",
                    H5: "HEADING_LEVEL5",
                    H6: "HEADING_LEVEL6",
                    HR: "HORIZONTAL_RULE",
                    I: "ITALIC_TEXT",
                    LI: "LIST_ITEM",
                    LINK: "MEDIA_LINK",
                    OL: "ORDERED_LIST",
                    P: "PARAGRAPH",
                    Q: "QUOTATION",
                    S: "STRIKETHROUGH_TEXT",
                    SMALL: "SMALL_TEXT",
                    SUB: "SUBSTRIPT",
                    SUP: "SUPERSCRIPT",
                    TBODY: "TABLE_BODY",
                    TD: "TABLE_CELL",
                    TFOOT: "TABLE_FOOTER",
                    TH: "TABLE_HEADER_CELL",
                    THEAD: "TABLE_HEADER",
                    TR: "TABLE_ROW",
                    TT: "MONOSPACED_TEXT",
                    U: "UNDERLINED_TEXT",
                    UL: "UNORDERED_LIST"
                };
                class Zc {
                    constructor() {
                        this._placeHolderNameCounts = {}, this._signatureToName = {}
                    }
                    getStartTagPlaceholderName(e, t, n) {
                        const s = this._hashTag(e, t, n);
                        if (this._signatureToName[s]) return this._signatureToName[s];
                        const r = e.toUpperCase(),
                            i = Qc[r] || `TAG_${r}`,
                            o = this._generateUniqueName(n ? i : `START_${i}`);
                        return this._signatureToName[s] = o, o
                    }
                    getCloseTagPlaceholderName(e) {
                        const t = this._hashClosingTag(e);
                        if (this._signatureToName[t]) return this._signatureToName[t];
                        const n = e.toUpperCase(),
                            s = Qc[n] || `TAG_${n}`,
                            r = this._generateUniqueName(`CLOSE_${s}`);
                        return this._signatureToName[t] = r, r
                    }
                    getPlaceholderName(e, t) {
                        const n = e.toUpperCase(),
                            s = `PH: ${n}=${t}`;
                        if (this._signatureToName[s]) return this._signatureToName[s];
                        const r = this._generateUniqueName(n);
                        return this._signatureToName[s] = r, r
                    }
                    getUniquePlaceholder(e) {
                        return this._generateUniqueName(e.toUpperCase())
                    }
                    _hashTag(e, t, n) {
                        return `<${e}` + Object.keys(t).sort().map(e => ` ${e}=${t[e]}`).join("") + (n ? "/>" : `></${e}>`)
                    }
                    _hashClosingTag(e) {
                        return this._hashTag(`/${e}`, {}, !1)
                    }
                    _generateUniqueName(e) {
                        if (!this._placeHolderNameCounts.hasOwnProperty(e)) return this._placeHolderNameCounts[e] = 1, e;
                        const t = this._placeHolderNameCounts[e];
                        return this._placeHolderNameCounts[e] = t + 1, `${e}_${t}`
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Jc = new Ec(new cc);

                function Xc(e) {
                    const t = new eu(Jc, e);
                    return (e, n, s, r, i) => t.toI18nMessage(e, n, s, r, i)
                }

                function Yc(e, t) {
                    return t
                }
                class eu {
                    constructor(e, t) {
                        this._expressionParser = e, this._interpolationConfig = t
                    }
                    toI18nMessage(e, t = "", n = "", s = "", r) {
                        const i = {
                                isIcu: 1 == e.length && e[0] instanceof pa,
                                icuDepth: 0,
                                placeholderRegistry: new Zc,
                                placeholderToContent: {},
                                placeholderToMessage: {},
                                visitNodeFn: r || Yc
                            },
                            o = ya(this, e, i);
                        return new es(o, i.placeholderToContent, i.placeholderToMessage, t, n, s)
                    }
                    visitElement(e, t) {
                        var n;
                        const s = ya(this, e.children, t),
                            r = {};
                        e.attrs.forEach(e => {
                            r[e.name] = e.value
                        });
                        const i = f(e.name).isVoid,
                            o = t.placeholderRegistry.getStartTagPlaceholderName(e.name, r, i);
                        t.placeholderToContent[o] = {
                            text: e.startSourceSpan.toString(),
                            sourceSpan: e.startSourceSpan
                        };
                        let a = "";
                        i || (a = t.placeholderRegistry.getCloseTagPlaceholderName(e.name), t.placeholderToContent[a] = {
                            text: `</${e.name}>`,
                            sourceSpan: null !== (n = e.endSourceSpan) && void 0 !== n ? n : e.sourceSpan
                        });
                        const l = new rs(e.name, r, o, a, s, i, e.sourceSpan, e.startSourceSpan, e.endSourceSpan);
                        return t.visitNodeFn(e, l)
                    }
                    visitAttribute(e, t) {
                        const n = this._visitTextWithInterpolation(e.value, e.valueSpan || e.sourceSpan, t, e.i18n);
                        return t.visitNodeFn(e, n)
                    }
                    visitText(e, t) {
                        const n = this._visitTextWithInterpolation(e.value, e.sourceSpan, t, e.i18n);
                        return t.visitNodeFn(e, n)
                    }
                    visitComment(e, t) {
                        return null
                    }
                    visitExpansion(e, t) {
                        t.icuDepth++;
                        const n = {},
                            s = new ss(e.switchValue, e.type, n, e.sourceSpan);
                        if (e.cases.forEach(e => {
                                n[e.value] = new ns(e.expression.map(e => e.visit(this, t)), e.expSourceSpan)
                            }), t.icuDepth--, t.isIcu || t.icuDepth > 0) {
                            const n = t.placeholderRegistry.getUniquePlaceholder(`VAR_${e.type}`);
                            return s.expressionPlaceholder = n, t.placeholderToContent[n] = {
                                text: e.switchValue,
                                sourceSpan: e.switchValueSourceSpan
                            }, t.visitNodeFn(e, s)
                        }
                        const r = t.placeholderRegistry.getPlaceholderName("ICU", e.sourceSpan.toString());
                        t.placeholderToMessage[r] = this.toI18nMessage([e], "", "", "", void 0);
                        const i = new os(s, r, e.sourceSpan);
                        return t.visitNodeFn(e, i)
                    }
                    visitExpansionCase(e, t) {
                        throw new Error("Unreachable code")
                    }
                    _visitTextWithInterpolation(e, t, n, s) {
                        const {
                            strings: r,
                            expressions: i
                        } = this._expressionParser.splitInterpolation(e, t.start.toString(), this._interpolationConfig);
                        if (0 === i.length) return new ts(e, t);
                        const o = [];
                        for (let a = 0; a < r.length - 1; a++) this._addText(o, r[a], t), this._addPlaceholder(o, n, i[a], t);
                        return this._addText(o, r[r.length - 1], t),
                            function(e, t) {
                                t instanceof es && (! function(e) {
                                    const t = e.nodes;
                                    if (1 !== t.length || !(t[0] instanceof ns)) throw new Error("Unexpected previous i18n message - expected it to consist of only a single `Container` node.")
                                }(t), t = t.nodes[0]);
                                if (t instanceof ns) {
                                    ! function(e, t) {
                                        if (e.length !== t.length) throw new Error("The number of i18n message children changed between first and second pass.");
                                        if (e.some((e, n) => t[n].constructor !== e.constructor)) throw new Error("The types of the i18n message children changed between first and second pass.")
                                    }(t.children, e);
                                    for (let n = 0; n < e.length; n++) e[n].sourceSpan = t.children[n].sourceSpan
                                }
                            }(o, s), new ns(o, t)
                    }
                    _addText(e, t, n) {
                        if (t.text.length > 0) {
                            const s = tu(n, t);
                            e.push(new ts(t.text, s))
                        }
                    }
                    _addPlaceholder(e, t, n, s) {
                        const r = tu(s, n),
                            i = n.text.split(nu)[2] || "INTERPOLATION";
                        const o = t.placeholderRegistry.getPlaceholderName(i, n.text),
                            a = this._interpolationConfig.start + n.text + this._interpolationConfig.end;
                        t.placeholderToContent[o] = {
                            text: a,
                            sourceSpan: r
                        }, e.push(new is(n.text, o, r))
                    }
                }

                function tu(e, {
                    start: t,
                    end: n
                }) {
                    return new vi(e.fullStart.moveBy(t), e.fullStart.moveBy(n))
                }
                const nu = /\/\/[\s\S]*i18n[\s\S]*\([\s\S]*ph[\s\S]*=[\s\S]*("|')([\s\S]*?)\1[\s\S]*\)/g;
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const su = (e, t) => (e instanceof ua && (t instanceof os && e.i18n instanceof es && (t.previousMessage = e.i18n), e.i18n = t), t);
                class ru {
                    constructor(e = Fr, t = !1, n = !1) {
                        this.interpolationConfig = e, this.keepI18nAttrs = t, this.enableI18nLegacyMessageIdFormat = n, this.hasI18nMeta = !1, this._createI18nMessage = Xc(this.interpolationConfig)
                    }
                    _generateI18nMessage(e, t = "", n) {
                        const {
                            meaning: s,
                            description: r,
                            customId: i
                        } = this._parseMetadata(t), o = this._createI18nMessage(e, s, r, i, n);
                        return this._setMessageId(o, t), this._setLegacyIds(o, t), o
                    }
                    visitElement(e) {
                        if (function(e) {
                                return e.attrs.some(e => Qs(e.name))
                            }(e)) {
                            this.hasI18nMeta = !0;
                            const t = [],
                                n = {};
                            for (const s of e.attrs)
                                if (s.name === Gs) {
                                    const t = e.i18n || s.value,
                                        n = this._generateI18nMessage(e.children, t, su);
                                    n.nodes.length && (e.i18n = n)
                                } else if (s.name.startsWith(Ks)) {
                                n[s.name.slice(Ks.length)] = s.value
                            } else t.push(s);
                            if (Object.keys(n).length)
                                for (const e of t) {
                                    const t = n[e.name];
                                    void 0 !== t && e.value && (e.i18n = this._generateI18nMessage([e], e.i18n || t))
                                }
                            this.keepI18nAttrs || (e.attrs = t)
                        }
                        return ya(this, e.children, e.i18n), e
                    }
                    visitExpansion(e, t) {
                        let n;
                        const s = e.i18n;
                        if (this.hasI18nMeta = !0, s instanceof os) {
                            const t = s.name;
                            n = this._generateI18nMessage([e], s);
                            Ys(n).name = t
                        } else n = this._generateI18nMessage([e], t || s);
                        return e.i18n = n, e
                    }
                    visitText(e) {
                        return e
                    }
                    visitAttribute(e) {
                        return e
                    }
                    visitComment(e) {
                        return e
                    }
                    visitExpansionCase(e) {
                        return e
                    }
                    _parseMetadata(e) {
                        return "string" == typeof e ? function(e = "") {
                            let t, n, s;
                            if (e = e.trim()) {
                                const r = e.indexOf("@@"),
                                    i = e.indexOf("|");
                                let o;
                                [o, t] = r > -1 ? [e.slice(0, r), e.slice(r + 2)] : [e, ""], [n, s] = i > -1 ? [o.slice(0, i), o.slice(i + 1)] : ["", o]
                            }
                            return {
                                customId: t,
                                meaning: n,
                                description: s
                            }
                        }(e) : e instanceof es ? e : {}
                    }
                    _setMessageId(e, t) {
                        e.id || (e.id = t instanceof es && t.id || hs(e))
                    }
                    _setLegacyIds(e, t) {
                        if (this.enableI18nLegacyMessageIdFormat) e.legacyIds = [us(e), ps(e)];
                        else if ("string" != typeof t) {
                            const n = t instanceof es ? t : t instanceof os ? t.previousMessage : void 0;
                            e.legacyIds = n ? n.legacyIds : []
                        }
                    }
                }

                function iu(e) {
                    const t = [];
                    return e.description && t.push({
                        tagName: "desc",
                        text: e.description
                    }), e.meaning && t.push({
                        tagName: "meaning",
                        text: e.meaning
                    }), 0 == t.length ? null : function(e = []) {
                        return new Ye(e)
                    }(t)
                }

                function ou(e, t, n, s) {
                    const r = [At(function(e) {
                        return e.nodes.map(e => e.visit(au, null)).join("")
                    }(t))];
                    Object.keys(s).length && r.push(xi(s, !0));
                    const i = n.set(vt("goog.getMsg").callFn(r)).toConstDecl(),
                        o = iu(t);
                    null !== o && i.addLeadingComment(o);
                    return [i, new st(e.set(n))]
                }
                const au = new class {
                    formatPh(e) {
                        return `{$${or(e)}}`
                    }
                    visitText(e) {
                        return e.value
                    }
                    visitContainer(e) {
                        return e.children.map(e => e.visit(this)).join("")
                    }
                    visitIcu(e) {
                        return Kc(e)
                    }
                    visitTagPlaceholder(e) {
                        return e.isVoid ? this.formatPh(e.startName) : `${this.formatPh(e.startName)}${e.children.map(e=>e.visit(this)).join("")}${this.formatPh(e.closeName)}`
                    }
                    visitPlaceholder(e) {
                        return this.formatPh(e.name)
                    }
                    visitIcuPlaceholder(e, t) {
                        return this.formatPh(e.name)
                    }
                };

                function lu(e, t, n) {
                    const {
                        messageParts: s,
                        placeHolders: r
                    } = function(e) {
                        const t = [];
                        return e.nodes.forEach(e => e.visit(cu, t)),
                            function(e) {
                                const t = [],
                                    n = [];
                                e[0] instanceof De && t.push(uu(e[0].sourceSpan.start));
                                for (let s = 0; s < e.length; s++) {
                                    const r = e[s];
                                    r instanceof Ae ? t.push(r) : (n.push(r), e[s - 1] instanceof De && t.push(uu(e[s - 1].sourceSpan.end)))
                                }
                                e[e.length - 1] instanceof De && t.push(uu(e[e.length - 1].sourceSpan.end));
                                return {
                                    messageParts: t,
                                    placeHolders: n
                                }
                            }(t)
                    }(t), i = function(e) {
                        const t = e.nodes[0],
                            n = e.nodes[e.nodes.length - 1];
                        return new vi(t.sourceSpan.start, n.sourceSpan.end, t.sourceSpan.fullStart, t.sourceSpan.details)
                    }(t), o = r.map(e => n[e.text]), a = function(e, t, n, s, r) {
                        return new Pe(e, t, n, s, r)
                    }(t, s, r, o, i), l = e.set(a);
                    return [new st(l)]
                }
                const cu = new class {
                    visitText(e, t) {
                        t[t.length - 1] instanceof Ae ? t[t.length - 1].text += e.value : t.push(new Ae(e.value, e.sourceSpan))
                    }
                    visitContainer(e, t) {
                        e.children.forEach(e => e.visit(this, t))
                    }
                    visitIcu(e, t) {
                        t.push(new Ae(Kc(e), e.sourceSpan))
                    }
                    visitTagPlaceholder(e, t) {
                        var n, s;
                        t.push(this.createPlaceholderPiece(e.startName, null !== (n = e.startSourceSpan) && void 0 !== n ? n : e.sourceSpan)), e.isVoid || (e.children.forEach(e => e.visit(this, t)), t.push(this.createPlaceholderPiece(e.closeName, null !== (s = e.endSourceSpan) && void 0 !== s ? s : e.sourceSpan)))
                    }
                    visitPlaceholder(e, t) {
                        t.push(this.createPlaceholderPiece(e.name, e.sourceSpan))
                    }
                    visitIcuPlaceholder(e, t) {
                        t.push(this.createPlaceholderPiece(e.name, e.sourceSpan))
                    }
                    createPlaceholderPiece(e, t) {
                        return new De(or(e, !1), t)
                    }
                };

                function uu(e) {
                    return new Ae("", new vi(e, e))
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const hu = new Set(["$event"]),
                    pu = new Map([
                        ["window", jn.resolveWindow],
                        ["document", jn.resolveDocument],
                        ["body", jn.resolveBody]
                    ]),
                    du = [" ", "\n", "\r", "\t"];

                function fu(e, t) {
                    return Tt(vt(pr).bitwiseAnd(At(e), null, !1), t)
                }

                function mu(e, t = null, n = null) {
                    const {
                        type: s,
                        name: r,
                        target: i,
                        phase: o,
                        handler: a
                    } = e;
                    if (i && !pu.has(i)) throw new Error(`Unexpected global target '${i}' defined for '${r}' event.\n        Supported list of global targets: ${Array.from(pu.keys())}.`);
                    const l = "$event",
                        c = new Set,
                        u = null === n || 0 === n.bindingLevel ? vt(hr) : n.getOrCreateSharedContextVar(0),
                        h = mo(n, u, a, "b", () => $t("Unexpected interpolation"), e.handlerSpan, c, hu),
                        p = [];
                    n && (p.push(...n.restoreViewStatement()), p.push(...n.variableDeclarations())), p.push(...h.render3Stmts);
                    const d = 1 === s ? function(e, t) {
                            return `@${e}.${t}`
                        }(r, o) : r,
                        f = t && mn(t),
                        m = [];
                    c.has(l) && m.push(new Ve(l, se));
                    const g = xt(m, p, re, null, f),
                        y = [At(d), g];
                    return i && y.push(At(!1), _t(pu.get(i))), y
                }
                class gu {
                    constructor(e, t, n = 0, s, r, i, o, a, l, c, u, h, p, d, f = {
                        prepareStatements: [],
                        constExpressions: []
                    }) {
                        this.constantPool = e, this.level = n, this.contextName = s, this.i18nContext = r, this.templateIndex = i, this.templateName = o, this.directiveMatcher = a, this.directives = l, this.pipeTypeByName = c, this.pipes = u, this._namespace = h, this.i18nUseExternalIds = d, this._constants = f, this._dataIndex = 0, this._bindingContext = 0, this._prefixCode = [], this._creationCodeFns = [], this._updateCodeFns = [], this._currentIndex = 0, this._tempVariables = [], this._nestedTemplateFns = [], this._unsupported = fr, this.i18n = null, this._pureFunctionSlots = 0, this._bindingSlots = 0, this._ngContentReservedSlots = [], this._ngContentSelectorsOffset = 0, this._implicitReceiverExpr = null, this.visitReference = mr, this.visitVariable = mr, this.visitTextAttribute = mr, this.visitBoundAttribute = mr, this.visitBoundEvent = mr, this._bindingScope = t.nestedScope(n), this.fileBasedI18nSuffix = p.replace(/[^A-Za-z0-9]/g, "_") + "_", this._valueConverter = new yu(e, () => this.allocateDataSlot(), e => this.allocatePureFunctionSlots(e), (e, t, n, s) => {
                            const r = c.get(e);
                            r && this.pipes.add(r), this._bindingScope.set(this.level, t, s), this.creationInstruction(null, jn.pipe, [At(n), At(e)])
                        })
                    }
                    buildTemplateFunction(e, t, n = 0, s) {
                        this._ngContentSelectorsOffset = n, this._namespace !== jn.namespaceHTML && this.creationInstruction(null, this._namespace), t.forEach(e => this.registerContextVariables(e));
                        const r = this.i18nContext || Zs(s) && !Js(s) && !(1 === (i = e).length && i[0] instanceof Gn && e[0].i18n === s);
                        var i;
                        const o = Nu(e);
                        if (r && this.i18nStart(null, s, o), Yn(this, e), this._pureFunctionSlots += this._bindingSlots, this._valueConverter.updatePipeSlotOffsets(this._bindingSlots), this._nestedTemplateFns.forEach(e => e()), 0 === this.level && this._ngContentReservedSlots.length) {
                            const e = [];
                            if (this._ngContentReservedSlots.length > 1 || "*" !== this._ngContentReservedSlots[0]) {
                                const t = this._ngContentReservedSlots.map(e => "*" !== e ? Q(e) : e);
                                e.push(this.constantPool.getConstLiteral(gr(t), !0))
                            }
                            this.creationInstruction(null, jn.projectionDef, e, !0)
                        }
                        r && this.i18nEnd(null, o);
                        const a = this._creationCodeFns.map(e => e()),
                            l = this._updateCodeFns.map(e => e()),
                            c = this._bindingScope.viewSnapshotStatements(),
                            u = this._bindingScope.variableDeclarations().concat(this._tempVariables),
                            h = a.length > 0 ? [fu(1, c.concat(a))] : [],
                            p = l.length > 0 ? [fu(2, u.concat(l))] : [];
                        return xt([new Ve(pr, oe), new Ve(hr, null)], [...this._prefixCode, ...h, ...p], re, null, this.templateName)
                    }
                    getLocal(e) {
                        return this._bindingScope.get(e)
                    }
                    notifyImplicitReceiverUse() {
                        this._bindingScope.notifyImplicitReceiverUse()
                    }
                    i18nTranslate(e, t = {}, n, s) {
                        const r = n || this.i18nGenerateMainBlockVar(),
                            i = function(e, t, n, s = {}, r) {
                                const i = [lr(t), Tt(Fu(), ou(t, e, n, ir(s, !0)), lu(t, e, ir(s, !1)))];
                                r && i.push(new st(t.set(r(t))));
                                return i
                            }(e, r, this.i18nGenerateClosureVar(e.id), t, s);
                        return this._constants.prepareStatements.push(...i), r
                    }
                    registerContextVariables(e) {
                        const t = this._bindingScope.freshReferenceName(),
                            n = this.level,
                            s = vt(e.name + t);
                        this._bindingScope.set(n, e.name, s, 1, (t, r) => {
                            let i;
                            if (t.bindingLevel === n) i = vt(hr);
                            else {
                                const e = t.getSharedContextName(n);
                                i = e || wu(r)
                            }
                            return [s.set(i.prop(e.value || "$implicit")).toConstDecl()]
                        })
                    }
                    i18nAppendBindings(e) {
                        e.length > 0 && e.forEach(e => this.i18n.appendBinding(e))
                    }
                    i18nBindProps(e) {
                        const t = {};
                        return Object.keys(e).forEach(n => {
                            const s = e[n];
                            if (s instanceof Hn) t[n] = At(s.value);
                            else {
                                const e = s.value.visit(this._valueConverter);
                                if (this.allocateBindingSlots(e), e instanceof Qi) {
                                    const {
                                        strings: s,
                                        expressions: r
                                    } = e, {
                                        id: i,
                                        bindings: o
                                    } = this.i18n, a = function(e, t = 0, n = 0) {
                                        if (!e.length) return "";
                                        let s = "";
                                        const r = e.length - 1;
                                        for (let i = 0; i < r; i++) s += `${e[i]}${er(t+i,n)}`;
                                        return s += e[r], s
                                    }(s, o.size, i);
                                    this.i18nAppendBindings(r), t[n] = At(a)
                                }
                            }
                        }), t
                    }
                    i18nGenerateMainBlockVar() {
                        return vt(this.constantPool.uniqueName("i18n_"))
                    }
                    i18nGenerateClosureVar(e) {
                        let t;
                        const n = this.fileBasedI18nSuffix.toUpperCase();
                        if (this.i18nUseExternalIds) {
                            const s = ar("EXTERNAL_"),
                                r = this.constantPool.uniqueName(n);
                            t = `${s}${mn(e)}$$${r}`
                        } else {
                            const e = ar(n);
                            t = this.constantPool.uniqueName(e)
                        }
                        return vt(t)
                    }
                    i18nUpdateRef(e) {
                        const {
                            icus: t,
                            meta: n,
                            isRoot: s,
                            isResolved: r,
                            isEmitted: i
                        } = e;
                        if (s && r && !i && !Js(n)) {
                            e.isEmitted = !0;
                            const s = e.getSerializedPlaceholders();
                            let r = {},
                                i = s.size ? nr(s) : {};
                            t.size && t.forEach((e, t) => {
                                if (1 === e.length) i[t] = e[0];
                                else {
                                    const n = er(`I18N_EXP_${t}`);
                                    i[t] = At(n), r[t] = Ct(e)
                                }
                            });
                            let o;
                            (Array.from(s.values()).some(e => e.length > 1) || Object.keys(r).length) && (o = e => {
                                const t = [e];
                                return Object.keys(r).length && t.push(xi(r, !0)), bu(null, jn.i18nPostprocess, t)
                            }), this.i18nTranslate(n, i, e.ref, o)
                        }
                    }
                    i18nStart(e = null, t, n) {
                        const s = this.allocateDataSlot();
                        this.i18n = this.i18nContext ? this.i18nContext.forkChildContext(s, this.templateIndex, t) : new Hc(s, this.i18nGenerateMainBlockVar(), 0, this.templateIndex, t);
                        const {
                            id: r,
                            ref: i
                        } = this.i18n, o = [At(s), this.addToConsts(i)];
                        r > 0 && o.push(At(r)), this.creationInstruction(e, n ? jn.i18n : jn.i18nStart, o)
                    }
                    i18nEnd(e = null, t) {
                        if (!this.i18n) throw new Error("i18nEnd is executed with no i18n context present");
                        this.i18nContext ? (this.i18nContext.reconcileChildContext(this.i18n), this.i18nUpdateRef(this.i18nContext)) : this.i18nUpdateRef(this.i18n);
                        const {
                            index: n,
                            bindings: s
                        } = this.i18n;
                        if (s.size) {
                            const t = [];
                            s.forEach(n => {
                                t.push({
                                    sourceSpan: e,
                                    value: () => this.convertPropertyBinding(n)
                                })
                            }), this.updateInstructionChainWithAdvance(this.getConstCount() - 1, jn.i18nExp, t), this.updateInstruction(e, jn.i18nApply, [At(n)])
                        }
                        t || this.creationInstruction(e, jn.i18nEnd), this.i18n = null
                    }
                    i18nAttributesInstruction(e, t, n) {
                        let s = !1;
                        const r = [],
                            i = [];
                        if (t.forEach(e => {
                                const t = e.i18n,
                                    o = e.value.visit(this._valueConverter);
                                if (this.allocateBindingSlots(o), o instanceof Qi) {
                                    const a = nr(rr(t));
                                    r.push(At(e.name), this.i18nTranslate(t, a)), o.expressions.forEach(e => {
                                        s = !0, i.push({
                                            sourceSpan: n,
                                            value: () => this.convertPropertyBinding(e)
                                        })
                                    })
                                }
                            }), i.length > 0 && this.updateInstructionChainWithAdvance(e, jn.i18nExp, i), r.length > 0) {
                            const e = At(this.allocateDataSlot()),
                                t = this.addToConsts(Ct(r));
                            this.creationInstruction(n, jn.i18nAttributes, [e, t]), s && this.updateInstruction(n, jn.i18nApply, [e])
                        }
                    }
                    getNamespaceInstruction(e) {
                        switch (e) {
                            case "math":
                                return jn.namespaceMathML;
                            case "svg":
                                return jn.namespaceSVG;
                            default:
                                return jn.namespaceHTML
                        }
                    }
                    addNamespaceInstruction(e, t) {
                        this._namespace = e, this.creationInstruction(t.startSourceSpan, e)
                    }
                    interpolatedUpdateInstruction(e, t, n, s, r, i) {
                        this.updateInstructionWithAdvance(t, s.sourceSpan, e, () => [At(n), ...this.getUpdateInstructionArguments(r), ...i])
                    }
                    visitContent(e) {
                        const t = this.allocateDataSlot(),
                            n = this._ngContentSelectorsOffset + this._ngContentReservedSlots.length,
                            s = [At(t)];
                        this._ngContentReservedSlots.push(e.selector);
                        const r = e.attributes.filter(e => "select" !== e.name.toLowerCase()),
                            i = this.getAttributeExpressions(e.name, r, [], []);
                        i.length > 0 ? s.push(At(n), Ct(i)) : 0 !== n && s.push(At(n)), this.creationInstruction(e.sourceSpan, jn.projection, s), this.i18n && this.i18n.appendProjection(e.i18n, t)
                    }
                    visitElement(e) {
                        var t, n;
                        const s = this.allocateDataSlot(),
                            o = new sc(null);
                        let a = !1;
                        const l = Zs(e.i18n) && !Js(e.i18n),
                            c = [],
                            [u, h] = r(e.name),
                            p = i(e.name);
                        for (const r of e.attributes) {
                            const {
                                name: e,
                                value: t
                            } = r;
                            "ngNonBindable" === e ? a = !0 : "style" === e ? o.registerStyleAttr(t) : "class" === e ? o.registerClassAttr(t) : c.push(r)
                        }
                        this.matchDirectives(e.name, e);
                        const d = [At(s)];
                        p || d.push(At(h));
                        const f = [],
                            m = [];
                        e.inputs.forEach(e => {
                            o.registerBoundInput(e) || (0 === e.type && e.i18n ? m.push(e) : f.push(e))
                        });
                        const g = this.getAttributeExpressions(e.name, c, f, e.outputs, o, [], m);
                        d.push(this.addAttrsToConsts(g));
                        const y = this.prepareRefsArray(e.references);
                        d.push(this.addToConsts(y));
                        const v = this._namespace,
                            _ = this.getNamespaceInstruction(u);
                        _ !== v && this.addNamespaceInstruction(_, e), this.i18n && this.i18n.appendElement(e.i18n, s);
                        const b = !l && this.i18n ? !Nu(e.children) : e.children.length > 0,
                            w = !o.hasBindingsWithPipes && 0 === e.outputs.length && 0 === m.length && !b,
                            E = !w && Nu(e.children);
                        if (w) this.creationInstruction(e.sourceSpan, p ? jn.elementContainer : jn.element, vr(d));
                        else {
                            if (this.creationInstruction(e.startSourceSpan, p ? jn.elementContainerStart : jn.elementStart, vr(d)), a && this.creationInstruction(e.startSourceSpan, jn.disableBindings), m.length > 0 && this.i18nAttributesInstruction(s, m, null !== (t = e.startSourceSpan) && void 0 !== t ? t : e.sourceSpan), e.outputs.length > 0) {
                                const t = e.outputs.map(t => ({
                                    sourceSpan: t.sourceSpan,
                                    params: this.prepareListenerParameter(e.name, t, s)
                                }));
                                this.creationInstructionChain(jn.listener, t)
                            }
                            l && this.i18nStart(e.startSourceSpan, e.i18n, E)
                        }
                        const C = o.buildUpdateLevelInstructions(this._valueConverter),
                            S = C.length - 1;
                        for (let r = 0; r <= S; r++) {
                            const e = C[r];
                            this._bindingSlots += this.processStylingUpdateInstruction(s, e)
                        }
                        const x = At(void 0),
                            T = [],
                            A = [];
                        if (f.forEach(e => {
                                const t = e.type;
                                if (4 === t) {
                                    const t = e.value.visit(this._valueConverter),
                                        n = !(t instanceof Wi) || !!t.value;
                                    this.allocateBindingSlots(t), T.push({
                                        name: $n(e.name),
                                        sourceSpan: e.sourceSpan,
                                        value: () => n ? this.convertPropertyBinding(t) : x
                                    })
                                } else {
                                    if (e.i18n) return;
                                    const n = e.value.visit(this._valueConverter);
                                    if (void 0 !== n) {
                                        const i = [],
                                            [o, a] = r(e.name),
                                            l = 1 === t,
                                            c = ku(e.securityContext, l);
                                        if (c && i.push(c), o) {
                                            const e = At(o);
                                            c ? i.push(e) : i.push(At(null), e)
                                        }
                                        if (this.allocateBindingSlots(n), 0 === t) n instanceof Qi ? this.interpolatedUpdateInstruction(Au(n), s, a, e, n, i) : T.push({
                                            name: a,
                                            sourceSpan: e.sourceSpan,
                                            value: () => this.convertPropertyBinding(n),
                                            params: i
                                        });
                                        else if (1 === t)
                                            if (n instanceof Qi && Cr(n) > 1) this.interpolatedUpdateInstruction(function(e) {
                                                switch (Cr(e)) {
                                                    case 3:
                                                        return jn.attributeInterpolate1;
                                                    case 5:
                                                        return jn.attributeInterpolate2;
                                                    case 7:
                                                        return jn.attributeInterpolate3;
                                                    case 9:
                                                        return jn.attributeInterpolate4;
                                                    case 11:
                                                        return jn.attributeInterpolate5;
                                                    case 13:
                                                        return jn.attributeInterpolate6;
                                                    case 15:
                                                        return jn.attributeInterpolate7;
                                                    case 17:
                                                        return jn.attributeInterpolate8;
                                                    default:
                                                        return jn.attributeInterpolateV
                                                }
                                            }(n), s, a, e, n, i);
                                            else {
                                                const t = n instanceof Qi ? n.expressions[0] : n;
                                                A.push({
                                                    name: a,
                                                    sourceSpan: e.sourceSpan,
                                                    value: () => this.convertPropertyBinding(t),
                                                    params: i
                                                })
                                            }
                                        else this.updateInstructionWithAdvance(s, e.sourceSpan, jn.classProp, () => [At(s), At(a), this.convertPropertyBinding(n), ...i])
                                    }
                                }
                            }), T.length > 0 && this.updateInstructionChainWithAdvance(s, jn.property, T), A.length > 0 && this.updateInstructionChainWithAdvance(s, jn.attribute, A), Yn(this, e.children), !l && this.i18n && this.i18n.appendElement(e.i18n, s, !0), !w) {
                            const t = null !== (n = e.endSourceSpan) && void 0 !== n ? n : e.sourceSpan;
                            l && this.i18nEnd(t, E), a && this.creationInstruction(t, jn.enableBindings), this.creationInstruction(t, p ? jn.elementContainerEnd : jn.elementEnd)
                        }
                    }
                    visitTemplate(e) {
                        var t;
                        const n = "ng-template",
                            s = this.allocateDataSlot();
                        this.i18n && this.i18n.appendTemplate(e.i18n, s);
                        const i = mn(e.tagName || ""),
                            o = `${this.contextName}${i?"_"+i:""}_${s}`,
                            a = `${o}_Template`,
                            l = [At(s), vt(a), At(e.tagName ? r(e.tagName)[1] : e.tagName)];
                        this.matchDirectives(n, e);
                        const c = this.getAttributeExpressions(n, e.attributes, e.inputs, e.outputs, void 0, e.templateAttrs);
                        if (l.push(this.addAttrsToConsts(c)), e.references && e.references.length) {
                            const t = this.prepareRefsArray(e.references);
                            l.push(this.addToConsts(t)), l.push(_t(jn.templateRefExtractor))
                        }
                        const u = new gu(this.constantPool, this._bindingScope, this.level + 1, o, this.i18n, s, a, this.directiveMatcher, this.directives, this.pipeTypeByName, this.pipes, this._namespace, this.fileBasedI18nSuffix, this.i18nUseExternalIds, this._constants);
                        if (this._nestedTemplateFns.push(() => {
                                const t = u.buildTemplateFunction(e.children, e.variables, this._ngContentReservedSlots.length + this._ngContentSelectorsOffset, e.i18n);
                                this.constantPool.statements.push(t.toDeclStmt(a)), u._ngContentReservedSlots.length && this._ngContentReservedSlots.push(...u._ngContentReservedSlots)
                            }), this.creationInstruction(e.sourceSpan, jn.templateCreate, () => (l.splice(2, 0, At(u.getConstCount()), At(u.getVarCount())), vr(l))), this.templatePropertyBindings(s, e.templateAttrs), e.tagName === n) {
                            const [n, r] = function(e, t) {
                                const n = [],
                                    s = [];
                                for (const r of e)(t(r) ? n : s).push(r);
                                return [n, s]
                            }(e.inputs, Xs);
                            if (n.length > 0 && this.i18nAttributesInstruction(s, n, null !== (t = e.startSourceSpan) && void 0 !== t ? t : e.sourceSpan), r.length > 0 && this.templatePropertyBindings(s, r), e.outputs.length > 0) {
                                const t = e.outputs.map(e => ({
                                    sourceSpan: e.sourceSpan,
                                    params: this.prepareListenerParameter("ng_template", e, s)
                                }));
                                this.creationInstructionChain(jn.listener, t)
                            }
                        }
                    }
                    visitBoundText(e) {
                        if (this.i18n) {
                            const t = e.value.visit(this._valueConverter);
                            return this.allocateBindingSlots(t), void(t instanceof Qi && (this.i18n.appendBoundText(e.i18n), this.i18nAppendBindings(t.expressions)))
                        }
                        const t = this.allocateDataSlot();
                        this.creationInstruction(e.sourceSpan, jn.text, [At(t)]);
                        const n = e.value.visit(this._valueConverter);
                        this.allocateBindingSlots(n), n instanceof Qi ? this.updateInstructionWithAdvance(t, e.sourceSpan, function(e) {
                            switch (Cr(e)) {
                                case 1:
                                    return jn.textInterpolate;
                                case 3:
                                    return jn.textInterpolate1;
                                case 5:
                                    return jn.textInterpolate2;
                                case 7:
                                    return jn.textInterpolate3;
                                case 9:
                                    return jn.textInterpolate4;
                                case 11:
                                    return jn.textInterpolate5;
                                case 13:
                                    return jn.textInterpolate6;
                                case 15:
                                    return jn.textInterpolate7;
                                case 17:
                                    return jn.textInterpolate8;
                                default:
                                    return jn.textInterpolateV
                            }
                        }(n), () => this.getUpdateInstructionArguments(n)) : $t("Text nodes should be interpolated and never bound directly.")
                    }
                    visitText(e) {
                        this.i18n || this.creationInstruction(e.sourceSpan, jn.text, [At(this.allocateDataSlot()), At(e.value)])
                    }
                    visitIcu(e) {
                        let t = !1;
                        this.i18n || (t = !0, this.i18nStart(null, e.i18n, !0));
                        const n = this.i18n,
                            s = this.i18nBindProps(e.vars),
                            r = this.i18nBindProps(e.placeholders),
                            i = e.i18n,
                            o = e => {
                                const t = ir(Object.assign(Object.assign({}, s), r), !1);
                                return bu(null, jn.i18nPostprocess, [e, xi(t, !0)])
                            };
                        if (Js(n.meta)) this.i18nTranslate(i, {}, n.ref, o);
                        else {
                            const e = this.i18nTranslate(i, {}, void 0, o);
                            n.appendIcu(Ys(i).name, e)
                        }
                        return t && this.i18nEnd(null, !0), null
                    }
                    allocateDataSlot() {
                        return this._dataIndex++
                    }
                    getConstCount() {
                        return this._dataIndex
                    }
                    getVarCount() {
                        return this._pureFunctionSlots
                    }
                    getConsts() {
                        return this._constants
                    }
                    getNgContentSelectors() {
                        return this._ngContentReservedSlots.length ? this.constantPool.getConstLiteral(gr(this._ngContentReservedSlots), !0) : null
                    }
                    bindingContext() {
                        return "" + this._bindingContext++
                    }
                    templatePropertyBindings(e, t) {
                        const n = [];
                        t.forEach(t => {
                            if (t instanceof zn) {
                                const s = t.value.visit(this._valueConverter);
                                if (void 0 !== s)
                                    if (this.allocateBindingSlots(s), s instanceof Qi) {
                                        const n = [];
                                        this.interpolatedUpdateInstruction(Au(s), e, t.name, t, s, n)
                                    } else n.push({
                                        name: t.name,
                                        sourceSpan: t.sourceSpan,
                                        value: () => this.convertPropertyBinding(s)
                                    })
                            }
                        }), n.length > 0 && this.updateInstructionChainWithAdvance(e, jn.property, n)
                    }
                    instructionFn(e, t, n, s, r = !1) {
                        e[r ? "unshift" : "push"](() => {
                            const e = Array.isArray(s) ? s : s();
                            return bu(t, n, e).toStmt()
                        })
                    }
                    processStylingUpdateInstruction(e, t) {
                        let n = 0;
                        if (t) {
                            const s = [];
                            t.calls.forEach(e => {
                                n += e.allocateBindingSlots, s.push({
                                    sourceSpan: e.sourceSpan,
                                    value: () => e.params(t => e.supportsInterpolation && t instanceof Qi ? this.getUpdateInstructionArguments(t) : this.convertPropertyBinding(t))
                                })
                            }), this.updateInstructionChainWithAdvance(e, t.reference, s)
                        }
                        return n
                    }
                    creationInstruction(e, t, n, s) {
                        this.instructionFn(this._creationCodeFns, e, t, n || [], s)
                    }
                    creationInstructionChain(e, t) {
                        const n = t.length ? t[0].sourceSpan : null;
                        this._creationCodeFns.push(() => Er(e, t.map(e => e.params()), n).toStmt())
                    }
                    updateInstructionWithAdvance(e, t, n, s) {
                        this.addAdvanceInstructionIfNecessary(e, t), this.updateInstruction(t, n, s)
                    }
                    updateInstruction(e, t, n) {
                        this.instructionFn(this._updateCodeFns, e, t, n || [])
                    }
                    updateInstructionChain(e, t) {
                        const n = t.length ? t[0].sourceSpan : null;
                        this._updateCodeFns.push(() => {
                            const s = t.map(e => {
                                const t = e.value(),
                                    n = Array.isArray(t) ? t : [t];
                                return e.params && n.push(...e.params), e.name && n.unshift(At(e.name)), n
                            });
                            return Er(e, s, n).toStmt()
                        })
                    }
                    updateInstructionChainWithAdvance(e, t, n) {
                        this.addAdvanceInstructionIfNecessary(e, n.length ? n[0].sourceSpan : null), this.updateInstructionChain(t, n)
                    }
                    addAdvanceInstructionIfNecessary(e, t) {
                        if (e !== this._currentIndex) {
                            const n = e - this._currentIndex;
                            if (n < 1) throw new Error("advance instruction can only go forwards");
                            this.instructionFn(this._updateCodeFns, t, jn.advance, [At(n)]), this._currentIndex = e
                        }
                    }
                    allocatePureFunctionSlots(e) {
                        const t = this._pureFunctionSlots;
                        return this._pureFunctionSlots += e, t
                    }
                    allocateBindingSlots(e) {
                        this._bindingSlots += e instanceof Qi ? e.expressions.length : 1
                    }
                    getImplicitReceiverExpr() {
                        return this._implicitReceiverExpr ? this._implicitReceiverExpr : this._implicitReceiverExpr = 0 === this.level ? vt(hr) : this._bindingScope.getOrCreateSharedContextVar(0)
                    }
                    convertPropertyBinding(e) {
                        const t = vo(this, this.getImplicitReceiverExpr(), e, this.bindingContext(), wi.Expression, () => $t("Unexpected interpolation")),
                            n = t.currValExpr;
                        return this._tempVariables.push(...t.stmts), n
                    }
                    getUpdateInstructionArguments(e) {
                        const {
                            args: t,
                            stmts: n
                        } = function(e, t, n, s) {
                            const r = new xo(e, t, s, void 0),
                                i = n.visit(r, Ei.Expression);
                            r.usesImplicitReceiver && e.notifyImplicitReceiverUse();
                            const o = _o(r, s);
                            let a = i.args.slice(1);
                            if (n instanceof Qi) {
                                const e = n.strings;
                                3 === a.length && "" === e[0] && "" === e[1] ? a = [a[1]] : a.length >= 19 && (a = [Ct(a)])
                            }
                            return {
                                stmts: o,
                                args: a
                            }
                        }(this, this.getImplicitReceiverExpr(), e, this.bindingContext());
                        return this._tempVariables.push(...n), t
                    }
                    matchDirectives(e, t) {
                        if (this.directiveMatcher) {
                            const n = Tu(e, wr(t));
                            this.directiveMatcher.match(n, (e, t) => {
                                this.directives.add(t)
                            })
                        }
                    }
                    getAttributeExpressions(e, t, n, s, r, i = [], o = []) {
                        const a = new Set,
                            l = [];
                        let c;
                        for (const h of t) "ngProjectAs" === h.name && (c = h), h.i18n ? l.push(At(h.name), this.i18nTranslate(h.i18n)) : l.push(...Cu(h.name), Ou(e, h));

                        function u(e, t) {
                            "string" == typeof e ? a.has(e) || (l.push(...Cu(e)), void 0 !== t && l.push(t), a.add(e)) : l.push(At(e))
                        }
                        if (c && l.push(... function(e) {
                                const t = Q(e.value)[0];
                                return [At(5), gr(t)]
                            }(c)), r && r.populateInitialStylingAttrs(l), n.length || s.length) {
                            const e = l.length;
                            for (let t = 0; t < n.length; t++) {
                                const e = n[t];
                                4 !== e.type && 1 !== e.type && u(e.name)
                            }
                            for (let t = 0; t < s.length; t++) {
                                const e = s[t];
                                1 !== e.type && u(e.name)
                            }
                            l.length !== e && l.splice(e, 0, At(3))
                        }
                        return i.length && (l.push(At(4)), i.forEach(e => u(e.name))), o.length && (l.push(At(6)), o.forEach(e => u(e.name))), l
                    }
                    addToConsts(e) {
                        if (Dt(e)) return Ze;
                        const t = this._constants.constExpressions;
                        for (let n = 0; n < t.length; n++)
                            if (t[n].isEquivalent(e)) return At(n);
                        return At(t.push(e) - 1)
                    }
                    addAttrsToConsts(e) {
                        return e.length > 0 ? this.addToConsts(Ct(e)) : Ze
                    }
                    prepareRefsArray(e) {
                        if (!e || 0 === e.length) return Ze;
                        return gr(Nn(e.map(e => {
                            const t = this.allocateDataSlot(),
                                n = this._bindingScope.freshReferenceName(),
                                s = this.level,
                                r = vt(n);
                            return this._bindingScope.set(s, e.name, r, 0, (e, n) => {
                                const s = n > 0 ? [wu(n).toStmt()] : [],
                                    i = r.set(_t(jn.reference).callFn([At(t)]));
                                return s.concat(i.toConstDecl())
                            }, !0), [e.name, e.value]
                        })))
                    }
                    prepareListenerParameter(e, t, n) {
                        return () => {
                            const s = t.name,
                                r = 1 === t.type ? Bn(s, t.phase) : mn(s),
                                i = `${this.templateName}_${e}_${r}_${n}_listener`,
                                o = this._bindingScope.nestedScope(this._bindingScope.bindingLevel, hu);
                            return mu(t, i, o)
                        }
                    }
                }
                class yu extends class {
                    visitImplicitReceiver(e, t) {
                        return e
                    }
                    visitThisReceiver(e, t) {
                        return e
                    }
                    visitInterpolation(e, t) {
                        const n = this.visitAll(e.expressions);
                        return n !== e.expressions ? new Qi(e.span, e.sourceSpan, e.strings, n) : e
                    }
                    visitLiteralPrimitive(e, t) {
                        return e
                    }
                    visitPropertyRead(e, t) {
                        const n = e.receiver.visit(this);
                        return n !== e.receiver ? new $i(e.span, e.sourceSpan, e.nameSpan, n, e.name) : e
                    }
                    visitPropertyWrite(e, t) {
                        const n = e.receiver.visit(this),
                            s = e.value.visit(this);
                        return n !== e.receiver || s !== e.value ? new Bi(e.span, e.sourceSpan, e.nameSpan, n, e.name, s) : e
                    }
                    visitSafePropertyRead(e, t) {
                        const n = e.receiver.visit(this);
                        return n !== e.receiver ? new Hi(e.span, e.sourceSpan, e.nameSpan, n, e.name) : e
                    }
                    visitMethodCall(e, t) {
                        const n = e.receiver.visit(this),
                            s = this.visitAll(e.args);
                        return n !== e.receiver || s !== e.args ? new eo(e.span, e.sourceSpan, e.nameSpan, n, e.name, s) : e
                    }
                    visitSafeMethodCall(e, t) {
                        const n = e.receiver.visit(this),
                            s = this.visitAll(e.args);
                        return n !== e.receiver || s !== e.args ? new to(e.span, e.sourceSpan, e.nameSpan, n, e.name, s) : e
                    }
                    visitFunctionCall(e, t) {
                        const n = e.target && e.target.visit(this),
                            s = this.visitAll(e.args);
                        return n !== e.target || s !== e.args ? new no(e.span, e.sourceSpan, n, s) : e
                    }
                    visitLiteralArray(e, t) {
                        const n = this.visitAll(e.expressions);
                        return n !== e.expressions ? new Gi(e.span, e.sourceSpan, n) : e
                    }
                    visitLiteralMap(e, t) {
                        const n = this.visitAll(e.values);
                        return n !== e.values ? new Ki(e.span, e.sourceSpan, e.keys, n) : e
                    }
                    visitUnary(e, t) {
                        const n = e.expr.visit(this);
                        if (n !== e.expr) switch (e.operator) {
                            case "+":
                                return Ji.createPlus(e.span, e.sourceSpan, n);
                            case "-":
                                return Ji.createMinus(e.span, e.sourceSpan, n);
                            default:
                                throw new Error(`Unknown unary operator ${e.operator}`)
                        }
                        return e
                    }
                    visitBinary(e, t) {
                        const n = e.left.visit(this),
                            s = e.right.visit(this);
                        return n !== e.left || s !== e.right ? new Zi(e.span, e.sourceSpan, e.operation, n, s) : e
                    }
                    visitPrefixNot(e, t) {
                        const n = e.expression.visit(this);
                        return n !== e.expression ? new Xi(e.span, e.sourceSpan, n) : e
                    }
                    visitNonNullAssert(e, t) {
                        const n = e.expression.visit(this);
                        return n !== e.expression ? new Yi(e.span, e.sourceSpan, n) : e
                    }
                    visitConditional(e, t) {
                        const n = e.condition.visit(this),
                            s = e.trueExp.visit(this),
                            r = e.falseExp.visit(this);
                        return n !== e.condition || s !== e.trueExp || r !== e.falseExp ? new Vi(e.span, e.sourceSpan, n, s, r) : e
                    }
                    visitPipe(e, t) {
                        const n = e.exp.visit(this),
                            s = this.visitAll(e.args);
                        return n !== e.exp || s !== e.args ? new zi(e.span, e.sourceSpan, n, e.name, s, e.nameSpan) : e
                    }
                    visitKeyedRead(e, t) {
                        const n = e.obj.visit(this),
                            s = e.key.visit(this);
                        return n !== e.obj || s !== e.key ? new Ui(e.span, e.sourceSpan, n, s) : e
                    }
                    visitKeyedWrite(e, t) {
                        const n = e.obj.visit(this),
                            s = e.key.visit(this),
                            r = e.value.visit(this);
                        return n !== e.obj || s !== e.key || r !== e.value ? new qi(e.span, e.sourceSpan, n, s, r) : e
                    }
                    visitAll(e) {
                        const t = [];
                        let n = !1;
                        for (let s = 0; s < e.length; ++s) {
                            const r = e[s],
                                i = r.visit(this);
                            t[s] = i, n = n || i !== r
                        }
                        return n ? t : e
                    }
                    visitChain(e, t) {
                        const n = this.visitAll(e.expressions);
                        return n !== e.expressions ? new Li(e.span, e.sourceSpan, n) : e
                    }
                    visitQuote(e, t) {
                        return e
                    }
                } {
                    constructor(e, t, n, s) {
                        super(), this.constantPool = e, this.allocateSlot = t, this.allocatePureFunctionSlots = n, this.definePipe = s, this._pipeBindExprs = []
                    }
                    visitPipe(e, t) {
                        const n = this.allocateSlot(),
                            s = `PIPE:${n}`,
                            r = this.allocatePureFunctionSlots(2 + e.args.length),
                            i = new $i(e.span, e.sourceSpan, e.nameSpan, new Ri(e.span, e.sourceSpan), s),
                            {
                                identifier: o,
                                isVarLength: a
                            } = function(e) {
                                const t = vu[e.length];
                                return {
                                    identifier: t || jn.pipeBindV,
                                    isVarLength: !t
                                }
                            }(e.args);
                        this.definePipe(e.name, s, n, _t(o));
                        const l = [e.exp, ...e.args],
                            c = a ? this.visitAll([new Gi(e.span, e.sourceSpan, l)]) : this.visitAll(l),
                            u = new no(e.span, e.sourceSpan, i, [new Wi(e.span, e.sourceSpan, n), new Wi(e.span, e.sourceSpan, r), ...c]);
                        return this._pipeBindExprs.push(u), u
                    }
                    updatePipeSlotOffsets(e) {
                        this._pipeBindExprs.forEach(t => {
                            t.args[1].value += e
                        })
                    }
                    visitLiteralArray(e, t) {
                        return new Do(e.span, e.sourceSpan, this.visitAll(e.expressions), e => {
                            const t = Ct(e);
                            return Eu(this.constantPool, t, this.allocatePureFunctionSlots)
                        })
                    }
                    visitLiteralMap(e, t) {
                        return new Do(e.span, e.sourceSpan, this.visitAll(e.values), t => {
                            const n = St(t.map((t, n) => ({
                                key: e.keys[n].key,
                                value: t,
                                quoted: e.keys[n].quoted
                            })));
                            return Eu(this.constantPool, n, this.allocatePureFunctionSlots)
                        })
                    }
                }
                const vu = [jn.pipeBind1, jn.pipeBind2, jn.pipeBind3, jn.pipeBind4];
                const _u = [jn.pureFunction0, jn.pureFunction1, jn.pureFunction2, jn.pureFunction3, jn.pureFunction4, jn.pureFunction5, jn.pureFunction6, jn.pureFunction7, jn.pureFunction8];

                function bu(e, t, n) {
                    return _t(t, null, e).callFn(n, e)
                }

                function wu(e) {
                    return _t(jn.nextContext).callFn(e > 1 ? [At(e)] : [])
                }

                function Eu(e, t, n) {
                    const {
                        literalFactory: s,
                        literalFactoryArguments: r
                    } = e.getLiteralFactory(t), i = n(1 + r.length), {
                        identifier: o,
                        isVarLength: a
                    } = function(e) {
                        const t = _u[e.length];
                        return {
                            identifier: t || jn.pureFunctionV,
                            isVarLength: !t
                        }
                    }(r), l = [At(i), s];
                    return a ? l.push(Ct(r)) : l.push(...r), _t(o).callFn(l)
                }

                function Cu(e) {
                    const [t, n] = r(e), s = At(n);
                    return t ? [At(0), At(t), s] : [s]
                }
                const Su = "$$shared_ctx$$";
                class xu {
                    constructor(e = 0, t = null, n) {
                        if (this.bindingLevel = e, this.parent = t, this.globals = n, this.map = new Map, this.referenceNameIndex = 0, this.restoreViewVariable = null, void 0 !== n)
                            for (const s of n) this.set(0, s, vt(s))
                    }
                    static createRootScope() {
                        return new xu
                    }
                    get(e) {
                        let t = this;
                        for (; t;) {
                            let n = t.map.get(e);
                            if (null != n) return t !== this && (n = {
                                retrievalLevel: n.retrievalLevel,
                                lhs: n.lhs,
                                declareLocalCallback: n.declareLocalCallback,
                                declare: !1,
                                priority: n.priority,
                                localRef: n.localRef
                            }, this.map.set(e, n), this.maybeGenerateSharedContextVar(n), this.maybeRestoreView(n.retrievalLevel, n.localRef)), n.declareLocalCallback && !n.declare && (n.declare = !0), n.lhs;
                            t = t.parent
                        }
                        return 0 === this.bindingLevel ? null : this.getComponentProperty(e)
                    }
                    set(e, t, n, s = 0, r, i) {
                        if (this.map.has(t)) {
                            if (i) return this;
                            $t(`The name ${t} is already defined in scope to be ${this.map.get(t)}`)
                        }
                        return this.map.set(t, {
                            retrievalLevel: e,
                            lhs: n,
                            declare: !1,
                            declareLocalCallback: r,
                            priority: s,
                            localRef: i || !1
                        }), this
                    }
                    getLocal(e) {
                        return this.get(e)
                    }
                    notifyImplicitReceiverUse() {
                        0 !== this.bindingLevel && (this.map.get("$$shared_ctx$$0").declare = !0)
                    }
                    nestedScope(e, t) {
                        const n = new xu(e, this, t);
                        return e > 0 && n.generateSharedContextVar(0), n
                    }
                    getOrCreateSharedContextVar(e) {
                        const t = Su + e;
                        return this.map.has(t) || this.generateSharedContextVar(e), this.map.get(t).lhs
                    }
                    getSharedContextName(e) {
                        const t = this.map.get(Su + e);
                        return t && t.declare ? t.lhs : null
                    }
                    maybeGenerateSharedContextVar(e) {
                        if (1 === e.priority && e.retrievalLevel < this.bindingLevel) {
                            const t = this.map.get(Su + e.retrievalLevel);
                            t ? t.declare = !0 : this.generateSharedContextVar(e.retrievalLevel)
                        }
                    }
                    generateSharedContextVar(e) {
                        const t = vt(hr + this.freshReferenceName());
                        this.map.set(Su + e, {
                            retrievalLevel: e,
                            lhs: t,
                            declareLocalCallback: (e, n) => [t.set(wu(n)).toConstDecl()],
                            declare: !1,
                            priority: 2,
                            localRef: !1
                        })
                    }
                    getComponentProperty(e) {
                        const t = this.map.get("$$shared_ctx$$0");
                        return t.declare = !0, this.maybeRestoreView(0, !1), t.lhs.prop(e)
                    }
                    maybeRestoreView(e, t) {
                        this.isListenerScope() && (e < this.bindingLevel || t) && (this.parent.restoreViewVariable || (this.parent.restoreViewVariable = vt(this.parent.freshReferenceName())), this.restoreViewVariable = this.parent.restoreViewVariable)
                    }
                    restoreViewStatement() {
                        return this.restoreViewVariable ? [bu(null, jn.restoreView, [this.restoreViewVariable]).toStmt()] : []
                    }
                    viewSnapshotStatements() {
                        const e = bu(null, jn.getCurrentView, []);
                        return this.restoreViewVariable ? [this.restoreViewVariable.set(e).toConstDecl()] : []
                    }
                    isListenerScope() {
                        return this.parent && this.parent.bindingLevel === this.bindingLevel
                    }
                    variableDeclarations() {
                        let e = 0;
                        return Array.from(this.map.values()).filter(e => e.declare).sort((e, t) => t.retrievalLevel - e.retrievalLevel || t.priority - e.priority).reduce((t, n) => {
                            const s = this.bindingLevel - n.retrievalLevel,
                                r = n.declareLocalCallback(this, s - e);
                            return e = s, t.concat(r)
                        }, [])
                    }
                    freshReferenceName() {
                        let e = this;
                        for (; e.parent;) e = e.parent;
                        return "_r" + e.referenceNameIndex++
                    }
                }

                function Tu(e, t) {
                    const n = new g,
                        s = r(e)[1];
                    return n.setElement(s), Object.getOwnPropertyNames(t).forEach(e => {
                        const s = r(e)[1],
                            i = t[e];
                        if (n.addAttribute(s, i), "class" === e.toLowerCase()) {
                            i.trim().split(/\s+/).forEach(e => n.addClassName(e))
                        }
                    }), n
                }

                function Au(e) {
                    switch (Cr(e)) {
                        case 1:
                            return jn.propertyInterpolate;
                        case 3:
                            return jn.propertyInterpolate1;
                        case 5:
                            return jn.propertyInterpolate2;
                        case 7:
                            return jn.propertyInterpolate3;
                        case 9:
                            return jn.propertyInterpolate4;
                        case 11:
                            return jn.propertyInterpolate5;
                        case 13:
                            return jn.propertyInterpolate6;
                        case 15:
                            return jn.propertyInterpolate7;
                        case 17:
                            return jn.propertyInterpolate8;
                        default:
                            return jn.propertyInterpolateV
                    }
                }
                const Du = new Mc;

                function Pu(e = Fr) {
                    return new Il(new Cc(new cc), e, Du, null, [])
                }

                function ku(e, t) {
                    switch (e) {
                        case z.HTML:
                            return _t(jn.sanitizeHtml);
                        case z.SCRIPT:
                            return _t(jn.sanitizeScript);
                        case z.STYLE:
                            return t ? _t(jn.sanitizeStyle) : null;
                        case z.URL:
                            return _t(jn.sanitizeUrl);
                        case z.RESOURCE_URL:
                            return _t(jn.sanitizeResourceUrl);
                        default:
                            return null
                    }
                }

                function Ou(e, t) {
                    const n = gr(t.value);
                    switch (Du.securityContext(e, t.name, !0)) {
                        case z.HTML:
                            return _t(jn.trustConstantHtml).callFn([n], t.valueSpan);
                        case z.SCRIPT:
                            return _t(jn.trustConstantScript).callFn([n], t.valueSpan);
                        case z.RESOURCE_URL:
                            return _t(jn.trustConstantResourceUrl).callFn([n], t.valueSpan);
                        default:
                            return n
                    }
                }

                function Iu(e) {
                    return e instanceof Hn || e instanceof Un || e instanceof Xn
                }

                function Nu(e) {
                    return e.every(Iu)
                }
                const Mu = "ngI18nClosureMode";

                function Fu() {
                    return Et(vt(Mu)).notIdentical(At("undefined", ae)).and(vt(Mu))
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Ru = /attr\.([^\]]+)/;

                function ju(e, t, n) {
                    const s = new br,
                        r = Q(e.selector);
                    return s.set("type", e.internalType), r.length > 0 && s.set("selectors", gr(r)), e.queries.length > 0 && s.set("contentQueries", function(e, t, n) {
                        const s = [],
                            r = [],
                            i = dr(r, ur);
                        for (const a of e) {
                            const e = a.static ? jn.staticContentQuery : jn.contentQuery;
                            s.push(_t(e).callFn([vt("dirIndex"), ...Bu(a, t)]).toStmt());
                            const n = i(),
                                o = _t(jn.loadQuery).callFn([]),
                                l = _t(jn.queryRefresh).callFn([n.set(o)]),
                                c = vt(hr).prop(a.propertyName).set(a.first ? n.prop("first") : n);
                            r.push(l.and(c).toStmt())
                        }
                        const o = n ? `${n}_ContentQueries` : null;
                        return xt([new Ve(pr, oe), new Ve(hr, null), new Ve("dirIndex", null)], [fu(1, s), fu(2, r)], re, null, o)
                    }(e.queries, t, e.name)), e.viewQueries.length && s.set("viewQuery", function(e, t, n) {
                        const s = [],
                            r = [],
                            i = dr(r, ur);
                        e.forEach(e => {
                            const n = _t(e.static ? jn.staticViewQuery : jn.viewQuery).callFn(Bu(e, t));
                            s.push(n.toStmt());
                            const o = i(),
                                a = _t(jn.loadQuery).callFn([]),
                                l = _t(jn.queryRefresh).callFn([o.set(a)]),
                                c = vt(hr).prop(e.propertyName).set(e.first ? o.prop("first") : o);
                            r.push(l.and(c).toStmt())
                        });
                        const o = n ? `${n}_Query` : null;
                        return xt([new Ve(pr, oe), new Ve(hr, null)], [fu(1, s), fu(2, r)], re, null, o)
                    }(e.viewQueries, t, e.name)), s.set("hostBindings", function(e, t, n, s, r, i, o) {
                        const a = vt(hr),
                            l = new sc(a),
                            {
                                styleAttr: c,
                                classAttr: u
                            } = e.specialAttributes;
                        void 0 !== c && l.registerStyleAttr(c);
                        void 0 !== u && l.registerClassAttr(u);
                        const h = [],
                            p = [],
                            d = t,
                            f = Wu(e),
                            m = n.createDirectiveHostEventAsts(f, d);
                        if (m && m.length) {
                            const e = function(e, t) {
                                const n = [],
                                    s = [],
                                    r = [];
                                e.forEach(e => {
                                    let r = e.name && mn(e.name);
                                    const i = 1 === e.type ? Bn(r, e.targetOrPhase) : r,
                                        o = t && r ? `${t}_${i}_HostBindingHandler` : null,
                                        a = mu(Wn.fromParsedEvent(e), o);
                                    1 == e.type ? s.push(a) : n.push(a)
                                }), s.length > 0 && r.push(Er(jn.syntheticHostListener, s).toStmt());
                                n.length > 0 && r.push(Er(jn.listener, n).toStmt());
                                return r
                            }(m, i);
                            h.push(...e)
                        }
                        const g = n.createBoundHostProperties(f, d),
                            y = [];
                        let v, _ = 0;
                        g && g.forEach(e => {
                            l.registerInputBasedOnName(e.name, e.expression, d) ? _ += 2 : (y.push(e), _++)
                        });
                        const b = () => {
                                if (!v) {
                                    v = new yu(s, () => $t("Unexpected node"), e => {
                                        const t = _;
                                        return _ += e, t
                                    }, () => $t("Unexpected pipe"))
                                }
                                return v
                            },
                            w = [],
                            E = [],
                            C = [];
                        y.forEach(e => {
                            const t = e.expression.visit(b()),
                                s = zu(a, t),
                                {
                                    bindingName: i,
                                    instruction: o,
                                    isAttribute: l
                                } = function(e) {
                                    let t, n = e.name;
                                    const s = n.match(Ru);
                                    s ? (n = s[1], t = jn.attribute) : e.isAnimation ? (n = $n(n), t = jn.syntheticHostProperty) : t = jn.hostProperty;
                                    return {
                                        bindingName: n,
                                        instruction: t,
                                        isAttribute: !!s
                                    }
                                }(e),
                                c = n.calcPossibleSecurityContexts(r, i, l).filter(e => e !== z.NONE);
                            let u = null;
                            c.length && (u = 2 === c.length && c.indexOf(z.URL) > -1 && c.indexOf(z.RESOURCE_URL) > -1 ? _t(jn.sanitizeUrlOrResourceUrl) : ku(c[0], l));
                            const h = [At(i), s.currValExpr];
                            u && h.push(u), p.push(...s.stmts), o === jn.hostProperty ? w.push(h) : o === jn.attribute ? E.push(h) : o === jn.syntheticHostProperty ? C.push(h) : p.push(_t(o).callFn(h).toStmt())
                        }), w.length > 0 && p.push(Er(jn.hostProperty, w).toStmt());
                        E.length > 0 && p.push(Er(jn.attribute, E).toStmt());
                        C.length > 0 && p.push(Er(jn.syntheticHostProperty, C).toStmt());
                        const S = function(e) {
                            const t = [];
                            for (let n of Object.getOwnPropertyNames(e)) {
                                const s = e[n];
                                t.push(At(n), s)
                            }
                            return t
                        }(e.attributes);
                        l.assignHostAttrs(S, o), l.hasBindings && l.buildUpdateLevelInstructions(b()).forEach(e => {
                            if (e.calls.length > 0) {
                                const t = [];
                                e.calls.forEach(e => {
                                    _ += Math.max(e.allocateBindingSlots - 2, 0), t.push(function(e, t, n) {
                                        return e.params(e => n(t, e).currValExpr)
                                    }(e, a, zu))
                                }), p.push(Er(e.reference, t).toStmt())
                            }
                        });
                        _ && o.set("hostVars", At(_));
                        if (h.length > 0 || p.length > 0) {
                            const e = i ? `${i}_HostBindings` : null,
                                t = [];
                            return h.length > 0 && t.push(fu(1, h)), p.length > 0 && t.push(fu(2, p)), xt([new Ve(pr, oe), new Ve(hr, null)], t, re, null, e)
                        }
                        return null
                    }(e.host, e.typeSourceSpan, n, t, e.selector || "", e.name, s)), s.set("inputs", yr(e.inputs, !0)), s.set("outputs", yr(e.outputs)), null !== e.exportAs && s.set("exportAs", Ct(e.exportAs.map(e => At(e)))), s
                }

                function Lu(e, t) {
                    const n = [],
                        s = t.providers,
                        r = t.viewProviders;
                    if (s || r) {
                        const e = [s || new ze([])];
                        r && e.push(r), n.push(_t(jn.ProvidersFeature).callFn(e))
                    }
                    t.usesInheritance && n.push(_t(jn.InheritDefinitionFeature)), t.fullInheritance && n.push(_t(jn.CopyDefinitionFeature)), t.lifecycle.usesOnChanges && n.push(_t(jn.NgOnChangesFeature)), n.length && e.set("features", Ct(n))
                }

                function Vu(e, t, n) {
                    const s = ju(e, t, n);
                    Lu(s, e);
                    const r = _t(jn.defineDirective).callFn([s.toLiteralMap()]),
                        i = qu(e);
                    return {
                        expression: r,
                        type: wt(_t(jn.DirectiveDefWithMeta, i))
                    }
                }

                function $u(e, t, n) {
                    const s = ju(e, t, n);
                    Lu(s, e);
                    const r = e.selector && g.parse(e.selector),
                        i = r && r[0];
                    if (i) {
                        const e = i.getAttrs();
                        e.length && s.set("attrs", t.getConstLiteral(Ct(e.map(e => At(null != e ? e : void 0))), !0))
                    }
                    let o = null;
                    if (e.directives.length > 0) {
                        const t = new y;
                        for (const {
                                selector: n,
                                expression: s
                            } of e.directives) t.addSelectables(g.parse(n), s);
                        o = t
                    }
                    const a = e.name,
                        l = a ? `${a}_Template` : null,
                        c = new Set,
                        u = new Set,
                        h = e.changeDetection,
                        p = e.template,
                        d = new gu(t, xu.createRootScope(), 0, a, null, null, l, o, c, e.pipes, u, jn.namespaceHTML, e.relativeContextFilePath, e.i18nUseExternalIds),
                        f = d.buildTemplateFunction(p.nodes, []),
                        m = d.getNgContentSelectors();
                    m && s.set("ngContentSelectors", m), s.set("decls", At(d.getConstCount())), s.set("vars", At(d.getVarCount()));
                    const {
                        constExpressions: v,
                        prepareStatements: _
                    } = d.getConsts();
                    if (v.length > 0) {
                        let e = Ct(v);
                        _.length > 0 && (e = xt([], [..._, new rt(e)])), s.set("consts", e)
                    }
                    if (s.set("template", f), c.size) {
                        let t = Ct(Array.from(c));
                        e.wrapDirectivesAndPipesInClosure && (t = xt([], [new rt(t)])), s.set("directives", t)
                    }
                    if (u.size) {
                        let t = Ct(Array.from(u));
                        e.wrapDirectivesAndPipesInClosure && (t = xt([], [new rt(t)])), s.set("pipes", t)
                    }
                    if (null === e.encapsulation && (e.encapsulation = D.Emulated), e.styles && e.styles.length) {
                        const n = (e.encapsulation == D.Emulated ? function(e, t, n) {
                                const s = new Po;
                                return e.map(e => s.shimCssText(e, t, n))
                            }
                            /**
                             * @license
                             * Copyright Google LLC All Rights Reserved.
                             *
                             * Use of this source code is governed by an MIT-style license that can be
                             * found in the LICENSE file at https://angular.io/license
                             */
                            (e.styles, ia, ra) : e.styles).map(e => t.getConstLiteral(At(e)));
                        s.set("styles", Ct(n))
                    } else e.encapsulation === D.Emulated && (e.encapsulation = D.None);
                    e.encapsulation !== D.Emulated && s.set("encapsulation", At(e.encapsulation)), null !== e.animations && s.set("data", St([{
                        key: "animation",
                        value: e.animations,
                        quoted: !1
                    }])), null != h && h !== P.Default && s.set("changeDetection", At(h));
                    const b = _t(jn.defineComponent).callFn([s.toLiteralMap()]),
                        w = qu(e);
                    w.push(Uu(e.template.ngContentSelectors));
                    return {
                        expression: b,
                        type: wt(_t(jn.ComponentDefWithMeta, w))
                    }
                }

                function Bu(e, t) {
                    const n = [_r(e, t), At(e.descendants)];
                    return e.read && n.push(e.read), n
                }

                function Hu(e) {
                    return wt(St(Object.keys(e).map(t => ({
                        key: t,
                        value: At(Array.isArray(e[t]) ? e[t][0] : e[t]),
                        quoted: !0
                    }))))
                }

                function Uu(e) {
                    return e.length > 0 ? wt(Ct(e.map(e => At(e)))) : le
                }

                function qu(e) {
                    const t = null !== e.selector ? e.selector.replace(/\n/g, "") : null;
                    return [Vn(e.type.type, e.typeArgumentCount), null !== t ? (n = t, wt(At(n))) : le, null !== e.exportAs ? Uu(e.exportAs) : le, Hu(e.inputs), Hu(e.outputs), Uu(e.queries.map(e => e.propertyName))];
                    var n
                }

                function zu(e, t) {
                    return vo(null, e, t, "b", wi.Expression, () => $t("Unexpected interpolation"))
                }

                function Wu(e) {
                    return {
                        hostAttributes: {},
                        hostListeners: e.listeners,
                        hostProperties: e.properties
                    }
                }
                const Gu = /^(?:\[([^\]]+)\])|(?:\(([^\)]+)\))$/;
                class Ku {
                    get(e) {
                        return ""
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Qu {
                    constructor(e = new Zr) {
                        this.jitEvaluator = e, this.R3ResolvedDependencyType = Tr, this.R3FactoryTarget = xr, this.ResourceLoader = Ku, this.elementSchemaRegistry = new Mc
                    }
                    compilePipe(e, t, n) {
                        const s = Pi({
                            name: n.name,
                            type: eh(n.type),
                            internalType: new ve(n.type),
                            typeArgumentCount: n.typeArgumentCount,
                            deps: oh(n.deps),
                            pipeName: n.pipeName,
                            pure: n.pure
                        });
                        return this.jitExpression(s.expression, e, t, [])
                    }
                    compileInjectable(e, t, n) {
                        const {
                            expression: s,
                            statements: r
                        } = function(e) {
                            let t = null;
                            const n = {
                                name: e.name,
                                type: e.type,
                                internalType: e.internalType,
                                typeArgumentCount: e.typeArgumentCount,
                                deps: [],
                                injectFn: cn.inject,
                                target: xr.Injectable
                            };
                            if (void 0 !== e.useClass) {
                                const s = e.useClass.isEquivalent(e.internalType);
                                let r;
                                void 0 !== e.userDeps && (r = e.userDeps), t = void 0 !== r ? Ar(Object.assign(Object.assign({}, n), {
                                    delegate: e.useClass,
                                    delegateDeps: r,
                                    delegateType: Sr.Class
                                })) : s ? Ar(n) : kr(e.type.value, e.useClass)
                            } else t = void 0 !== e.useFactory ? void 0 !== e.userDeps ? Ar(Object.assign(Object.assign({}, n), {
                                delegate: e.useFactory,
                                delegateDeps: e.userDeps || [],
                                delegateType: Sr.Function
                            })) : {
                                statements: [],
                                factory: xt([], [new rt(e.useFactory.callFn([]))])
                            } : void 0 !== e.useValue ? Ar(Object.assign(Object.assign({}, n), {
                                expression: e.useValue
                            })) : void 0 !== e.useExisting ? Ar(Object.assign(Object.assign({}, n), {
                                expression: _t(cn.inject).callFn([e.useExisting])
                            })) : kr(e.type.value, e.internalType);
                            const s = {
                                token: e.internalType,
                                factory: t.factory
                            };
                            return null !== e.providedIn.value && (s.providedIn = e.providedIn), {
                                expression: _t(cn.\u0275\ u0275defineInjectable).callFn([Ln(s)]),
                                type: new ee(_t(cn.InjectableDef, [Vn(e.type.type, e.typeArgumentCount)])),
                                statements: t.statements
                            }
                        }({
                            name: n.name,
                            type: eh(n.type),
                            internalType: new ve(n.type),
                            typeArgumentCount: n.typeArgumentCount,
                            providedIn: rh(n.providedIn),
                            useClass: sh(n, Zu),
                            useFactory: sh(n, Ju),
                            useValue: sh(n, Xu),
                            useExisting: sh(n, Yu),
                            userDeps: oh(n.userDeps) || void 0
                        });
                        return this.jitExpression(s, e, t, r)
                    }
                    compileInjector(e, t, n) {
                        const s = function(e) {
                            const t = Ar({
                                    name: e.name,
                                    type: e.type,
                                    internalType: e.internalType,
                                    typeArgumentCount: 0,
                                    deps: e.deps,
                                    injectFn: jn.inject,
                                    target: xr.NgModule
                                }),
                                n = {
                                    factory: t.factory
                                };
                            return null !== e.providers && (n.providers = e.providers), e.imports.length > 0 && (n.imports = Ct(e.imports)), {
                                expression: _t(jn.defineInjector).callFn([Ln(n)]),
                                type: new ee(_t(jn.InjectorDef, [new ee(e.type.type)])),
                                statements: t.statements
                            }
                        }({
                            name: n.name,
                            type: eh(n.type),
                            internalType: new ve(n.type),
                            deps: oh(n.deps),
                            providers: new ve(n.providers),
                            imports: n.imports.map(e => new ve(e))
                        });
                        return this.jitExpression(s.expression, e, t, s.statements)
                    }
                    compileNgModule(e, t, n) {
                        const s = Ti({
                            type: eh(n.type),
                            internalType: new ve(n.type),
                            adjacentType: new ve(n.type),
                            bootstrap: n.bootstrap.map(eh),
                            declarations: n.declarations.map(eh),
                            imports: n.imports.map(eh),
                            exports: n.exports.map(eh),
                            emitInline: !0,
                            containsForwardDecls: !1,
                            schemas: n.schemas ? n.schemas.map(eh) : null,
                            id: n.id ? new ve(n.id) : null
                        });
                        return this.jitExpression(s.expression, e, t, [])
                    }
                    compileDirective(e, t, n) {
                        const s = new nn,
                            r = Pu(),
                            i = Vu(nh(n), s, r);
                        return this.jitExpression(i.expression, e, t, s.statements)
                    }
                    compileComponent(e, t, n) {
                        const s = new nn,
                            r = n.interpolation ? Mr.fromArray(n.interpolation) : Fr,
                            i = function(e, t, n = {}) {
                                const {
                                    interpolationConfig: s,
                                    preserveWhitespaces: r,
                                    enableI18nLegacyMessageIdFormat: i
                                } = n, o = Pu(s), a = (new Ha).parse(e, t, Object.assign(Object.assign({
                                    leadingTriviaChars: du
                                }, n), {
                                    tokenizeExpansionForms: !0
                                }));
                                if (a.errors && a.errors.length > 0) return {
                                    interpolationConfig: s,
                                    preserveWhitespaces: r,
                                    template: e,
                                    errors: a.errors,
                                    nodes: [],
                                    styleUrls: [],
                                    styles: [],
                                    ngContentSelectors: []
                                };
                                let l = a.rootNodes;
                                const c = new ru(s, !r, i);
                                l = ya(c, l), r || (l = ya(new Qa, l), c.hasI18nMeta && (l = ya(new ru(s, !1), l)));
                                const {
                                    nodes: u,
                                    errors: h,
                                    styleUrls: p,
                                    styles: d,
                                    ngContentSelectors: f
                                } = Rc(l, o);
                                return {
                                    interpolationConfig: s,
                                    preserveWhitespaces: r,
                                    errors: h.length > 0 ? h : null,
                                    template: e,
                                    nodes: u,
                                    styleUrls: p,
                                    styles: d,
                                    ngContentSelectors: f
                                }
                            }(n.template, t, {
                                preserveWhitespaces: n.preserveWhitespaces,
                                interpolationConfig: r
                            });
                        if (null !== i.errors) {
                            const e = i.errors.map(e => e.toString()).join(", ");
                            throw new Error(`Errors during JIT compilation of template for ${n.name}: ${e}`)
                        }
                        const o = $u(Object.assign(Object.assign(Object.assign({}, n), nh(n)), {
                                selector: n.selector || this.elementSchemaRegistry.getDefaultComponentElementName(),
                                template: i,
                                wrapDirectivesAndPipesInClosure: !1,
                                styles: [...n.styles, ...i.styles],
                                encapsulation: n.encapsulation,
                                interpolation: r,
                                changeDetection: n.changeDetection,
                                animations: null != n.animations ? new ve(n.animations) : null,
                                viewProviders: null != n.viewProviders ? new ve(n.viewProviders) : null,
                                relativeContextFilePath: "",
                                i18nUseExternalIds: !0
                            }), s, Pu(r)),
                            a = `ng:///${n.name}.js`;
                        return this.jitExpression(o.expression, e, a, s.statements)
                    }
                    compileFactory(e, t, n) {
                        const s = Ar({
                            name: n.name,
                            type: eh(n.type),
                            internalType: new ve(n.type),
                            typeArgumentCount: n.typeArgumentCount,
                            deps: oh(n.deps),
                            injectFn: "directiveInject" === n.injectFn ? cn.directiveInject : cn.inject,
                            target: n.target
                        });
                        return this.jitExpression(s.factory, e, t, s.statements)
                    }
                    createParseSourceSpan(e, t, n) {
                        return function(e, t, n) {
                            const s = new yi("", `in ${e} ${t} in ${n}`);
                            return new vi(new gi(s, -1, -1, -1), new gi(s, -1, -1, -1))
                        }(e, t, n)
                    }
                    jitExpression(e, t, n, s) {
                        const r = [...s, new tt("$def", e, void 0, [Je.Exported])];
                        return this.jitEvaluator.evaluateStatements(n, r, new Si(t), !0).$def
                    }
                }
                const Zu = Object.keys({
                        useClass: null
                    })[0],
                    Ju = Object.keys({
                        useFactory: null
                    })[0],
                    Xu = Object.keys({
                        useValue: null
                    })[0],
                    Yu = Object.keys({
                        useExisting: null
                    })[0],
                    eh = function(e) {
                        const t = new ve(e);
                        return {
                            value: t,
                            type: t
                        }
                    };

                function th(e) {
                    return Object.assign(Object.assign({}, e), {
                        predicate: Array.isArray(e.predicate) ? e.predicate : new ve(e.predicate),
                        read: e.read ? new ve(e.read) : null,
                        static: e.static
                    })
                }

                function nh(e) {
                    const t = uh(e.inputs || []),
                        n = uh(e.outputs || []),
                        s = e.propMetadata,
                        r = {},
                        i = {};
                    for (const o in s) s.hasOwnProperty(o) && s[o].forEach(e => {
                        "Input" === e.ngMetadataName ? r[o] = e.bindingPropertyName ? [e.bindingPropertyName, o] : o : ch(e) && (i[o] = e.bindingPropertyName || o)
                    });
                    return Object.assign(Object.assign({}, e), {
                        typeSourceSpan: e.typeSourceSpan,
                        type: eh(e.type),
                        internalType: new ve(e.type),
                        deps: oh(e.deps),
                        host: ah(e.propMetadata, e.typeSourceSpan, e.host),
                        inputs: Object.assign(Object.assign({}, t), r),
                        outputs: Object.assign(Object.assign({}, n), i),
                        queries: e.queries.map(th),
                        providers: null != e.providers ? new ve(e.providers) : null,
                        viewQueries: e.viewQueries.map(th),
                        fullInheritance: !1
                    })
                }

                function sh(e, t) {
                    return e.hasOwnProperty(t) ? new ve(e[t]) : void 0
                }

                function rh(e) {
                    return null == e || "string" == typeof e ? new xe(e) : new ve(e)
                }

                function ih(e) {
                    let t;
                    return t = null === e.token ? new xe(null) : e.resolved === Tr.Attribute ? new xe(e.token) : new ve(e.token), {
                        token: t,
                        attribute: null,
                        resolved: e.resolved,
                        host: e.host,
                        optional: e.optional,
                        self: e.self,
                        skipSelf: e.skipSelf
                    }
                }

                function oh(e) {
                    return null == e ? null : e.map(ih)
                }

                function ah(e, t, n) {
                    const s = function(e) {
                            const t = {},
                                n = {},
                                s = {},
                                r = {};
                            for (const i of Object.keys(e)) {
                                const o = e[i],
                                    a = i.match(Gu);
                                if (null === a) switch (i) {
                                    case "class":
                                        if ("string" != typeof o) throw new Error("Class binding must be string");
                                        r.classAttr = o;
                                        break;
                                    case "style":
                                        if ("string" != typeof o) throw new Error("Style binding must be string");
                                        r.styleAttr = o;
                                        break;
                                    default:
                                        t[i] = "string" == typeof o ? At(o) : o
                                } else if (null != a[1]) {
                                    if ("string" != typeof o) throw new Error("Property binding must be string");
                                    s[a[1]] = o
                                } else if (null != a[2]) {
                                    if ("string" != typeof o) throw new Error("Event binding must be string");
                                    n[a[2]] = o
                                }
                            }
                            return {
                                attributes: t,
                                listeners: n,
                                properties: s,
                                specialAttributes: r
                            }
                        }(n || {}),
                        r = function(e, t) {
                            const n = Wu(e),
                                s = Pu();
                            return s.createDirectiveHostEventAsts(n, t), s.createBoundHostProperties(n, t), s.errors
                        }(s, t);
                    if (r.length) throw new Error(r.map(e => e.msg).join("\n"));
                    for (const i in e) e.hasOwnProperty(i) && e[i].forEach(e => {
                        "HostBinding" === e.ngMetadataName ? s.properties[e.hostPropertyName || i] = i : lh(e) && (s.listeners[e.eventName || i] = `${i}(${(e.args||[]).join(",")})`)
                    });
                    return s
                }

                function lh(e) {
                    return "HostListener" === e.ngMetadataName
                }

                function ch(e) {
                    return "Output" === e.ngMetadataName
                }

                function uh(e) {
                    return e.reduce((e, t) => {
                        const [n, s] = t.split(",").map(e => e.trim());
                        return e[n] = s || n, e
                    }, {})
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                new class {
                    constructor(e) {
                        this.full = e;
                        const t = e.split(".");
                        this.major = t[0], this.minor = t[1], this.patch = t.slice(2).join(".")
                    }
                }("11.0.7");
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class hh {
                    constructor({
                        defaultEncapsulation: e = D.Emulated,
                        useJit: t = !0,
                        jitDevMode: n = !1,
                        missingTranslation: s = null,
                        preserveWhitespaces: r,
                        strictInjectionParameters: i
                    } = {}) {
                        this.defaultEncapsulation = e, this.useJit = !!t, this.jitDevMode = !!n, this.missingTranslation = s, this.preserveWhitespaces = ph(Ft(r)), this.strictInjectionParameters = !0 === i
                    }
                }

                function ph(e, t = !1) {
                    return null === e ? t : e
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class dh {
                    constructor(e, t, n, s) {
                        this._resourceLoader = e, this._urlResolver = t, this._htmlParser = n, this._config = s, this._resourceLoaderCache = new Map
                    }
                    clearCache() {
                        this._resourceLoaderCache.clear()
                    }
                    clearCacheFor(e) {
                        if (!e.isComponent) return;
                        const t = e.template;
                        this._resourceLoaderCache.delete(t.templateUrl), t.externalStylesheets.forEach(e => {
                            this._resourceLoaderCache.delete(e.moduleUrl)
                        })
                    }
                    _fetch(e) {
                        let t = this._resourceLoaderCache.get(e);
                        return t || (t = this._resourceLoader.get(e), this._resourceLoaderCache.set(e, t)), t
                    }
                    normalizeTemplate(e) {
                        if (Mt(e.template)) {
                            if (Mt(e.templateUrl)) throw Bt(`'${Wt(e.componentType)}' component cannot define both template and templateUrl`);
                            if ("string" != typeof e.template) throw Bt(`The template specified for component ${Wt(e.componentType)} is not a string`)
                        } else {
                            if (!Mt(e.templateUrl)) throw Bt(`No template specified for component ${Wt(e.componentType)}`);
                            if ("string" != typeof e.templateUrl) throw Bt(`The templateUrl specified for component ${Wt(e.componentType)} is not a string`)
                        }
                        if (Mt(e.preserveWhitespaces) && "boolean" != typeof e.preserveWhitespaces) throw Bt(`The preserveWhitespaces option for component ${Wt(e.componentType)} must be a boolean`);
                        return Lt(this._preParseTemplate(e), t => this._normalizeTemplateMetadata(e, t))
                    }
                    _preParseTemplate(e) {
                        let t, n;
                        return null != e.template ? (t = e.template, n = e.moduleUrl) : (n = this._urlResolver.resolve(e.moduleUrl, e.templateUrl), t = this._fetch(n)), Lt(t, t => this._preparseLoadedTemplate(e, t, n))
                    }
                    _preparseLoadedTemplate(e, t, n) {
                        const s = !!e.template,
                            r = Mr.fromArray(e.interpolation),
                            i = Fn({
                                reference: e.ngModuleType
                            }, {
                                type: {
                                    reference: e.componentType
                                }
                            }, {
                                isInline: s,
                                templateUrl: n
                            }),
                            o = this._htmlParser.parse(t, i, {
                                tokenizeExpansionForms: !0,
                                interpolationConfig: r
                            });
                        if (o.errors.length > 0) {
                            throw Bt(`Template parse errors:\n${o.errors.join("\n")}`)
                        }
                        const a = this._normalizeStylesheet(new xn({
                                styles: e.styles,
                                moduleUrl: e.moduleUrl
                            })),
                            l = new fh;
                        ya(l, o.rootNodes);
                        const c = this._normalizeStylesheet(new xn({
                            styles: l.styles,
                            styleUrls: l.styleUrls,
                            moduleUrl: n
                        }));
                        return {
                            template: t,
                            templateUrl: n,
                            isInline: s,
                            htmlAst: o,
                            styles: a.styles.concat(c.styles),
                            inlineStyleUrls: a.styleUrls.concat(c.styleUrls),
                            styleUrls: this._normalizeStylesheet(new xn({
                                styleUrls: e.styleUrls,
                                moduleUrl: e.moduleUrl
                            })).styleUrls,
                            ngContentSelectors: l.ngContentSelectors
                        }
                    }
                    _normalizeTemplateMetadata(e, t) {
                        return Lt(this._loadMissingExternalStylesheets(t.styleUrls.concat(t.inlineStyleUrls)), n => this._normalizeLoadedTemplateMetadata(e, t, n))
                    }
                    _normalizeLoadedTemplateMetadata(e, t, n) {
                        const s = [...t.styles];
                        this._inlineStyles(t.inlineStyleUrls, n, s);
                        const r = t.styleUrls,
                            i = r.map(e => {
                                const t = n.get(e),
                                    s = [...t.styles];
                                return this._inlineStyles(t.styleUrls, n, s), new xn({
                                    moduleUrl: e,
                                    styles: s
                                })
                            });
                        let o = e.encapsulation;
                        return null == o && (o = this._config.defaultEncapsulation), o === D.Emulated && 0 === s.length && 0 === r.length && (o = D.None), new Tn({
                            encapsulation: o,
                            template: t.template,
                            templateUrl: t.templateUrl,
                            htmlAst: t.htmlAst,
                            styles: s,
                            styleUrls: r,
                            ngContentSelectors: t.ngContentSelectors,
                            animations: e.animations,
                            interpolation: e.interpolation,
                            isInline: t.isInline,
                            externalStylesheets: i,
                            preserveWhitespaces: ph(e.preserveWhitespaces, this._config.preserveWhitespaces)
                        })
                    }
                    _inlineStyles(e, t, n) {
                        e.forEach(e => {
                            const s = t.get(e);
                            s.styles.forEach(e => n.push(e)), this._inlineStyles(s.styleUrls, t, n)
                        })
                    }
                    _loadMissingExternalStylesheets(e, t = new Map) {
                        return Lt(Vt(e.filter(e => !t.has(e)).map(e => Lt(this._fetch(e), n => {
                            const s = this._normalizeStylesheet(new xn({
                                styles: [n],
                                moduleUrl: e
                            }));
                            return t.set(e, s), this._loadMissingExternalStylesheets(s.styleUrls, t)
                        }))), e => t)
                    }
                    _normalizeStylesheet(e) {
                        const t = e.moduleUrl,
                            n = e.styleUrls.filter(Al).map(e => this._urlResolver.resolve(t, e)),
                            s = e.styles.map(e => {
                                const s = function(e, t, n) {
                                    const s = [],
                                        r = n.replace(Pl, "").replace(Dl, (...n) => {
                                            const r = n[1] || n[2];
                                            return Al(r) ? (s.push(e.resolve(t, r)), "") : n[0]
                                        });
                                    return new Tl(r, s)
                                }(this._urlResolver, t, e);
                                return n.push(...s.styleUrls), s.style
                            });
                        return new xn({
                            styles: s,
                            styleUrls: n,
                            moduleUrl: t
                        })
                    }
                }
                class fh {
                    constructor() {
                        this.ngContentSelectors = [], this.styles = [], this.styleUrls = [], this.ngNonBindableStackCount = 0
                    }
                    visitElement(e, t) {
                        const n = jl(e);
                        switch (n.type) {
                            case Ll.NG_CONTENT:
                                0 === this.ngNonBindableStackCount && this.ngContentSelectors.push(n.selectAttr);
                                break;
                            case Ll.STYLE:
                                let t = "";
                                e.children.forEach(e => {
                                    e instanceof ha && (t += e.value)
                                }), this.styles.push(t);
                                break;
                            case Ll.STYLESHEET:
                                this.styleUrls.push(n.hrefAttr)
                        }
                        return n.nonBindable && this.ngNonBindableStackCount++, ya(this, e.children), n.nonBindable && this.ngNonBindableStackCount--, null
                    }
                    visitExpansion(e, t) {
                        ya(this, e.cases)
                    }
                    visitExpansionCase(e, t) {
                        ya(this, e.expression)
                    }
                    visitComment(e, t) {
                        return null
                    }
                    visitAttribute(e, t) {
                        return null
                    }
                    visitText(e, t) {
                        return null
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const mh = [T, x, S, C];
                class gh {
                    constructor(e) {
                        this._reflector = e
                    }
                    isDirective(e) {
                        const t = this._reflector.annotations(Gt(e));
                        return t && t.some(yh)
                    }
                    resolve(e, t = !0) {
                        const n = this._reflector.annotations(Gt(e));
                        if (n) {
                            const t = vh(n, yh);
                            if (t) {
                                const n = this._reflector.propMetadata(e),
                                    s = this._reflector.guards(e);
                                return this._mergeWithPropertyMetadata(t, n, s, e)
                            }
                        }
                        if (t) throw new Error(`No Directive annotation found on ${Wt(e)}`);
                        return null
                    }
                    _mergeWithPropertyMetadata(e, t, n, s) {
                        const r = [],
                            i = [],
                            o = {},
                            a = {};
                        return Object.keys(t).forEach(e => {
                            const n = vh(t[e], e => I.isTypeOf(e));
                            n && (n.bindingPropertyName ? r.push(`${e}: ${n.bindingPropertyName}`) : r.push(e));
                            const s = vh(t[e], e => N.isTypeOf(e));
                            s && (s.bindingPropertyName ? i.push(`${e}: ${s.bindingPropertyName}`) : i.push(e));
                            t[e].filter(e => M.isTypeOf(e)).forEach(t => {
                                if (t.hostPropertyName) {
                                    const n = t.hostPropertyName[0];
                                    if ("(" === n) throw new Error("@HostBinding can not bind to events. Use @HostListener instead.");
                                    if ("[" === n) throw new Error("@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.");
                                    o[`[${t.hostPropertyName}]`] = e
                                } else o[`[${e}]`] = e
                            });
                            t[e].filter(e => F.isTypeOf(e)).forEach(t => {
                                const n = t.args || [];
                                o[`(${t.eventName})`] = `${e}(${n.join(",")})`
                            });
                            const l = vh(t[e], e => mh.some(t => t.isTypeOf(e)));
                            l && (a[e] = l)
                        }), this._merge(e, r, i, o, a, n, s)
                    }
                    _extractPublicName(e) {
                        return Ot(e, [null, e])[1].trim()
                    }
                    _dedupeBindings(e) {
                        const t = new Set,
                            n = new Set,
                            s = [];
                        for (let r = e.length - 1; r >= 0; r--) {
                            const i = e[r],
                                o = this._extractPublicName(i);
                            n.add(o), t.has(o) || (t.add(o), s.push(i))
                        }
                        return s.reverse()
                    }
                    _merge(e, t, n, s, r, i, o) {
                        const a = this._dedupeBindings(e.inputs ? e.inputs.concat(t) : t),
                            l = this._dedupeBindings(e.outputs ? e.outputs.concat(n) : n),
                            c = e.host ? Object.assign(Object.assign({}, e.host), s) : s,
                            u = e.queries ? Object.assign(Object.assign({}, e.queries), r) : r;
                        if (k.isTypeOf(e)) {
                            const t = e;
                            return k({
                                selector: t.selector,
                                inputs: a,
                                outputs: l,
                                host: c,
                                exportAs: t.exportAs,
                                moduleId: t.moduleId,
                                queries: u,
                                changeDetection: t.changeDetection,
                                providers: t.providers,
                                viewProviders: t.viewProviders,
                                entryComponents: t.entryComponents,
                                template: t.template,
                                templateUrl: t.templateUrl,
                                styles: t.styles,
                                styleUrls: t.styleUrls,
                                encapsulation: t.encapsulation,
                                animations: t.animations,
                                interpolation: t.interpolation,
                                preserveWhitespaces: e.preserveWhitespaces
                            })
                        }
                        return A({
                            selector: e.selector,
                            inputs: a,
                            outputs: l,
                            host: c,
                            exportAs: e.exportAs,
                            queries: u,
                            providers: e.providers,
                            guards: i
                        })
                    }
                }

                function yh(e) {
                    return A.isTypeOf(e) || k.isTypeOf(e)
                }

                function vh(e, t) {
                    for (let n = e.length - 1; n >= 0; n--)
                        if (t(e[n])) return e[n];
                    return null
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class _h extends Ci {
                    constructor(e, t) {
                        super(e, t)
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const bh = "i18n",
                    wh = "i18n-",
                    Eh = /^i18n:?/;
                let Ch = !1;
                class Sh {
                    constructor(e, t) {
                        this.messages = e, this.errors = t
                    }
                }
                var xh;
                ! function(e) {
                    e[e.Extract = 0] = "Extract", e[e.Merge = 1] = "Merge"
                }(xh || (xh = {}));
                class Th {
                    constructor(e, t) {
                        this._implicitTags = e, this._implicitAttrs = t
                    }
                    extract(e, t) {
                        return this._init(xh.Extract, t), e.forEach(e => e.visit(this, null)), this._inI18nBlock && this._reportError(e[e.length - 1], "Unclosed block"), new Sh(this._messages, this._errors)
                    }
                    merge(e, t, n) {
                        this._init(xh.Merge, n), this._translations = t;
                        const s = new ma("wrapper", [], e, void 0, void 0, void 0).visit(this, null);
                        return this._inI18nBlock && this._reportError(e[e.length - 1], "Unclosed block"), new La(s.children, this._errors)
                    }
                    visitExpansionCase(e, t) {
                        const n = ya(this, e.expression, t);
                        if (this._mode === xh.Merge) return new da(e.value, n, e.sourceSpan, e.valueSourceSpan, e.expSourceSpan)
                    }
                    visitExpansion(e, t) {
                        this._mayBeAddBlockChildren(e);
                        const n = this._inIcu;
                        this._inIcu || (this._isInTranslatableSection && this._addMessage([e]), this._inIcu = !0);
                        const s = ya(this, e.cases, t);
                        return this._mode === xh.Merge && (e = new pa(e.switchValue, e.type, s, e.sourceSpan, e.switchValueSourceSpan)), this._inIcu = n, e
                    }
                    visitComment(e, t) {
                        const n = !!((s = e) instanceof ga && s.value && s.value.startsWith("i18n"));
                        var s;
                        if (n && this._isInTranslatableSection) return void this._reportError(e, "Could not start a block inside a translatable section");
                        const r = function(e) {
                            return !!(e instanceof ga && e.value && "/i18n" === e.value)
                        }(e);
                        if (!r || this._inI18nBlock) {
                            if (!this._inI18nNode && !this._inIcu)
                                if (this._inI18nBlock) {
                                    if (r) {
                                        if (this._depth == this._blockStartDepth) {
                                            this._closeTranslatableSection(e, this._blockChildren), this._inI18nBlock = !1;
                                            const t = this._addMessage(this._blockChildren, this._blockMeaningAndDesc);
                                            return ya(this, this._translateMessage(e, t))
                                        }
                                        return void this._reportError(e, "I18N blocks should not cross element boundaries")
                                    }
                                } else if (n) {
                                if (!Ch && console && console.warn) {
                                    Ch = !0;
                                    const t = e.sourceSpan.details ? `, ${e.sourceSpan.details}` : "";
                                    console.warn(`I18n comments are deprecated, use an <ng-container> element instead (${e.sourceSpan.start}${t})`)
                                }
                                this._inI18nBlock = !0, this._blockStartDepth = this._depth, this._blockChildren = [], this._blockMeaningAndDesc = e.value.replace(Eh, "").trim(), this._openTranslatableSection(e)
                            }
                        } else this._reportError(e, "Trying to close an unopened block")
                    }
                    visitText(e, t) {
                        return this._isInTranslatableSection && this._mayBeAddBlockChildren(e), e
                    }
                    visitElement(e, t) {
                        this._mayBeAddBlockChildren(e), this._depth++;
                        const n = this._inI18nNode,
                            s = this._inImplicitNode;
                        let r, i = [];
                        const o = e.attrs.find(e => e.name === bh) || null;
                        const a = o ? o.value : "",
                            l = this._implicitTags.some(t => e.name === t) && !this._inIcu && !this._isInTranslatableSection,
                            c = !s && l;
                        if (this._inImplicitNode = s || l, this._isInTranslatableSection || this._inIcu)(o || c) && this._reportError(e, "Could not mark an element as translatable inside a translatable section"), this._mode == xh.Extract && ya(this, e.children);
                        else {
                            if (o || c) {
                                this._inI18nNode = !0;
                                const t = this._addMessage(e.children, a);
                                r = this._translateMessage(e, t)
                            }
                            if (this._mode == xh.Extract) {
                                const t = o || c;
                                t && this._openTranslatableSection(e), ya(this, e.children), t && this._closeTranslatableSection(e, e.children)
                            }
                        }
                        if (this._mode === xh.Merge) {
                            (r || e.children).forEach(e => {
                                const n = e.visit(this, t);
                                n && !this._isInTranslatableSection && (i = i.concat(n))
                            })
                        }
                        if (this._visitAttributesOf(e), this._depth--, this._inI18nNode = n, this._inImplicitNode = s, this._mode === xh.Merge) {
                            const t = this._translateAttributes(e);
                            return new ma(e.name, t, i, e.sourceSpan, e.startSourceSpan, e.endSourceSpan)
                        }
                        return null
                    }
                    visitAttribute(e, t) {
                        throw new Error("unreachable code")
                    }
                    _init(e, t) {
                        this._mode = e, this._inI18nBlock = !1, this._inI18nNode = !1, this._depth = 0, this._inIcu = !1, this._msgCountAtSectionStart = void 0, this._errors = [], this._messages = [], this._inImplicitNode = !1, this._createI18nMessage = Xc(t)
                    }
                    _visitAttributesOf(e) {
                        const t = {},
                            n = this._implicitAttrs[e.name] || [];
                        e.attrs.filter(e => e.name.startsWith(wh)).forEach(e => t[e.name.slice(wh.length)] = e.value), e.attrs.forEach(e => {
                            e.name in t ? this._addMessage([e], t[e.name]) : n.some(t => e.name === t) && this._addMessage([e])
                        })
                    }
                    _addMessage(e, t) {
                        if (0 == e.length || 1 == e.length && e[0] instanceof fa && !e[0].value) return null;
                        const {
                            meaning: n,
                            description: s,
                            id: r
                        } = Ah(t), i = this._createI18nMessage(e, n, s, r);
                        return this._messages.push(i), i
                    }
                    _translateMessage(e, t) {
                        if (t && this._mode === xh.Merge) {
                            const n = this._translations.get(t);
                            if (n) return n;
                            this._reportError(e, `Translation unavailable for message id="${this._translations.digest(t)}"`)
                        }
                        return []
                    }
                    _translateAttributes(e) {
                        const t = e.attrs,
                            n = {};
                        t.forEach(e => {
                            e.name.startsWith(wh) && (n[e.name.slice(wh.length)] = Ah(e.value))
                        });
                        const s = [];
                        return t.forEach(t => {
                            if (t.name !== bh && !t.name.startsWith(wh))
                                if (t.value && "" != t.value && n.hasOwnProperty(t.name)) {
                                    const {
                                        meaning: r,
                                        description: i,
                                        id: o
                                    } = n[t.name], a = this._createI18nMessage([t], r, i, o), l = this._translations.get(a);
                                    if (l)
                                        if (0 == l.length) s.push(new fa(t.name, "", t.sourceSpan));
                                        else if (l[0] instanceof ha) {
                                        const e = l[0].value;
                                        s.push(new fa(t.name, e, t.sourceSpan))
                                    } else this._reportError(e, `Unexpected translation for attribute "${t.name}" (id="${o||this._translations.digest(a)}")`);
                                    else this._reportError(e, `Translation unavailable for attribute "${t.name}" (id="${o||this._translations.digest(a)}")`)
                                } else s.push(t)
                        }), s
                    }
                    _mayBeAddBlockChildren(e) {
                        this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth && this._blockChildren.push(e)
                    }
                    _openTranslatableSection(e) {
                        this._isInTranslatableSection ? this._reportError(e, "Unexpected section start") : this._msgCountAtSectionStart = this._messages.length
                    }
                    get _isInTranslatableSection() {
                        return void 0 !== this._msgCountAtSectionStart
                    }
                    _closeTranslatableSection(e, t) {
                        if (!this._isInTranslatableSection) return void this._reportError(e, "Unexpected section end");
                        const n = this._msgCountAtSectionStart;
                        if (1 == t.reduce((e, t) => e + (t instanceof ga ? 0 : 1), 0))
                            for (let s = this._messages.length - 1; s >= n; s--) {
                                const e = this._messages[s].nodes;
                                if (!(1 == e.length && e[0] instanceof ts)) {
                                    this._messages.splice(s, 1);
                                    break
                                }
                            }
                        this._msgCountAtSectionStart = void 0
                    }
                    _reportError(e, t) {
                        this._errors.push(new _h(e.sourceSpan, t))
                    }
                }

                function Ah(e) {
                    if (!e) return {
                        meaning: "",
                        description: "",
                        id: ""
                    };
                    const t = e.indexOf("@@"),
                        n = e.indexOf("|"),
                        [s, r] = t > -1 ? [e.slice(0, t), e.slice(t + 2)] : [e, ""],
                        [i, o] = n > -1 ? [s.slice(0, n), s.slice(n + 1)] : ["", s];
                    return {
                        meaning: i,
                        description: o,
                        id: r.trim()
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Dh = new class {
                    constructor() {
                        this.closedByParent = !1, this.contentType = s.PARSABLE_DATA, this.isVoid = !1, this.ignoreFirstLf = !1, this.canSelfClose = !0, this.preventNamespaceInheritance = !1
                    }
                    requireExtraParent(e) {
                        return !1
                    }
                    isClosedByChild(e) {
                        return !1
                    }
                };

                function Ph(e) {
                    return Dh
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class kh extends Va {
                    constructor() {
                        super(Ph)
                    }
                    parse(e, t, n) {
                        return super.parse(e, t, n)
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Oh = "x",
                    Ih = "source",
                    Nh = "trans-unit",
                    Mh = "context";
                class Fh extends Ds {
                    write(e, t) {
                        const n = new Rh,
                            s = [];
                        e.forEach(e => {
                            let t = [];
                            e.sources.forEach(e => {
                                let n = new Ms("context-group", {
                                    purpose: "location"
                                });
                                n.children.push(new Rs(10), new Ms(Mh, {
                                    "context-type": "sourcefile"
                                }, [new Fs(e.filePath)]), new Rs(10), new Ms(Mh, {
                                    "context-type": "linenumber"
                                }, [new Fs(`${e.startLine}`)]), new Rs(8)), t.push(new Rs(8), n)
                            });
                            const r = new Ms(Nh, {
                                id: e.id,
                                datatype: "html"
                            });
                            r.children.push(new Rs(8), new Ms(Ih, {}, n.serialize(e.nodes)), ...t), e.description && r.children.push(new Rs(8), new Ms("note", {
                                priority: "1",
                                from: "description"
                            }, [new Fs(e.description)])), e.meaning && r.children.push(new Rs(8), new Ms("note", {
                                priority: "1",
                                from: "meaning"
                            }, [new Fs(e.meaning)])), r.children.push(new Rs(6)), s.push(new Rs(6), r)
                        });
                        const r = new Ms("body", {}, [...s, new Rs(4)]),
                            i = new Ms("file", {
                                "source-language": t || "en",
                                datatype: "plaintext",
                                original: "ng2.template"
                            }, [new Rs(4), r, new Rs(2)]),
                            o = new Ms("xliff", {
                                version: "1.2",
                                xmlns: "urn:oasis:names:tc:xliff:document:1.2"
                            }, [new Rs(2), i, new Rs]);
                        return Os([new Is({
                            version: "1.0",
                            encoding: "UTF-8"
                        }), new Rs, o, new Rs])
                    }
                    load(e, t) {
                        const n = new jh,
                            {
                                locale: s,
                                msgIdToHtml: r,
                                errors: i
                            } = n.parse(e, t),
                            o = {},
                            a = new Lh;
                        if (Object.keys(r).forEach(e => {
                                const {
                                    i18nNodes: n,
                                    errors: s
                                } = a.convert(r[e], t);
                                i.push(...s), o[e] = n
                            }), i.length) throw new Error(`xliff parse errors:\n${i.join("\n")}`);
                        return {
                            locale: s,
                            i18nNodesByMsgId: o
                        }
                    }
                    digest(e) {
                        return cs(e)
                    }
                }
                class Rh {
                    visitText(e, t) {
                        return [new Fs(e.value)]
                    }
                    visitContainer(e, t) {
                        const n = [];
                        return e.children.forEach(e => n.push(...e.visit(this))), n
                    }
                    visitIcu(e, t) {
                        const n = [new Fs(`{${e.expressionPlaceholder}, ${e.type}, `)];
                        return Object.keys(e.cases).forEach(t => {
                            n.push(new Fs(`${t} {`), ...e.cases[t].visit(this), new Fs("} "))
                        }), n.push(new Fs("}")), n
                    }
                    visitTagPlaceholder(e, t) {
                        const n = function(e) {
                            switch (e.toLowerCase()) {
                                case "br":
                                    return "lb";
                                case "img":
                                    return "image";
                                default:
                                    return `x-${e}`
                            }
                        }
                        /**
                         * @license
                         * Copyright Google LLC All Rights Reserved.
                         *
                         * Use of this source code is governed by an MIT-style license that can be
                         * found in the LICENSE file at https://angular.io/license
                         */
                        (e.tag);
                        if (e.isVoid) return [new Ms(Oh, {
                            id: e.startName,
                            ctype: n,
                            "equiv-text": `<${e.tag}/>`
                        })];
                        const s = new Ms(Oh, {
                                id: e.startName,
                                ctype: n,
                                "equiv-text": `<${e.tag}>`
                            }),
                            r = new Ms(Oh, {
                                id: e.closeName,
                                ctype: n,
                                "equiv-text": `</${e.tag}>`
                            });
                        return [s, ...this.serialize(e.children), r]
                    }
                    visitPlaceholder(e, t) {
                        return [new Ms(Oh, {
                            id: e.name,
                            "equiv-text": `{{${e.value}}}`
                        })]
                    }
                    visitIcuPlaceholder(e, t) {
                        const n = `{${e.value.expression}, ${e.value.type}, ${Object.keys(e.value.cases).map(e=>e+" {...}").join(" ")}}`;
                        return [new Ms(Oh, {
                            id: e.name,
                            "equiv-text": n
                        })]
                    }
                    serialize(e) {
                        return [].concat(...e.map(e => e.visit(this)))
                    }
                }
                class jh {
                    constructor() {
                        this._locale = null
                    }
                    parse(e, t) {
                        this._unitMlString = null, this._msgIdToHtml = {};
                        const n = (new kh).parse(e, t);
                        return this._errors = n.errors, ya(this, n.rootNodes, null), {
                            msgIdToHtml: this._msgIdToHtml,
                            errors: this._errors,
                            locale: this._locale
                        }
                    }
                    visitElement(e, t) {
                        switch (e.name) {
                            case Nh:
                                this._unitMlString = null;
                                const t = e.attrs.find(e => "id" === e.name);
                                if (t) {
                                    const n = t.value;
                                    this._msgIdToHtml.hasOwnProperty(n) ? this._addError(e, `Duplicated translations for msg ${n}`) : (ya(this, e.children, null), "string" == typeof this._unitMlString ? this._msgIdToHtml[n] = this._unitMlString : this._addError(e, `Message ${n} misses a translation`))
                                } else this._addError(e, '<trans-unit> misses the "id" attribute');
                                break;
                            case Ih:
                            case "seg-source":
                            case "alt-trans":
                                break;
                            case "target":
                                const n = e.startSourceSpan.end.offset,
                                    s = e.endSourceSpan.start.offset,
                                    r = e.startSourceSpan.start.file.content.slice(n, s);
                                this._unitMlString = r;
                                break;
                            case "file":
                                const i = e.attrs.find(e => "target-language" === e.name);
                                i && (this._locale = i.value), ya(this, e.children, null);
                                break;
                            default:
                                ya(this, e.children, null)
                        }
                    }
                    visitAttribute(e, t) {}
                    visitText(e, t) {}
                    visitComment(e, t) {}
                    visitExpansion(e, t) {}
                    visitExpansionCase(e, t) {}
                    _addError(e, t) {
                        this._errors.push(new _h(e.sourceSpan, t))
                    }
                }
                class Lh {
                    convert(e, t) {
                        const n = (new kh).parse(e, t, {
                            tokenizeExpansionForms: !0
                        });
                        this._errors = n.errors;
                        return {
                            i18nNodes: this._errors.length > 0 || 0 == n.rootNodes.length ? [] : [].concat(...ya(this, n.rootNodes)),
                            errors: this._errors
                        }
                    }
                    visitText(e, t) {
                        return new ts(e.value, e.sourceSpan)
                    }
                    visitElement(e, t) {
                        if (e.name === Oh) {
                            const t = e.attrs.find(e => "id" === e.name);
                            return t ? new is("", t.value, e.sourceSpan) : (this._addError(e, '<x> misses the "id" attribute'), null)
                        }
                        return "mrk" === e.name ? [].concat(...ya(this, e.children)) : (this._addError(e, "Unexpected tag"), null)
                    }
                    visitExpansion(e, t) {
                        const n = {};
                        return ya(this, e.cases).forEach(t => {
                            n[t.value] = new ns(t.nodes, e.sourceSpan)
                        }), new ss(e.switchValue, e.type, n, e.sourceSpan)
                    }
                    visitExpansionCase(e, t) {
                        return {
                            value: e.value,
                            nodes: ya(this, e.expression)
                        }
                    }
                    visitComment(e, t) {}
                    visitAttribute(e, t) {}
                    _addError(e, t) {
                        this._errors.push(new _h(e.sourceSpan, t))
                    }
                }
                const Vh = "ph",
                    $h = "xliff",
                    Bh = "source",
                    Hh = "unit";
                class Uh extends Ds {
                    write(e, t) {
                        const n = new qh,
                            s = [];
                        e.forEach(e => {
                            const t = new Ms(Hh, {
                                    id: e.id
                                }),
                                r = new Ms("notes");
                            (e.description || e.meaning) && (e.description && r.children.push(new Rs(8), new Ms("note", {
                                category: "description"
                            }, [new Fs(e.description)])), e.meaning && r.children.push(new Rs(8), new Ms("note", {
                                category: "meaning"
                            }, [new Fs(e.meaning)]))), e.sources.forEach(e => {
                                r.children.push(new Rs(8), new Ms("note", {
                                    category: "location"
                                }, [new Fs(`${e.filePath}:${e.startLine}${e.endLine!==e.startLine?","+e.endLine:""}`)]))
                            }), r.children.push(new Rs(6)), t.children.push(new Rs(6), r);
                            const i = new Ms("segment");
                            i.children.push(new Rs(8), new Ms(Bh, {}, n.serialize(e.nodes)), new Rs(6)), t.children.push(new Rs(6), i, new Rs(4)), s.push(new Rs(4), t)
                        });
                        const r = new Ms("file", {
                                original: "ng.template",
                                id: "ngi18n"
                            }, [...s, new Rs(2)]),
                            i = new Ms($h, {
                                version: "2.0",
                                xmlns: "urn:oasis:names:tc:xliff:document:2.0",
                                srcLang: t || "en"
                            }, [new Rs(2), r, new Rs]);
                        return Os([new Is({
                            version: "1.0",
                            encoding: "UTF-8"
                        }), new Rs, i, new Rs])
                    }
                    load(e, t) {
                        const n = new zh,
                            {
                                locale: s,
                                msgIdToHtml: r,
                                errors: i
                            } = n.parse(e, t),
                            o = {},
                            a = new Wh;
                        if (Object.keys(r).forEach(e => {
                                const {
                                    i18nNodes: n,
                                    errors: s
                                } = a.convert(r[e], t);
                                i.push(...s), o[e] = n
                            }), i.length) throw new Error(`xliff2 parse errors:\n${i.join("\n")}`);
                        return {
                            locale: s,
                            i18nNodesByMsgId: o
                        }
                    }
                    digest(e) {
                        return hs(e)
                    }
                }
                class qh {
                    visitText(e, t) {
                        return [new Fs(e.value)]
                    }
                    visitContainer(e, t) {
                        const n = [];
                        return e.children.forEach(e => n.push(...e.visit(this))), n
                    }
                    visitIcu(e, t) {
                        const n = [new Fs(`{${e.expressionPlaceholder}, ${e.type}, `)];
                        return Object.keys(e.cases).forEach(t => {
                            n.push(new Fs(`${t} {`), ...e.cases[t].visit(this), new Fs("} "))
                        }), n.push(new Fs("}")), n
                    }
                    visitTagPlaceholder(e, t) {
                        const n = function(e) {
                            switch (e.toLowerCase()) {
                                case "br":
                                case "b":
                                case "i":
                                case "u":
                                    return "fmt";
                                case "img":
                                    return "image";
                                case "a":
                                    return "link";
                                default:
                                    return "other"
                            }
                        }
                        /**
                         * @license
                         * Copyright Google LLC All Rights Reserved.
                         *
                         * Use of this source code is governed by an MIT-style license that can be
                         * found in the LICENSE file at https://angular.io/license
                         */
                        (e.tag);
                        if (e.isVoid) {
                            return [new Ms(Vh, {
                                id: (this._nextPlaceholderId++).toString(),
                                equiv: e.startName,
                                type: n,
                                disp: `<${e.tag}/>`
                            })]
                        }
                        const s = new Ms("pc", {
                                id: (this._nextPlaceholderId++).toString(),
                                equivStart: e.startName,
                                equivEnd: e.closeName,
                                type: n,
                                dispStart: `<${e.tag}>`,
                                dispEnd: `</${e.tag}>`
                            }),
                            r = [].concat(...e.children.map(e => e.visit(this)));
                        return r.length ? r.forEach(e => s.children.push(e)) : s.children.push(new Fs("")), [s]
                    }
                    visitPlaceholder(e, t) {
                        const n = (this._nextPlaceholderId++).toString();
                        return [new Ms(Vh, {
                            id: n,
                            equiv: e.name,
                            disp: `{{${e.value}}}`
                        })]
                    }
                    visitIcuPlaceholder(e, t) {
                        const n = Object.keys(e.value.cases).map(e => e + " {...}").join(" "),
                            s = (this._nextPlaceholderId++).toString();
                        return [new Ms(Vh, {
                            id: s,
                            equiv: e.name,
                            disp: `{${e.value.expression}, ${e.value.type}, ${n}}`
                        })]
                    }
                    serialize(e) {
                        return this._nextPlaceholderId = 0, [].concat(...e.map(e => e.visit(this)))
                    }
                }
                class zh {
                    constructor() {
                        this._locale = null
                    }
                    parse(e, t) {
                        this._unitMlString = null, this._msgIdToHtml = {};
                        const n = (new kh).parse(e, t);
                        return this._errors = n.errors, ya(this, n.rootNodes, null), {
                            msgIdToHtml: this._msgIdToHtml,
                            errors: this._errors,
                            locale: this._locale
                        }
                    }
                    visitElement(e, t) {
                        switch (e.name) {
                            case Hh:
                                this._unitMlString = null;
                                const t = e.attrs.find(e => "id" === e.name);
                                if (t) {
                                    const n = t.value;
                                    this._msgIdToHtml.hasOwnProperty(n) ? this._addError(e, `Duplicated translations for msg ${n}`) : (ya(this, e.children, null), "string" == typeof this._unitMlString ? this._msgIdToHtml[n] = this._unitMlString : this._addError(e, `Message ${n} misses a translation`))
                                } else this._addError(e, '<unit> misses the "id" attribute');
                                break;
                            case Bh:
                                break;
                            case "target":
                                const n = e.startSourceSpan.end.offset,
                                    s = e.endSourceSpan.start.offset,
                                    r = e.startSourceSpan.start.file.content.slice(n, s);
                                this._unitMlString = r;
                                break;
                            case $h:
                                const i = e.attrs.find(e => "trgLang" === e.name);
                                i && (this._locale = i.value);
                                const o = e.attrs.find(e => "version" === e.name);
                                if (o) {
                                    const t = o.value;
                                    "2.0" !== t ? this._addError(e, `The XLIFF file version ${t} is not compatible with XLIFF 2.0 serializer`) : ya(this, e.children, null)
                                }
                                break;
                            default:
                                ya(this, e.children, null)
                        }
                    }
                    visitAttribute(e, t) {}
                    visitText(e, t) {}
                    visitComment(e, t) {}
                    visitExpansion(e, t) {}
                    visitExpansionCase(e, t) {}
                    _addError(e, t) {
                        this._errors.push(new _h(e.sourceSpan, t))
                    }
                }
                class Wh {
                    convert(e, t) {
                        const n = (new kh).parse(e, t, {
                            tokenizeExpansionForms: !0
                        });
                        this._errors = n.errors;
                        return {
                            i18nNodes: this._errors.length > 0 || 0 == n.rootNodes.length ? [] : [].concat(...ya(this, n.rootNodes)),
                            errors: this._errors
                        }
                    }
                    visitText(e, t) {
                        return new ts(e.value, e.sourceSpan)
                    }
                    visitElement(e, t) {
                        switch (e.name) {
                            case Vh:
                                const t = e.attrs.find(e => "equiv" === e.name);
                                if (t) return [new is("", t.value, e.sourceSpan)];
                                this._addError(e, '<ph> misses the "equiv" attribute');
                                break;
                            case "pc":
                                const n = e.attrs.find(e => "equivStart" === e.name),
                                    s = e.attrs.find(e => "equivEnd" === e.name);
                                if (n) {
                                    if (s) {
                                        const t = n.value,
                                            r = s.value;
                                        return [].concat(new is("", t, e.sourceSpan), ...e.children.map(e => e.visit(this, null)), new is("", r, e.sourceSpan))
                                    }
                                    this._addError(e, '<ph> misses the "equivEnd" attribute')
                                } else this._addError(e, '<ph> misses the "equivStart" attribute');
                                break;
                            case "mrk":
                                return [].concat(...ya(this, e.children));
                            default:
                                this._addError(e, "Unexpected tag")
                        }
                        return null
                    }
                    visitExpansion(e, t) {
                        const n = {};
                        return ya(this, e.cases).forEach(t => {
                            n[t.value] = new ns(t.nodes, e.sourceSpan)
                        }), new ss(e.switchValue, e.type, n, e.sourceSpan)
                    }
                    visitExpansionCase(e, t) {
                        return {
                            value: e.value,
                            nodes: [].concat(...ya(this, e.expression))
                        }
                    }
                    visitComment(e, t) {}
                    visitAttribute(e, t) {}
                    _addError(e, t) {
                        this._errors.push(new _h(e.sourceSpan, t))
                    }
                }
                const Gh = "translationbundle",
                    Kh = "translation";
                class Qh extends Ds {
                    write(e, t) {
                        throw new Error("Unsupported")
                    }
                    load(e, t) {
                        const n = new Zh,
                            {
                                locale: s,
                                msgIdToHtml: r,
                                errors: i
                            } = n.parse(e, t),
                            o = {},
                            a = new Jh;
                        if (Object.keys(r).forEach(e => {
                                ! function(e, t, n) {
                                    Object.defineProperty(e, t, {
                                        configurable: !0,
                                        enumerable: !0,
                                        get: function() {
                                            const s = n();
                                            return Object.defineProperty(e, t, {
                                                enumerable: !0,
                                                value: s
                                            }), s
                                        },
                                        set: e => {
                                            throw new Error("Could not overwrite an XTB translation")
                                        }
                                    })
                                }(o, e, function() {
                                    const {
                                        i18nNodes: n,
                                        errors: s
                                    } = a.convert(r[e], t);
                                    if (s.length) throw new Error(`xtb parse errors:\n${s.join("\n")}`);
                                    return n
                                })
                            }), i.length) throw new Error(`xtb parse errors:\n${i.join("\n")}`);
                        return {
                            locale: s,
                            i18nNodesByMsgId: o
                        }
                    }
                    digest(e) {
                        return qs(e)
                    }
                    createNameMapper(e) {
                        return new Ps(e, Ws)
                    }
                }
                class Zh {
                    constructor() {
                        this._locale = null
                    }
                    parse(e, t) {
                        this._bundleDepth = 0, this._msgIdToHtml = {};
                        const n = (new kh).parse(e, t);
                        return this._errors = n.errors, ya(this, n.rootNodes), {
                            msgIdToHtml: this._msgIdToHtml,
                            errors: this._errors,
                            locale: this._locale
                        }
                    }
                    visitElement(e, t) {
                        switch (e.name) {
                            case Gh:
                                this._bundleDepth++, this._bundleDepth > 1 && this._addError(e, "<translationbundle> elements can not be nested");
                                const t = e.attrs.find(e => "lang" === e.name);
                                t && (this._locale = t.value), ya(this, e.children, null), this._bundleDepth--;
                                break;
                            case Kh:
                                const n = e.attrs.find(e => "id" === e.name);
                                if (n) {
                                    const t = n.value;
                                    if (this._msgIdToHtml.hasOwnProperty(t)) this._addError(e, `Duplicated translations for msg ${t}`);
                                    else {
                                        const n = e.startSourceSpan.end.offset,
                                            s = e.endSourceSpan.start.offset,
                                            r = e.startSourceSpan.start.file.content.slice(n, s);
                                        this._msgIdToHtml[t] = r
                                    }
                                } else this._addError(e, '<translation> misses the "id" attribute');
                                break;
                            default:
                                this._addError(e, "Unexpected tag")
                        }
                    }
                    visitAttribute(e, t) {}
                    visitText(e, t) {}
                    visitComment(e, t) {}
                    visitExpansion(e, t) {}
                    visitExpansionCase(e, t) {}
                    _addError(e, t) {
                        this._errors.push(new _h(e.sourceSpan, t))
                    }
                }
                class Jh {
                    convert(e, t) {
                        const n = (new kh).parse(e, t, {
                            tokenizeExpansionForms: !0
                        });
                        this._errors = n.errors;
                        return {
                            i18nNodes: this._errors.length > 0 || 0 == n.rootNodes.length ? [] : ya(this, n.rootNodes),
                            errors: this._errors
                        }
                    }
                    visitText(e, t) {
                        return new ts(e.value, e.sourceSpan)
                    }
                    visitExpansion(e, t) {
                        const n = {};
                        return ya(this, e.cases).forEach(t => {
                            n[t.value] = new ns(t.nodes, e.sourceSpan)
                        }), new ss(e.switchValue, e.type, n, e.sourceSpan)
                    }
                    visitExpansionCase(e, t) {
                        return {
                            value: e.value,
                            nodes: ya(this, e.expression)
                        }
                    }
                    visitElement(e, t) {
                        if ("ph" === e.name) {
                            const t = e.attrs.find(e => "name" === e.name);
                            if (t) return new is("", t.value, e.sourceSpan);
                            this._addError(e, '<ph> misses the "name" attribute')
                        } else this._addError(e, "Unexpected tag");
                        return null
                    }
                    visitComment(e, t) {}
                    visitAttribute(e, t) {}
                    _addError(e, t) {
                        this._errors.push(new _h(e.sourceSpan, t))
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Xh {
                    constructor(e = {}, t, n, s, r = W.Warning, i) {
                        this._i18nNodesByMsgId = e, this.digest = n, this.mapperFactory = s, this._i18nToHtml = new Yh(e, t, n, s, r, i)
                    }
                    static load(e, t, n, s, r) {
                        const {
                            locale: i,
                            i18nNodesByMsgId: o
                        } = n.load(e, t);
                        return new Xh(o, i, e => n.digest(e), e => n.createNameMapper(e), s, r)
                    }
                    get(e) {
                        const t = this._i18nToHtml.convert(e);
                        if (t.errors.length) throw new Error(t.errors.join("\n"));
                        return t.nodes
                    }
                    has(e) {
                        return this.digest(e) in this._i18nNodesByMsgId
                    }
                }
                class Yh {
                    constructor(e = {}, t, n, s, r, i) {
                        this._i18nNodesByMsgId = e, this._locale = t, this._digest = n, this._mapperFactory = s, this._missingTranslationStrategy = r, this._console = i, this._contextStack = [], this._errors = []
                    }
                    convert(e) {
                        this._contextStack.length = 0, this._errors.length = 0;
                        const t = this._convertToText(e),
                            n = e.nodes[0].sourceSpan.start.file.url,
                            s = (new Ha).parse(t, n, {
                                tokenizeExpansionForms: !0
                            });
                        return {
                            nodes: s.rootNodes,
                            errors: [...this._errors, ...s.errors]
                        }
                    }
                    visitText(e, t) {
                        return Ls(e.value)
                    }
                    visitContainer(e, t) {
                        return e.children.map(e => e.visit(this)).join("")
                    }
                    visitIcu(e, t) {
                        const n = Object.keys(e.cases).map(t => `${t} {${e.cases[t].visit(this)}}`);
                        return `{${this._srcMsg.placeholders.hasOwnProperty(e.expression)?this._srcMsg.placeholders[e.expression].text:e.expression}, ${e.type}, ${n.join(" ")}}`
                    }
                    visitPlaceholder(e, t) {
                        const n = this._mapper(e.name);
                        return this._srcMsg.placeholders.hasOwnProperty(n) ? this._srcMsg.placeholders[n].text : this._srcMsg.placeholderToMessage.hasOwnProperty(n) ? this._convertToText(this._srcMsg.placeholderToMessage[n]) : (this._addError(e, `Unknown placeholder "${e.name}"`), "")
                    }
                    visitTagPlaceholder(e, t) {
                        const n = `${e.tag}`,
                            s = Object.keys(e.attrs).map(t => `${t}="${e.attrs[t]}"`).join(" ");
                        if (e.isVoid) return `<${n} ${s}/>`;
                        return `<${n} ${s}>${e.children.map(e=>e.visit(this)).join("")}</${n}>`
                    }
                    visitIcuPlaceholder(e, t) {
                        return this._convertToText(this._srcMsg.placeholderToMessage[e.name])
                    }
                    _convertToText(e) {
                        const t = this._digest(e),
                            n = this._mapperFactory ? this._mapperFactory(e) : null;
                        let s;
                        if (this._contextStack.push({
                                msg: this._srcMsg,
                                mapper: this._mapper
                            }), this._srcMsg = e, this._i18nNodesByMsgId.hasOwnProperty(t)) s = this._i18nNodesByMsgId[t], this._mapper = e => n ? n.toInternalName(e) : e;
                        else {
                            if (this._missingTranslationStrategy === W.Error) {
                                const n = this._locale ? ` for locale "${this._locale}"` : "";
                                this._addError(e.nodes[0], `Missing translation for message "${t}"${n}`)
                            } else if (this._console && this._missingTranslationStrategy === W.Warning) {
                                const e = this._locale ? ` for locale "${this._locale}"` : "";
                                this._console.warn(`Missing translation for message "${t}"${e}`)
                            }
                            s = e.nodes, this._mapper = e => e
                        }
                        const r = s.map(e => e.visit(this)).join(""),
                            i = this._contextStack.pop();
                        return this._srcMsg = i.msg, this._mapper = i.mapper, r
                    }
                    _addError(e, t) {
                        this._errors.push(new _h(e.sourceSpan, t))
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class ep {
                    constructor(e, t, n, s = W.Warning, r) {
                        if (this._htmlParser = e, t) {
                            const e = function(e) {
                                switch (e = (e || "xlf").toLowerCase()) {
                                    case "xmb":
                                        return new Hs;
                                    case "xtb":
                                        return new Qh;
                                    case "xliff2":
                                    case "xlf2":
                                        return new Uh;
                                    case "xliff":
                                    case "xlf":
                                    default:
                                        return new Fh
                                }
                            }
                            /**
                             * @license
                             * Copyright Google LLC All Rights Reserved.
                             *
                             * Use of this source code is governed by an MIT-style license that can be
                             * found in the LICENSE file at https://angular.io/license
                             */
                            (n);
                            this._translationBundle = Xh.load(t, "i18n", e, s, r)
                        } else this._translationBundle = new Xh({}, null, cs, void 0, s, r)
                    }
                    parse(e, t, n = {}) {
                        const s = n.interpolationConfig || Fr,
                            r = this._htmlParser.parse(e, t, Object.assign({
                                interpolationConfig: s
                            }, n));
                        return r.errors.length ? new La(r.rootNodes, r.errors) : function(e, t, n, s, r) {
                            return new Th(s, r).merge(e, t, n)
                        }(r.rootNodes, this._translationBundle, s, [], {})
                    }
                }

                function tp(e, t, n = null) {
                    return Nt(t, new np(e), n)
                }
                class np {
                    constructor(e) {
                        this.ctx = e
                    }
                    visitArray(e, t) {
                        const n = [];
                        for (let s = 0; s < e.length; ++s) n.push(Nt(e[s], this, null));
                        return Ct(n, t)
                    }
                    visitStringMap(e, t) {
                        const n = [],
                            s = new Set(e && e.$quoted$);
                        return Object.keys(e).forEach(t => {
                            n.push(new We(t, Nt(e[t], this, null), s.has(t)))
                        }), new Ge(n, t)
                    }
                    visitPrimitive(e, t) {
                        return At(e, t)
                    }
                    visitOther(e, t) {
                        return e instanceof me ? e : this.ctx.importExpr(e)
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function sp(e, t = !1) {
                    const n = rp(e, t);
                    return `${n[0]}.ngfactory${ip(n[1])}`
                }

                function rp(e, t = !1) {
                    if (e.endsWith(".d.ts")) return [e.slice(0, -5), t ? ".ts" : ".d.ts"];
                    const n = e.lastIndexOf(".");
                    return -1 !== n ? [e.substring(0, n), e.substring(n)] : [e, ""]
                }

                function ip(e) {
                    return ".tsx" === e ? ".ts" : e
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var op;
                ! function(e) {
                    e[e.OnInit = 0] = "OnInit", e[e.OnDestroy = 1] = "OnDestroy", e[e.DoCheck = 2] = "DoCheck", e[e.OnChanges = 3] = "OnChanges", e[e.AfterContentInit = 4] = "AfterContentInit", e[e.AfterContentChecked = 5] = "AfterContentChecked", e[e.AfterViewInit = 6] = "AfterViewInit", e[e.AfterViewChecked = 7] = "AfterViewChecked"
                }(op || (op = {}));
                const ap = [op.OnInit, op.OnDestroy, op.DoCheck, op.OnChanges, op.AfterContentInit, op.AfterContentChecked, op.AfterViewInit, op.AfterViewChecked];

                function lp(e, t, n) {
                    return e.hasLifecycleHook(n, function(e) {
                            switch (e) {
                                case op.OnInit:
                                    return "ngOnInit";
                                case op.OnDestroy:
                                    return "ngOnDestroy";
                                case op.DoCheck:
                                    return "ngDoCheck";
                                case op.OnChanges:
                                    return "ngOnChanges";
                                case op.AfterContentInit:
                                    return "ngAfterContentInit";
                                case op.AfterContentChecked:
                                    return "ngAfterContentChecked";
                                case op.AfterViewInit:
                                    return "ngAfterViewInit";
                                case op.AfterViewChecked:
                                    return "ngAfterViewChecked";
                                default:
                                    throw new Error(`unexpected ${e}`)
                            }
                        }
                        /**
                         * @license
                         * Copyright Google LLC All Rights Reserved.
                         *
                         * Use of this source code is governed by an MIT-style license that can be
                         * found in the LICENSE file at https://angular.io/license
                         */
                        (t))
                }
                class cp {
                    constructor(e, t, n, s, r, i, o, a, l, c, u, h) {
                        this._config = e, this._htmlParser = t, this._ngModuleResolver = n, this._directiveResolver = s, this._pipeResolver = r, this._summaryResolver = i, this._schemaRegistry = o, this._directiveNormalizer = a, this._console = l, this._staticSymbolCache = c, this._reflector = u, this._errorCollector = h, this._nonNormalizedDirectiveCache = new Map, this._directiveCache = new Map, this._summaryCache = new Map, this._pipeCache = new Map, this._ngModuleCache = new Map, this._ngModuleOfTypes = new Map, this._shallowModuleCache = new Map
                    }
                    getReflector() {
                        return this._reflector
                    }
                    clearCacheFor(e) {
                        const t = this._directiveCache.get(e);
                        this._directiveCache.delete(e), this._nonNormalizedDirectiveCache.delete(e), this._summaryCache.delete(e), this._pipeCache.delete(e), this._ngModuleOfTypes.delete(e), this._ngModuleCache.clear(), t && this._directiveNormalizer.clearCacheFor(t)
                    }
                    clearCache() {
                        this._directiveCache.clear(), this._nonNormalizedDirectiveCache.clear(), this._summaryCache.clear(), this._pipeCache.clear(), this._ngModuleCache.clear(), this._ngModuleOfTypes.clear(), this._directiveNormalizer.clearCache()
                    }
                    _createProxyClass(e, t) {
                        let n = null;
                        const s = function() {
                            if (!n) throw new Error(`Illegal state: Class ${t} for type ${Wt(e)} is not compiled yet!`);
                            return n.apply(this, arguments)
                        };
                        return s.setDelegate = e => {
                            n = e, s.prototype = e.prototype
                        }, s.overriddenName = t, s
                    }
                    getGeneratedClass(e, t) {
                        return e instanceof pn ? this._staticSymbolCache.get(sp(e.filePath), t) : this._createProxyClass(e, t)
                    }
                    getComponentViewClass(e) {
                        return this.getGeneratedClass(e, _n(e, 0))
                    }
                    getHostComponentViewClass(e) {
                        return this.getGeneratedClass(e, `HostView_${yn({reference:e})}`)
                    }
                    getHostComponentType(e) {
                        const t = `${yn({reference:e})}_Host`;
                        return e instanceof pn ? this._staticSymbolCache.get(e.filePath, t) : this._createProxyClass(e, t)
                    }
                    getRendererType(e) {
                        return e instanceof pn ? this._staticSymbolCache.get(sp(e.filePath), bn(e)) : {}
                    }
                    getComponentFactory(e, t, n, s) {
                        if (t instanceof pn) return this._staticSymbolCache.get(sp(t.filePath), wn(t)); {
                            const r = this.getHostComponentViewClass(t);
                            return this._reflector.resolveExternalReference(cn.createComponentFactory)(e, t, r, n, s, [])
                        }
                    }
                    initComponentFactory(e, t) {
                        e instanceof pn || e.ngContentSelectors.push(...t)
                    }
                    _loadSummary(e, t) {
                        let n = this._summaryCache.get(e);
                        if (!n) {
                            const t = this._summaryResolver.resolveSummary(e);
                            n = t ? t.type : null, this._summaryCache.set(e, n || null)
                        }
                        return n && n.summaryKind === t ? n : null
                    }
                    getHostComponentMetadata(e, t) {
                        const n = this.getHostComponentType(e.type.reference);
                        t || (t = this.getHostComponentViewClass(n));
                        const s = g.parse(e.selector)[0].getMatchingElementTemplate(),
                            r = this._htmlParser.parse(s, "");
                        return An.create({
                            isHost: !0,
                            type: {
                                reference: n,
                                diDeps: [],
                                lifecycleHooks: []
                            },
                            template: new Tn({
                                encapsulation: D.None,
                                template: s,
                                templateUrl: "",
                                htmlAst: r,
                                styles: [],
                                styleUrls: [],
                                ngContentSelectors: [],
                                animations: [],
                                isInline: !0,
                                externalStylesheets: [],
                                interpolation: null,
                                preserveWhitespaces: !1
                            }),
                            exportAs: null,
                            changeDetection: P.Default,
                            inputs: [],
                            outputs: [],
                            host: {},
                            isComponent: !0,
                            selector: "*",
                            providers: [],
                            viewProviders: [],
                            queries: [],
                            guards: {},
                            viewQueries: [],
                            componentViewType: t,
                            rendererType: {
                                id: "__Host__",
                                encapsulation: D.None,
                                styles: [],
                                data: {}
                            },
                            entryComponents: [],
                            componentFactory: null
                        })
                    }
                    loadDirectiveMetadata(e, t, n) {
                        if (this._directiveCache.has(t)) return null;
                        t = Gt(t);
                        const {
                            annotation: s,
                            metadata: r
                        } = this.getNonNormalizedDirectiveMetadata(t), i = e => {
                            const n = new An({
                                isHost: !1,
                                type: r.type,
                                isComponent: r.isComponent,
                                selector: r.selector,
                                exportAs: r.exportAs,
                                changeDetection: r.changeDetection,
                                inputs: r.inputs,
                                outputs: r.outputs,
                                hostListeners: r.hostListeners,
                                hostProperties: r.hostProperties,
                                hostAttributes: r.hostAttributes,
                                providers: r.providers,
                                viewProviders: r.viewProviders,
                                queries: r.queries,
                                guards: r.guards,
                                viewQueries: r.viewQueries,
                                entryComponents: r.entryComponents,
                                componentViewType: r.componentViewType,
                                rendererType: r.rendererType,
                                componentFactory: r.componentFactory,
                                template: e
                            });
                            return e && this.initComponentFactory(r.componentFactory, e.ngContentSelectors), this._directiveCache.set(t, n), this._summaryCache.set(t, n.toSummary()), null
                        };
                        if (r.isComponent) {
                            const o = r.template,
                                a = this._directiveNormalizer.normalizeTemplate({
                                    ngModuleType: e,
                                    componentType: t,
                                    moduleUrl: this._reflector.componentModuleUrl(t, s),
                                    encapsulation: o.encapsulation,
                                    template: o.template,
                                    templateUrl: o.templateUrl,
                                    styles: o.styles,
                                    styleUrls: o.styleUrls,
                                    animations: o.animations,
                                    interpolation: o.interpolation,
                                    preserveWhitespaces: o.preserveWhitespaces
                                });
                            return Kt(a) && n ? (this._reportError(function(e) {
                                    const t = Error(`Can't compile synchronously as ${Wt(e)} is still being loaded!`);
                                    return t.ngComponentType = e, t
                                }
                                /**
                                 * @license
                                 * Copyright Google LLC All Rights Reserved.
                                 *
                                 * Use of this source code is governed by an MIT-style license that can be
                                 * found in the LICENSE file at https://angular.io/license
                                 */
                                (t), t), null) : Lt(a, i)
                        }
                        return i(null), null
                    }
                    getNonNormalizedDirectiveMetadata(e) {
                        if (!(e = Gt(e))) return null;
                        let t = this._nonNormalizedDirectiveCache.get(e);
                        if (t) return t;
                        const n = this._directiveResolver.resolve(e, !1);
                        if (!n) return null;
                        let s;
                        if (k.isTypeOf(n)) {
                            const e = n;
                            Or("styles", e.styles), Or("styleUrls", e.styleUrls), Nr("interpolation", e.interpolation);
                            const t = e.animations;
                            s = new Tn({
                                encapsulation: Ft(e.encapsulation),
                                template: Ft(e.template),
                                templateUrl: Ft(e.templateUrl),
                                htmlAst: null,
                                styles: e.styles || [],
                                styleUrls: e.styleUrls || [],
                                animations: t || [],
                                interpolation: Ft(e.interpolation),
                                isInline: !!e.template,
                                externalStylesheets: [],
                                ngContentSelectors: [],
                                preserveWhitespaces: Ft(n.preserveWhitespaces)
                            })
                        }
                        let r = null,
                            i = [],
                            o = [],
                            a = n.selector;
                        if (k.isTypeOf(n)) {
                            const t = n;
                            r = t.changeDetection, t.viewProviders && (i = this._getProvidersMetadata(t.viewProviders, o, `viewProviders for "${fp(e)}"`, [], e)), t.entryComponents && (o = hp(t.entryComponents).map(e => this._getEntryComponentMetadata(e)).concat(o)), a || (a = this._schemaRegistry.getDefaultComponentElementName())
                        } else a || (a = null);
                        let l = [];
                        null != n.providers && (l = this._getProvidersMetadata(n.providers, o, `providers for "${fp(e)}"`, [], e));
                        let c = [],
                            u = [];
                        null != n.queries && (c = this._getQueriesMetadata(n.queries, !1, e), u = this._getQueriesMetadata(n.queries, !0, e));
                        const h = An.create({
                            isHost: !1,
                            selector: a,
                            exportAs: Ft(n.exportAs),
                            isComponent: !!s,
                            type: this._getTypeMetadata(e),
                            template: s,
                            changeDetection: r,
                            inputs: n.inputs || [],
                            outputs: n.outputs || [],
                            host: n.host || {},
                            providers: l || [],
                            viewProviders: i || [],
                            queries: c || [],
                            guards: n.guards || {},
                            viewQueries: u || [],
                            entryComponents: o,
                            componentViewType: s ? this.getComponentViewClass(e) : null,
                            rendererType: s ? this.getRendererType(e) : null,
                            componentFactory: null
                        });
                        return s && (h.componentFactory = this.getComponentFactory(a, e, h.inputs, h.outputs)), t = {
                            metadata: h,
                            annotation: n
                        }, this._nonNormalizedDirectiveCache.set(e, t), t
                    }
                    getDirectiveMetadata(e) {
                        const t = this._directiveCache.get(e);
                        return t || this._reportError(Bt(`Illegal state: getDirectiveMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Directive ${fp(e)}.`), e), t
                    }
                    getDirectiveSummary(e) {
                        const t = this._loadSummary(e, En.Directive);
                        return t || this._reportError(Bt(`Illegal state: Could not load the summary for directive ${fp(e)}.`), e), t
                    }
                    isDirective(e) {
                        return !!this._loadSummary(e, En.Directive) || this._directiveResolver.isDirective(e)
                    }
                    isAbstractDirective(e) {
                        const t = this._loadSummary(e, En.Directive);
                        if (t && !t.isComponent) return !t.selector;
                        const n = this._directiveResolver.resolve(e, !1);
                        return !(!n || k.isTypeOf(n)) && !n.selector
                    }
                    isPipe(e) {
                        return !!this._loadSummary(e, En.Pipe) || this._pipeResolver.isPipe(e)
                    }
                    isNgModule(e) {
                        return !!this._loadSummary(e, En.NgModule) || this._ngModuleResolver.isNgModule(e)
                    }
                    getNgModuleSummary(e, t = null) {
                        let n = this._loadSummary(e, En.NgModule);
                        if (!n) {
                            const s = this.getNgModuleMetadata(e, !1, t);
                            n = s ? s.toSummary() : null, n && this._summaryCache.set(e, n)
                        }
                        return n
                    }
                    loadNgModuleDirectiveAndPipeMetadata(e, t, n = !0) {
                        const s = this.getNgModuleMetadata(e, n),
                            r = [];
                        return s && (s.declaredDirectives.forEach(n => {
                            const s = this.loadDirectiveMetadata(e, n.reference, t);
                            s && r.push(s)
                        }), s.declaredPipes.forEach(e => this._loadPipeMetadata(e.reference))), Promise.all(r)
                    }
                    getShallowModuleMetadata(e) {
                        let t = this._shallowModuleCache.get(e);
                        if (t) return t;
                        const n = vh(this._reflector.shallowAnnotations(e), R.isTypeOf);
                        return t = {
                            type: this._getTypeMetadata(e),
                            rawExports: n.exports,
                            rawImports: n.imports,
                            rawProviders: n.providers
                        }, this._shallowModuleCache.set(e, t), t
                    }
                    getNgModuleMetadata(e, t = !0, n = null) {
                        e = Gt(e);
                        let s = this._ngModuleCache.get(e);
                        if (s) return s;
                        const r = this._ngModuleResolver.resolve(e, t);
                        if (!r) return null;
                        const i = [],
                            o = [],
                            a = [],
                            l = [],
                            c = [],
                            u = [],
                            h = [],
                            p = [],
                            d = [];
                        r.imports && hp(r.imports).forEach(t => {
                            let s;
                            if (pp(t)) s = t;
                            else if (t && t.ngModule) {
                                const e = t;
                                s = e.ngModule, e.providers && u.push(...this._getProvidersMetadata(e.providers, h, `provider for the NgModule '${fp(s)}'`, [], t))
                            }
                            if (s) {
                                if (this._checkSelfImport(e, s)) return;
                                if (n || (n = new Set), n.has(s)) return void this._reportError(Bt(`${this._getTypeDescriptor(s)} '${fp(t)}' is imported recursively by the module '${fp(e)}'.`), e);
                                n.add(s);
                                const r = this.getNgModuleSummary(s, n);
                                if (n.delete(s), !r) return void this._reportError(Bt(`Unexpected ${this._getTypeDescriptor(t)} '${fp(t)}' imported by the module '${fp(e)}'. Please add a @NgModule annotation.`), e);
                                l.push(r)
                            } else this._reportError(Bt(`Unexpected value '${fp(t)}' imported by the module '${fp(e)}'`), e)
                        }), r.exports && hp(r.exports).forEach(t => {
                            if (!pp(t)) return void this._reportError(Bt(`Unexpected value '${fp(t)}' exported by the module '${fp(e)}'`), e);
                            if (n || (n = new Set), n.has(t)) return void this._reportError(Bt(`${this._getTypeDescriptor(t)} '${Wt(t)}' is exported recursively by the module '${fp(e)}'`), e);
                            n.add(t);
                            const s = this.getNgModuleSummary(t, n);
                            n.delete(t), s ? c.push(s) : o.push(this._getIdentifierMetadata(t))
                        });
                        const f = this._getTransitiveNgModuleMetadata(l, c);
                        r.declarations && hp(r.declarations).forEach(t => {
                            if (!pp(t)) return void this._reportError(Bt(`Unexpected value '${fp(t)}' declared by the module '${fp(e)}'`), e);
                            const n = this._getIdentifierMetadata(t);
                            if (this.isDirective(t)) this.isAbstractDirective(t) && this._reportError(Bt(`Directive ${fp(t)} has no selector, please add it!`), t), f.addDirective(n), i.push(n), this._addTypeToModule(t, e);
                            else {
                                if (!this.isPipe(t)) return void this._reportError(Bt(`Unexpected ${this._getTypeDescriptor(t)} '${fp(t)}' declared by the module '${fp(e)}'. Please add a @Pipe/@Directive/@Component annotation.`), e);
                                f.addPipe(n), f.pipes.push(n), a.push(n), this._addTypeToModule(t, e)
                            }
                        });
                        const m = [],
                            g = [];
                        return o.forEach(t => {
                            if (f.directivesSet.has(t.reference)) m.push(t), f.addExportedDirective(t);
                            else {
                                if (!f.pipesSet.has(t.reference)) return void this._reportError(Bt(`Can't export ${this._getTypeDescriptor(t.reference)} ${fp(t.reference)} from ${fp(e)} as it was neither declared nor imported!`), e);
                                g.push(t), f.addExportedPipe(t)
                            }
                        }), r.providers && u.push(...this._getProvidersMetadata(r.providers, h, `provider for the NgModule '${fp(e)}'`, [], e)), r.entryComponents && h.push(...hp(r.entryComponents).map(e => this._getEntryComponentMetadata(e))), r.bootstrap && hp(r.bootstrap).forEach(t => {
                            pp(t) ? p.push(this._getIdentifierMetadata(t)) : this._reportError(Bt(`Unexpected value '${fp(t)}' used in the bootstrap property of module '${fp(e)}'`), e)
                        }), h.push(...p.map(e => this._getEntryComponentMetadata(e.reference))), r.schemas && d.push(...hp(r.schemas)), s = new Pn({
                            type: this._getTypeMetadata(e),
                            providers: u,
                            entryComponents: h,
                            bootstrapComponents: p,
                            schemas: d,
                            declaredDirectives: i,
                            exportedDirectives: m,
                            declaredPipes: a,
                            exportedPipes: g,
                            importedModules: l,
                            exportedModules: c,
                            transitiveModule: f,
                            id: r.id || null
                        }), h.forEach(e => f.addEntryComponent(e)), u.forEach(e => f.addProvider(e, s.type)), f.addModule(s.type), this._ngModuleCache.set(e, s), s
                    }
                    _checkSelfImport(e, t) {
                        return e === t && (this._reportError(Bt(`'${fp(e)}' module can't import itself`), e), !0)
                    }
                    _getTypeDescriptor(e) {
                        if (pp(e)) {
                            if (this.isDirective(e)) return "directive";
                            if (this.isPipe(e)) return "pipe";
                            if (this.isNgModule(e)) return "module"
                        }
                        return e.provide ? "provider" : "value"
                    }
                    _addTypeToModule(e, t) {
                        const n = this._ngModuleOfTypes.get(e);
                        n && n !== t ? this._reportError(Bt(`Type ${fp(e)} is part of the declarations of 2 modules: ${fp(n)} and ${fp(t)}! Please consider moving ${fp(e)} to a higher module that imports ${fp(n)} and ${fp(t)}. You can also create a new NgModule that exports and includes ${fp(e)} then import that NgModule in ${fp(n)} and ${fp(t)}.`), t) : this._ngModuleOfTypes.set(e, t)
                    }
                    _getTransitiveNgModuleMetadata(e, t) {
                        const n = new kn,
                            s = new Map;
                        return e.concat(t).forEach(e => {
                            e.modules.forEach(e => n.addModule(e)), e.entryComponents.forEach(e => n.addEntryComponent(e));
                            const t = new Set;
                            e.providers.forEach(e => {
                                const r = Sn(e.provider.token);
                                let i = s.get(r);
                                i || (i = new Set, s.set(r, i));
                                const o = e.module.reference;
                                !t.has(r) && i.has(o) || (i.add(o), t.add(r), n.addProvider(e.provider, e.module))
                            })
                        }), t.forEach(e => {
                            e.exportedDirectives.forEach(e => n.addExportedDirective(e)), e.exportedPipes.forEach(e => n.addExportedPipe(e))
                        }), e.forEach(e => {
                            e.exportedDirectives.forEach(e => n.addDirective(e)), e.exportedPipes.forEach(e => n.addPipe(e))
                        }), n
                    }
                    _getIdentifierMetadata(e) {
                        return {
                            reference: e = Gt(e)
                        }
                    }
                    isInjectable(e) {
                        return this._reflector.tryAnnotations(e).some(e => j.isTypeOf(e))
                    }
                    getInjectableSummary(e) {
                        return {
                            summaryKind: En.Injectable,
                            type: this._getTypeMetadata(e, null, !1)
                        }
                    }
                    getInjectableMetadata(e, t = null, n = !0) {
                        const s = this._loadSummary(e, En.Injectable),
                            r = s ? s.type : this._getTypeMetadata(e, t, n),
                            i = this._reflector.annotations(e).filter(e => j.isTypeOf(e));
                        if (0 === i.length) return null;
                        const o = i[i.length - 1];
                        return {
                            symbol: e,
                            type: r,
                            providedIn: o.providedIn,
                            useValue: o.useValue,
                            useClass: o.useClass,
                            useExisting: o.useExisting,
                            useFactory: o.useFactory,
                            deps: o.deps
                        }
                    }
                    _getTypeMetadata(e, t = null, n = !0) {
                        const s = this._getIdentifierMetadata(e);
                        return {
                            reference: s.reference,
                            diDeps: this._getDependenciesMetadata(s.reference, t, n),
                            lifecycleHooks: (r = this._reflector, i = s.reference, ap.filter(e => lp(r, e, i)))
                        };
                        var r, i
                    }
                    _getFactoryMetadata(e, t = null) {
                        return {
                            reference: e = Gt(e),
                            diDeps: this._getDependenciesMetadata(e, t)
                        }
                    }
                    getPipeMetadata(e) {
                        const t = this._pipeCache.get(e);
                        return t || this._reportError(Bt(`Illegal state: getPipeMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Pipe ${fp(e)}.`), e), t || null
                    }
                    getPipeSummary(e) {
                        const t = this._loadSummary(e, En.Pipe);
                        return t || this._reportError(Bt(`Illegal state: Could not load the summary for pipe ${fp(e)}.`), e), t
                    }
                    getOrLoadPipeMetadata(e) {
                        let t = this._pipeCache.get(e);
                        return t || (t = this._loadPipeMetadata(e)), t
                    }
                    _loadPipeMetadata(e) {
                        e = Gt(e);
                        const t = this._pipeResolver.resolve(e),
                            n = new Dn({
                                type: this._getTypeMetadata(e),
                                name: t.name,
                                pure: !!t.pure
                            });
                        return this._pipeCache.set(e, n), this._summaryCache.set(e, n.toSummary()), n
                    }
                    _getDependenciesMetadata(e, t, n = !0) {
                        let s = !1;
                        const r = (t || this._reflector.parameters(e) || []).map(e => {
                            let t = !1,
                                n = !1,
                                r = !1,
                                i = !1,
                                o = !1,
                                a = null;
                            return Array.isArray(e) ? e.forEach(e => {
                                U.isTypeOf(e) ? n = !0 : B.isTypeOf(e) ? r = !0 : H.isTypeOf(e) ? i = !0 : $.isTypeOf(e) ? o = !0 : E.isTypeOf(e) ? (t = !0, a = e.attributeName) : b.isTypeOf(e) ? a = e.token : (w.isTypeOf(e) || e instanceof pn || pp(e) && null == a) && (a = e)
                            }) : a = e, null == a ? (s = !0, {}) : {
                                isAttribute: t,
                                isHost: n,
                                isSelf: r,
                                isSkipSelf: i,
                                isOptional: o,
                                token: this._getTokenMetadata(a)
                            }
                        });
                        if (s) {
                            const t = r.map(e => e.token ? fp(e.token) : "?").join(", "),
                                s = `Can't resolve all parameters for ${fp(e)}: (${t}).`;
                            (n || this._config.strictInjectionParameters) && this._reportError(Bt(s), e)
                        }
                        return r
                    }
                    _getTokenMetadata(e) {
                        let t;
                        return t = "string" == typeof(e = Gt(e)) ? {
                            value: e
                        } : {
                            identifier: {
                                reference: e
                            }
                        }, t
                    }
                    _getProvidersMetadata(e, t, n, s = [], r) {
                        return e.forEach((i, o) => {
                            if (Array.isArray(i)) this._getProvidersMetadata(i, t, n, s);
                            else {
                                let a;
                                if ((i = Gt(i)) && "object" == typeof i && i.hasOwnProperty("provide")) this._validateProvider(i), a = new In(i.provide, i);
                                else {
                                    if (!pp(i)) {
                                        if (void 0 === i) return void this._reportError(Bt("Encountered undefined provider! Usually this means you have a circular dependencies. This might be caused by using 'barrel' index.ts files.")); {
                                            const t = e.reduce((e, t, n) => (n < o ? e.push(`${fp(t)}`) : n == o ? e.push(`?${fp(t)}?`) : n == o + 1 && e.push("..."), e), []).join(", ");
                                            return void this._reportError(Bt(`Invalid ${n||"provider"} - only instances of Provider and Type are allowed, got: [${t}]`), r)
                                        }
                                    }
                                    a = new In(i, {
                                        useClass: i
                                    })
                                }
                                a.token === this._reflector.resolveExternalReference(cn.ANALYZE_FOR_ENTRY_COMPONENTS) ? t.push(...this._getEntryComponentsFromProvider(a, r)) : s.push(this.getProviderMetadata(a))
                            }
                        }), s
                    }
                    _validateProvider(e) {
                        e.hasOwnProperty("useClass") && null == e.useClass && this._reportError(Bt(`Invalid provider for ${fp(e.provide)}. useClass cannot be ${e.useClass}.\n           Usually it happens when:\n           1. There's a circular dependency (might be caused by using index.ts (barrel) files).\n           2. Class was used before it was declared. Use forwardRef in this case.`))
                    }
                    _getEntryComponentsFromProvider(e, t) {
                        const n = [],
                            s = [];
                        return e.useFactory || e.useExisting || e.useClass ? (this._reportError(Bt("The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!"), t), []) : e.multi ? (r = e.useValue, i = s, Nt(r, new dp, i), s.forEach(e => {
                            const t = this._getEntryComponentMetadata(e.reference, !1);
                            t && n.push(t)
                        }), n) : (this._reportError(Bt("The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!"), t), []);
                        var r, i
                    }
                    _getEntryComponentMetadata(e, t = !0) {
                        const n = this.getNonNormalizedDirectiveMetadata(e);
                        if (n && n.metadata.isComponent) return {
                            componentType: e,
                            componentFactory: n.metadata.componentFactory
                        };
                        const s = this._loadSummary(e, En.Directive);
                        if (s && s.isComponent) return {
                            componentType: e,
                            componentFactory: s.componentFactory
                        };
                        if (t) throw Bt(`${e.name} cannot be used as an entry component.`);
                        return null
                    }
                    _getInjectableTypeMetadata(e, t = null) {
                        const n = this._loadSummary(e, En.Injectable);
                        return n ? n.type : this._getTypeMetadata(e, t)
                    }
                    getProviderMetadata(e) {
                        let t, n = null,
                            s = null,
                            r = this._getTokenMetadata(e.token);
                        return e.useClass ? (n = this._getInjectableTypeMetadata(e.useClass, e.dependencies), t = n.diDeps, e.token === e.useClass && (r = {
                            identifier: n
                        })) : e.useFactory && (s = this._getFactoryMetadata(e.useFactory, e.dependencies), t = s.diDeps), {
                            token: r,
                            useClass: n,
                            useValue: e.useValue,
                            useFactory: s,
                            useExisting: e.useExisting ? this._getTokenMetadata(e.useExisting) : void 0,
                            deps: t,
                            multi: e.multi
                        }
                    }
                    _getQueriesMetadata(e, t, n) {
                        const s = [];
                        return Object.keys(e).forEach(r => {
                            const i = e[r];
                            i.isViewQuery === t && s.push(this._getQueryMetadata(i, r, n))
                        }), s
                    }
                    _queryVarBindings(e) {
                        return e.split(/\s*,\s*/)
                    }
                    _getQueryMetadata(e, t, n) {
                        let s;
                        return "string" == typeof e.selector ? s = this._queryVarBindings(e.selector).map(e => this._getTokenMetadata(e)) : e.selector ? s = [this._getTokenMetadata(e.selector)] : (this._reportError(Bt(`Can't construct a query for the property "${t}" of "${fp(n)}" since the query selector wasn't defined.`), n), s = []), {
                            selectors: s,
                            first: e.first,
                            descendants: e.descendants,
                            propertyName: t,
                            read: e.read ? this._getTokenMetadata(e.read) : null,
                            static: e.static
                        }
                    }
                    _reportError(e, t, n) {
                        if (!this._errorCollector) throw e;
                        this._errorCollector(e, t), n && this._errorCollector(e, n)
                    }
                }

                function up(e, t = []) {
                    if (e)
                        for (let n = 0; n < e.length; n++) {
                            const s = Gt(e[n]);
                            Array.isArray(s) ? up(s, t) : t.push(s)
                        }
                    return t
                }

                function hp(e) {
                    return (t = up(e)) ? Array.from(new Set(t)) : [];
                    var t
                }

                function pp(e) {
                    return e instanceof pn || e instanceof q
                }
                class dp extends Rt {
                    visitOther(e, t) {
                        t.push({
                            reference: e
                        })
                    }
                }

                function fp(e) {
                    return e instanceof pn ? `${e.name} in ${e.filePath}` : Wt(e)
                }

                function mp(e, t) {
                    let n = 0;
                    t.eager || (n |= 4096), t.providerType === ml.PrivateService && (n |= 8192), t.isModule && (n |= 1073741824), t.lifecycleHooks.forEach(e => {
                        e !== op.OnDestroy && t.providerType !== ml.Directive && t.providerType !== ml.Component || (n |= _p(e))
                    });
                    const {
                        providerExpr: s,
                        flags: r,
                        depsExpr: i
                    } = t.multiProvider ? function(e, t, n) {
                        const s = [],
                            r = [],
                            i = n.map((t, n) => {
                                let s;
                                if (t.useClass) {
                                    const r = o(n, t.deps || t.useClass.diDeps);
                                    s = e.importExpr(t.useClass.reference).instantiate(r)
                                } else if (t.useFactory) {
                                    const r = o(n, t.deps || t.useFactory.diDeps);
                                    s = e.importExpr(t.useFactory.reference).callFn(r)
                                } else if (t.useExisting) {
                                    s = o(n, [{
                                        token: t.useExisting
                                    }])[0]
                                } else s = tp(e, t.useValue);
                                return s
                            });
                        return {
                            providerExpr: xt(r, [new rt(Ct(i))], re),
                            flags: 1024 | t,
                            depsExpr: Ct(s)
                        };

                        function o(t, n) {
                            return n.map((n, i) => {
                                const o = `p${t}_${i}`;
                                return r.push(new Ve(o, se)), s.push(vp(e, n)), vt(o)
                            })
                        }
                    }(e, n, t.providers) : gp(e, n, t.providerType, t.providers[0]);
                    return {
                        providerExpr: s,
                        flags: r,
                        depsExpr: i,
                        tokenExpr: yp(e, t.token)
                    }
                }

                function gp(e, t, n, s) {
                    let r, i;
                    n === ml.Directive || n === ml.Component ? (r = e.importExpr(s.useClass.reference), t |= 16384, i = s.deps || s.useClass.diDeps) : s.useClass ? (r = e.importExpr(s.useClass.reference), t |= 512, i = s.deps || s.useClass.diDeps) : s.useFactory ? (r = e.importExpr(s.useFactory.reference), t |= 1024, i = s.deps || s.useFactory.diDeps) : s.useExisting ? (r = Qe, t |= 2048, i = [{
                        token: s.useExisting
                    }]) : (r = tp(e, s.useValue), t |= 256, i = []);
                    return {
                        providerExpr: r,
                        flags: t,
                        depsExpr: Ct(i.map(t => vp(e, t)))
                    }
                }

                function yp(e, t) {
                    return t.identifier ? e.importExpr(t.identifier.reference) : At(t.value)
                }

                function vp(e, t) {
                    const n = t.isValue ? tp(e, t.value) : yp(e, t.token);
                    let s = 0;
                    return t.isSkipSelf && (s |= 1), t.isOptional && (s |= 2), t.isSelf && (s |= 4), t.isValue && (s |= 8), 0 === s ? n : Ct([At(s), n])
                }

                function _p(e) {
                    let t = 0;
                    switch (e) {
                        case op.AfterContentChecked:
                            t = 2097152;
                            break;
                        case op.AfterContentInit:
                            t = 1048576;
                            break;
                        case op.AfterViewChecked:
                            t = 8388608;
                            break;
                        case op.AfterViewInit:
                            t = 4194304;
                            break;
                        case op.DoCheck:
                            t = 262144;
                            break;
                        case op.OnChanges:
                            t = 524288;
                            break;
                        case op.OnDestroy:
                            t = 131072;
                            break;
                        case op.OnInit:
                            t = 65536
                    }
                    return t
                }

                function bp(e, t, n, s) {
                    const r = s.map(e => t.importExpr(e.componentFactory)),
                        i = hn(e, cn.ComponentFactoryResolver),
                        o = {
                            diDeps: [{
                                isValue: !0,
                                value: Ct(r)
                            }, {
                                token: i,
                                isSkipSelf: !0,
                                isOptional: !0
                            }, {
                                token: hn(e, cn.NgModuleRef)
                            }],
                            lifecycleHooks: [],
                            reference: e.resolveExternalReference(cn.CodegenComponentFactoryResolver)
                        },
                        {
                            providerExpr: a,
                            flags: l,
                            depsExpr: c
                        } = gp(t, n, ml.PrivateService, {
                            token: i,
                            multi: !1,
                            useClass: o
                        });
                    return {
                        providerExpr: a,
                        flags: l,
                        depsExpr: c,
                        tokenExpr: yp(t, i)
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class wp {
                    constructor(e) {
                        this.ngModuleFactoryVar = e
                    }
                }
                const Ep = vt("_l");
                class Cp {
                    constructor(e) {
                        this.reflector = e
                    }
                    compile(e, t, n) {
                        const s = function(e, t) {
                                const n = vn(t),
                                    s = null != n ? `in ${e} ${yn(t)} in ${n}` : `in ${e} ${yn(t)}`,
                                    r = new yi("", s);
                                return new vi(new gi(r, -1, -1, -1), new gi(r, -1, -1, -1))
                            }("NgModule", t.type),
                            r = t.transitiveModule.entryComponents,
                            i = t.bootstrapComponents,
                            o = new wl(this.reflector, t, n, s),
                            a = [bp(this.reflector, e, 0, r)].concat(o.parse().map(t => mp(e, t))).map(({
                                providerExpr: e,
                                depsExpr: t,
                                flags: n,
                                tokenExpr: s
                            }) => _t(cn.moduleProviderDef).callFn([At(n), s, e, t])),
                            l = _t(cn.moduleDef).callFn([Ct(a)]),
                            c = xt([new Ve(Ep.name)], [new rt(l)], re),
                            u = `${yn(t.type)}NgFactory`;
                        if (this._createNgModuleFactory(e, t.type.reference, _t(cn.createModuleFactory).callFn([e.importExpr(t.type.reference), Ct(i.map(t => e.importExpr(t.reference))), c])), t.id) {
                            const n = "string" == typeof t.id ? At(t.id) : e.importExpr(t.id),
                                s = _t(cn.RegisterModuleFactoryFn).callFn([n, vt(u)]).toStmt();
                            e.statements.push(s)
                        }
                        return new wp(u)
                    }
                    createStub(e, t) {
                        this._createNgModuleFactory(e, t, Qe)
                    }
                    _createNgModuleFactory(e, t, n) {
                        const s = vt(`${yn({reference:t})}NgFactory`).set(n).toDeclStmt(bt(cn.NgModuleFactory, [wt(e.importExpr(t))], [Z.Const]), [Je.Final, Je.Exported]);
                        e.statements.push(s)
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Sp {
                    constructor(e) {
                        this._reflector = e
                    }
                    isNgModule(e) {
                        return this._reflector.annotations(e).some(R.isTypeOf)
                    }
                    resolve(e, t = !0) {
                        const n = vh(this._reflector.annotations(e), R.isTypeOf);
                        if (n) return n;
                        if (t) throw new Error(`No NgModule metadata found for '${Wt(e)}'.`);
                        return null
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class xp extends Wr {
                    constructor(e, t) {
                        super(!1), this.referenceFilter = e, this.importFilter = t, this.typeExpression = 0, this.importsWithPrefixes = new Map, this.reexports = new Map
                    }
                    visitType(e, t, n = "any") {
                        e ? (this.typeExpression++, e.visitType(this, t), this.typeExpression--) : t.print(null, n)
                    }
                    visitLiteralExpr(e, t) {
                        const n = e.value;
                        return null == n && e.type != re ? (t.print(e, `(${n} as any)`), null) : super.visitLiteralExpr(e, t)
                    }
                    visitLiteralArrayExpr(e, t) {
                        0 === e.entries.length && t.print(e, "(");
                        const n = super.visitLiteralArrayExpr(e, t);
                        return 0 === e.entries.length && t.print(e, " as any[])"), n
                    }
                    visitExternalExpr(e, t) {
                        return this._visitIdentifier(e.value, e.typeParams, t), null
                    }
                    visitAssertNotNullExpr(e, t) {
                        const n = super.visitAssertNotNullExpr(e, t);
                        return t.print(e, "!"), n
                    }
                    visitDeclareVarStmt(e, t) {
                        if (e.hasModifier(Je.Exported) && e.value instanceof Me && !e.type) {
                            const {
                                name: t,
                                moduleName: n
                            } = e.value.value;
                            if (n) {
                                let s = this.reexports.get(n);
                                return s || (s = [], this.reexports.set(n, s)), s.push({
                                    name: t,
                                    as: e.name
                                }), null
                            }
                        }
                        return e.hasModifier(Je.Exported) && t.print(e, "export "), e.hasModifier(Je.Final) ? t.print(e, "const") : t.print(e, "var"), t.print(e, ` ${e.name}`), this._printColonType(e.type, t), e.value && (t.print(e, " = "), e.value.visitExpression(this, t)), t.println(e, ";"), null
                    }
                    visitWrappedNodeExpr(e, t) {
                        throw new Error("Cannot visit a WrappedNodeExpr when outputting Typescript.")
                    }
                    visitCastExpr(e, t) {
                        return t.print(e, "(<"), e.type.visitType(this, t), t.print(e, ">"), e.value.visitExpression(this, t), t.print(e, ")"), null
                    }
                    visitInstantiateExpr(e, t) {
                        return t.print(e, "new "), this.typeExpression++, e.classExpr.visitExpression(this, t), this.typeExpression--, t.print(e, "("), this.visitAllExpressions(e.args, t, ","), t.print(e, ")"), null
                    }
                    visitDeclareClassStmt(e, t) {
                        return t.pushClass(e), e.hasModifier(Je.Exported) && t.print(e, "export "), t.print(e, `class ${e.name}`), null != e.parent && (t.print(e, " extends "), this.typeExpression++, e.parent.visitExpression(this, t), this.typeExpression--), t.println(e, " {"), t.incIndent(), e.fields.forEach(e => this._visitClassField(e, t)), null != e.constructorMethod && this._visitClassConstructor(e, t), e.getters.forEach(e => this._visitClassGetter(e, t)), e.methods.forEach(e => this._visitClassMethod(e, t)), t.decIndent(), t.println(e, "}"), t.popClass(), null
                    }
                    _visitClassField(e, t) {
                        e.hasModifier(Je.Private) && t.print(null, "/*private*/ "), e.hasModifier(Je.Static) && t.print(null, "static "), t.print(null, e.name), this._printColonType(e.type, t), e.initializer && (t.print(null, " = "), e.initializer.visitExpression(this, t)), t.println(null, ";")
                    }
                    _visitClassGetter(e, t) {
                        e.hasModifier(Je.Private) && t.print(null, "private "), t.print(null, `get ${e.name}()`), this._printColonType(e.type, t), t.println(null, " {"), t.incIndent(), this.visitAllStatements(e.body, t), t.decIndent(), t.println(null, "}")
                    }
                    _visitClassConstructor(e, t) {
                        t.print(e, "constructor("), this._visitParams(e.constructorMethod.params, t), t.println(e, ") {"), t.incIndent(), this.visitAllStatements(e.constructorMethod.body, t), t.decIndent(), t.println(e, "}")
                    }
                    _visitClassMethod(e, t) {
                        e.hasModifier(Je.Private) && t.print(null, "private "), t.print(null, `${e.name}(`), this._visitParams(e.params, t), t.print(null, ")"), this._printColonType(e.type, t, "void"), t.println(null, " {"), t.incIndent(), this.visitAllStatements(e.body, t), t.decIndent(), t.println(null, "}")
                    }
                    visitFunctionExpr(e, t) {
                        return e.name && (t.print(e, "function "), t.print(e, e.name)), t.print(e, "("), this._visitParams(e.params, t), t.print(e, ")"), this._printColonType(e.type, t, "void"), e.name || t.print(e, " => "), t.println(e, "{"), t.incIndent(), this.visitAllStatements(e.statements, t), t.decIndent(), t.print(e, "}"), null
                    }
                    visitDeclareFunctionStmt(e, t) {
                        return e.hasModifier(Je.Exported) && t.print(e, "export "), t.print(e, `function ${e.name}(`), this._visitParams(e.params, t), t.print(e, ")"), this._printColonType(e.type, t, "void"), t.println(e, " {"), t.incIndent(), this.visitAllStatements(e.statements, t), t.decIndent(), t.println(e, "}"), null
                    }
                    visitTryCatchStmt(e, t) {
                        t.println(e, "try {"), t.incIndent(), this.visitAllStatements(e.bodyStmts, t), t.decIndent(), t.println(e, `} catch (${Hr.name}) {`), t.incIndent();
                        const n = [Ur.set(Hr.prop("stack", null)).toDeclStmt(null, [Je.Final])].concat(e.catchStmts);
                        return this.visitAllStatements(n, t), t.decIndent(), t.println(e, "}"), null
                    }
                    visitBuiltinType(e, t) {
                        let n;
                        switch (e.name) {
                            case J.Bool:
                                n = "boolean";
                                break;
                            case J.Dynamic:
                                n = "any";
                                break;
                            case J.Function:
                                n = "Function";
                                break;
                            case J.Number:
                            case J.Int:
                                n = "number";
                                break;
                            case J.String:
                                n = "string";
                                break;
                            case J.None:
                                n = "never";
                                break;
                            default:
                                throw new Error(`Unsupported builtin type ${e.name}`)
                        }
                        return t.print(null, n), null
                    }
                    visitExpressionType(e, t) {
                        return e.value.visitExpression(this, t), null !== e.typeParams && (t.print(null, "<"), this.visitAllObjects(e => this.visitType(e, t), e.typeParams, t, ","), t.print(null, ">")), null
                    }
                    visitArrayType(e, t) {
                        return this.visitType(e.of, t), t.print(null, "[]"), null
                    }
                    visitMapType(e, t) {
                        return t.print(null, "{[key: string]:"), this.visitType(e.valueType, t), t.print(null, "}"), null
                    }
                    getBuiltinMethodName(e) {
                        let t;
                        switch (e) {
                            case pe.ConcatArray:
                                t = "concat";
                                break;
                            case pe.SubscribeObservable:
                                t = "subscribe";
                                break;
                            case pe.Bind:
                                t = "bind";
                                break;
                            default:
                                throw new Error(`Unknown builtin method: ${e}`)
                        }
                        return t
                    }
                    _visitParams(e, t) {
                        this.visitAllObjects(e => {
                            t.print(null, e.name), this._printColonType(e.type, t)
                        }, e, t, ",")
                    }
                    _visitIdentifier(e, t, n) {
                        const {
                            name: s,
                            moduleName: r
                        } = e;
                        if (this.referenceFilter && this.referenceFilter(e)) n.print(null, "(null as any)");
                        else {
                            if (r && (!this.importFilter || !this.importFilter(e))) {
                                let e = this.importsWithPrefixes.get(r);
                                null == e && (e = `i${this.importsWithPrefixes.size}`, this.importsWithPrefixes.set(r, e)), n.print(null, `${e}.`)
                            }
                            if (n.print(null, s), this.typeExpression > 0) {
                                (t || []).length > 0 && (n.print(null, "<"), this.visitAllObjects(e => e.visitType(this, n), t, n, ","), n.print(null, ">"))
                            }
                        }
                    }
                    _printColonType(e, t, n) {
                        e !== re && (t.print(null, ":"), this.visitType(e, t, n))
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Tp {
                    constructor(e) {
                        this._reflector = e
                    }
                    isPipe(e) {
                        const t = this._reflector.annotations(Gt(e));
                        return t && t.some(O.isTypeOf)
                    }
                    resolve(e, t = !0) {
                        const n = this._reflector.annotations(Gt(e));
                        if (n) {
                            const e = vh(n, O.isTypeOf);
                            if (e) return e
                        }
                        if (t) throw new Error(`No Pipe decorator found on ${Wt(e)}`);
                        return null
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Ap = "_any";
                new class {
                    notifyImplicitReceiverUse() {}
                    getLocal(e) {
                        return e === po.event.name ? vt(Ap) : null
                    }
                };
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Dp = "class",
                    Pp = "style";
                class kp {
                    constructor(e, t) {
                        this.viewClassVar = e, this.rendererTypeVar = t
                    }
                }
                class Op {
                    constructor(e) {
                        this._reflector = e
                    }
                    compileComponent(e, t, n, s, r) {
                        let i, o = 0;
                        if (!t.isHost) {
                            const n = t.template,
                                r = [];
                            n.animations && n.animations.length && r.push(new We("animation", tp(e, n.animations), !0));
                            const o = vt(bn(t.type.reference));
                            i = o.name, e.statements.push(o.set(_t(cn.createRendererType2).callFn([new Ge([new We("encapsulation", At(n.encapsulation), !1), new We("styles", s, !1), new We("data", new Ge(r), !1)])])).toDeclStmt(bt(cn.RendererType2), [Je.Final, Je.Exported]))
                        }
                        const a = n => {
                                const s = o++;
                                return new Lp(this._reflector, e, n, t, s, r, a)
                            },
                            l = a(null);
                        return l.visitAll([], n), e.statements.push(...l.build()), new kp(l.viewName, i)
                    }
                }
                const Ip = vt("_l"),
                    Np = vt("_v"),
                    Mp = vt("_ck"),
                    Fp = vt("_co"),
                    Rp = vt("en"),
                    jp = vt("ad");
                class Lp {
                    constructor(e, t, n, s, r, i, o) {
                        this.reflector = e, this.outputCtx = t, this.parent = n, this.component = s, this.embeddedViewIndex = r, this.usedPipes = i, this.viewBuilderFactory = o, this.nodes = [], this.purePipeNodeIndices = Object.create(null), this.refNodeIndices = Object.create(null), this.variables = [], this.children = [], this.compType = this.embeddedViewIndex > 0 ? se : wt(t.importExpr(this.component.type.reference)), this.viewName = _n(this.component.type.reference, this.embeddedViewIndex)
                    }
                    visitAll(e, t) {
                        this.variables = e, this.parent || this.usedPipes.forEach(e => {
                            e.pure && (this.purePipeNodeIndices[e.name] = this._createPipe(null, e))
                        }), this.parent || this.component.viewQueries.forEach((e, t) => {
                            const n = t + 1,
                                s = e.first ? 0 : 1,
                                r = 134217728 | qp(e);
                            this.nodes.push(() => ({
                                sourceSpan: null,
                                nodeFlags: r,
                                nodeDef: _t(cn.queryDef).callFn([At(r), At(n), new Ge([new We(e.propertyName, At(s), !1)])])
                            }))
                        }), yl(this, t), this.parent && (0 === t.length || Vp(t)) && this.nodes.push(() => ({
                            sourceSpan: null,
                            nodeFlags: 1,
                            nodeDef: _t(cn.anchorDef).callFn([At(0), Qe, Qe, At(0)])
                        }))
                    }
                    build(e = []) {
                        this.children.forEach(t => t.build(e));
                        const {
                            updateRendererStmts: t,
                            updateDirectivesStmts: n,
                            nodeDefExprs: s
                        } = this._createNodeExpressions(), r = this._createUpdateFn(t), i = this._createUpdateFn(n);
                        let o = 0;
                        this.parent || this.component.changeDetection !== P.OnPush || (o |= 2);
                        const a = new nt(this.viewName, [new Ve(Ip.name)], [new rt(_t(cn.viewDef).callFn([At(o), Ct(s), i, r]))], bt(cn.ViewDefinition), 0 === this.embeddedViewIndex ? [Je.Exported] : []);
                        return e.push(a), e
                    }
                    _createUpdateFn(e) {
                        let t;
                        if (e.length > 0) {
                            const n = [];
                            !this.component.isHost && dt(e).has(Fp.name) && n.push(Fp.set(Np.prop("component")).toDeclStmt(this.compType)), t = xt([new Ve(Mp.name, re), new Ve(Np.name, re)], [...n, ...e], re)
                        } else t = Qe;
                        return t
                    }
                    visitNgContent(e, t) {
                        this.nodes.push(() => ({
                            sourceSpan: e.sourceSpan,
                            nodeFlags: 8,
                            nodeDef: _t(cn.ngContentDef).callFn([At(e.ngContentIndex), At(e.index)])
                        }))
                    }
                    visitText(e, t) {
                        this.nodes.push(() => ({
                            sourceSpan: e.sourceSpan,
                            nodeFlags: 2,
                            nodeDef: _t(cn.textDef).callFn([At(-1), At(e.ngContentIndex), Ct([At(e.value)])])
                        }))
                    }
                    visitBoundText(e, t) {
                        const n = this.nodes.length;
                        this.nodes.push(null);
                        const s = e.value.ast,
                            r = s.expressions.map((t, s) => this._preprocessUpdateExpression({
                                nodeIndex: n,
                                bindingIndex: s,
                                sourceSpan: e.sourceSpan,
                                context: Fp,
                                value: t
                            })),
                            i = n;
                        this.nodes[n] = () => ({
                            sourceSpan: e.sourceSpan,
                            nodeFlags: 2,
                            nodeDef: _t(cn.textDef).callFn([At(i), At(e.ngContentIndex), Ct(s.strings.map(e => At(e)))]),
                            updateRenderer: r
                        })
                    }
                    visitEmbeddedTemplate(e, t) {
                        const n = this.nodes.length;
                        this.nodes.push(null);
                        const {
                            flags: s,
                            queryMatchesExpr: r,
                            hostEvents: i
                        } = this._visitElementOrTemplate(n, e), o = this.viewBuilderFactory(this);
                        this.children.push(o), o.visitAll(e.variables, e.children);
                        const a = this.nodes.length - n - 1;
                        this.nodes[n] = () => ({
                            sourceSpan: e.sourceSpan,
                            nodeFlags: 1 | s,
                            nodeDef: _t(cn.anchorDef).callFn([At(s), r, At(e.ngContentIndex), At(a), this._createElementHandleEventFn(n, i), vt(o.viewName)])
                        })
                    }
                    visitElement(e, t) {
                        const n = this.nodes.length;
                        this.nodes.push(null);
                        const s = i(e.name) ? null : e.name,
                            {
                                flags: r,
                                usedEvents: o,
                                queryMatchesExpr: a,
                                hostBindings: l,
                                hostEvents: c
                            } = this._visitElementOrTemplate(n, e);
                        let u = [],
                            h = [],
                            p = [];
                        if (s) {
                            const t = e.inputs.map(e => ({
                                context: Fp,
                                inputAst: e,
                                dirAst: null
                            })).concat(l);
                            t.length && (h = t.map((e, t) => this._preprocessUpdateExpression({
                                context: e.context,
                                nodeIndex: n,
                                bindingIndex: t,
                                sourceSpan: e.inputAst.sourceSpan,
                                value: e.inputAst.value
                            })), u = t.map(e => function(e, t) {
                                const n = e.type;
                                switch (n) {
                                    case 1:
                                        return Ct([At(1), At(e.name), At(e.securityContext)]);
                                    case 0:
                                        return Ct([At(8), At(e.name), At(e.securityContext)]);
                                    case 4:
                                        return Ct([At(8 | (t && t.directive.isComponent ? 32 : 16)), At("@" + e.name), At(e.securityContext)]);
                                    case 2:
                                        return Ct([At(2), At(e.name), Qe]);
                                    case 3:
                                        return Ct([At(4), At(e.name), At(e.unit)]);
                                    default:
                                        throw new Error(`unexpected ${n}`)
                                }
                            }(e.inputAst, e.dirAst))), p = o.map(([e, t]) => Ct([At(e), At(t)]))
                        }
                        yl(this, e.children);
                        const d = this.nodes.length - n - 1,
                            f = e.directives.find(e => e.directive.isComponent);
                        let m = Qe,
                            g = Qe;
                        f && (g = this.outputCtx.importExpr(f.directive.componentViewType), m = this.outputCtx.importExpr(f.directive.rendererType));
                        const y = n;
                        this.nodes[n] = () => ({
                            sourceSpan: e.sourceSpan,
                            nodeFlags: 1 | r,
                            nodeDef: _t(cn.elementDef).callFn([At(y), At(r), a, At(e.ngContentIndex), At(d), At(s), s ? $p(e) : Qe, u.length ? Ct(u) : Qe, p.length ? Ct(p) : Qe, this._createElementHandleEventFn(n, c), g, m]),
                            updateRenderer: h
                        })
                    }
                    _visitElementOrTemplate(e, t) {
                        let n = 0;
                        t.hasViewContainer && (n |= 16777216);
                        const s = new Map;
                        t.outputs.forEach(e => {
                            const {
                                name: t,
                                target: n
                            } = Up(e, null);
                            s.set(zp(n, t), [n, t])
                        }), t.directives.forEach(e => {
                            e.hostEvents.forEach(t => {
                                const {
                                    name: n,
                                    target: r
                                } = Up(t, e);
                                s.set(zp(r, n), [r, n])
                            })
                        });
                        const r = [],
                            i = [];
                        this._visitComponentFactoryResolverProvider(t.directives), t.providers.forEach(e => {
                            let n;
                            if (t.directives.forEach(t => {
                                    t.directive.type.reference === Sn(e.token) && (n = t)
                                }), n) {
                                const {
                                    hostBindings: o,
                                    hostEvents: a
                                } = this._visitDirective(e, n, t.references, t.queryMatches, s);
                                r.push(...o), i.push(...a)
                            } else this._visitProvider(e, t.queryMatches)
                        });
                        let o = [];
                        return t.queryMatches.forEach(e => {
                            let t;
                            Sn(e.value) === this.reflector.resolveExternalReference(cn.ElementRef) ? t = 0 : Sn(e.value) === this.reflector.resolveExternalReference(cn.ViewContainerRef) ? t = 3 : Sn(e.value) === this.reflector.resolveExternalReference(cn.TemplateRef) && (t = 2), null != t && o.push(Ct([At(e.queryId), At(t)]))
                        }), t.references.forEach(t => {
                            let n;
                            t.value ? Sn(t.value) === this.reflector.resolveExternalReference(cn.TemplateRef) && (n = 2) : n = 1, null != n && (this.refNodeIndices[t.name] = e, o.push(Ct([At(t.name), At(n)])))
                        }), t.outputs.forEach(e => {
                            i.push({
                                context: Fp,
                                eventAst: e,
                                dirAst: null
                            })
                        }), {
                            flags: n,
                            usedEvents: Array.from(s.values()),
                            queryMatchesExpr: o.length ? Ct(o) : Qe,
                            hostBindings: r,
                            hostEvents: i
                        }
                    }
                    _visitDirective(e, t, n, s, r) {
                        const i = this.nodes.length;
                        this.nodes.push(null), t.directive.queries.forEach((e, n) => {
                            const s = t.contentQueryStartId + n,
                                r = 67108864 | qp(e),
                                i = e.first ? 0 : 1;
                            this.nodes.push(() => ({
                                sourceSpan: t.sourceSpan,
                                nodeFlags: r,
                                nodeDef: _t(cn.queryDef).callFn([At(r), At(s), new Ge([new We(e.propertyName, At(i), !1)])])
                            }))
                        });
                        const o = this.nodes.length - i - 1;
                        let {
                            flags: a,
                            queryMatchExprs: l,
                            providerExpr: c,
                            depsExpr: u
                        } = this._visitProviderOrDirective(e, s);
                        n.forEach(t => {
                            t.value && Sn(t.value) === Sn(e.token) && (this.refNodeIndices[t.name] = i, l.push(Ct([At(t.name), At(4)])))
                        }), t.directive.isComponent && (a |= 32768);
                        const h = t.inputs.map((e, t) => {
                                const n = Ct([At(t), At(e.directiveName)]);
                                return new We(e.directiveName, n, !1)
                            }),
                            p = [],
                            d = t.directive;
                        Object.keys(d.outputs).forEach(e => {
                            const t = d.outputs[e];
                            r.has(t) && p.push(new We(e, At(t), !1))
                        });
                        let f = [];
                        (t.inputs.length || (327680 & a) > 0) && (f = t.inputs.map((e, t) => this._preprocessUpdateExpression({
                            nodeIndex: i,
                            bindingIndex: t,
                            sourceSpan: e.sourceSpan,
                            context: Fp,
                            value: e.value
                        })));
                        const m = _t(cn.nodeValue).callFn([Np, At(i)]),
                            g = t.hostProperties.map(e => ({
                                context: m,
                                dirAst: t,
                                inputAst: e
                            })),
                            y = t.hostEvents.map(e => ({
                                context: m,
                                eventAst: e,
                                dirAst: t
                            })),
                            v = i;
                        return this.nodes[i] = () => ({
                            sourceSpan: t.sourceSpan,
                            nodeFlags: 16384 | a,
                            nodeDef: _t(cn.directiveDef).callFn([At(v), At(a), l.length ? Ct(l) : Qe, At(o), c, u, h.length ? new Ge(h) : Qe, p.length ? new Ge(p) : Qe]),
                            updateDirectives: f,
                            directive: t.directive.type
                        }), {
                            hostBindings: g,
                            hostEvents: y
                        }
                    }
                    _visitProvider(e, t) {
                        this._addProviderNode(this._visitProviderOrDirective(e, t))
                    }
                    _visitComponentFactoryResolverProvider(e) {
                        const t = e.find(e => e.directive.isComponent);
                        if (t && t.directive.entryComponents.length) {
                            const {
                                providerExpr: e,
                                depsExpr: n,
                                flags: s,
                                tokenExpr: r
                            } = bp(this.reflector, this.outputCtx, 8192, t.directive.entryComponents);
                            this._addProviderNode({
                                providerExpr: e,
                                depsExpr: n,
                                flags: s,
                                tokenExpr: r,
                                queryMatchExprs: [],
                                sourceSpan: t.sourceSpan
                            })
                        }
                    }
                    _addProviderNode(e) {
                        this.nodes.push(() => ({
                            sourceSpan: e.sourceSpan,
                            nodeFlags: e.flags,
                            nodeDef: _t(cn.providerDef).callFn([At(e.flags), e.queryMatchExprs.length ? Ct(e.queryMatchExprs) : Qe, e.tokenExpr, e.providerExpr, e.depsExpr])
                        }))
                    }
                    _visitProviderOrDirective(e, t) {
                        let n = [];
                        t.forEach(t => {
                            Sn(t.value) === Sn(e.token) && n.push(Ct([At(t.queryId), At(4)]))
                        });
                        const {
                            providerExpr: s,
                            depsExpr: r,
                            flags: i,
                            tokenExpr: o
                        } = mp(this.outputCtx, e);
                        return {
                            flags: 0 | i,
                            queryMatchExprs: n,
                            providerExpr: s,
                            depsExpr: r,
                            tokenExpr: o,
                            sourceSpan: e.sourceSpan
                        }
                    }
                    getLocal(e) {
                        if (e == po.event.name) return po.event;
                        let t = Np;
                        for (let n = this; n; n = n.parent, t = t.prop("parent").cast(se)) {
                            const s = n.refNodeIndices[e];
                            if (null != s) return _t(cn.nodeValue).callFn([t, At(s)]);
                            const r = n.variables.find(t => t.name === e);
                            if (r) {
                                const e = r.value || "$implicit";
                                return t.prop("context").prop(e)
                            }
                        }
                        return null
                    }
                    notifyImplicitReceiverUse() {}
                    _createLiteralArrayConverter(e, t) {
                        if (0 === t) {
                            const e = _t(cn.EMPTY_ARRAY);
                            return () => e
                        }
                        const n = this.nodes.length;
                        return this.nodes.push(() => ({
                            sourceSpan: e,
                            nodeFlags: 32,
                            nodeDef: _t(cn.pureArrayDef).callFn([At(n), At(t)])
                        })), e => Bp(n, e)
                    }
                    _createLiteralMapConverter(e, t) {
                        if (0 === t.length) {
                            const e = _t(cn.EMPTY_MAP);
                            return () => e
                        }
                        const n = St(t.map((e, t) => Object.assign(Object.assign({}, e), {
                                value: At(t)
                            }))),
                            s = this.nodes.length;
                        return this.nodes.push(() => ({
                            sourceSpan: e,
                            nodeFlags: 64,
                            nodeDef: _t(cn.pureObjectDef).callFn([At(s), n])
                        })), e => Bp(s, e)
                    }
                    _createPipeConverter(e, t, n) {
                        const s = this.usedPipes.find(e => e.name === t);
                        if (s.pure) {
                            const s = this.nodes.length;
                            this.nodes.push(() => ({
                                sourceSpan: e.sourceSpan,
                                nodeFlags: 128,
                                nodeDef: _t(cn.purePipeDef).callFn([At(s), At(n)])
                            }));
                            let r = Np,
                                i = this;
                            for (; i.parent;) i = i.parent, r = r.prop("parent").cast(se);
                            const o = i.purePipeNodeIndices[t],
                                a = _t(cn.nodeValue).callFn([r, At(o)]);
                            return t => Hp(e.nodeIndex, e.bindingIndex, Bp(s, [a].concat(t)))
                        } {
                            const t = this._createPipe(e.sourceSpan, s),
                                n = _t(cn.nodeValue).callFn([Np, At(t)]);
                            return t => Hp(e.nodeIndex, e.bindingIndex, n.callMethod("transform", t))
                        }
                    }
                    _createPipe(e, t) {
                        const n = this.nodes.length;
                        let s = 0;
                        t.type.lifecycleHooks.forEach(e => {
                            e === op.OnDestroy && (s |= _p(e))
                        });
                        const r = t.type.diDeps.map(e => vp(this.outputCtx, e));
                        return this.nodes.push(() => ({
                            sourceSpan: e,
                            nodeFlags: 16,
                            nodeDef: _t(cn.pipeDef).callFn([At(s), this.outputCtx.importExpr(t.type.reference), Ct(r)])
                        })), n
                    }
                    _preprocessUpdateExpression(e) {
                        return {
                            nodeIndex: e.nodeIndex,
                            bindingIndex: e.bindingIndex,
                            sourceSpan: e.sourceSpan,
                            context: e.context,
                            value: go({
                                createLiteralArrayConverter: t => this._createLiteralArrayConverter(e.sourceSpan, t),
                                createLiteralMapConverter: t => this._createLiteralMapConverter(e.sourceSpan, t),
                                createPipeConverter: (t, n) => this._createPipeConverter(e, t, n)
                            }, e.value)
                        }
                    }
                    _createNodeExpressions() {
                        const e = this;
                        let t = 0;
                        const n = [],
                            s = [],
                            r = this.nodes.map((e, t) => {
                                const {
                                    nodeDef: r,
                                    nodeFlags: o,
                                    updateDirectives: a,
                                    updateRenderer: l,
                                    sourceSpan: c
                                } = e();
                                l && n.push(...i(t, c, l, !1)), a && s.push(...i(t, c, a, (327680 & o) > 0));
                                return gt(3 & o ? new Ke([Ip.callFn([]).callFn([]), r]) : r, c)
                            });
                        return {
                            updateRendererStmts: n,
                            updateDirectivesStmts: s,
                            nodeDefExprs: r
                        };

                        function i(n, s, r, i) {
                            const o = [],
                                a = r.map(({
                                    sourceSpan: n,
                                    context: s,
                                    value: r
                                }) => {
                                    const i = "" + t++,
                                        a = s === Fp ? e : null,
                                        {
                                            stmts: l,
                                            currValExpr: c
                                        } = vo(a, s, r, i, wi.General);
                                    return o.push(...l.map(e => mt(e, n))), gt(c, n)
                                });
                            return (r.length || i) && o.push(mt(Bp(n, a).toStmt(), s)), o
                        }
                    }
                    _createElementHandleEventFn(e, t) {
                        const n = [];
                        let s, r = 0;
                        if (t.forEach(({
                                context: e,
                                eventAst: t,
                                dirAst: s
                            }) => {
                                const i = "" + r++,
                                    o = e === Fp ? this : null,
                                    {
                                        stmts: a,
                                        allowDefault: l
                                    } = mo(o, e, t.handler, i),
                                    c = a;
                                l && c.push(jp.set(l.and(jp)).toStmt());
                                const {
                                    target: u,
                                    name: h
                                } = Up(t, s), p = zp(u, h);
                                n.push(mt(new ct(At(p).identical(Rp), c), t.sourceSpan))
                            }), n.length > 0) {
                            const e = [jp.set(At(!0)).toDeclStmt(ie)];
                            !this.component.isHost && dt(n).has(Fp.name) && e.push(Fp.set(Np.prop("component")).toDeclStmt(this.compType)), s = xt([new Ve(Np.name, re), new Ve(Rp.name, re), new Ve(po.event.name, re)], [...e, ...n, new rt(jp)], re)
                        } else s = Qe;
                        return s
                    }
                    visitDirective(e, t) {}
                    visitDirectiveProperty(e, t) {}
                    visitReference(e, t) {}
                    visitVariable(e, t) {}
                    visitEvent(e, t) {}
                    visitElementProperty(e, t) {}
                    visitAttr(e, t) {}
                }

                function Vp(e) {
                    const t = e[e.length - 1];
                    return t instanceof hl ? t.hasViewContainer : t instanceof ul ? i(t.name) && t.children.length ? Vp(t.children) : t.hasViewContainer : t instanceof gl
                }

                function $p(e) {
                    const t = Object.create(null);
                    return e.attrs.forEach(e => {
                        t[e.name] = e.value
                    }), e.directives.forEach(e => {
                        Object.keys(e.directive.hostAttributes).forEach(n => {
                            const s = e.directive.hostAttributes[n],
                                r = t[n];
                            var i, o, a;
                            t[n] = null != r ? (o = r, a = s, (i = n) == Dp || i == Pp ? `${o} ${a}` : a) : s
                        })
                    }), Ct(Object.keys(t).sort().map(e => Ct([At(e), At(t[e])])))
                }

                function Bp(e, t) {
                    return t.length > 10 ? Mp.callFn([Np, At(e), At(1), Ct(t)]) : Mp.callFn([Np, At(e), At(0), ...t])
                }

                function Hp(e, t, n) {
                    return _t(cn.unwrapValue).callFn([Np, At(e), At(t), n])
                }

                function Up(e, t) {
                    return e.isAnimation ? {
                        name: `@${e.name}.${e.phase}`,
                        target: t && t.directive.isComponent ? "component" : null
                    } : e
                }

                function qp(e) {
                    let t = 0;
                    return e.first && e.static ? t |= 268435456 : t |= 536870912, t
                }

                function zp(e, t) {
                    return e ? `${e}:${t}` : t
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Wp = "useValue";
                new Set([Wp, "useFactory", "data", "id", "loadChildren"]);
                class Gp {
                    static build() {
                        const e = new Map;
                        return {
                            define: function(t, n) {
                                return e.set(t, n), this
                            },
                            done: function() {
                                return e.size > 0 ? new Kp(e) : Gp.empty
                            }
                        }
                    }
                }
                Gp.missing = {}, Gp.empty = {
                    resolve: e => Gp.missing
                };
                class Kp extends Gp {
                    constructor(e) {
                        super(), this.bindings = e
                    }
                    resolve(e) {
                        return this.bindings.has(e) ? this.bindings.get(e) : Gp.missing
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Qp {}
                class Zp {
                    constructor() {
                        this._summaries = new Map
                    }
                    isLibraryFile() {
                        return !1
                    }
                    toSummaryFileName(e) {
                        return e
                    }
                    fromSummaryFileName(e) {
                        return e
                    }
                    resolveSummary(e) {
                        return this._summaries.get(e) || null
                    }
                    getSymbolsOf() {
                        return []
                    }
                    getImportAs(e) {
                        return e
                    }
                    getKnownModuleName(e) {
                        return null
                    }
                    addSummary(e) {
                        this._summaries.set(e.symbol, e)
                    }
                }

                function Jp(e, t, n, s, r) {
                    const i = s.createChildWihtLocalVars();
                    for (let a = 0; a < e.length; a++) i.vars.set(e[a], t[a]);
                    const o = r.visitAllStatements(n, i);
                    return o ? o.value : null
                }
                class Xp {
                    constructor(e, t, n, s) {
                        this.parent = e, this.instance = t, this.className = n, this.vars = s, this.exports = []
                    }
                    createChildWihtLocalVars() {
                        return new Xp(this, this.instance, this.className, new Map)
                    }
                }
                class Yp {
                    constructor(e) {
                        this.value = e
                    }
                }
                class ed {
                    constructor(e) {
                        this.reflector = e
                    }
                    debugAst(e) {
                        return function(e) {
                            const t = new xp,
                                n = zr.createRoot();
                            return (Array.isArray(e) ? e : [e]).forEach(e => {
                                if (e instanceof et) e.visitStatement(t, n);
                                else if (e instanceof me) e.visitExpression(t, n);
                                else {
                                    if (!(e instanceof X)) throw new Error(`Don't know how to print debug info for ${e}`);
                                    e.visitType(t, n)
                                }
                            }), n.toSource()
                        }(e)
                    }
                    visitDeclareVarStmt(e, t) {
                        const n = e.value ? e.value.visitExpression(this, t) : void 0;
                        return t.vars.set(e.name, n), e.hasModifier(Je.Exported) && t.exports.push(e.name), null
                    }
                    visitWriteVarExpr(e, t) {
                        const n = e.value.visitExpression(this, t);
                        let s = t;
                        for (; null != s;) {
                            if (s.vars.has(e.name)) return s.vars.set(e.name, n), n;
                            s = s.parent
                        }
                        throw new Error(`Not declared variable ${e.name}`)
                    }
                    visitWrappedNodeExpr(e, t) {
                        throw new Error("Cannot interpret a WrappedNodeExpr.")
                    }
                    visitTypeofExpr(e, t) {
                        throw new Error("Cannot interpret a TypeofExpr")
                    }
                    visitReadVarExpr(e, t) {
                        let n = e.name;
                        if (null != e.builtin) switch (e.builtin) {
                            case he.Super:
                                return Object.getPrototypeOf(t.instance);
                            case he.This:
                                return t.instance;
                            case he.CatchError:
                                n = nd;
                                break;
                            case he.CatchStack:
                                n = sd;
                                break;
                            default:
                                throw new Error(`Unknown builtin variable ${e.builtin}`)
                        }
                        let s = t;
                        for (; null != s;) {
                            if (s.vars.has(n)) return s.vars.get(n);
                            s = s.parent
                        }
                        throw new Error(`Not declared variable ${n}`)
                    }
                    visitWriteKeyExpr(e, t) {
                        const n = e.receiver.visitExpression(this, t),
                            s = e.index.visitExpression(this, t),
                            r = e.value.visitExpression(this, t);
                        return n[s] = r, r
                    }
                    visitWritePropExpr(e, t) {
                        const n = e.receiver.visitExpression(this, t),
                            s = e.value.visitExpression(this, t);
                        return n[e.name] = s, s
                    }
                    visitInvokeMethodExpr(e, t) {
                        const n = e.receiver.visitExpression(this, t),
                            s = this.visitAllExpressions(e.args, t);
                        let r;
                        if (null != e.builtin) switch (e.builtin) {
                            case pe.ConcatArray:
                                r = n.concat(...s);
                                break;
                            case pe.SubscribeObservable:
                                r = n.subscribe({
                                    next: s[0]
                                });
                                break;
                            case pe.Bind:
                                r = n.bind(...s);
                                break;
                            default:
                                throw new Error(`Unknown builtin method ${e.builtin}`)
                        } else r = n[e.name].apply(n, s);
                        return r
                    }
                    visitInvokeFunctionExpr(e, t) {
                        const n = this.visitAllExpressions(e.args, t),
                            s = e.fn;
                        if (s instanceof ge && s.builtin === he.Super) return t.instance.constructor.prototype.constructor.apply(t.instance, n), null;
                        return e.fn.visitExpression(this, t).apply(null, n)
                    }
                    visitReturnStmt(e, t) {
                        return new Yp(e.value.visitExpression(this, t))
                    }
                    visitDeclareClassStmt(e, t) {
                        const n = function(e, t, n) {
                            const s = {};
                            e.getters.forEach(r => {
                                s[r.name] = {
                                    configurable: !1,
                                    get: function() {
                                        const s = new Xp(t, this, e.name, t.vars);
                                        return Jp([], [], r.body, s, n)
                                    }
                                }
                            }), e.methods.forEach(function(r) {
                                const i = r.params.map(e => e.name);
                                s[r.name] = {
                                    writable: !1,
                                    configurable: !1,
                                    value: function(...s) {
                                        const o = new Xp(t, this, e.name, t.vars);
                                        return Jp(i, s, r.body, o, n)
                                    }
                                }
                            });
                            const r = e.constructorMethod.params.map(e => e.name),
                                i = function(...s) {
                                    const i = new Xp(t, this, e.name, t.vars);
                                    e.fields.forEach(e => {
                                        this[e.name] = void 0
                                    }), Jp(r, s, e.constructorMethod.body, i, n)
                                },
                                o = e.parent ? e.parent.visitExpression(n, t) : Object;
                            return i.prototype = Object.create(o.prototype, s), i
                        }(e, t, this);
                        return t.vars.set(e.name, n), e.hasModifier(Je.Exported) && t.exports.push(e.name), null
                    }
                    visitExpressionStmt(e, t) {
                        return e.expr.visitExpression(this, t)
                    }
                    visitIfStmt(e, t) {
                        return e.condition.visitExpression(this, t) ? this.visitAllStatements(e.trueCase, t) : null != e.falseCase ? this.visitAllStatements(e.falseCase, t) : null
                    }
                    visitTryCatchStmt(e, t) {
                        try {
                            return this.visitAllStatements(e.bodyStmts, t)
                        } catch (n) {
                            const s = t.createChildWihtLocalVars();
                            return s.vars.set(nd, n), s.vars.set(sd, n.stack), this.visitAllStatements(e.catchStmts, s)
                        }
                    }
                    visitThrowStmt(e, t) {
                        throw e.error.visitExpression(this, t)
                    }
                    visitInstantiateExpr(e, t) {
                        const n = this.visitAllExpressions(e.args, t);
                        return new(e.classExpr.visitExpression(this, t))(...n)
                    }
                    visitLiteralExpr(e, t) {
                        return e.value
                    }
                    visitLocalizedString(e, t) {
                        return null
                    }
                    visitExternalExpr(e, t) {
                        return this.reflector.resolveExternalReference(e.value)
                    }
                    visitConditionalExpr(e, t) {
                        return e.condition.visitExpression(this, t) ? e.trueCase.visitExpression(this, t) : null != e.falseCase ? e.falseCase.visitExpression(this, t) : null
                    }
                    visitNotExpr(e, t) {
                        return !e.condition.visitExpression(this, t)
                    }
                    visitAssertNotNullExpr(e, t) {
                        return e.condition.visitExpression(this, t)
                    }
                    visitCastExpr(e, t) {
                        return e.value.visitExpression(this, t)
                    }
                    visitFunctionExpr(e, t) {
                        return td(e.params.map(e => e.name), e.statements, t, this)
                    }
                    visitDeclareFunctionStmt(e, t) {
                        const n = e.params.map(e => e.name);
                        return t.vars.set(e.name, td(n, e.statements, t, this)), e.hasModifier(Je.Exported) && t.exports.push(e.name), null
                    }
                    visitUnaryOperatorExpr(e, t) {
                        const n = () => e.expr.visitExpression(this, t);
                        switch (e.operator) {
                            case ce.Plus:
                                return +n();
                            case ce.Minus:
                                return -n();
                            default:
                                throw new Error(`Unknown operator ${e.operator}`)
                        }
                    }
                    visitBinaryOperatorExpr(e, t) {
                        const n = () => e.lhs.visitExpression(this, t),
                            s = () => e.rhs.visitExpression(this, t);
                        switch (e.operator) {
                            case ue.Equals:
                                return n() == s();
                            case ue.Identical:
                                return n() === s();
                            case ue.NotEquals:
                                return n() != s();
                            case ue.NotIdentical:
                                return n() !== s();
                            case ue.And:
                                return n() && s();
                            case ue.Or:
                                return n() || s();
                            case ue.Plus:
                                return n() + s();
                            case ue.Minus:
                                return n() - s();
                            case ue.Divide:
                                return n() / s();
                            case ue.Multiply:
                                return n() * s();
                            case ue.Modulo:
                                return n() % s();
                            case ue.Lower:
                                return n() < s();
                            case ue.LowerEquals:
                                return n() <= s();
                            case ue.Bigger:
                                return n() > s();
                            case ue.BiggerEquals:
                                return n() >= s();
                            default:
                                throw new Error(`Unknown operator ${e.operator}`)
                        }
                    }
                    visitReadPropExpr(e, t) {
                        let n;
                        return n = e.receiver.visitExpression(this, t)[e.name], n
                    }
                    visitReadKeyExpr(e, t) {
                        return e.receiver.visitExpression(this, t)[e.index.visitExpression(this, t)]
                    }
                    visitLiteralArrayExpr(e, t) {
                        return this.visitAllExpressions(e.entries, t)
                    }
                    visitLiteralMapExpr(e, t) {
                        const n = {};
                        return e.entries.forEach(e => n[e.key] = e.value.visitExpression(this, t)), n
                    }
                    visitCommaExpr(e, t) {
                        const n = this.visitAllExpressions(e.parts, t);
                        return n[n.length - 1]
                    }
                    visitAllExpressions(e, t) {
                        return e.map(e => e.visitExpression(this, t))
                    }
                    visitAllStatements(e, t) {
                        for (let n = 0; n < e.length; n++) {
                            const s = e[n].visitStatement(this, t);
                            if (s instanceof Yp) return s
                        }
                        return null
                    }
                }

                function td(e, t, n, s) {
                    return (...r) => Jp(e, r, t, n, s)
                }
                const nd = "error",
                    sd = "stack";
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class rd {
                    constructor(e, t, n, s, r, i, o, a, l, c, u) {
                        this._metadataResolver = e, this._templateParser = t, this._styleCompiler = n, this._viewCompiler = s, this._ngModuleCompiler = r, this._summaryResolver = i, this._reflector = o, this._jitEvaluator = a, this._compilerConfig = l, this._console = c, this.getExtraNgModuleProviders = u, this._compiledTemplateCache = new Map, this._compiledHostTemplateCache = new Map, this._compiledDirectiveWrapperCache = new Map, this._compiledNgModuleCache = new Map, this._sharedStylesheetCount = 0, this._addedAotSummaries = new Set
                    }
                    compileModuleSync(e) {
                        return jt(this._compileModuleAndComponents(e, !0))
                    }
                    compileModuleAsync(e) {
                        return Promise.resolve(this._compileModuleAndComponents(e, !1))
                    }
                    compileModuleAndAllComponentsSync(e) {
                        return jt(this._compileModuleAndAllComponents(e, !0))
                    }
                    compileModuleAndAllComponentsAsync(e) {
                        return Promise.resolve(this._compileModuleAndAllComponents(e, !1))
                    }
                    getComponentFactory(e) {
                        return this._metadataResolver.getDirectiveSummary(e).componentFactory
                    }
                    loadAotSummaries(e) {
                        this.clearCache(), this._addAotSummaries(e)
                    }
                    _addAotSummaries(e) {
                        if (this._addedAotSummaries.has(e)) return;
                        this._addedAotSummaries.add(e);
                        const t = e();
                        for (let n = 0; n < t.length; n++) {
                            const e = t[n];
                            if ("function" == typeof e) this._addAotSummaries(e);
                            else {
                                const t = e;
                                this._summaryResolver.addSummary({
                                    symbol: t.type.reference,
                                    metadata: null,
                                    type: t
                                })
                            }
                        }
                    }
                    hasAotSummary(e) {
                        return !!this._summaryResolver.resolveSummary(e)
                    }
                    _filterJitIdentifiers(e) {
                        return e.map(e => e.reference).filter(e => !this.hasAotSummary(e))
                    }
                    _compileModuleAndComponents(e, t) {
                        return Lt(this._loadModules(e, t), () => (this._compileComponents(e, null), this._compileModule(e)))
                    }
                    _compileModuleAndAllComponents(e, t) {
                        return Lt(this._loadModules(e, t), () => {
                            const t = [];
                            return this._compileComponents(e, t), {
                                ngModuleFactory: this._compileModule(e),
                                componentFactories: t
                            }
                        })
                    }
                    _loadModules(e, t) {
                        const n = [],
                            s = this._metadataResolver.getNgModuleMetadata(e);
                        return this._filterJitIdentifiers(s.transitiveModule.modules).forEach(e => {
                            const s = this._metadataResolver.getNgModuleMetadata(e);
                            this._filterJitIdentifiers(s.declaredDirectives).forEach(e => {
                                const r = this._metadataResolver.loadDirectiveMetadata(s.type.reference, e, t);
                                r && n.push(r)
                            }), this._filterJitIdentifiers(s.declaredPipes).forEach(e => this._metadataResolver.getOrLoadPipeMetadata(e))
                        }), Vt(n)
                    }
                    _compileModule(e) {
                        let t = this._compiledNgModuleCache.get(e);
                        if (!t) {
                            const n = this._metadataResolver.getNgModuleMetadata(e),
                                s = this.getExtraNgModuleProviders(n.type.reference),
                                r = ad(),
                                i = this._ngModuleCompiler.compile(r, n, s);
                            t = this._interpretOrJit(function(e) {
                                return Mn(`${yn(e.type)}/module.ngfactory.js`)
                            }(n), r.statements)[i.ngModuleFactoryVar], this._compiledNgModuleCache.set(n.type.reference, t)
                        }
                        return t
                    }
                    _compileComponents(e, t) {
                        const n = this._metadataResolver.getNgModuleMetadata(e),
                            s = new Map,
                            r = new Set,
                            i = this._filterJitIdentifiers(n.transitiveModule.modules);
                        i.forEach(e => {
                            const n = this._metadataResolver.getNgModuleMetadata(e);
                            this._filterJitIdentifiers(n.declaredDirectives).forEach(e => {
                                s.set(e, n);
                                const i = this._metadataResolver.getDirectiveMetadata(e);
                                if (i.isComponent && (r.add(this._createCompiledTemplate(i, n)), t)) {
                                    const e = this._createCompiledHostTemplate(i.type.reference, n);
                                    r.add(e), t.push(i.componentFactory)
                                }
                            })
                        }), i.forEach(e => {
                            const t = this._metadataResolver.getNgModuleMetadata(e);
                            this._filterJitIdentifiers(t.declaredDirectives).forEach(e => {
                                const t = this._metadataResolver.getDirectiveMetadata(e);
                                t.isComponent && t.entryComponents.forEach(e => {
                                    const t = s.get(e.componentType);
                                    r.add(this._createCompiledHostTemplate(e.componentType, t))
                                })
                            }), t.entryComponents.forEach(e => {
                                if (!this.hasAotSummary(e.componentType)) {
                                    const t = s.get(e.componentType);
                                    r.add(this._createCompiledHostTemplate(e.componentType, t))
                                }
                            })
                        }), r.forEach(e => this._compileTemplate(e))
                    }
                    clearCacheFor(e) {
                        this._compiledNgModuleCache.delete(e), this._metadataResolver.clearCacheFor(e), this._compiledHostTemplateCache.delete(e);
                        this._compiledTemplateCache.get(e) && this._compiledTemplateCache.delete(e)
                    }
                    clearCache() {
                        this._metadataResolver.clearCache(), this._compiledTemplateCache.clear(), this._compiledHostTemplateCache.clear(), this._compiledNgModuleCache.clear()
                    }
                    _createCompiledHostTemplate(e, t) {
                        if (!t) throw new Error(`Component ${Wt(e)} is not part of any NgModule or the module has not been imported into your module.`);
                        let n = this._compiledHostTemplateCache.get(e);
                        if (!n) {
                            const s = this._metadataResolver.getDirectiveMetadata(e);
                            od(s);
                            const r = this._metadataResolver.getHostComponentMetadata(s, s.componentFactory.viewDefFactory);
                            n = new id(!0, s.type, r, t, [s.type]), this._compiledHostTemplateCache.set(e, n)
                        }
                        return n
                    }
                    _createCompiledTemplate(e, t) {
                        let n = this._compiledTemplateCache.get(e.type.reference);
                        return n || (od(e), n = new id(!1, e.type, e, t, t.transitiveModule.directives), this._compiledTemplateCache.set(e.type.reference, n)), n
                    }
                    _compileTemplate(e) {
                        if (e.isCompiled) return;
                        const t = e.compMeta,
                            n = new Map,
                            s = ad(),
                            r = this._styleCompiler.compileComponent(s, t);
                        t.template.externalStylesheets.forEach(e => {
                            const s = this._styleCompiler.compileStyles(ad(), t, e);
                            n.set(e.moduleUrl, s)
                        }), this._resolveStylesCompileResult(r, n);
                        e.ngModule.transitiveModule.pipes.map(e => this._metadataResolver.getPipeSummary(e.reference));
                        const {
                            template: i,
                            pipes: o
                        } = this._parseTemplate(t, e.ngModule, e.directives), a = this._viewCompiler.compileComponent(s, t, i, vt(r.stylesVar), o), l = this._interpretOrJit(function(e, t) {
                            return Mn(`${yn(e)}/${yn(t.type)}.ngfactory.js`)
                        }(e.ngModule.type, e.compMeta), s.statements), c = l[a.viewClassVar], u = l[a.rendererTypeVar];
                        e.compiled(c, u)
                    }
                    _parseTemplate(e, t, n) {
                        const s = e.template.preserveWhitespaces,
                            r = n.map(e => this._metadataResolver.getDirectiveSummary(e.reference)),
                            i = t.transitiveModule.pipes.map(e => this._metadataResolver.getPipeSummary(e.reference));
                        return this._templateParser.parse(e, e.template.htmlAst, r, i, t.schemas, Fn(t.type, e, e.template), s)
                    }
                    _resolveStylesCompileResult(e, t) {
                        e.dependencies.forEach((e, n) => {
                            const s = t.get(e.moduleUrl),
                                r = this._resolveAndEvalStylesCompileResult(s, t);
                            e.setValue(r)
                        })
                    }
                    _resolveAndEvalStylesCompileResult(e, t) {
                        return this._resolveStylesCompileResult(e, t), this._interpretOrJit(function(e, t) {
                            const n = e.moduleUrl.split(/\/\\/g);
                            return Mn(`css/${t}${n[n.length-1]}.ngstyle.js`)
                        }(e.meta, this._sharedStylesheetCount++), e.outputCtx.statements)[e.stylesVar]
                    }
                    _interpretOrJit(e, t) {
                        return this._compilerConfig.useJit ? this._jitEvaluator.evaluateStatements(e, t, this._reflector, this._compilerConfig.jitDevMode) : function(e, t) {
                            const n = new Xp(null, null, null, new Map);
                            new ed(t).visitAllStatements(e, n);
                            const s = {};
                            return n.exports.forEach(e => {
                                s[e] = n.vars.get(e)
                            }), s
                        }(t, this._reflector)
                    }
                }
                class id {
                    constructor(e, t, n, s, r) {
                        this.isHost = e, this.compType = t, this.compMeta = n, this.ngModule = s, this.directives = r, this._viewClass = null, this.isCompiled = !1
                    }
                    compiled(e, t) {
                        this._viewClass = e, this.compMeta.componentViewType.setDelegate(e);
                        for (let n in t) this.compMeta.rendererType[n] = t[n];
                        this.isCompiled = !0
                    }
                }

                function od(e) {
                    if (!e.isComponent) throw new Error(`Could not compile '${yn(e.type)}' because it is not a component.`)
                }

                function ad() {
                    return {
                        statements: [],
                        genFilePath: "",
                        importExpr: e => _t({
                            name: yn(e),
                            moduleName: null,
                            runtime: e
                        }),
                        constantPool: new nn
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class ld {}
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const cd = class {
                    constructor(e = null) {
                        this._packagePrefix = e
                    }
                    resolve(e, t) {
                        let n = t;
                        null != e && e.length > 0 && (n = function(e, t) {
                                const n = dd(encodeURI(t)),
                                    s = dd(e);
                                if (null != n[pd.Scheme]) return fd(n);
                                n[pd.Scheme] = s[pd.Scheme];
                                for (let o = pd.Scheme; o <= pd.Port; o++) null == n[o] && (n[o] = s[o]);
                                if ("/" == n[pd.Path][0]) return fd(n);
                                let r = s[pd.Path];
                                null == r && (r = "/");
                                const i = r.lastIndexOf("/");
                                return r = r.substring(0, i + 1) + n[pd.Path], n[pd.Path] = r, fd(n)
                            }
                            /**
                             * @license
                             * Copyright Google LLC All Rights Reserved.
                             *
                             * Use of this source code is governed by an MIT-style license that can be
                             * found in the LICENSE file at https://angular.io/license
                             */
                            (e, n));
                        const s = dd(n);
                        let r = this._packagePrefix;
                        if (null != r && null != s && "package" == s[pd.Scheme]) {
                            let e = s[pd.Path];
                            return r = r.replace(/\/+$/, ""), e = e.replace(/^\/+/, ""), `${r}/${e}`
                        }
                        return n
                    }
                };

                function ud(e) {
                    const t = dd(e);
                    return t && t[pd.Scheme] || ""
                }
                const hd = new RegExp("^(?:([^:/?#.]+):)?(?://(?:([^/?#]*)@)?([\\w\\d\\-\\u0100-\\uffff.%]*)(?::([0-9]+))?)?([^?#]+)?(?:\\?([^#]*))?(?:#(.*))?$");
                var pd;

                function dd(e) {
                    return e.match(hd)
                }

                function fd(e) {
                    let t = e[pd.Path];
                    return t = null == t ? "" : function(e) {
                            if ("/" == e) return "/";
                            const t = "/" == e[0] ? "/" : "",
                                n = "/" === e[e.length - 1] ? "/" : "",
                                s = e.split("/"),
                                r = [];
                            let i = 0;
                            for (let o = 0; o < s.length; o++) {
                                const e = s[o];
                                switch (e) {
                                    case "":
                                    case ".":
                                        break;
                                    case "..":
                                        r.length > 0 ? r.pop() : i++;
                                        break;
                                    default:
                                        r.push(e)
                                }
                            }
                            if ("" == t) {
                                for (; i-- > 0;) r.unshift("..");
                                0 === r.length && r.push(".")
                            }
                            return t + r.join("/") + n
                        }(t), e[pd.Path] = t,
                        function(e, t, n, s, r, i, o) {
                            const a = [];
                            return null != e && a.push(e + ":"), null != n && (a.push("//"), null != t && a.push(t + "@"), a.push(n), null != s && a.push(":" + s)), null != r && a.push(r), null != i && a.push("?" + i), null != o && a.push("#" + o), a.join("")
                        }(e[pd.Scheme], e[pd.UserInfo], e[pd.Domain], e[pd.Port], t, e[pd.QueryData], e[pd.Fragment])
                }! function(e) {
                    e[e.Scheme = 1] = "Scheme", e[e.UserInfo = 2] = "UserInfo", e[e.Domain = 3] = "Domain", e[e.Port = 4] = "Port", e[e.Path = 5] = "Path", e[e.QueryData = 6] = "QueryData", e[e.Fragment = 7] = "Fragment"
                }(pd || (pd = {}));
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                ! function(e) {
                    (e.ng || (e.ng = {})).\u0275compilerFacade = new Qu
                }(Jt)
            }).call(this, n("yLpj"))
        },
        "24Ii": function(e, t, n) {
            let s;
            "undefined" != typeof window ? s = window : "undefined" != typeof self ? s = self : (console.warn("Using browser-only version of superagent in non-browser environment"), s = this);
            const r = n("cpc2"),
                i = n("kMlx"),
                o = n("8zgK"),
                a = n("/yFf"),
                l = n("nZbv");

            function c() {}
            const u = t = e.exports = function(e, n) {
                return "function" == typeof n ? new t.Request("GET", e).end(n) : 1 == arguments.length ? new t.Request("GET", e) : new t.Request(e, n)
            };
            t.Request = y, u.getXHR = () => {
                if (!(!s.XMLHttpRequest || s.location && "file:" == s.location.protocol && s.ActiveXObject)) return new XMLHttpRequest;
                try {
                    return new ActiveXObject("Microsoft.XMLHTTP")
                } catch (e) {}
                try {
                    return new ActiveXObject("Msxml2.XMLHTTP.6.0")
                } catch (e) {}
                try {
                    return new ActiveXObject("Msxml2.XMLHTTP.3.0")
                } catch (e) {}
                try {
                    return new ActiveXObject("Msxml2.XMLHTTP")
                } catch (e) {}
                throw Error("Browser-only version of superagent could not find XHR")
            };
            const h = "".trim ? e => e.trim() : e => e.replace(/(^\s*|\s*$)/g, "");

            function p(e) {
                if (!o(e)) return e;
                const t = [];
                for (const n in e) d(t, n, e[n]);
                return t.join("&")
            }

            function d(e, t, n) {
                if (null != n)
                    if (Array.isArray(n)) n.forEach(n => {
                        d(e, t, n)
                    });
                    else if (o(n))
                    for (const s in n) d(e, `${t}[${s}]`, n[s]);
                else e.push(encodeURIComponent(t) + "=" + encodeURIComponent(n));
                else null === n && e.push(encodeURIComponent(t))
            }

            function f(e) {
                const t = {},
                    n = e.split("&");
                let s, r;
                for (let i = 0, o = n.length; i < o; ++i) s = n[i], r = s.indexOf("="), -1 == r ? t[decodeURIComponent(s)] = "" : t[decodeURIComponent(s.slice(0, r))] = decodeURIComponent(s.slice(r + 1));
                return t
            }

            function m(e) {
                return /[\/+]json($|[^-\w])/.test(e)
            }

            function g(e) {
                this.req = e, this.xhr = this.req.xhr, this.text = "HEAD" != this.req.method && ("" === this.xhr.responseType || "text" === this.xhr.responseType) || void 0 === this.xhr.responseType ? this.xhr.responseText : null, this.statusText = this.req.xhr.statusText;
                let t = this.xhr.status;
                1223 === t && (t = 204), this._setStatusProperties(t), this.header = this.headers = function(e) {
                    const t = e.split(/\r?\n/),
                        n = {};
                    let s, r, i, o;
                    for (let a = 0, l = t.length; a < l; ++a) r = t[a], s = r.indexOf(":"), -1 !== s && (i = r.slice(0, s).toLowerCase(), o = h(r.slice(s + 1)), n[i] = o);
                    return n
                }(this.xhr.getAllResponseHeaders()), this.header["content-type"] = this.xhr.getResponseHeader("content-type"), this._setHeaderProperties(this.header), null === this.text && e._responseType ? this.body = this.xhr.response : this.body = "HEAD" != this.req.method ? this._parseBody(this.text ? this.text : this.xhr.response) : null
            }

            function y(e, t) {
                const n = this;
                this._query = this._query || [], this.method = e, this.url = t, this.header = {}, this._header = {}, this.on("end", () => {
                    let e, t = null,
                        s = null;
                    try {
                        s = new g(n)
                    } catch (r) {
                        return t = new Error("Parser is unable to parse the response"), t.parse = !0, t.original = r, n.xhr ? (t.rawResponse = void 0 === n.xhr.responseType ? n.xhr.responseText : n.xhr.response, t.status = n.xhr.status ? n.xhr.status : null, t.statusCode = t.status) : (t.rawResponse = null, t.status = null), n.callback(t)
                    }
                    n.emit("response", s);
                    try {
                        n._isResponseOK(s) || (e = new Error(s.statusText || "Unsuccessful HTTP response"))
                    } catch (i) {
                        e = i
                    }
                    e ? (e.original = t, e.response = s, e.status = s.status, n.callback(e, s)) : n.callback(null, s)
                })
            }

            function v(e, t, n) {
                const s = u("DELETE", e);
                return "function" == typeof t && (n = t, t = null), t && s.send(t), n && s.end(n), s
            }
            u.serializeObject = p, u.parseString = f, u.types = {
                html: "text/html",
                json: "application/json",
                xml: "text/xml",
                urlencoded: "application/x-www-form-urlencoded",
                form: "application/x-www-form-urlencoded",
                "form-data": "application/x-www-form-urlencoded"
            }, u.serialize = {
                "application/x-www-form-urlencoded": p,
                "application/json": JSON.stringify
            }, u.parse = {
                "application/x-www-form-urlencoded": f,
                "application/json": JSON.parse
            }, a(g.prototype), g.prototype._parseBody = function(e) {
                let t = u.parse[this.type];
                return this.req._parser ? this.req._parser(this, e) : (!t && m(this.type) && (t = u.parse["application/json"]), t && e && (e.length || e instanceof Object) ? t(e) : null)
            }, g.prototype.toError = function() {
                const e = this.req,
                    t = e.method,
                    n = e.url,
                    s = `cannot ${t} ${n} (${this.status})`,
                    r = new Error(s);
                return r.status = this.status, r.method = t, r.url = n, r
            }, u.Response = g, r(y.prototype), i(y.prototype), y.prototype.type = function(e) {
                return this.set("Content-Type", u.types[e] || e), this
            }, y.prototype.accept = function(e) {
                return this.set("Accept", u.types[e] || e), this
            }, y.prototype.auth = function(e, t, n) {
                1 === arguments.length && (t = ""), "object" == typeof t && null !== t && (n = t, t = ""), n || (n = {
                    type: "function" == typeof btoa ? "basic" : "auto"
                });
                const s = e => {
                    if ("function" == typeof btoa) return btoa(e);
                    throw new Error("Cannot use basic auth, btoa is not a function")
                };
                return this._auth(e, t, n, s)
            }, y.prototype.query = function(e) {
                return "string" != typeof e && (e = p(e)), e && this._query.push(e), this
            }, y.prototype.attach = function(e, t, n) {
                if (t) {
                    if (this._data) throw Error("superagent can't mix .send() and .attach()");
                    this._getFormData().append(e, t, n || t.name)
                }
                return this
            }, y.prototype._getFormData = function() {
                return this._formData || (this._formData = new s.FormData), this._formData
            }, y.prototype.callback = function(e, t) {
                if (this._shouldRetry(e, t)) return this._retry();
                const n = this._callback;
                this.clearTimeout(), e && (this._maxRetries && (e.retries = this._retries - 1), this.emit("error", e)), n(e, t)
            }, y.prototype.crossDomainError = function() {
                const e = new Error("Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.");
                e.crossDomain = !0, e.status = this.status, e.method = this.method, e.url = this.url, this.callback(e)
            }, y.prototype.buffer = y.prototype.ca = y.prototype.agent = function() {
                return console.warn("This is not supported in browser version of superagent"), this
            }, y.prototype.pipe = y.prototype.write = () => {
                throw Error("Streaming is not supported in browser version of superagent")
            }, y.prototype._isHost = function(e) {
                return e && "object" == typeof e && !Array.isArray(e) && "[object Object]" !== Object.prototype.toString.call(e)
            }, y.prototype.end = function(e) {
                this._endCalled && console.warn("Warning: .end() was called twice. This is not supported in superagent"), this._endCalled = !0, this._callback = e || c, this._finalizeQueryString(), this._end()
            }, y.prototype._end = function() {
                if (this._aborted) return this.callback(Error("The request has been aborted even before .end() was called"));
                const e = this,
                    t = this.xhr = u.getXHR();
                let n = this._formData || this._data;
                this._setTimeouts(), t.onreadystatechange = () => {
                    const n = t.readyState;
                    if (n >= 2 && e._responseTimeoutTimer && clearTimeout(e._responseTimeoutTimer), 4 != n) return;
                    let s;
                    try {
                        s = t.status
                    } catch (r) {
                        s = 0
                    }
                    if (!s) {
                        if (e.timedout || e._aborted) return;
                        return e.crossDomainError()
                    }
                    e.emit("end")
                };
                const s = (t, n) => {
                    n.total > 0 && (n.percent = n.loaded / n.total * 100), n.direction = t, e.emit("progress", n)
                };
                if (this.hasListeners("progress")) try {
                    t.onprogress = s.bind(null, "download"), t.upload && (t.upload.onprogress = s.bind(null, "upload"))
                } catch (r) {}
                try {
                    this.username && this.password ? t.open(this.method, this.url, !0, this.username, this.password) : t.open(this.method, this.url, !0)
                } catch (i) {
                    return this.callback(i)
                }
                if (this._withCredentials && (t.withCredentials = !0), !this._formData && "GET" != this.method && "HEAD" != this.method && "string" != typeof n && !this._isHost(n)) {
                    const e = this._header["content-type"];
                    let t = this._serializer || u.serialize[e ? e.split(";")[0] : ""];
                    !t && m(e) && (t = u.serialize["application/json"]), t && (n = t(n))
                }
                for (const o in this.header) null != this.header[o] && this.header.hasOwnProperty(o) && t.setRequestHeader(o, this.header[o]);
                this._responseType && (t.responseType = this._responseType), this.emit("request", this), t.send(void 0 !== n ? n : null)
            }, u.agent = () => new l, ["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(e => {
                l.prototype[e.toLowerCase()] = function(t, n) {
                    const s = new u.Request(e, t);
                    return this._setDefaults(s), n && s.end(n), s
                }
            }), l.prototype.del = l.prototype.delete, u.get = (e, t, n) => {
                const s = u("GET", e);
                return "function" == typeof t && (n = t, t = null), t && s.query(t), n && s.end(n), s
            }, u.head = (e, t, n) => {
                const s = u("HEAD", e);
                return "function" == typeof t && (n = t, t = null), t && s.query(t), n && s.end(n), s
            }, u.options = (e, t, n) => {
                const s = u("OPTIONS", e);
                return "function" == typeof t && (n = t, t = null), t && s.send(t), n && s.end(n), s
            }, u.del = v, u.delete = v, u.patch = (e, t, n) => {
                const s = u("PATCH", e);
                return "function" == typeof t && (n = t, t = null), t && s.send(t), n && s.end(n), s
            }, u.post = (e, t, n) => {
                const s = u("POST", e);
                return "function" == typeof t && (n = t, t = null), t && s.send(t), n && s.end(n), s
            }, u.put = (e, t, n) => {
                const s = u("PUT", e);
                return "function" == typeof t && (n = t, t = null), t && s.send(t), n && s.end(n), s
            }
        },
        "2QA8": function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return s
            });
            const s = "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random()
        },
        "2fFW": function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return r
            });
            let s = !1;
            const r = {
                Promise: void 0,
                set useDeprecatedSynchronousErrorHandling(e) {
                    if (e) {
                        const e = new Error;
                        console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + e.stack)
                    } else s && console.log("RxJS: Back to a better error behavior. Thank you. <3");
                    s = e
                },
                get useDeprecatedSynchronousErrorHandling() {
                    return s
                }
            }
        },
        "3t9w": function(e, t) {
            e.exports = e => Array.from(new Set(e))
        },
        "5+tZ": function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return l
            });
            var s = n("ZUHj"),
                r = n("l7GE"),
                i = n("51Dv"),
                o = n("lJxs"),
                a = n("Cfvw");

            function l(e, t, n = Number.POSITIVE_INFINITY) {
                return "function" == typeof t ? s => s.pipe(l((n, s) => Object(a.a)(e(n, s)).pipe(Object(o.a)((e, r) => t(n, e, s, r))), n)) : ("number" == typeof t && (n = t), t => t.lift(new c(e, n)))
            }
            class c {
                constructor(e, t = Number.POSITIVE_INFINITY) {
                    this.project = e, this.concurrent = t
                }
                call(e, t) {
                    return t.subscribe(new u(e, this.project, this.concurrent))
                }
            }
            class u extends r.a {
                constructor(e, t, n = Number.POSITIVE_INFINITY) {
                    super(e), this.project = t, this.concurrent = n, this.hasCompleted = !1, this.buffer = [], this.active = 0, this.index = 0
                }
                _next(e) {
                    this.active < this.concurrent ? this._tryNext(e) : this.buffer.push(e)
                }
                _tryNext(e) {
                    let t;
                    const n = this.index++;
                    try {
                        t = this.project(e, n)
                    } catch (s) {
                        return void this.destination.error(s)
                    }
                    this.active++, this._innerSub(t, e, n)
                }
                _innerSub(e, t, n) {
                    const r = new i.a(this, t, n),
                        o = this.destination;
                    o.add(r);
                    const a = Object(s.a)(this, e, void 0, void 0, r);
                    a !== r && o.add(a)
                }
                _complete() {
                    this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), this.unsubscribe()
                }
                notifyNext(e, t, n, s, r) {
                    this.destination.next(t)
                }
                notifyComplete(e) {
                    const t = this.buffer;
                    this.remove(e), this.active--, t.length > 0 ? this._next(t.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete()
                }
            }
        },
        "51Dv": function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return r
            });
            var s = n("7o/Q");
            class r extends s.a {
                constructor(e, t, n) {
                    super(), this.parent = e, this.outerValue = t, this.outerIndex = n, this.index = 0
                }
                _next(e) {
                    this.parent.notifyNext(this.outerValue, e, this.outerIndex, this.index++, this)
                }
                _error(e) {
                    this.parent.notifyError(e, this), this.unsubscribe()
                }
                _complete() {
                    this.parent.notifyComplete(this), this.unsubscribe()
                }
            }
        },
        "56io": function(e, t, n) {
            "use strict";
            e.exports = (e, t, n) => {
                e && void 0 === e[t] && (e[t] = n)
            }
        },
        "6rNy": function(e, t, n) {
            "use strict";
            const s = n("Qup9"),
                r = n("Qwta"),
                i = n("3t9w"),
                o = {
                    filter: function(e, t) {
                        return !e || "string" == typeof e && void 0 === t || ("string" == typeof e && (e = r(e, t)), this._filters = { ...this._filters,
                            ...e
                        }), this
                    },
                    taxonomy: function(e, t) {
                        const n = Array.isArray(t),
                            r = n ? t.reduce((e, t) => e && "number" == typeof t, !0) : "number" == typeof t,
                            o = n ? t.reduce((e, t) => e && "string" == typeof t, !0) : "string" == typeof t;
                        if (!o && !r) throw new Error("term must be a number, string, or array of numbers or strings");
                        "category" === e ? e = o ? "category_name" : "cat" : "post_tag" === e && (e = "tag"), this._taxonomyFilters = this._taxonomyFilters || {};
                        const a = (this._taxonomyFilters[e] || []).concat(t).sort(s);
                        return this._taxonomyFilters[e] = i(a, !0), this
                    },
                    year: function(e) {
                        return o.filter.call(this, "year", e)
                    },
                    month: function(e) {
                        let t;
                        if ("string" == typeof e) {
                            if (t = new Date(Date.parse(e + " 1, 2012")), isNaN(t)) return this;
                            e = t.getMonth() + 1
                        }
                        return "number" == typeof e ? o.filter.call(this, "monthnum", e) : this
                    },
                    day: function(e) {
                        return o.filter.call(this, "day", e)
                    },
                    path: function(e) {
                        return o.filter.call(this, "pagename", e)
                    }
                };
            e.exports = o
        },
        "7o/Q": function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return c
            });
            var s = n("n6bG"),
                r = n("gRHU"),
                i = n("quSY"),
                o = n("2QA8"),
                a = n("2fFW"),
                l = n("NJ4a");
            class c extends i.a {
                constructor(e, t, n) {
                    switch (super(), this.syncErrorValue = null, this.syncErrorThrown = !1, this.syncErrorThrowable = !1, this.isStopped = !1, arguments.length) {
                        case 0:
                            this.destination = r.a;
                            break;
                        case 1:
                            if (!e) {
                                this.destination = r.a;
                                break
                            }
                            if ("object" == typeof e) {
                                e instanceof c ? (this.syncErrorThrowable = e.syncErrorThrowable, this.destination = e, e.add(this)) : (this.syncErrorThrowable = !0, this.destination = new u(this, e));
                                break
                            }
                        default:
                            this.syncErrorThrowable = !0, this.destination = new u(this, e, t, n)
                    }
                }[o.a]() {
                    return this
                }
                static create(e, t, n) {
                    const s = new c(e, t, n);
                    return s.syncErrorThrowable = !1, s
                }
                next(e) {
                    this.isStopped || this._next(e)
                }
                error(e) {
                    this.isStopped || (this.isStopped = !0, this._error(e))
                }
                complete() {
                    this.isStopped || (this.isStopped = !0, this._complete())
                }
                unsubscribe() {
                    this.closed || (this.isStopped = !0, super.unsubscribe())
                }
                _next(e) {
                    this.destination.next(e)
                }
                _error(e) {
                    this.destination.error(e), this.unsubscribe()
                }
                _complete() {
                    this.destination.complete(), this.unsubscribe()
                }
                _unsubscribeAndRecycle() {
                    const {
                        _parentOrParents: e
                    } = this;
                    return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = e, this
                }
            }
            class u extends c {
                constructor(e, t, n, i) {
                    let o;
                    super(), this._parentSubscriber = e;
                    let a = this;
                    Object(s.a)(t) ? o = t : t && (o = t.next, n = t.error, i = t.complete, t !== r.a && (a = Object.create(t), Object(s.a)(a.unsubscribe) && this.add(a.unsubscribe.bind(a)), a.unsubscribe = this.unsubscribe.bind(this))), this._context = a, this._next = o, this._error = n, this._complete = i
                }
                next(e) {
                    if (!this.isStopped && this._next) {
                        const {
                            _parentSubscriber: t
                        } = this;
                        a.a.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable ? this.__tryOrSetError(t, this._next, e) && this.unsubscribe() : this.__tryOrUnsub(this._next, e)
                    }
                }
                error(e) {
                    if (!this.isStopped) {
                        const {
                            _parentSubscriber: t
                        } = this, {
                            useDeprecatedSynchronousErrorHandling: n
                        } = a.a;
                        if (this._error) n && t.syncErrorThrowable ? (this.__tryOrSetError(t, this._error, e), this.unsubscribe()) : (this.__tryOrUnsub(this._error, e), this.unsubscribe());
                        else if (t.syncErrorThrowable) n ? (t.syncErrorValue = e, t.syncErrorThrown = !0) : Object(l.a)(e), this.unsubscribe();
                        else {
                            if (this.unsubscribe(), n) throw e;
                            Object(l.a)(e)
                        }
                    }
                }
                complete() {
                    if (!this.isStopped) {
                        const {
                            _parentSubscriber: e
                        } = this;
                        if (this._complete) {
                            const t = () => this._complete.call(this._context);
                            a.a.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable ? (this.__tryOrSetError(e, t), this.unsubscribe()) : (this.__tryOrUnsub(t), this.unsubscribe())
                        } else this.unsubscribe()
                    }
                }
                __tryOrUnsub(e, t) {
                    try {
                        e.call(this._context, t)
                    } catch (n) {
                        if (this.unsubscribe(), a.a.useDeprecatedSynchronousErrorHandling) throw n;
                        Object(l.a)(n)
                    }
                }
                __tryOrSetError(e, t, n) {
                    if (!a.a.useDeprecatedSynchronousErrorHandling) throw new Error("bad call");
                    try {
                        t.call(this._context, n)
                    } catch (s) {
                        return a.a.useDeprecatedSynchronousErrorHandling ? (e.syncErrorValue = s, e.syncErrorThrown = !0, !0) : (Object(l.a)(s), !0)
                    }
                    return !1
                }
                _unsubscribe() {
                    const {
                        _parentSubscriber: e
                    } = this;
                    this._context = null, this._parentSubscriber = null, e.unsubscribe()
                }
            }
        },
        "7vnS": function(e, t) {
            e.exports = function(e, t, n) {
                if (!e) return n;
                var s, r;
                Array.isArray(t) && (s = t.slice(0));
                "string" == typeof t && (s = t.split("."));
                "symbol" == typeof t && (s = [t]);
                if (!Array.isArray(s)) throw new Error("props arg must be an array, a string or a symbol");
                for (; s.length;) {
                    if (r = s.shift(), !e) return n;
                    if (void 0 === (e = e[r])) return n
                }
                return e
            }
        },
        "8Y7J": function(e, t, n) {
            "use strict";
            (function(e) {
                n.d(t, "a", function() {
                    return Ot
                }), n.d(t, "b", function() {
                    return Hl
                }), n.d(t, "c", function() {
                    return $l
                }), n.d(t, "d", function() {
                    return Bl
                }), n.d(t, "e", function() {
                    return eu
                }), n.d(t, "f", function() {
                    return Rc
                }), n.d(t, "g", function() {
                    return Pt
                }), n.d(t, "h", function() {
                    return ac
                }), n.d(t, "i", function() {
                    return us
                }), n.d(t, "j", function() {
                    return T
                }), n.d(t, "k", function() {
                    return fo
                }), n.d(t, "l", function() {
                    return oc
                }), n.d(t, "m", function() {
                    return lc
                }), n.d(t, "n", function() {
                    return kl
                }), n.d(t, "o", function() {
                    return Fi
                }), n.d(t, "p", function() {
                    return Li
                }), n.d(t, "q", function() {
                    return Mi
                }), n.d(t, "r", function() {
                    return Jl
                }), n.d(t, "s", function() {
                    return Pl
                }), n.d(t, "t", function() {
                    return qi
                }), n.d(t, "u", function() {
                    return cs
                }), n.d(t, "v", function() {
                    return Tl
                }), n.d(t, "w", function() {
                    return en
                }), n.d(t, "x", function() {
                    return Ml
                }), n.d(t, "y", function() {
                    return Cr
                }), n.d(t, "z", function() {
                    return Zt
                }), n.d(t, "A", function() {
                    return Jr
                }), n.d(t, "B", function() {
                    return kt
                }), n.d(t, "C", function() {
                    return Ar
                }), n.d(t, "D", function() {
                    return Il
                }), n.d(t, "E", function() {
                    return ao
                }), n.d(t, "F", function() {
                    return lo
                }), n.d(t, "G", function() {
                    return Zl
                }), n.d(t, "H", function() {
                    return ec
                }), n.d(t, "I", function() {
                    return Ll
                }), n.d(t, "J", function() {
                    return Eo
                }), n.d(t, "K", function() {
                    return wo
                }), n.d(t, "L", function() {
                    return Oc
                }), n.d(t, "M", function() {
                    return hc
                }), n.d(t, "N", function() {
                    return Jt
                }), n.d(t, "O", function() {
                    return Nl
                }), n.d(t, "P", function() {
                    return Kl
                }), n.d(t, "Q", function() {
                    return Wl
                }), n.d(t, "R", function() {
                    return zl
                }), n.d(t, "S", function() {
                    return Ol
                }), n.d(t, "T", function() {
                    return Dl
                }), n.d(t, "U", function() {
                    return Wi
                }), n.d(t, "V", function() {
                    return zi
                }), n.d(t, "W", function() {
                    return vs
                }), n.d(t, "X", function() {
                    return Ki
                }), n.d(t, "Y", function() {
                    return is
                }), n.d(t, "Z", function() {
                    return Xt
                }), n.d(t, "ab", function() {
                    return Yt
                }), n.d(t, "bb", function() {
                    return Xl
                }), n.d(t, "cb", function() {
                    return Yl
                }), n.d(t, "db", function() {
                    return bo
                }), n.d(t, "eb", function() {
                    return vc
                }), n.d(t, "fb", function() {
                    return Qi
                }), n.d(t, "gb", function() {
                    return Nt
                }), n.d(t, "hb", function() {
                    return So
                }), n.d(t, "ib", function() {
                    return D
                }), n.d(t, "jb", function() {
                    return Ic
                }), n.d(t, "kb", function() {
                    return Tc
                }), n.d(t, "lb", function() {
                    return p
                }), n.d(t, "mb", function() {
                    return xc
                }), n.d(t, "nb", function() {
                    return Xc
                }), n.d(t, "ob", function() {
                    return bc
                }), n.d(t, "pb", function() {
                    return Vi
                }), n.d(t, "qb", function() {
                    return Ql
                }), n.d(t, "rb", function() {
                    return va
                }), n.d(t, "sb", function() {
                    return _a
                }), n.d(t, "tb", function() {
                    return xr
                }), n.d(t, "ub", function() {
                    return Oi
                }), n.d(t, "vb", function() {
                    return Gt
                }), n.d(t, "wb", function() {
                    return ss
                }), n.d(t, "xb", function() {
                    return Fn
                }), n.d(t, "yb", function() {
                    return Cn
                }), n.d(t, "zb", function() {
                    return tu
                }), n.d(t, "Ab", function() {
                    return xn
                }), n.d(t, "Bb", function() {
                    return Pn
                }), n.d(t, "Cb", function() {
                    return An
                }), n.d(t, "Db", function() {
                    return Tn
                }), n.d(t, "Eb", function() {
                    return Dn
                }), n.d(t, "Fb", function() {
                    return Na
                }), n.d(t, "Gb", function() {
                    return Ah
                }), n.d(t, "Hb", function() {
                    return Ho
                }), n.d(t, "Ib", function() {
                    return el
                }), n.d(t, "Jb", function() {
                    return nu
                }), n.d(t, "Kb", function() {
                    return Ai
                }), n.d(t, "Lb", function() {
                    return Zc
                }), n.d(t, "Mb", function() {
                    return Di
                }), n.d(t, "Nb", function() {
                    return Pi
                }), n.d(t, "Ob", function() {
                    return Sn
                }), n.d(t, "Pb", function() {
                    return I
                }), n.d(t, "Qb", function() {
                    return ga
                }), n.d(t, "Rb", function() {
                    return ma
                }), n.d(t, "Sb", function() {
                    return Wr
                }), n.d(t, "Tb", function() {
                    return Ei
                }), n.d(t, "Ub", function() {
                    return wi
                }), n.d(t, "Vb", function() {
                    return xa
                }), n.d(t, "Wb", function() {
                    return Sa
                }), n.d(t, "Xb", function() {
                    return pu
                }), n.d(t, "Yb", function() {
                    return qa
                }), n.d(t, "Zb", function() {
                    return mu
                }), n.d(t, "ac", function() {
                    return tl
                }), n.d(t, "bc", function() {
                    return gu
                }), n.d(t, "cc", function() {
                    return fu
                }), n.d(t, "dc", function() {
                    return nl
                }), n.d(t, "ec", function() {
                    return au
                }), n.d(t, "fc", function() {
                    return Ti
                }), n.d(t, "gc", function() {
                    return Cl
                }), n.d(t, "hc", function() {
                    return oe
                }), n.d(t, "ic", function() {
                    return c
                }), n.d(t, "jc", function() {
                    return vu
                }), n.d(t, "kc", function() {
                    return Vo
                }), n.d(t, "lc", function() {
                    return En
                }), n.d(t, "mc", function() {
                    return wu
                }), n.d(t, "nc", function() {
                    return m
                }), n.d(t, "oc", function() {
                    return cn
                });
                var s = n("XNiG"),
                    r = n("quSY"),
                    i = n("HDdC"),
                    o = n("VRyK"),
                    a = n("w1tV");
                /**
                 * @license Angular v11.0.7
                 * (c) 2010-2020 Google LLC. https://angular.io/
                 * License: MIT
                 */
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function l(e) {
                    for (let t in e)
                        if (e[t] === l) return t;
                    throw Error("Could not find renamed property on target object.")
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function c(e) {
                    if ("string" == typeof e) return e;
                    if (Array.isArray(e)) return "[" + e.map(c).join(", ") + "]";
                    if (null == e) return "" + e;
                    if (e.overriddenName) return `${e.overriddenName}`;
                    if (e.name) return `${e.name}`;
                    const t = e.toString();
                    if (null == t) return "" + t;
                    const n = t.indexOf("\n");
                    return -1 === n ? t : t.substring(0, n)
                }

                function u(e, t) {
                    return null == e || "" === e ? null === t ? "" : t : null == t || "" === t ? e : e + " " + t
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const h = l({
                    __forward_ref__: l
                });

                function p(e) {
                    return e.__forward_ref__ = p, e.toString = function() {
                        return c(this())
                    }, e
                }

                function d(e) {
                    return f(e) ? e() : e
                }

                function f(e) {
                    return "function" == typeof e && e.hasOwnProperty(h) && e.__forward_ref__ === p
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function m(e) {
                    return {
                        token: e.token,
                        providedIn: e.providedIn || null,
                        factory: e.factory,
                        value: void 0
                    }
                }

                function g(e) {
                    return {
                        factory: e.factory,
                        providers: e.providers || [],
                        imports: e.imports || []
                    }
                }

                function y(e) {
                    return v(e, _) || v(e, b)
                }

                function v(e, t) {
                    return e.hasOwnProperty(t) ? e[t] : null
                }
                const _ = l({
                        "\u0275prov": l
                    }),
                    b = (l({
                        "\u0275inj": l
                    }), l({
                        ngInjectableDef: l
                    }));
                l({
                    ngInjectorDef: l
                });
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var w;
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                let E;

                function C(e) {
                    const t = E;
                    return E = e, t
                }

                function S(e, t, n) {
                    const s = y(e);
                    if (s && "root" == s.providedIn) return void 0 === s.value ? s.value = s.factory() : s.value;
                    if (n & w.Optional) return null;
                    if (void 0 !== t) return t;
                    throw new Error(`Injector: NOT_FOUND [${c(e)}]`)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function x(e) {
                    return {
                        toString: e
                    }.toString()
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var T, A, D;
                ! function(e) {
                    e[e.Default = 0] = "Default", e[e.Host = 1] = "Host", e[e.Self = 2] = "Self", e[e.SkipSelf = 4] = "SkipSelf", e[e.Optional = 8] = "Optional"
                }(w || (w = {})),
                function(e) {
                    e[e.OnPush = 0] = "OnPush", e[e.Default = 1] = "Default"
                }(T || (T = {})),
                function(e) {
                    e[e.CheckOnce = 0] = "CheckOnce", e[e.Checked = 1] = "Checked", e[e.CheckAlways = 2] = "CheckAlways", e[e.Detached = 3] = "Detached", e[e.Errored = 4] = "Errored", e[e.Destroyed = 5] = "Destroyed"
                }(A || (A = {})),
                function(e) {
                    e[e.Emulated = 0] = "Emulated", e[e.None = 2] = "None", e[e.ShadowDom = 3] = "ShadowDom"
                }(D || (D = {}));
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const P = "undefined" != typeof globalThis && globalThis,
                    k = "undefined" != typeof window && window,
                    O = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self,
                    I = P || void 0 !== e && e || k || O;
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const N = {};
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const M = l({
                        "\u0275cmp": l
                    }),
                    F = (l({
                        "\u0275dir": l
                    }), l({
                        "\u0275pipe": l
                    }), l({
                        "\u0275mod": l
                    }), l({
                        "\u0275loc": l
                    }), l({
                        "\u0275fac": l
                    })),
                    R = l({
                        __NG_ELEMENT_ID__: l
                    });

                function j(e) {
                    return e[M] || null
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const L = 20,
                    V = 10;
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function $(e) {
                    return Array.isArray(e) && "object" == typeof e[1]
                }

                function B(e) {
                    return Array.isArray(e) && !0 === e[1]
                }

                function H(e) {
                    return 2 == (2 & e.flags)
                }

                function U(e) {
                    return null !== e.template
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function q(e, t) {
                    const n = e.hasOwnProperty(F);
                    return n ? e[F] : null
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class z extends Error {
                    constructor(e, t) {
                        super(W(e, t)), this.code = e
                    }
                }

                function W(e, t) {
                    return `${e?`NG0${e}: `:""}${t}`
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function G(e) {
                    return "string" == typeof e ? e : null == e ? "" : String(e)
                }

                function K(e) {
                    return "function" == typeof e ? e.name || e.toString() : "object" == typeof e && null != e && "function" == typeof e.type ? e.type.name || e.type.toString() : G(e)
                }

                function Q(e, t) {
                    const n = t ? `. Dependency path: ${t.join(" > ")} > ${e}` : "";
                    throw new z("200", `Circular dependency in DI detected for ${e}${n}`)
                }

                function Z(e, t) {
                    const n = t ? ` in ${t}` : "";
                    throw new z("201", `No provider for ${K(e)} found${n}`)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class J {
                    constructor(e, t, n) {
                        this.previousValue = e, this.currentValue = t, this.firstChange = n
                    }
                    isFirstChange() {
                        return this.firstChange
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function X() {
                    return Y
                }

                function Y(e) {
                    return e.type.prototype.ngOnChanges && (e.setInput = te), ee
                }

                function ee() {
                    const e = ne(this),
                        t = null == e ? void 0 : e.current;
                    if (t) {
                        const n = e.previous;
                        if (n === N) e.previous = t;
                        else
                            for (let e in t) n[e] = t[e];
                        e.current = null, this.ngOnChanges(t)
                    }
                }

                function te(e, t, n, s) {
                    const r = ne(e) || function(e, t) {
                        return e.__ngSimpleChanges__ = t
                    }
                    /**
                     * @license
                     * Copyright Google LLC All Rights Reserved.
                     *
                     * Use of this source code is governed by an MIT-style license that can be
                     * found in the LICENSE file at https://angular.io/license
                     */
                    (e, {
                        previous: N,
                        current: null
                    }), i = r.current || (r.current = {}), o = r.previous, a = this.declaredInputs[n], l = o[a];
                    i[a] = new J(l && l.currentValue, t, o === N), e[s] = t
                }
                X.ngInherit = !0;

                function ne(e) {
                    return e.__ngSimpleChanges__ || null
                }
                const se = "http://www.w3.org/2000/svg",
                    re = "http://www.w3.org/1998/MathML/";
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                let ie;

                function oe(e) {
                    ie = e
                }

                function ae() {
                    return void 0 !== ie ? ie : "undefined" != typeof document ? document : void 0
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var le;

                function ce(e) {
                    return !!e.listen
                }! function(e) {
                    e[e.Important = 1] = "Important", e[e.DashCase = 2] = "DashCase"
                }(le || (le = {}));
                const ue = {
                    createRenderer: (e, t) => ae()
                };
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function he(e) {
                    for (; Array.isArray(e);) e = e[0];
                    return e
                }

                function pe(e, t) {
                    const n = he(t[e.index]);
                    return n
                }

                function de(e, t) {
                    const n = e.data[t];
                    return n
                }

                function fe(e, t) {
                    const n = t[e];
                    return $(n) ? n : n[0]
                }

                function me(e) {
                    return e.__ngContext__ || null
                }

                function ge(e) {
                    const t = me(e);
                    return t ? Array.isArray(t) ? t : t.lView : null
                }

                function ye(e) {
                    return 4 == (4 & e[2])
                }

                function ve(e) {
                    return 128 == (128 & e[2])
                }

                function _e(e) {
                    e[18] = 0
                }

                function be(e, t) {
                    e[5] += t;
                    let n = e,
                        s = e[3];
                    for (; null !== s && (1 === t && 1 === n[5] || -1 === t && 0 === n[5]);) s[5] += t, n = s, s = s[3]
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const we = {
                    lFrame: Le(null),
                    bindingsEnabled: !0,
                    isInCheckNoChangesMode: !1
                };

                function Ee() {
                    return we.lFrame.lView
                }

                function Ce() {
                    let e = Se();
                    for (; null !== e && 64 === e.type;) e = e.parent;
                    return e
                }

                function Se() {
                    return we.lFrame.currentTNode
                }

                function xe() {
                    const e = we.lFrame,
                        t = e.currentTNode;
                    return e.isParent ? t : t.parent
                }

                function Te(e, t) {
                    const n = we.lFrame;
                    n.currentTNode = e, n.isParent = t
                }

                function Ae() {
                    return we.lFrame.isParent
                }

                function De() {
                    return we.isInCheckNoChangesMode
                }

                function Pe(e) {
                    we.isInCheckNoChangesMode = e
                }

                function ke(e) {
                    return we.lFrame.bindingIndex = e
                }

                function Oe(e, t) {
                    const n = we.lFrame;
                    n.bindingIndex = n.bindingRootIndex = e, Ie(t)
                }

                function Ie(e) {
                    we.lFrame.currentDirectiveIndex = e
                }

                function Ne(e) {
                    we.lFrame.currentQueryIndex = e
                }

                function Me(e) {
                    const t = e[1];
                    return 2 === t.type ? t.declTNode : 1 === t.type ? e[6] : null
                }

                function Fe(e, t, n) {
                    if (n & w.SkipSelf) {
                        let s = t,
                            r = e;
                        for (; !(s = s.parent, null !== s || n & w.Host || (s = Me(r), null === s) || (r = r[15], 10 & s.type)););
                        if (null === s) return !1;
                        t = s, e = r
                    }
                    const s = we.lFrame = je();
                    return s.currentTNode = t, s.lView = e, !0
                }

                function Re(e) {
                    const t = je();
                    const n = e[1];
                    we.lFrame = t, t.currentTNode = n.firstChild, t.lView = e, t.tView = n, t.contextLView = e, t.bindingIndex = n.bindingStartIndex, t.inI18n = !1
                }

                function je() {
                    const e = we.lFrame,
                        t = null === e ? null : e.child;
                    return null === t ? Le(e) : t
                }

                function Le(e) {
                    const t = {
                        currentTNode: null,
                        isParent: !0,
                        lView: null,
                        tView: null,
                        selectedIndex: -1,
                        contextLView: null,
                        elementDepthCount: 0,
                        currentNamespace: null,
                        currentDirectiveIndex: -1,
                        bindingRootIndex: -1,
                        bindingIndex: -1,
                        currentQueryIndex: 0,
                        parent: e,
                        child: null,
                        inI18n: !1
                    };
                    return null !== e && (e.child = t), t
                }

                function Ve() {
                    const e = we.lFrame;
                    return we.lFrame = e.parent, e.currentTNode = null, e.lView = null, e
                }
                const $e = Ve;

                function Be() {
                    const e = Ve();
                    e.isParent = !0, e.tView = null, e.selectedIndex = -1, e.contextLView = null, e.elementDepthCount = 0, e.currentDirectiveIndex = -1, e.currentNamespace = null, e.bindingRootIndex = -1, e.bindingIndex = -1, e.currentQueryIndex = 0
                }

                function He() {
                    return we.lFrame.selectedIndex
                }

                function Ue(e) {
                    we.lFrame.selectedIndex = e
                }

                function qe(e, t) {
                    for (let n = t.directiveStart, s = t.directiveEnd; n < s; n++) {
                        const t = e.data[n],
                            s = t.type.prototype,
                            {
                                ngAfterContentInit: r,
                                ngAfterContentChecked: i,
                                ngAfterViewInit: o,
                                ngAfterViewChecked: a,
                                ngOnDestroy: l
                            } = s;
                        r && (e.contentHooks || (e.contentHooks = [])).push(-n, r), i && ((e.contentHooks || (e.contentHooks = [])).push(n, i), (e.contentCheckHooks || (e.contentCheckHooks = [])).push(n, i)), o && (e.viewHooks || (e.viewHooks = [])).push(-n, o), a && ((e.viewHooks || (e.viewHooks = [])).push(n, a), (e.viewCheckHooks || (e.viewCheckHooks = [])).push(n, a)), null != l && (e.destroyHooks || (e.destroyHooks = [])).push(n, l)
                    }
                }

                function ze(e, t, n) {
                    Ke(e, t, 3, n)
                }

                function We(e, t, n, s) {
                    (3 & e[2]) === n && Ke(e, t, n, s)
                }

                function Ge(e, t) {
                    let n = e[2];
                    (3 & n) === t && (n &= 2047, n += 1, e[2] = n)
                }

                function Ke(e, t, n, s) {
                    const r = void 0 !== s ? 65535 & e[18] : 0,
                        i = null != s ? s : -1,
                        o = t.length - 1;
                    let a = 0;
                    for (let l = r; l < o; l++) {
                        if ("number" == typeof t[l + 1]) {
                            if (a = t[l], null != s && a >= s) break
                        } else {
                            t[l] < 0 && (e[18] += 65536), (a < i || -1 == i) && (Qe(e, n, t, l), e[18] = (4294901760 & e[18]) + l + 2), l++
                        }
                    }
                }

                function Qe(e, t, n, s) {
                    const r = n[s] < 0,
                        i = n[s + 1],
                        o = e[r ? -n[s] : n[s]];
                    if (r) {
                        e[2] >> 11 < e[18] >> 16 && (3 & e[2]) === t && (e[2] += 2048, i.call(o))
                    } else i.call(o)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Ze = -1;
                class Je {
                    constructor(e, t, n) {
                        this.factory = e, this.resolving = !1, this.canSeeViewProviders = t, this.injectImpl = n
                    }
                }

                function Xe(e, t, n) {
                    const s = ce(e);
                    let r = 0;
                    for (; r < n.length;) {
                        const i = n[r];
                        if ("number" == typeof i) {
                            if (0 !== i) break;
                            r++;
                            const o = n[r++],
                                a = n[r++],
                                l = n[r++];
                            s ? e.setAttribute(t, a, l, o) : t.setAttributeNS(o, a, l)
                        } else {
                            const o = i,
                                a = n[++r];
                            Ye(o) ? s && e.setProperty(t, o, a) : s ? e.setAttribute(t, o, a) : t.setAttribute(o, a), r++
                        }
                    }
                    return r
                }

                function Ye(e) {
                    return 64 === e.charCodeAt(0)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function et(e) {
                    return e !== Ze
                }

                function tt(e) {
                    return 32767 & e
                }

                function nt(e, t) {
                    let n = e >> 16;
                    let s = t;
                    for (; n > 0;) s = s[15], n--;
                    return s
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                let st = !0;

                function rt(e) {
                    const t = st;
                    return st = e, t
                }
                let it = 0;

                function ot(e, t) {
                    const n = lt(e, t);
                    if (-1 !== n) return n;
                    const s = t[1];
                    s.firstCreatePass && (e.injectorIndex = t.length, at(s.data, e), at(t, null), at(s.blueprint, null));
                    const r = ct(e, t),
                        i = e.injectorIndex;
                    if (et(r)) {
                        const e = tt(r),
                            n = nt(r, t),
                            s = n[1].data;
                        for (let r = 0; r < 8; r++) t[i + r] = n[e + r] | s[e + r]
                    }
                    return t[i + 8] = r, i
                }

                function at(e, t) {
                    e.push(0, 0, 0, 0, 0, 0, 0, 0, t)
                }

                function lt(e, t) {
                    return -1 === e.injectorIndex || e.parent && e.parent.injectorIndex === e.injectorIndex || null === t[e.injectorIndex + 8] ? -1 : e.injectorIndex
                }

                function ct(e, t) {
                    if (e.parent && -1 !== e.parent.injectorIndex) return e.parent.injectorIndex;
                    let n = 0,
                        s = null,
                        r = t;
                    for (; null !== r;) {
                        const e = r[1],
                            t = e.type;
                        if (s = 2 === t ? e.declTNode : 1 === t ? r[6] : null, null === s) return Ze;
                        if (n++, r = r[15], -1 !== s.injectorIndex) return s.injectorIndex | n << 16
                    }
                    return Ze
                }

                function ut(e, t, n) {
                    ! function(e, t, n) {
                        let s;
                        "string" == typeof n ? s = n.charCodeAt(0) || 0 : n.hasOwnProperty(R) && (s = n[R]), null == s && (s = n[R] = it++);
                        const r = 255 & s,
                            i = 1 << r,
                            o = 128 & r,
                            a = 64 & r,
                            l = 32 & r,
                            c = t.data;
                        o ? a ? l ? c[e + 7] |= i : c[e + 6] |= i : l ? c[e + 5] |= i : c[e + 4] |= i : a ? l ? c[e + 3] |= i : c[e + 2] |= i : l ? c[e + 1] |= i : c[e] |= i
                    }(e, t, n)
                }

                function ht(e, t, n) {
                    if (n & w.Optional) return e;
                    Z(t, "NodeInjector")
                }

                function pt(e, t, n, s) {
                    if (n & w.Optional && void 0 === s && (s = null), 0 == (n & (w.Self | w.Host))) {
                        const r = e[9],
                            i = C(void 0);
                        try {
                            return r ? r.get(t, s, n & w.Optional) : S(t, s, n & w.Optional)
                        } finally {
                            C(i)
                        }
                    }
                    return ht(s, t, n)
                }

                function dt(e, t, n, s = w.Default, r) {
                    if (null !== e) {
                        const i = function(e) {
                            if ("string" == typeof e) return e.charCodeAt(0) || 0;
                            const t = e.hasOwnProperty(R) ? e[R] : void 0;
                            return "number" == typeof t ? t >= 0 ? 255 & t : mt : t
                        }(n);
                        if ("function" == typeof i) {
                            if (!Fe(t, e, s)) return s & w.Host ? ht(r, n, s) : pt(t, n, s, r);
                            try {
                                const e = i();
                                if (null != e || s & w.Optional) return e;
                                Z(n)
                            } finally {
                                $e()
                            }
                        } else if ("number" == typeof i) {
                            let r = null,
                                o = lt(e, t),
                                a = Ze,
                                l = s & w.Host ? t[16][6] : null;
                            for ((-1 === o || s & w.SkipSelf) && (a = -1 === o ? ct(e, t) : t[o + 8], a !== Ze && bt(s, !1) ? (r = t[1], o = tt(a), t = nt(a, t)) : o = -1); - 1 !== o;) {
                                const e = t[1];
                                if (_t(i, o, e.data)) {
                                    const e = gt(o, t, n, r, s, l);
                                    if (e !== ft) return e
                                }
                                a = t[o + 8], a !== Ze && bt(s, t[1].data[o + 8] === l) && _t(i, o, t) ? (r = e, o = tt(a), t = nt(a, t)) : o = -1
                            }
                        }
                    }
                    return pt(t, n, s, r)
                }
                const ft = {};

                function mt() {
                    return new wt(Ce(), Ee())
                }

                function gt(e, t, n, s, r, i) {
                    const o = t[1],
                        a = o.data[e + 8],
                        l = yt(a, o, n, null == s ? H(a) && st : s != o && 0 != (3 & a.type), r & w.Host && i === a);
                    return null !== l ? vt(t, o, l, a) : ft
                }

                function yt(e, t, n, s, r) {
                    const i = e.providerIndexes,
                        o = t.data,
                        a = 1048575 & i,
                        l = e.directiveStart,
                        c = e.directiveEnd,
                        u = i >> 20,
                        h = r ? a + u : c;
                    for (let p = s ? a : a + u; p < h; p++) {
                        const e = o[p];
                        if (p < l && n === e || p >= l && e.type === n) return p
                    }
                    if (r) {
                        const e = o[l];
                        if (e && U(e) && e.type === n) return l
                    }
                    return null
                }

                function vt(e, t, n, s) {
                    let r = e[n];
                    const i = t.data;
                    if (r instanceof Je) {
                        const o = r;
                        o.resolving && Q(K(i[n]));
                        const a = rt(o.canSeeViewProviders);
                        o.resolving = !0;
                        const l = o.injectImpl ? C(o.injectImpl) : null;
                        Fe(e, s, w.Default);
                        try {
                            r = e[n] = o.factory(void 0, i, e, s), t.firstCreatePass && n >= s.directiveStart &&
                                /**
                                 * @license
                                 * Copyright Google LLC All Rights Reserved.
                                 *
                                 * Use of this source code is governed by an MIT-style license that can be
                                 * found in the LICENSE file at https://angular.io/license
                                 */
                                function(e, t, n) {
                                    const {
                                        ngOnChanges: s,
                                        ngOnInit: r,
                                        ngDoCheck: i
                                    } = t.type.prototype;
                                    if (s) {
                                        const s = Y(t);
                                        (n.preOrderHooks || (n.preOrderHooks = [])).push(e, s), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(e, s)
                                    }
                                    r && (n.preOrderHooks || (n.preOrderHooks = [])).push(0 - e, r), i && ((n.preOrderHooks || (n.preOrderHooks = [])).push(e, i), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(e, i))
                                }(n, i[n], t)
                        } finally {
                            null !== l && C(l), rt(a), o.resolving = !1, $e()
                        }
                    }
                    return r
                }

                function _t(e, t, n) {
                    const s = 1 << e,
                        r = 64 & e,
                        i = 32 & e;
                    let o;
                    return o = 128 & e ? r ? i ? n[t + 7] : n[t + 6] : i ? n[t + 5] : n[t + 4] : r ? i ? n[t + 3] : n[t + 2] : i ? n[t + 1] : n[t], !!(o & s)
                }

                function bt(e, t) {
                    return !(e & w.Self || e & w.Host && t)
                }
                class wt {
                    constructor(e, t) {
                        this._tNode = e, this._lView = t
                    }
                    get(e, t) {
                        return dt(this._tNode, this._lView, e, void 0, t)
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Et = "__annotations__",
                    Ct = "__parameters__",
                    St = "__prop__metadata__";

                function xt(e, t, n, s, r) {
                    return x(() => {
                        const i = Tt(t);

                        function o(...e) {
                            if (this instanceof o) return i.call(this, ...e), this;
                            const t = new o(...e);
                            return function(n) {
                                r && r(n, ...e);
                                return (n.hasOwnProperty(Et) ? n[Et] : Object.defineProperty(n, Et, {
                                    value: []
                                })[Et]).push(t), s && s(n), n
                            }
                        }
                        return n && (o.prototype = Object.create(n.prototype)), o.prototype.ngMetadataName = e, o.annotationCls = o, o
                    })
                }

                function Tt(e) {
                    return function(...t) {
                        if (e) {
                            const n = e(...t);
                            for (const e in n) this[e] = n[e]
                        }
                    }
                }

                function At(e, t, n) {
                    return x(() => {
                        const s = Tt(t);

                        function r(...e) {
                            if (this instanceof r) return s.apply(this, e), this;
                            const t = new r(...e);
                            return n.annotation = t, n;

                            function n(e, n, s) {
                                const r = e.hasOwnProperty(Ct) ? e[Ct] : Object.defineProperty(e, Ct, {
                                    value: []
                                })[Ct];
                                for (; r.length <= s;) r.push(null);
                                return (r[s] = r[s] || []).push(t), e
                            }
                        }
                        return n && (r.prototype = Object.create(n.prototype)), r.prototype.ngMetadataName = e, r.annotationCls = r, r
                    })
                }

                function Dt(e, t, n, s) {
                    return x(() => {
                        const r = Tt(t);

                        function i(...e) {
                            if (this instanceof i) return r.apply(this, e), this;
                            const t = new i(...e);
                            return function(n, r) {
                                const i = n.constructor,
                                    o = i.hasOwnProperty(St) ? i[St] : Object.defineProperty(i, St, {
                                        value: {}
                                    })[St];
                                o[r] = o.hasOwnProperty(r) && o[r] || [], o[r].unshift(t), s && s(n, r, ...e)
                            }
                        }
                        return n && (i.prototype = Object.create(n.prototype)), i.prototype.ngMetadataName = e, i.annotationCls = i, i
                    })
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Pt = function() {
                    return At("Attribute", e => ({
                        attributeName: e
                    }))
                }();
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class kt {
                    constructor(e, t) {
                        this._desc = e, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof t ? this.__NG_ELEMENT_ID__ = t : void 0 !== t && (this.\u0275prov = m({
                            token: this,
                            providedIn: t.providedIn || "root",
                            factory: t.factory
                        }))
                    }
                    toString() {
                        return `InjectionToken ${this._desc}`
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Ot = new kt("AnalyzeForEntryComponents");
                class It {}
                Dt("ContentChildren", (e, t = {}) => Object.assign({
                    selector: e,
                    first: !1,
                    isViewQuery: !1,
                    descendants: !1
                }, t), It), Dt("ContentChild", (e, t = {}) => Object.assign({
                    selector: e,
                    first: !0,
                    isViewQuery: !1,
                    descendants: !0
                }, t), It), Dt("ViewChildren", (e, t = {}) => Object.assign({
                    selector: e,
                    first: !1,
                    isViewQuery: !0,
                    descendants: !0
                }, t), It);
                const Nt = Dt("ViewChild", (e, t) => Object.assign({
                    selector: e,
                    first: !0,
                    isViewQuery: !0,
                    descendants: !0
                }, t), It);
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var Mt, Ft, Rt;
                ! function(e) {
                    e[e.Token = 0] = "Token", e[e.Attribute = 1] = "Attribute", e[e.ChangeDetectorRef = 2] = "ChangeDetectorRef", e[e.Invalid = 3] = "Invalid"
                }(Mt || (Mt = {})),
                function(e) {
                    e[e.Directive = 0] = "Directive", e[e.Component = 1] = "Component", e[e.Injectable = 2] = "Injectable", e[e.Pipe = 3] = "Pipe", e[e.NgModule = 4] = "NgModule"
                }(Ft || (Ft = {})),
                function(e) {
                    e[e.Emulated = 0] = "Emulated", e[e.None = 2] = "None", e[e.ShadowDom = 3] = "ShadowDom"
                }(Rt || (Rt = {}));
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const jt = Function;

                function Lt(e) {
                    return "function" == typeof e
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function Vt(e, t) {
                    void 0 === t && (t = e);
                    for (let n = 0; n < e.length; n++) {
                        let s = e[n];
                        Array.isArray(s) ? (t === e && (t = e.slice(0, n)), Vt(s, t)) : t !== e && t.push(s)
                    }
                    return t
                }

                function $t(e, t, n) {
                    t >= e.length ? e.push(n) : e.splice(t, 0, n)
                }

                function Bt(e, t) {
                    return t >= e.length - 1 ? e.pop() : e.splice(t, 1)[0]
                }

                function Ht(e, t) {
                    const n = [];
                    for (let s = 0; s < e; s++) n.push(t);
                    return n
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Ut = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|[^()]+\(arguments\))\)/,
                    qt = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/,
                    zt = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/,
                    Wt = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{\s*super\(\.\.\.arguments\)/;
                class Gt {
                    constructor(e) {
                        this._reflect = e || I.Reflect
                    }
                    isReflectionEnabled() {
                        return !0
                    }
                    factory(e) {
                        return (...t) => new e(...t)
                    }
                    _zipTypesAndAnnotations(e, t) {
                        let n;
                        n = Ht(void 0 === e ? t.length : e.length);
                        for (let s = 0; s < n.length; s++) void 0 === e ? n[s] = [] : e[s] && e[s] != Object ? n[s] = [e[s]] : n[s] = [], t && null != t[s] && (n[s] = n[s].concat(t[s]));
                        return n
                    }
                    _ownParameters(e, t) {
                        if (function(e) {
                                return Ut.test(e) || Wt.test(e) || qt.test(e) && !zt.test(e)
                            }(e.toString())) return null;
                        if (e.parameters && e.parameters !== t.parameters) return e.parameters;
                        const n = e.ctorParameters;
                        if (n && n !== t.ctorParameters) {
                            const e = "function" == typeof n ? n() : n,
                                t = e.map(e => e && e.type),
                                s = e.map(e => e && Kt(e.decorators));
                            return this._zipTypesAndAnnotations(t, s)
                        }
                        const s = e.hasOwnProperty(Ct) && e[Ct],
                            r = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata("design:paramtypes", e);
                        return r || s ? this._zipTypesAndAnnotations(r, s) : Ht(e.length)
                    }
                    parameters(e) {
                        if (!Lt(e)) return [];
                        const t = Qt(e);
                        let n = this._ownParameters(e, t);
                        return n || t === Object || (n = this.parameters(t)), n || []
                    }
                    _ownAnnotations(e, t) {
                        if (e.annotations && e.annotations !== t.annotations) {
                            let t = e.annotations;
                            return "function" == typeof t && t.annotations && (t = t.annotations), t
                        }
                        return e.decorators && e.decorators !== t.decorators ? Kt(e.decorators) : e.hasOwnProperty(Et) ? e[Et] : null
                    }
                    annotations(e) {
                        if (!Lt(e)) return [];
                        const t = Qt(e),
                            n = this._ownAnnotations(e, t) || [];
                        return (t !== Object ? this.annotations(t) : []).concat(n)
                    }
                    _ownPropMetadata(e, t) {
                        if (e.propMetadata && e.propMetadata !== t.propMetadata) {
                            let t = e.propMetadata;
                            return "function" == typeof t && t.propMetadata && (t = t.propMetadata), t
                        }
                        if (e.propDecorators && e.propDecorators !== t.propDecorators) {
                            const t = e.propDecorators,
                                n = {};
                            return Object.keys(t).forEach(e => {
                                n[e] = Kt(t[e])
                            }), n
                        }
                        return e.hasOwnProperty(St) ? e[St] : null
                    }
                    propMetadata(e) {
                        if (!Lt(e)) return {};
                        const t = Qt(e),
                            n = {};
                        if (t !== Object) {
                            const e = this.propMetadata(t);
                            Object.keys(e).forEach(t => {
                                n[t] = e[t]
                            })
                        }
                        const s = this._ownPropMetadata(e, t);
                        return s && Object.keys(s).forEach(e => {
                            const t = [];
                            n.hasOwnProperty(e) && t.push(...n[e]), t.push(...s[e]), n[e] = t
                        }), n
                    }
                    ownPropMetadata(e) {
                        return Lt(e) && this._ownPropMetadata(e, Qt(e)) || {}
                    }
                    hasLifecycleHook(e, t) {
                        return e instanceof jt && t in e.prototype
                    }
                    guards(e) {
                        return {}
                    }
                    getter(e) {
                        return new Function("o", "return o." + e + ";")
                    }
                    setter(e) {
                        return new Function("o", "v", "return o." + e + " = v;")
                    }
                    method(e) {
                        return new Function("o", "args", `if (!o.${e}) throw new Error('"${e}" is undefined');\n        return o.${e}.apply(o, args);`)
                    }
                    importUri(e) {
                        return "object" == typeof e && e.filePath ? e.filePath : `./${c(e)}`
                    }
                    resourceUri(e) {
                        return `./${c(e)}`
                    }
                    resolveIdentifier(e, t, n, s) {
                        return s
                    }
                    resolveEnum(e, t) {
                        return e[t]
                    }
                }

                function Kt(e) {
                    return e ? e.map(e => new(0, e.type.annotationCls)(...e.args ? e.args : [])) : []
                }

                function Qt(e) {
                    const t = e.prototype ? Object.getPrototypeOf(e.prototype) : null;
                    return (t ? t.constructor : null) || Object
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Zt = At("Inject", e => ({
                        token: e
                    })),
                    Jt = At("Optional"),
                    Xt = At("Self"),
                    Yt = At("SkipSelf"),
                    en = At("Host");
                new Map;
                new Set;
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const tn = {},
                    nn = /\n/gm,
                    sn = "__source",
                    rn = l({
                        provide: String,
                        useValue: l
                    });
                let on;

                function an(e) {
                    const t = on;
                    return on = e, t
                }

                function ln(e, t = w.Default) {
                    if (void 0 === on) throw new Error("inject() must be called from an injection context");
                    return null === on ? S(e, void 0, t) : on.get(e, t & w.Optional ? null : void 0, t)
                }

                function cn(e, t = w.Default) {
                    return (E || ln)(d(e), t)
                }

                function un(e) {
                    const t = [];
                    for (let n = 0; n < e.length; n++) {
                        const s = d(e[n]);
                        if (Array.isArray(s)) {
                            if (0 === s.length) throw new Error("Arguments array must have arguments.");
                            let e, n = w.Default;
                            for (let t = 0; t < s.length; t++) {
                                const r = s[t];
                                r instanceof Jt || "Optional" === r.ngMetadataName || r === Jt ? n |= w.Optional : r instanceof Yt || "SkipSelf" === r.ngMetadataName || r === Yt ? n |= w.SkipSelf : r instanceof Xt || "Self" === r.ngMetadataName || r === Xt ? n |= w.Self : r instanceof en || "Host" === r.ngMetadataName || r === en ? n |= w.Host : e = r instanceof Zt || r === Zt ? r.token : r
                            }
                            t.push(cn(e, n))
                        } else t.push(cn(s))
                    }
                    return t
                }

                function hn(e, t, n, s) {
                    const r = e.ngTempTokenPath;
                    throw t[sn] && r.unshift(t[sn]), e.message = pn("\n" + e.message, r, n, s), e.ngTokenPath = r, e.ngTempTokenPath = null, e
                }

                function pn(e, t, n, s = null) {
                    e = e && "\n" === e.charAt(0) && "\u0275" == e.charAt(1) ? e.substr(2) : e;
                    let r = c(t);
                    if (Array.isArray(t)) r = t.map(c).join(" -> ");
                    else if ("object" == typeof t) {
                        let e = [];
                        for (let n in t)
                            if (t.hasOwnProperty(n)) {
                                let s = t[n];
                                e.push(n + ":" + ("string" == typeof s ? JSON.stringify(s) : c(s)))
                            }
                        r = `{${e.join(", ")}}`
                    }
                    return `${n}${s?"("+s+")":""}[${r}]: ${e.replace(nn,"\n  ")}`
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                let dn;

                function fn() {
                    if (void 0 === dn && (dn = null, I.trustedTypes)) try {
                        dn = I.trustedTypes.createPolicy("angular", {
                            createHTML: e => e,
                            createScript: e => e,
                            createScriptURL: e => e
                        })
                    } catch (e) {}
                    return dn
                }

                function mn(e) {
                    var t;
                    return (null === (t = fn()) || void 0 === t ? void 0 : t.createHTML(e)) || e
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class gn {
                    constructor(e) {
                        this.changingThisBreaksApplicationSecurity = e
                    }
                    toString() {
                        return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`
                    }
                }
                class yn extends gn {
                    getTypeName() {
                        return "HTML"
                    }
                }
                class vn extends gn {
                    getTypeName() {
                        return "Style"
                    }
                }
                class _n extends gn {
                    getTypeName() {
                        return "Script"
                    }
                }
                class bn extends gn {
                    getTypeName() {
                        return "URL"
                    }
                }
                class wn extends gn {
                    getTypeName() {
                        return "ResourceURL"
                    }
                }

                function En(e) {
                    return e instanceof gn ? e.changingThisBreaksApplicationSecurity : e
                }

                function Cn(e, t) {
                    const n = Sn(e);
                    if (null != n && n !== t) {
                        if ("ResourceURL" === n && "URL" === t) return !0;
                        throw new Error(`Required a safe ${t}, got a ${n} (see https://g.co/ng/security#xss)`)
                    }
                    return n === t
                }

                function Sn(e) {
                    return e instanceof gn && e.getTypeName() || null
                }

                function xn(e) {
                    return new yn(e)
                }

                function Tn(e) {
                    return new vn(e)
                }

                function An(e) {
                    return new _n(e)
                }

                function Dn(e) {
                    return new bn(e)
                }

                function Pn(e) {
                    return new wn(e)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function kn(e) {
                    const t = new In(e);
                    return function() {
                        try {
                            return !!(new window.DOMParser).parseFromString(mn(""), "text/html")
                        } catch (e) {
                            return !1
                        }
                    }
                    /**
                     * @license
                     * Copyright Google LLC All Rights Reserved.
                     *
                     * Use of this source code is governed by an MIT-style license that can be
                     * found in the LICENSE file at https://angular.io/license
                     */
                    () ? new On(t): t
                }
                class On {
                    constructor(e) {
                        this.inertDocumentHelper = e
                    }
                    getInertBodyElement(e) {
                        e = "<body><remove></remove>" + e;
                        try {
                            const t = (new window.DOMParser).parseFromString(mn(e), "text/html").body;
                            return null === t ? this.inertDocumentHelper.getInertBodyElement(e) : (t.removeChild(t.firstChild), t)
                        } catch (t) {
                            return null
                        }
                    }
                }
                class In {
                    constructor(e) {
                        if (this.defaultDoc = e, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), null == this.inertDocument.body) {
                            const e = this.inertDocument.createElement("html");
                            this.inertDocument.appendChild(e);
                            const t = this.inertDocument.createElement("body");
                            e.appendChild(t)
                        }
                    }
                    getInertBodyElement(e) {
                        const t = this.inertDocument.createElement("template");
                        if ("content" in t) return t.innerHTML = mn(e), t;
                        const n = this.inertDocument.createElement("body");
                        return n.innerHTML = mn(e), this.defaultDoc.documentMode && this.stripCustomNsAttrs(n), n
                    }
                    stripCustomNsAttrs(e) {
                        const t = e.attributes;
                        for (let s = t.length - 1; 0 < s; s--) {
                            const n = t.item(s).name;
                            "xmlns:ns1" !== n && 0 !== n.indexOf("ns1:") || e.removeAttribute(n)
                        }
                        let n = e.firstChild;
                        for (; n;) n.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(n), n = n.nextSibling
                    }
                }
                const Nn = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi,
                    Mn = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;

                function Fn(e) {
                    return (e = String(e)).match(Nn) || e.match(Mn) ? e : "unsafe:" + e
                }

                function Rn(e) {
                    return (e = String(e)).split(",").map(e => Fn(e.trim())).join(", ")
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function jn(e) {
                    const t = {};
                    for (const n of e.split(",")) t[n] = !0;
                    return t
                }

                function Ln(...e) {
                    const t = {};
                    for (const n of e)
                        for (const e in n) n.hasOwnProperty(e) && (t[e] = !0);
                    return t
                }
                const Vn = jn("area,br,col,hr,img,wbr"),
                    $n = jn("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
                    Bn = jn("rp,rt"),
                    Hn = Ln(Bn, $n),
                    Un = Ln($n, jn("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")),
                    qn = Ln(Bn, jn("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")),
                    zn = Ln(Vn, Un, qn, Hn),
                    Wn = jn("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),
                    Gn = jn("srcset"),
                    Kn = jn("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"),
                    Qn = jn("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext"),
                    Zn = Ln(Wn, Gn, Kn, Qn),
                    Jn = jn("script,style,template");
                class Xn {
                    constructor() {
                        this.sanitizedSomething = !1, this.buf = []
                    }
                    sanitizeChildren(e) {
                        let t = e.firstChild,
                            n = !0;
                        for (; t;)
                            if (t.nodeType === Node.ELEMENT_NODE ? n = this.startElement(t) : t.nodeType === Node.TEXT_NODE ? this.chars(t.nodeValue) : this.sanitizedSomething = !0, n && t.firstChild) t = t.firstChild;
                            else
                                for (; t;) {
                                    t.nodeType === Node.ELEMENT_NODE && this.endElement(t);
                                    let e = this.checkClobberedElement(t, t.nextSibling);
                                    if (e) {
                                        t = e;
                                        break
                                    }
                                    t = this.checkClobberedElement(t, t.parentNode)
                                }
                        return this.buf.join("")
                    }
                    startElement(e) {
                        const t = e.nodeName.toLowerCase();
                        if (!zn.hasOwnProperty(t)) return this.sanitizedSomething = !0, !Jn.hasOwnProperty(t);
                        this.buf.push("<"), this.buf.push(t);
                        const n = e.attributes;
                        for (let s = 0; s < n.length; s++) {
                            const e = n.item(s),
                                t = e.name,
                                r = t.toLowerCase();
                            if (!Zn.hasOwnProperty(r)) {
                                this.sanitizedSomething = !0;
                                continue
                            }
                            let i = e.value;
                            Wn[r] && (i = Fn(i)), Gn[r] && (i = Rn(i)), this.buf.push(" ", t, '="', ts(i), '"')
                        }
                        return this.buf.push(">"), !0
                    }
                    endElement(e) {
                        const t = e.nodeName.toLowerCase();
                        zn.hasOwnProperty(t) && !Vn.hasOwnProperty(t) && (this.buf.push("</"), this.buf.push(t), this.buf.push(">"))
                    }
                    chars(e) {
                        this.buf.push(ts(e))
                    }
                    checkClobberedElement(e, t) {
                        if (t && (e.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${e.outerHTML}`);
                        return t
                    }
                }
                const Yn = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                    es = /([^\#-~ |!])/g;

                function ts(e) {
                    return e.replace(/&/g, "&amp;").replace(Yn, function(e) {
                        return "&#" + (1024 * (e.charCodeAt(0) - 55296) + (e.charCodeAt(1) - 56320) + 65536) + ";"
                    }).replace(es, function(e) {
                        return "&#" + e.charCodeAt(0) + ";"
                    }).replace(/</g, "&lt;").replace(/>/g, "&gt;")
                }
                let ns;

                function ss(e, t) {
                    let n = null;
                    try {
                        ns = ns || kn(e);
                        let s = t ? String(t) : "";
                        n = ns.getInertBodyElement(s);
                        let r = 5,
                            i = s;
                        do {
                            if (0 === r) throw new Error("Failed to sanitize html because the input is unstable");
                            r--, s = i, i = n.innerHTML, n = ns.getInertBodyElement(s)
                        } while (s !== i);
                        const o = new Xn;
                        return o.sanitizeChildren(rs(n) || n)
                    } finally {
                        if (n) {
                            const e = rs(n) || n;
                            for (; e.firstChild;) e.removeChild(e.firstChild)
                        }
                    }
                }

                function rs(e) {
                    return "content" in e && function(e) {
                        return e.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === e.nodeName
                    }
                    /**
                     * @license
                     * Copyright Google LLC All Rights Reserved.
                     *
                     * Use of this source code is governed by an MIT-style license that can be
                     * found in the LICENSE file at https://angular.io/license
                     */
                    (e) ? e.content: null
                }
                var is;
                ! function(e) {
                    e[e.NONE = 0] = "NONE", e[e.HTML = 1] = "HTML", e[e.STYLE = 2] = "STYLE", e[e.SCRIPT = 3] = "SCRIPT", e[e.URL = 4] = "URL", e[e.RESOURCE_URL = 5] = "RESOURCE_URL"
                }(is || (is = {}));

                function os(e) {
                    return e.ngDebugContext
                }

                function as(e) {
                    return e.ngOriginalError
                }

                function ls(e, ...t) {
                    e.error(...t)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class cs {
                    constructor() {
                        this._console = console
                    }
                    handleError(e) {
                        const t = this._findOriginalError(e),
                            n = this._findContext(e),
                            s = function(e) {
                                return e.ngErrorLogger || ls
                            }(e);
                        s(this._console, "ERROR", e), t && s(this._console, "ORIGINAL ERROR", t), n && s(this._console, "ERROR CONTEXT", n)
                    }
                    _findContext(e) {
                        return e ? os(e) ? os(e) : this._findContext(as(e)) : null
                    }
                    _findOriginalError(e) {
                        let t = as(e);
                        for (; t && as(t);) t = as(t);
                        return t
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const us = {
                        name: "custom-elements"
                    },
                    hs = /-->/g;

                function ps(e) {
                    return e.replace(hs, "-\u200b-\u200b>")
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function ds(e) {
                    var t;
                    return t = e.replace(/[$@]/g, "_"), `ng-reflect-${e=t.replace(fs,(...e)=>"-"+e[1].toLowerCase())}`
                }
                const fs = /([A-Z])/g;

                function ms(e) {
                    try {
                        return null != e ? e.toString().slice(0, 30) : e
                    } catch (t) {
                        return "[ERROR] Exception while trying to serialize the value"
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function gs(e, t) {
                    e.__ngContext__ = t
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const ys = ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(I);
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                var vs;
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                let _s;

                function bs(e, t) {
                    return _s(e, t)
                }! function(e) {
                    e[e.Important = 1] = "Important", e[e.DashCase = 2] = "DashCase"
                }(vs || (vs = {}));
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function ws(e) {
                    const t = e[3];
                    return B(t) ? t[3] : t
                }

                function Es(e) {
                    return Ss(e[13])
                }

                function Cs(e) {
                    return Ss(e[4])
                }

                function Ss(e) {
                    for (; null !== e && !B(e);) e = e[4];
                    return e
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function xs(e, t, n, s, r) {
                    if (null != s) {
                        let i, o = !1;
                        B(s) ? i = s : $(s) && (o = !0, s = s[0]);
                        const a = he(s);
                        0 === e && null !== n ? null == r ? Os(t, n, a) : ks(t, n, a, r || null, !0) : 1 === e && null !== n ? ks(t, n, a, r || null, !0) : 2 === e ? Ns(t, a, o) : 3 === e && t.destroyNode(a), null != i && function(e, t, n, s, r) {
                            const i = n[7],
                                o = he(n);
                            i !== o && xs(t, e, s, i, r);
                            for (let a = V; a < n.length; a++) {
                                const r = n[a];
                                Fs(r[1], r, e, t, s, i)
                            }
                        }(t, e, i, n, r)
                    }
                }

                function Ts(e, t, n) {
                    return ce(e) ? e.createElement(t, n) : null === n ? e.createElement(t) : e.createElementNS(n, t)
                }

                function As(e, t) {
                    const n = e[9],
                        s = n.indexOf(t),
                        r = t[3];
                    1024 & t[2] && (t[2] &= -1025, be(r, -1)), n.splice(s, 1)
                }

                function Ds(e, t) {
                    if (!(256 & t[2])) {
                        const n = t[11];
                        ce(n) && n.destroyNode && Fs(e, t, n, 3, null, null),
                            function(e) {
                                let t = e[13];
                                if (!t) return Ps(e[1], e);
                                for (; t;) {
                                    let n = null;
                                    if ($(t)) n = t[13];
                                    else {
                                        const e = t[10];
                                        e && (n = e)
                                    }
                                    if (!n) {
                                        for (; t && !t[4] && t !== e;) $(t) && Ps(t[1], t), t = t[3];
                                        null === t && (t = e), $(t) && Ps(t[1], t), n = t && t[4]
                                    }
                                    t = n
                                }
                            }(t)
                    }
                }

                function Ps(e, t) {
                    if (!(256 & t[2])) {
                        t[2] &= -129, t[2] |= 256,
                            function(e, t) {
                                let n;
                                if (null != e && null != (n = e.destroyHooks))
                                    for (let s = 0; s < n.length; s += 2) {
                                        const e = t[n[s]];
                                        if (!(e instanceof Je)) {
                                            const t = n[s + 1];
                                            if (Array.isArray(t))
                                                for (let n = 0; n < t.length; n += 2) t[n + 1].call(e[t[n]]);
                                            else t.call(e)
                                        }
                                    }
                            }(e, t),
                            function(e, t) {
                                const n = e.cleanup,
                                    s = t[7];
                                let r = -1;
                                if (null !== n)
                                    for (let i = 0; i < n.length - 1; i += 2)
                                        if ("string" == typeof n[i]) {
                                            const e = n[i + 1],
                                                o = "function" == typeof e ? e(t) : he(t[e]),
                                                a = s[r = n[i + 2]],
                                                l = n[i + 3];
                                            "boolean" == typeof l ? o.removeEventListener(n[i], a, l) : l >= 0 ? s[r = l]() : s[r = -l].unsubscribe(), i += 2
                                        } else {
                                            const e = s[r = n[i + 1]];
                                            n[i].call(e)
                                        }
                                if (null !== s) {
                                    for (let e = r + 1; e < s.length; e++) {
                                        const t = s[e];
                                        t()
                                    }
                                    t[7] = null
                                }
                            }(e, t), 1 === t[1].type && ce(t[11]) && t[11].destroy();
                        const n = t[17];
                        if (null !== n && B(t[3])) {
                            n !== t[3] && As(n, t);
                            const s = t[19];
                            null !== s && s.detachView(e)
                        }
                    }
                }

                function ks(e, t, n, s, r) {
                    ce(e) ? e.insertBefore(t, n, s, r) : t.insertBefore(n, s, r)
                }

                function Os(e, t, n) {
                    ce(e) ? e.appendChild(t, n) : t.appendChild(n)
                }

                function Is(e, t) {
                    return ce(e) ? e.parentNode(t) : t.parentNode
                }

                function Ns(e, t, n) {
                    const s = Is(e, t);
                    s && function(e, t, n, s) {
                        ce(e) ? e.removeChild(t, n, s) : t.removeChild(n)
                    }(e, s, t, n)
                }

                function Ms(e, t, n, s, r, i, o) {
                    for (; null != n;) {
                        const a = s[n.index],
                            l = n.type;
                        if (o && 0 === t && (a && gs(he(a), s), n.flags |= 4), 64 != (64 & n.flags))
                            if (8 & l) Ms(e, t, n.child, s, r, i, !1), xs(t, e, r, a, i);
                            else if (32 & l) {
                            const o = bs(n, s);
                            let l;
                            for (; l = o();) xs(t, e, r, l, i);
                            xs(t, e, r, a, i)
                        } else 16 & l ? Rs(e, t, s, n, r, i) : xs(t, e, r, a, i);
                        n = o ? n.projectionNext : n.next
                    }
                }

                function Fs(e, t, n, s, r, i) {
                    Ms(n, s, e.firstChild, t, r, i, !1)
                }

                function Rs(e, t, n, s, r, i) {
                    const o = n[16],
                        a = o[6].projection[s.projection];
                    if (Array.isArray(a))
                        for (let l = 0; l < a.length; l++) {
                            xs(t, e, r, a[l], i)
                        } else {
                            Ms(e, t, a, o[3], r, i, !0)
                        }
                }

                function js(e, t, n) {
                    ce(e) ? e.setAttribute(t, "style", n) : t.style.cssText = n
                }

                function Ls(e, t, n) {
                    ce(e) ? "" === n ? e.removeAttribute(t, "class") : e.setAttribute(t, "class", n) : t.className = n
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function Vs(e) {
                    return 0 == (1 & e)
                }

                function $s(e, t) {
                    return e ? ":not(" + t.trim() + ")" : t
                }

                function Bs(e) {
                    let t = e[0],
                        n = 1,
                        s = 2,
                        r = "",
                        i = !1;
                    for (; n < e.length;) {
                        let o = e[n];
                        if ("string" == typeof o)
                            if (2 & s) {
                                const t = e[++n];
                                r += "[" + o + (t.length > 0 ? '="' + t + '"' : "") + "]"
                            } else 8 & s ? r += "." + o : 4 & s && (r += " " + o);
                        else "" === r || Vs(o) || (t += $s(i, r), r = ""), s = o, i = i || !Vs(s);
                        n++
                    }
                    return "" !== r && (t += $s(i, r)), t
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Hs = {};
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function Us(e, t, n, s) {
                    if (!s) {
                        if (3 == (3 & t[2])) {
                            const s = e.preOrderCheckHooks;
                            null !== s && ze(t, s, n)
                        } else {
                            const s = e.preOrderHooks;
                            null !== s && We(t, s, 0, n)
                        }
                    }
                    Ue(n)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const qs = Promise.resolve(null);

                function zs(e, t) {
                    const n = e.contentQueries;
                    if (null !== n)
                        for (let s = 0; s < n.length; s += 2) {
                            const r = n[s],
                                i = n[s + 1];
                            if (-1 !== i) {
                                const n = e.data[i];
                                Ne(r), n.contentQueries(2, t[i], i)
                            }
                        }
                }

                function Ws(e, t, n, s, r, i, o, a, l, c) {
                    const u = t.blueprint.slice();
                    return u[0] = r, u[2] = 140 | s, _e(u), u[3] = u[15] = e, u[8] = n, u[10] = o || e && e[10], u[11] = a || e && e[11], u[12] = l || e && e[12] || null, u[9] = c || e && e[9] || null, u[6] = i, u[16] = 2 == t.type ? e[16] : u, u
                }

                function Gs(e, t, n, s, r) {
                    let i = e.data[t];
                    if (null === i) i = Ks(e, t, n, s, r), we.lFrame.inI18n && (i.flags |= 64);
                    else if (64 & i.type) {
                        i.type = n, i.value = s, i.attrs = r;
                        const e = xe();
                        i.injectorIndex = null === e ? -1 : e.injectorIndex
                    }
                    return Te(i, !0), i
                }

                function Ks(e, t, n, s, r) {
                    const i = Se(),
                        o = Ae(),
                        a = o ? i : i && i.parent,
                        l = e.data[t] = function(e, t, n, s, r, i) {
                            let o = t ? t.injectorIndex : -1;
                            const a = {
                                type: n,
                                index: s,
                                insertBeforeIndex: null,
                                injectorIndex: o,
                                directiveStart: -1,
                                directiveEnd: -1,
                                directiveStylingLast: -1,
                                propertyBindings: null,
                                flags: 0,
                                providerIndexes: 0,
                                value: r,
                                attrs: i,
                                mergedAttrs: null,
                                localNames: null,
                                initialInputs: void 0,
                                inputs: null,
                                outputs: null,
                                tViews: null,
                                next: null,
                                projectionNext: null,
                                child: null,
                                parent: t,
                                projection: null,
                                styles: null,
                                stylesWithoutHost: null,
                                residualStyles: void 0,
                                classes: null,
                                classesWithoutHost: null,
                                residualClasses: void 0,
                                classBindings: 0,
                                styleBindings: 0
                            };
                            0;
                            return a
                        }(0, a, n, t, s, r);
                    return null === e.firstChild && (e.firstChild = l), null !== i && (o ? null == i.child && null !== l.parent && (i.child = l) : null === i.next && (i.next = l)), l
                }

                function Qs(e, t, n, s) {
                    if (0 === n) return -1;
                    const r = t.length;
                    for (let i = 0; i < n; i++) t.push(s), e.blueprint.push(s), e.data.push(null);
                    return r
                }

                function Zs(e, t, n) {
                    Re(t);
                    try {
                        const s = e.viewQuery;
                        null !== s && yr(1, s, n);
                        const r = e.template;
                        null !== r && Ys(e, t, r, 1, n), e.firstCreatePass && (e.firstCreatePass = !1), e.staticContentQueries && zs(e, t), e.staticViewQueries && yr(2, e.viewQuery, n);
                        const i = e.components;
                        null !== i && function(e, t) {
                            for (let n = 0; n < t.length; n++) hr(e, t[n])
                        }(t, i)
                    } catch (s) {
                        throw e.firstCreatePass && (e.incompleteFirstPass = !0), s
                    } finally {
                        t[2] &= -5, Be()
                    }
                }

                function Js(e, t, n, s) {
                    const r = t[2];
                    if (256 == (256 & r)) return;
                    Re(t);
                    const i = De();
                    try {
                        _e(t), ke(e.bindingStartIndex), null !== n && Ys(e, t, n, 2, s);
                        const o = 3 == (3 & r);
                        if (!i)
                            if (o) {
                                const n = e.preOrderCheckHooks;
                                null !== n && ze(t, n, null)
                            } else {
                                const n = e.preOrderHooks;
                                null !== n && We(t, n, 0, null), Ge(t, 0)
                            }
                        if (function(e) {
                                for (let t = Es(e); null !== t; t = Cs(t)) {
                                    if (!t[2]) continue;
                                    const e = t[9];
                                    for (let t = 0; t < e.length; t++) {
                                        const n = e[t],
                                            s = n[3];
                                        0 == (1024 & n[2]) && be(s, 1), n[2] |= 1024
                                    }
                                }
                            }(t), function(e) {
                                for (let t = Es(e); null !== t; t = Cs(t))
                                    for (let e = V; e < t.length; e++) {
                                        const n = t[e],
                                            s = n[1];
                                        ve(n) && Js(s, n, s.template, n[8])
                                    }
                            }(t), null !== e.contentQueries && zs(e, t), !i)
                            if (o) {
                                const n = e.contentCheckHooks;
                                null !== n && ze(t, n)
                            } else {
                                const n = e.contentHooks;
                                null !== n && We(t, n, 1), Ge(t, 1)
                            }! function(e, t) {
                            const n = e.hostBindingOpCodes;
                            if (null !== n) try {
                                for (let e = 0; e < n.length; e++) {
                                    const s = n[e];
                                    if (s < 0) Ue(~s);
                                    else {
                                        const r = s,
                                            i = n[++e],
                                            o = n[++e];
                                        Oe(i, r), o(2, t[r])
                                    }
                                }
                            } finally {
                                Ue(-1)
                            }
                        }(e, t);
                        const a = e.components;
                        null !== a && function(e, t) {
                            for (let n = 0; n < t.length; n++) cr(e, t[n])
                        }(t, a);
                        const l = e.viewQuery;
                        if (null !== l && yr(2, l, s), !i)
                            if (o) {
                                const n = e.viewCheckHooks;
                                null !== n && ze(t, n)
                            } else {
                                const n = e.viewHooks;
                                null !== n && We(t, n, 2), Ge(t, 2)
                            }!0 === e.firstUpdatePass && (e.firstUpdatePass = !1), i || (t[2] &= -73), 1024 & t[2] && (t[2] &= -1025, be(t[3], -1))
                    } finally {
                        Be()
                    }
                }

                function Xs(e, t, n, s) {
                    const r = t[10],
                        i = !De(),
                        o = ye(t);
                    try {
                        i && !o && r.begin && r.begin(), o && Zs(e, t, s), Js(e, t, n, s)
                    } finally {
                        i && !o && r.end && r.end()
                    }
                }

                function Ys(e, t, n, s, r) {
                    const i = He();
                    try {
                        Ue(-1), 2 & s && t.length > L && Us(e, t, L, De()), n(s, r)
                    } finally {
                        Ue(i)
                    }
                }

                function er(e) {
                    const t = e.tView;
                    if (null === t || t.incompleteFirstPass) {
                        const t = null;
                        return e.tView = tr(1, t, e.template, e.decls, e.vars, e.directiveDefs, e.pipeDefs, e.viewQuery, e.schemas, e.consts)
                    }
                    return t
                }

                function tr(e, t, n, s, r, i, o, a, l, c) {
                    const u = L + s,
                        h = u + r,
                        p = function(e, t) {
                            const n = [];
                            for (let s = 0; s < t; s++) n.push(s < e ? null : Hs);
                            return n
                        }(u, h),
                        d = "function" == typeof c ? c() : c,
                        f = p[1] = {
                            type: e,
                            blueprint: p,
                            template: n,
                            queries: null,
                            viewQuery: a,
                            declTNode: t,
                            data: p.slice().fill(null, u),
                            bindingStartIndex: u,
                            expandoStartIndex: h,
                            hostBindingOpCodes: null,
                            firstCreatePass: !0,
                            firstUpdatePass: !0,
                            staticViewQueries: !1,
                            staticContentQueries: !1,
                            preOrderHooks: null,
                            preOrderCheckHooks: null,
                            contentHooks: null,
                            contentCheckHooks: null,
                            viewHooks: null,
                            viewCheckHooks: null,
                            destroyHooks: null,
                            cleanup: null,
                            contentQueries: null,
                            components: null,
                            directiveRegistry: "function" == typeof i ? i() : i,
                            pipeRegistry: "function" == typeof o ? o() : o,
                            firstChild: null,
                            schemas: l,
                            consts: d,
                            incompleteFirstPass: !1
                        };
                    return f
                }

                function nr(e, t, n) {
                    if (ce(e)) {
                        const s = n === D.ShadowDom;
                        return e.selectRootElement(t, s)
                    }
                    let s = "string" == typeof t ? e.querySelector(t) : t;
                    return s.textContent = "", s
                }

                function sr(e, t, n, s) {
                    const r = _r(t);
                    null === n ? r.push(s) : (r.push(n), e.firstCreatePass && br(e).push(s, r.length - 1))
                }

                function rr(e, t, n, s, r, i) {
                    const o = i.hostBindings;
                    if (o) {
                        let n = e.hostBindingOpCodes;
                        null === n && (n = e.hostBindingOpCodes = []);
                        const i = ~t.index;
                        (function(e) {
                            let t = e.length;
                            for (; t > 0;) {
                                const n = e[--t];
                                if ("number" == typeof n && n < 0) return n
                            }
                            return 0
                        })(n) != i && n.push(i), n.push(s, r, o)
                    }
                }

                function ir(e, t) {
                    null !== e.hostBindings && e.hostBindings(1, t)
                }

                function or(e, t) {
                    t.flags |= 2, (e.components || (e.components = [])).push(t.index)
                }

                function ar(e, t, n) {
                    e.flags |= 1, e.directiveStart = t, e.directiveEnd = t + n, e.providerIndexes = t
                }

                function lr(e, t, n, s, r) {
                    e.data[s] = r;
                    const i = r.factory || (r.factory = q(r.type)),
                        o = new Je(i, U(r), null);
                    e.blueprint[s] = o, n[s] = o, rr(e, t, 0, s, Qs(e, n, r.hostVars, Hs), r)
                }

                function cr(e, t) {
                    const n = fe(t, e);
                    if (ve(n)) {
                        const e = n[1];
                        80 & n[2] ? Js(e, n, e.template, n[8]) : n[5] > 0 && ur(n)
                    }
                }

                function ur(e) {
                    for (let n = Es(e); null !== n; n = Cs(n))
                        for (let e = V; e < n.length; e++) {
                            const t = n[e];
                            if (1024 & t[2]) {
                                const e = t[1];
                                Js(e, t, e.template, t[8])
                            } else t[5] > 0 && ur(t)
                        }
                    const t = e[1].components;
                    if (null !== t)
                        for (let n = 0; n < t.length; n++) {
                            const s = fe(t[n], e);
                            ve(s) && s[5] > 0 && ur(s)
                        }
                }

                function hr(e, t) {
                    const n = fe(t, e),
                        s = n[1];
                    ! function(e, t) {
                        for (let n = t.length; n < e.blueprint.length; n++) t.push(e.blueprint[n])
                    }(s, n), Zs(s, n, n[8])
                }

                function pr(e, t) {
                    return e[13] ? e[14][4] = t : e[13] = t, e[14] = t, t
                }

                function dr(e) {
                    for (; e;) {
                        e[2] |= 64;
                        const t = ws(e);
                        if (0 != (512 & e[2]) && !t) return e;
                        e = t
                    }
                    return null
                }

                function fr(e) {
                    for (let t = 0; t < e.components.length; t++) {
                        const n = e.components[t],
                            s = ge(n),
                            r = s[1];
                        Xs(r, s, r.template, n)
                    }
                }

                function mr(e, t, n) {
                    const s = t[10];
                    s.begin && s.begin();
                    try {
                        Js(e, t, e.template, n)
                    } catch (r) {
                        throw wr(t, r), r
                    } finally {
                        s.end && s.end()
                    }
                }

                function gr(e) {
                    fr(e[8])
                }

                function yr(e, t, n) {
                    Ne(0), t(e, n)
                }
                const vr = qs;

                function _r(e) {
                    return e[7] || (e[7] = [])
                }

                function br(e) {
                    return e.cleanup || (e.cleanup = [])
                }

                function wr(e, t) {
                    const n = e[9],
                        s = n ? n.get(cs, null) : null;
                    s && s.handleError(t)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function Er(e, t, n) {
                    let s = n ? e.styles : null,
                        r = n ? e.classes : null,
                        i = 0;
                    if (null !== t)
                        for (let o = 0; o < t.length; o++) {
                            const e = t[o];
                            if ("number" == typeof e) i = e;
                            else if (1 == i) r = u(r, e);
                            else if (2 == i) {
                                s = u(s, e + ": " + t[++o] + ";")
                            }
                        }
                    n ? e.styles = s : e.stylesWithoutHost = s, n ? e.classes = r : e.classesWithoutHost = r
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Cr = new kt("INJECTOR", -1);
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Sr {
                    get(e, t = tn) {
                        if (t === tn) {
                            const t = new Error(`NullInjectorError: No provider for ${c(e)}!`);
                            throw t.name = "NullInjectorError", t
                        }
                        return t
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const xr = new kt("Set Injector scope.");
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Tr =
                    /**
                     * @license
                     * Copyright Google LLC All Rights Reserved.
                     *
                     * Use of this source code is governed by an MIT-style license that can be
                     * found in the LICENSE file at https://angular.io/license
                     */
                    function(e, t, n) {
                        return new Ir(e, t, n)
                    };
                class Ar {
                    static create(e, t) {
                        return Array.isArray(e) ? Tr(e, t, "") : Tr(e.providers, e.parent, e.name || "")
                    }
                }
                Ar.THROW_IF_NOT_FOUND = tn, Ar.NULL = new Sr, Ar.\u0275prov = m({
                    token: Ar,
                    providedIn: "any",
                    factory: () => cn(Cr)
                }), Ar.__NG_ELEMENT_ID__ = -1;
                const Dr = function(e) {
                        return e
                    },
                    Pr = [],
                    kr = Dr,
                    Or = function() {
                        return Array.prototype.slice.call(arguments)
                    };
                class Ir {
                    constructor(e, t = Ar.NULL, n = null) {
                        this.parent = t, this.source = n;
                        const s = this._records = new Map;
                        s.set(Ar, {
                            token: Ar,
                            fn: Dr,
                            deps: Pr,
                            value: this,
                            useNew: !1
                        }), s.set(Cr, {
                            token: Cr,
                            fn: Dr,
                            deps: Pr,
                            value: this,
                            useNew: !1
                        }), this.scope = Fr(s, e)
                    }
                    get(e, t, n = w.Default) {
                        const s = this._records;
                        let r = s.get(e);
                        if (void 0 === r) {
                            const t = y(e);
                            if (t) {
                                const n = t && t.providedIn;
                                ("any" === n || null != n && n === this.scope) && s.set(e, r = Nr({
                                    provide: e,
                                    useFactory: t.factory,
                                    deps: Pr
                                }))
                            }
                            void 0 === r && s.set(e, null)
                        }
                        let i = an(this);
                        try {
                            return Rr(e, r, s, this.parent, t, n)
                        } catch (o) {
                            return hn(o, e, "StaticInjectorError", this.source)
                        } finally {
                            an(i)
                        }
                    }
                    toString() {
                        const e = [];
                        return this._records.forEach((t, n) => e.push(c(n))), `StaticInjector[${e.join(", ")}]`
                    }
                }

                function Nr(e) {
                    const t = function(e) {
                        let t = Pr;
                        const n = e.deps;
                        if (n && n.length) {
                            t = [];
                            for (let e = 0; e < n.length; e++) {
                                let s = 6,
                                    r = d(n[e]);
                                if (Array.isArray(r))
                                    for (let e = 0, t = r; e < t.length; e++) {
                                        const n = t[e];
                                        n instanceof Jt || n == Jt ? s |= 1 : n instanceof Yt || n == Yt ? s &= -3 : n instanceof Xt || n == Xt ? s &= -5 : r = n instanceof Zt ? n.token : d(n)
                                    }
                                t.push({
                                    token: r,
                                    options: s
                                })
                            }
                        } else if (e.useExisting) {
                            t = [{
                                token: d(e.useExisting),
                                options: 6
                            }]
                        } else if (!n && !(rn in e)) throw jr("'deps' required", e);
                        return t
                    }(e);
                    let n = Dr,
                        s = Pr,
                        r = !1,
                        i = d(e.provide);
                    if (rn in e) s = e.useValue;
                    else if (e.useFactory) n = e.useFactory;
                    else if (e.useExisting);
                    else if (e.useClass) r = !0, n = d(e.useClass);
                    else {
                        if ("function" != typeof i) throw jr("StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable", e);
                        r = !0, n = i
                    }
                    return {
                        deps: t,
                        fn: n,
                        useNew: r,
                        value: s
                    }
                }

                function Mr(e) {
                    return jr("Cannot mix multi providers and regular providers", e)
                }

                function Fr(e, t) {
                    let n = null;
                    if (t)
                        if (t = d(t), Array.isArray(t))
                            for (let s = 0; s < t.length; s++) n = Fr(e, t[s]) || n;
                        else {
                            if ("function" == typeof t) throw jr("Function/Class not supported", t);
                            if (!t || "object" != typeof t || !t.provide) throw jr("Unexpected provider", t); {
                                let s = d(t.provide);
                                const r = Nr(t);
                                if (!0 === t.multi) {
                                    let n = e.get(s);
                                    if (n) {
                                        if (n.fn !== Or) throw Mr(s)
                                    } else e.set(s, n = {
                                        token: t.provide,
                                        deps: [],
                                        useNew: !1,
                                        fn: Or,
                                        value: Pr
                                    });
                                    s = t, n.deps.push({
                                        token: s,
                                        options: 6
                                    })
                                }
                                const i = e.get(s);
                                if (i && i.fn == Or) throw Mr(s);
                                s === xr && (n = r.value), e.set(s, r)
                            }
                        }
                    return n
                }

                function Rr(e, t, n, s, r, i) {
                    try {
                        return function(e, t, n, s, r, i) {
                            let o;
                            if (!t || i & w.SkipSelf) o = i & w.Self ? i & w.Optional ? Ar.NULL.get(e, void 0 !== r ? r : null) : Ar.NULL.get(e, r) : s.get(e, r, w.Default);
                            else {
                                if (o = t.value, o == kr) throw Error("\u0275Circular dependency");
                                if (o === Pr) {
                                    let e;
                                    t.value = kr;
                                    let r = t.useNew,
                                        i = t.fn,
                                        a = t.deps,
                                        l = Pr;
                                    if (a.length) {
                                        l = [];
                                        for (let e = 0; e < a.length; e++) {
                                            const t = a[e],
                                                r = t.options,
                                                i = 2 & r ? n.get(t.token) : void 0;
                                            l.push(Rr(t.token, i, n, i || 4 & r ? s : Ar.NULL, 1 & r ? null : Ar.THROW_IF_NOT_FOUND, w.Default))
                                        }
                                    }
                                    t.value = o = r ? new i(...l) : i.apply(e, l)
                                }
                            }
                            return o
                        }(e, t, n, s, r, i)
                    } catch (o) {
                        o instanceof Error || (o = new Error(o));
                        throw (o.ngTempTokenPath = o.ngTempTokenPath || []).unshift(e), t && t.value == kr && (t.value = Pr), o
                    }
                }

                function jr(e, t) {
                    return new Error(pn(e, t, "StaticInjectorError"))
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function Lr(e, t, n, s, r, i) {
                    const o = n[1];
                    n[20] = e;
                    const a = Gs(o, 20, 2, "#host", null),
                        l = a.mergedAttrs = t.hostAttrs;
                    null !== l && (Er(a, l, !0), null !== e && (Xe(r, e, l), null !== a.classes && Ls(r, e, a.classes), null !== a.styles && js(r, e, a.styles)));
                    const c = s.createRenderer(e, t),
                        u = Ws(n, er(t), null, t.onPush ? 64 : 16, n[20], a, s, c, i || null, null);
                    return o.firstCreatePass && (ut(ot(a, n), o, t.type), or(o, a), ar(a, n.length, 1)), pr(n, u), n[20] = u
                }

                function Vr(e, t, n, s, r) {
                    const i = n[1],
                        o = function(e, t, n) {
                            const s = Ce();
                            if (e.firstCreatePass) {
                                n.providersResolver && n.providersResolver(n);
                                lr(e, s, t, Qs(e, t, 1, null), n)
                            }
                            const r = vt(t, e, s.directiveStart, s);
                            gs(r, t);
                            const i = pe(s, t);
                            return i && gs(i, t), r
                        }(i, n, t);
                    if (s.components.push(o), e[8] = o, r && r.forEach(e => e(o, t)), t.contentQueries) {
                        const e = Ce();
                        t.contentQueries(1, o, e.directiveStart)
                    }
                    const a = Ce();
                    if (i.firstCreatePass && (null !== t.hostBindings || null !== t.hostAttrs)) {
                        Ue(a.index);
                        rr(n[1], a, 0, a.directiveStart, a.directiveEnd, t), ir(t, o)
                    }
                    return o
                }

                function $r(e, t) {
                    return {
                        components: [],
                        scheduler: e || ys,
                        clean: vr,
                        playerHandler: t || null,
                        flags: 0
                    }
                }

                function Br(e, t) {
                    const n = ge(e),
                        s = n[1],
                        r = Ce();
                    qe(s, r)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                let Hr = null;

                function Ur() {
                    if (!Hr) {
                        const e = I.Symbol;
                        if (e && e.iterator) Hr = e.iterator;
                        else {
                            const e = Object.getOwnPropertyNames(Map.prototype);
                            for (let t = 0; t < e.length; ++t) {
                                const n = e[t];
                                "entries" !== n && "size" !== n && Map.prototype[n] === Map.prototype.entries && (Hr = n)
                            }
                        }
                    }
                    return Hr
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function qr(e, t) {
                    const n = Wr(e),
                        s = Wr(t);
                    if (n && s) return function(e, t, n) {
                        const s = e[Ur()](),
                            r = t[Ur()]();
                        for (;;) {
                            const e = s.next(),
                                t = r.next();
                            if (e.done && t.done) return !0;
                            if (e.done || t.done) return !1;
                            if (!n(e.value, t.value)) return !1
                        }
                    }(e, t, qr); {
                        const r = e && ("object" == typeof e || "function" == typeof e),
                            i = t && ("object" == typeof t || "function" == typeof t);
                        return !(n || !r || s || !i) || Object.is(e, t)
                    }
                }
                class zr {
                    constructor(e) {
                        this.wrapped = e
                    }
                    static wrap(e) {
                        return new zr(e)
                    }
                    static unwrap(e) {
                        return zr.isWrapped(e) ? e.wrapped : e
                    }
                    static isWrapped(e) {
                        return e instanceof zr
                    }
                }

                function Wr(e) {
                    return !!Gr(e) && (Array.isArray(e) || !(e instanceof Map) && Ur() in e)
                }

                function Gr(e) {
                    return null !== e && ("function" == typeof e || "object" == typeof e)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                l({
                    provide: String,
                    useValue: l
                });
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Kr = l({
                        provide: String,
                        useValue: l
                    }),
                    Qr = [];

                function Zr(e, t) {
                    if (!t) {
                        const t = (new Gt).parameters(e);
                        return () => new e(...un(t))
                    }
                    if (Kr in t) {
                        const e = t;
                        return () => e.useValue
                    }
                    if (t.useExisting) {
                        const e = t;
                        return () => cn(d(e.useExisting))
                    }
                    if (t.useFactory) {
                        const e = t;
                        return () => e.useFactory(...un(e.deps || Qr))
                    }
                    if (t.useClass) {
                        const n = t;
                        let s = t.deps;
                        if (!s) {
                            const t = new Gt;
                            s = t.parameters(e)
                        }
                        return () => new(d(n.useClass))(...un(s))
                    } {
                        let n = t.deps;
                        if (!n) {
                            const t = new Gt;
                            n = t.parameters(e)
                        }
                        return () => new e(...un(n))
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Jr = xt("Injectable", void 0, void 0, void 0, (e, t) => Xr(e, t));
                const Xr = function(e, t) {
                    t && void 0 !== t.providedIn && !y(e) && (e.\u0275prov = m({
                        token: e,
                        providedIn: t.providedIn,
                        factory: Zr(e, t)
                    }))
                };

                function Yr(e) {
                    if (e.length > 1) {
                        return " (" +
                            /**
                             * @license
                             * Copyright Google LLC All Rights Reserved.
                             *
                             * Use of this source code is governed by an MIT-style license that can be
                             * found in the LICENSE file at https://angular.io/license
                             */
                            function(e) {
                                const t = [];
                                for (let n = 0; n < e.length; ++n) {
                                    if (t.indexOf(e[n]) > -1) return t.push(e[n]), t;
                                    t.push(e[n])
                                }
                                return t
                            }(e.slice().reverse()).map(e => c(e.token)).join(" -> ") + ")"
                    }
                    return ""
                }

                function ei(e, t, n, s) {
                    const r = [t],
                        i = n(r),
                        o = s ? function(e, t) {
                            const n = `${e} caused by: ${t instanceof Error?t.message:t}`,
                                s = Error(n);
                            return s.ngOriginalError = t, s
                        }
                    /**
                     * @license
                     * Copyright Google LLC All Rights Reserved.
                     *
                     * Use of this source code is governed by an MIT-style license that can be
                     * found in the LICENSE file at https://angular.io/license
                     */
                    (i, s): Error(i);
                    return o.addKey = ti, o.keys = r, o.injectors = [e], o.constructResolvingMessage = n, o.ngOriginalError = s, o
                }

                function ti(e, t) {
                    this.injectors.push(e), this.keys.push(t), this.message = this.constructResolvingMessage(this.keys)
                }

                function ni(e, t) {
                    const n = [];
                    for (let s = 0, r = t.length; s < r; s++) {
                        const e = t[s];
                        e && 0 != e.length ? n.push(e.map(c).join(" ")) : n.push("?")
                    }
                    return Error("Cannot resolve all parameters for '" + c(e) + "'(" + n.join(", ") + "). Make sure that all the parameters are decorated with Inject or have valid type annotations and that '" + c(e) + "' is decorated with Injectable.")
                }

                function si(e, t) {
                    return Error(`Cannot mix multi providers and regular providers, got: ${e} ${t}`)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class ri {
                    constructor(e, t) {
                        if (this.token = e, this.id = t, !e) throw new Error("Token must be defined!");
                        this.displayName = c(this.token)
                    }
                    static get(e) {
                        return ii.get(d(e))
                    }
                    static get numberOfKeys() {
                        return ii.numberOfKeys
                    }
                }
                const ii = new class {
                    constructor() {
                        this._allKeys = new Map
                    }
                    get(e) {
                        if (e instanceof ri) return e;
                        if (this._allKeys.has(e)) return this._allKeys.get(e);
                        const t = new ri(e, ri.numberOfKeys);
                        return this._allKeys.set(e, t), t
                    }
                    get numberOfKeys() {
                        return this._allKeys.size
                    }
                };
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const oi = new class {
                    constructor(e) {
                        this.reflectionCapabilities = e
                    }
                    updateCapabilities(e) {
                        this.reflectionCapabilities = e
                    }
                    factory(e) {
                        return this.reflectionCapabilities.factory(e)
                    }
                    parameters(e) {
                        return this.reflectionCapabilities.parameters(e)
                    }
                    annotations(e) {
                        return this.reflectionCapabilities.annotations(e)
                    }
                    propMetadata(e) {
                        return this.reflectionCapabilities.propMetadata(e)
                    }
                    hasLifecycleHook(e, t) {
                        return this.reflectionCapabilities.hasLifecycleHook(e, t)
                    }
                    getter(e) {
                        return this.reflectionCapabilities.getter(e)
                    }
                    setter(e) {
                        return this.reflectionCapabilities.setter(e)
                    }
                    method(e) {
                        return this.reflectionCapabilities.method(e)
                    }
                    importUri(e) {
                        return this.reflectionCapabilities.importUri(e)
                    }
                    resourceUri(e) {
                        return this.reflectionCapabilities.resourceUri(e)
                    }
                    resolveIdentifier(e, t, n, s) {
                        return this.reflectionCapabilities.resolveIdentifier(e, t, n, s)
                    }
                    resolveEnum(e, t) {
                        return this.reflectionCapabilities.resolveEnum(e, t)
                    }
                }(new Gt);
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class ai {
                    constructor(e, t, n) {
                        this.key = e, this.optional = t, this.visibility = n
                    }
                    static fromKey(e) {
                        return new ai(e, !1, null)
                    }
                }
                const li = [];
                class ci {
                    constructor(e, t, n) {
                        this.key = e, this.resolvedFactories = t, this.multiProvider = n, this.resolvedFactory = this.resolvedFactories[0]
                    }
                }
                class ui {
                    constructor(e, t) {
                        this.factory = e, this.dependencies = t
                    }
                }

                function hi(e) {
                    let t, n;
                    if (e.useClass) {
                        const s = d(e.useClass);
                        t = oi.factory(s), n = mi(s)
                    } else e.useExisting ? (t = e => e, n = [ai.fromKey(ri.get(e.useExisting))]) : e.useFactory ? (t = e.useFactory, n = function(e, t) {
                        if (t) {
                            const n = t.map(e => [e]);
                            return t.map(t => gi(e, t, n))
                        }
                        return mi(e)
                    }(e.useFactory, e.deps)) : (t = () => e.useValue, n = li);
                    return new ui(t, n)
                }

                function pi(e) {
                    return new ci(ri.get(e.provide), [hi(e)], e.multi || !1)
                }

                function di(e) {
                    const t = function(e, t) {
                        for (let n = 0; n < e.length; n++) {
                            const s = e[n],
                                r = t.get(s.key.id);
                            if (r) {
                                if (s.multiProvider !== r.multiProvider) throw si(r, s);
                                if (s.multiProvider)
                                    for (let e = 0; e < s.resolvedFactories.length; e++) r.resolvedFactories.push(s.resolvedFactories[e]);
                                else t.set(s.key.id, s)
                            } else {
                                let e;
                                e = s.multiProvider ? new ci(s.key, s.resolvedFactories.slice(), s.multiProvider) : s, t.set(s.key.id, e)
                            }
                        }
                        return t
                    }(fi(e, []).map(pi), new Map);
                    return Array.from(t.values())
                }

                function fi(e, t) {
                    return e.forEach(e => {
                        if (e instanceof jt) t.push({
                            provide: e,
                            useClass: e
                        });
                        else if (e && "object" == typeof e && void 0 !== e.provide) t.push(e);
                        else {
                            if (!Array.isArray(e)) throw Error(`Invalid provider - only instances of Provider and Type are allowed, got: ${e}`);
                            fi(e, t)
                        }
                    }), t
                }

                function mi(e) {
                    const t = oi.parameters(e);
                    if (!t) return [];
                    if (t.some(e => null == e)) throw ni(e, t);
                    return t.map(n => gi(e, n, t))
                }

                function gi(e, t, n) {
                    let s = null,
                        r = !1;
                    if (!Array.isArray(t)) return yi(t instanceof Zt ? t.token : t, r, null);
                    let i = null;
                    for (let o = 0; o < t.length; ++o) {
                        const e = t[o];
                        e instanceof jt ? s = e : e instanceof Zt ? s = e.token : e instanceof Jt ? r = !0 : e instanceof Xt || e instanceof Yt ? i = e : e instanceof kt && (s = e)
                    }
                    if (s = d(s), null != s) return yi(s, r, i);
                    throw ni(e, n)
                }

                function yi(e, t, n) {
                    return new ai(ri.get(e), t, n)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const vi = {};
                class _i {
                    static resolve(e) {
                        return di(e)
                    }
                    static resolveAndCreate(e, t) {
                        const n = _i.resolve(e);
                        return _i.fromResolvedProviders(n, t)
                    }
                    static fromResolvedProviders(e, t) {
                        return new bi(e, t)
                    }
                }
                class bi {
                    constructor(e, t) {
                        this._constructionCounter = 0, this._providers = e, this.parent = t || null;
                        const n = e.length;
                        this.keyIds = [], this.objs = [];
                        for (let s = 0; s < n; s++) this.keyIds[s] = e[s].key.id, this.objs[s] = vi
                    }
                    get(e, t = tn) {
                        return this._getByKey(ri.get(e), null, t)
                    }
                    resolveAndCreateChild(e) {
                        const t = _i.resolve(e);
                        return this.createChildFromResolved(t)
                    }
                    createChildFromResolved(e) {
                        const t = new bi(e);
                        return t.parent = this, t
                    }
                    resolveAndInstantiate(e) {
                        return this.instantiateResolved(_i.resolve([e])[0])
                    }
                    instantiateResolved(e) {
                        return this._instantiateProvider(e)
                    }
                    getProviderAtIndex(e) {
                        if (e < 0 || e >= this._providers.length) throw function(e) {
                            return Error(`Index ${e} is out-of-bounds.`)
                        }(e);
                        return this._providers[e]
                    }
                    _new(e) {
                        if (this._constructionCounter++ > this._getMaxNumberOfObjects()) throw t = this, n = e.key, ei(t, n, function(e) {
                            return `Cannot instantiate cyclic dependency!${Yr(e)}`
                        });
                        var t, n;
                        return this._instantiateProvider(e)
                    }
                    _getMaxNumberOfObjects() {
                        return this.objs.length
                    }
                    _instantiateProvider(e) {
                        if (e.multiProvider) {
                            const t = [];
                            for (let n = 0; n < e.resolvedFactories.length; ++n) t[n] = this._instantiate(e, e.resolvedFactories[n]);
                            return t
                        }
                        return this._instantiate(e, e.resolvedFactories[0])
                    }
                    _instantiate(e, t) {
                        const n = t.factory;
                        let s, r;
                        try {
                            s = t.dependencies.map(e => this._getByReflectiveDependency(e))
                        } catch (l) {
                            throw l.addKey && l.addKey(this, e.key), l
                        }
                        try {
                            r = n(...s)
                        } catch (l) {
                            throw i = this, o = l, l.stack, a = e.key, ei(i, a, function(e) {
                                const t = c(e[0].token);
                                return `${o.message}: Error during instantiation of ${t}!${Yr(e)}.`
                            }, o)
                        }
                        var i, o, a;
                        return r
                    }
                    _getByReflectiveDependency(e) {
                        return this._getByKey(e.key, e.visibility, e.optional ? null : tn)
                    }
                    _getByKey(e, t, n) {
                        return e === bi.INJECTOR_KEY ? this : t instanceof Xt ? this._getByKeySelf(e, n) : this._getByKeyDefault(e, n, t)
                    }
                    _getObjByKeyId(e) {
                        for (let t = 0; t < this.keyIds.length; t++)
                            if (this.keyIds[t] === e) return this.objs[t] === vi && (this.objs[t] = this._new(this._providers[t])), this.objs[t];
                        return vi
                    }
                    _throwOrNull(e, t) {
                        if (t !== tn) return t;
                        throw function(e, t) {
                            return ei(e, t, function(e) {
                                return `No provider for ${c(e[0].token)}!${Yr(e)}`
                            })
                        }(this, e)
                    }
                    _getByKeySelf(e, t) {
                        const n = this._getObjByKeyId(e.id);
                        return n !== vi ? n : this._throwOrNull(e, t)
                    }
                    _getByKeyDefault(e, t, n) {
                        let s;
                        for (s = n instanceof Yt ? this.parent : this; s instanceof bi;) {
                            const t = s,
                                n = t._getObjByKeyId(e.id);
                            if (n !== vi) return n;
                            s = t.parent
                        }
                        return null !== s ? s.get(e.token, t) : this._throwOrNull(e, t)
                    }
                    get displayName() {
                        return `ReflectiveInjector(providers: [${function(e,t){const n=[];for(let s=0;s<e._providers.length;++s)n[s]=t(e.getProviderAtIndex(s));return n}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */(this,e=>' "'+e.key.displayName+'" ').join(", ")}])`
                    }
                    toString() {
                        return this.displayName
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function wi(e) {
                    return !!e && "function" == typeof e.then
                }

                function Ei(e) {
                    return !!e && "function" == typeof e.subscribe
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                bi.INJECTOR_KEY = ri.get(Ar);
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Ci = void 0;
                var Si = ["en", [
                        ["a", "p"],
                        ["AM", "PM"], Ci
                    ],
                    [
                        ["AM", "PM"], Ci, Ci
                    ],
                    [
                        ["S", "M", "T", "W", "T", "F", "S"],
                        ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                        ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                        ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]
                    ], Ci, [
                        ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
                        ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                        ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
                    ], Ci, [
                        ["B", "A"],
                        ["BC", "AD"],
                        ["Before Christ", "Anno Domini"]
                    ], 0, [6, 0],
                    ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"],
                    ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"],
                    ["{1}, {0}", Ci, "{1} 'at' {0}", Ci],
                    [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"],
                    ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr",
                    function(e) {
                        let t = Math.floor(Math.abs(e)),
                            n = e.toString().replace(/^[^.]*\.?/, "").length;
                        return 1 === t && 0 === n ? 1 : 5
                    }
                ];
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                let xi = {};

                function Ti(e, t, n) {
                    "string" != typeof t && (n = t, t = e[Oi.LocaleId]), t = t.toLowerCase().replace(/_/g, "-"), xi[t] = e, n && (xi[t][Oi.ExtraData] = n)
                }

                function Ai(e) {
                    const t = function(e) {
                        return e.toLowerCase().replace(/_/g, "-")
                    }
                    /**
                     * @license
                     * Copyright Google LLC All Rights Reserved.
                     *
                     * Use of this source code is governed by an MIT-style license that can be
                     * found in the LICENSE file at https://angular.io/license
                     */
                    (e);
                    let n = ki(t);
                    if (n) return n;
                    const s = t.split("-")[0];
                    if (n = ki(s), n) return n;
                    if ("en" === s) return Si;
                    throw new Error(`Missing locale data for the locale "${e}".`)
                }

                function Di(e) {
                    return Ai(e)[Oi.CurrencyCode] || null
                }

                function Pi(e) {
                    return Ai(e)[Oi.PluralCase]
                }

                function ki(e) {
                    return e in xi || (xi[e] = I.ng && I.ng.common && I.ng.common.locales && I.ng.common.locales[e]), xi[e]
                }
                var Oi;
                ! function(e) {
                    e[e.LocaleId = 0] = "LocaleId", e[e.DayPeriodsFormat = 1] = "DayPeriodsFormat", e[e.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", e[e.DaysFormat = 3] = "DaysFormat", e[e.DaysStandalone = 4] = "DaysStandalone", e[e.MonthsFormat = 5] = "MonthsFormat", e[e.MonthsStandalone = 6] = "MonthsStandalone", e[e.Eras = 7] = "Eras", e[e.FirstDayOfWeek = 8] = "FirstDayOfWeek", e[e.WeekendRange = 9] = "WeekendRange", e[e.DateFormat = 10] = "DateFormat", e[e.TimeFormat = 11] = "TimeFormat", e[e.DateTimeFormat = 12] = "DateTimeFormat", e[e.NumberSymbols = 13] = "NumberSymbols", e[e.NumberFormats = 14] = "NumberFormats", e[e.CurrencyCode = 15] = "CurrencyCode", e[e.CurrencySymbol = 16] = "CurrencySymbol", e[e.CurrencyName = 17] = "CurrencyName", e[e.Currencies = 18] = "Currencies", e[e.Directionality = 19] = "Directionality", e[e.PluralCase = 20] = "PluralCase", e[e.ExtraData = 21] = "ExtraData"
                }(Oi || (Oi = {}));
                const Ii = "en-US";
                var Ni;
                ! function(e) {
                    e[e.SHIFT = 2] = "SHIFT", e[e.APPEND_EAGERLY = 1] = "APPEND_EAGERLY", e[e.COMMENT = 2] = "COMMENT"
                }(Ni || (Ni = {}));
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Mi {}
                class Fi {}
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function Ri(e) {
                    const t = Error(`No component factory found for ${c(e)}. Did you add it to @NgModule.entryComponents?`);
                    return t[ji] = e, t
                }
                const ji = "ngComponent";
                class Li {}
                Li.NULL = new class {
                    resolveComponentFactory(e) {
                        throw Ri(e)
                    }
                };
                class Vi {
                    constructor(e, t, n) {
                        this._parent = t, this._ngModule = n, this._factories = new Map;
                        for (let s = 0; s < e.length; s++) {
                            const t = e[s];
                            this._factories.set(t.componentType, t)
                        }
                    }
                    resolveComponentFactory(e) {
                        let t = this._factories.get(e);
                        if (!t && this._parent && (t = this._parent.resolveComponentFactory(e)), !t) throw Ri(e);
                        return new $i(t, this._ngModule)
                    }
                }
                class $i extends Fi {
                    constructor(e, t) {
                        super(), this.factory = e, this.ngModule = t, this.selector = e.selector, this.componentType = e.componentType, this.ngContentSelectors = e.ngContentSelectors, this.inputs = e.inputs, this.outputs = e.outputs
                    }
                    create(e, t, n, s) {
                        return this.factory.create(e, t, n, s || this.ngModule)
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function Bi(...e) {}
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function Hi(e, t) {
                    return new qi(pe(e, t))
                }
                const Ui = Bi;
                class qi {
                    constructor(e) {
                        this.nativeElement = e
                    }
                }
                qi.__NG_ELEMENT_ID__ = Ui;
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                new kt("Renderer2Interceptor");
                class zi {}
                class Wi {}
                Wi.__NG_ELEMENT_ID__ = () => Gi();
                const Gi = Bi;
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Ki {}
                Ki.\u0275prov = m({
                    token: Ki,
                    providedIn: "root",
                    factory: () => null
                });
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Qi {
                    constructor(e) {
                        this.full = e, this.major = e.split(".")[0], this.minor = e.split(".")[1], this.patch = e.split(".").slice(2).join(".")
                    }
                }
                const Zi = new Qi("11.0.7");
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Ji {
                    constructor() {}
                    supports(e) {
                        return Wr(e)
                    }
                    create(e) {
                        return new Yi(e)
                    }
                }
                const Xi = (e, t) => t;
                class Yi {
                    constructor(e) {
                        this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = e || Xi
                    }
                    forEachItem(e) {
                        let t;
                        for (t = this._itHead; null !== t; t = t._next) e(t)
                    }
                    forEachOperation(e) {
                        let t = this._itHead,
                            n = this._removalsHead,
                            s = 0,
                            r = null;
                        for (; t || n;) {
                            const i = !n || t && t.currentIndex < so(n, s, r) ? t : n,
                                o = so(i, s, r),
                                a = i.currentIndex;
                            if (i === n) s--, n = n._nextRemoved;
                            else if (t = t._next, null == i.previousIndex) s++;
                            else {
                                r || (r = []);
                                const e = o - s,
                                    t = a - s;
                                if (e != t) {
                                    for (let n = 0; n < e; n++) {
                                        const s = n < r.length ? r[n] : r[n] = 0,
                                            i = s + n;
                                        t <= i && i < e && (r[n] = s + 1)
                                    }
                                    r[i.previousIndex] = t - e
                                }
                            }
                            o !== a && e(i, o, a)
                        }
                    }
                    forEachPreviousItem(e) {
                        let t;
                        for (t = this._previousItHead; null !== t; t = t._nextPrevious) e(t)
                    }
                    forEachAddedItem(e) {
                        let t;
                        for (t = this._additionsHead; null !== t; t = t._nextAdded) e(t)
                    }
                    forEachMovedItem(e) {
                        let t;
                        for (t = this._movesHead; null !== t; t = t._nextMoved) e(t)
                    }
                    forEachRemovedItem(e) {
                        let t;
                        for (t = this._removalsHead; null !== t; t = t._nextRemoved) e(t)
                    }
                    forEachIdentityChange(e) {
                        let t;
                        for (t = this._identityChangesHead; null !== t; t = t._nextIdentityChange) e(t)
                    }
                    diff(e) {
                        if (null == e && (e = []), !Wr(e)) throw new Error(`Error trying to diff '${c(e)}'. Only arrays and iterables are allowed`);
                        return this.check(e) ? this : null
                    }
                    onDestroy() {}
                    check(e) {
                        this._reset();
                        let t, n, s, r = this._itHead,
                            i = !1;
                        if (Array.isArray(e)) {
                            this.length = e.length;
                            for (let t = 0; t < this.length; t++) n = e[t], s = this._trackByFn(t, n), null !== r && Object.is(r.trackById, s) ? (i && (r = this._verifyReinsertion(r, n, s, t)), Object.is(r.item, n) || this._addIdentityChange(r, n)) : (r = this._mismatch(r, n, s, t), i = !0), r = r._next
                        } else t = 0,
                            function(e, t) {
                                if (Array.isArray(e))
                                    for (let n = 0; n < e.length; n++) t(e[n]);
                                else {
                                    const n = e[Ur()]();
                                    let s;
                                    for (; !(s = n.next()).done;) t(s.value)
                                }
                            }(e, e => {
                                s = this._trackByFn(t, e), null !== r && Object.is(r.trackById, s) ? (i && (r = this._verifyReinsertion(r, e, s, t)), Object.is(r.item, e) || this._addIdentityChange(r, e)) : (r = this._mismatch(r, e, s, t), i = !0), r = r._next, t++
                            }), this.length = t;
                        return this._truncate(r), this.collection = e, this.isDirty
                    }
                    get isDirty() {
                        return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead
                    }
                    _reset() {
                        if (this.isDirty) {
                            let e;
                            for (e = this._previousItHead = this._itHead; null !== e; e = e._next) e._nextPrevious = e._next;
                            for (e = this._additionsHead; null !== e; e = e._nextAdded) e.previousIndex = e.currentIndex;
                            for (this._additionsHead = this._additionsTail = null, e = this._movesHead; null !== e; e = e._nextMoved) e.previousIndex = e.currentIndex;
                            this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null
                        }
                    }
                    _mismatch(e, t, n, s) {
                        let r;
                        return null === e ? r = this._itTail : (r = e._prev, this._remove(e)), null !== (e = null === this._linkedRecords ? null : this._linkedRecords.get(n, s)) ? (Object.is(e.item, t) || this._addIdentityChange(e, t), this._moveAfter(e, r, s)) : null !== (e = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null)) ? (Object.is(e.item, t) || this._addIdentityChange(e, t), this._reinsertAfter(e, r, s)) : e = this._addAfter(new eo(t, n), r, s), e
                    }
                    _verifyReinsertion(e, t, n, s) {
                        let r = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null);
                        return null !== r ? e = this._reinsertAfter(r, e._prev, s) : e.currentIndex != s && (e.currentIndex = s, this._addToMoves(e, s)), e
                    }
                    _truncate(e) {
                        for (; null !== e;) {
                            const t = e._next;
                            this._addToRemovals(this._unlink(e)), e = t
                        }
                        null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null)
                    }
                    _reinsertAfter(e, t, n) {
                        null !== this._unlinkedRecords && this._unlinkedRecords.remove(e);
                        const s = e._prevRemoved,
                            r = e._nextRemoved;
                        return null === s ? this._removalsHead = r : s._nextRemoved = r, null === r ? this._removalsTail = s : r._prevRemoved = s, this._insertAfter(e, t, n), this._addToMoves(e, n), e
                    }
                    _moveAfter(e, t, n) {
                        return this._unlink(e), this._insertAfter(e, t, n), this._addToMoves(e, n), e
                    }
                    _addAfter(e, t, n) {
                        return this._insertAfter(e, t, n), null === this._additionsTail ? this._additionsTail = this._additionsHead = e : this._additionsTail = this._additionsTail._nextAdded = e, e
                    }
                    _insertAfter(e, t, n) {
                        const s = null === t ? this._itHead : t._next;
                        return e._next = s, e._prev = t, null === s ? this._itTail = e : s._prev = e, null === t ? this._itHead = e : t._next = e, null === this._linkedRecords && (this._linkedRecords = new no), this._linkedRecords.put(e), e.currentIndex = n, e
                    }
                    _remove(e) {
                        return this._addToRemovals(this._unlink(e))
                    }
                    _unlink(e) {
                        null !== this._linkedRecords && this._linkedRecords.remove(e);
                        const t = e._prev,
                            n = e._next;
                        return null === t ? this._itHead = n : t._next = n, null === n ? this._itTail = t : n._prev = t, e
                    }
                    _addToMoves(e, t) {
                        return e.previousIndex === t || (null === this._movesTail ? this._movesTail = this._movesHead = e : this._movesTail = this._movesTail._nextMoved = e), e
                    }
                    _addToRemovals(e) {
                        return null === this._unlinkedRecords && (this._unlinkedRecords = new no), this._unlinkedRecords.put(e), e.currentIndex = null, e._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = e, e._prevRemoved = null) : (e._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = e), e
                    }
                    _addIdentityChange(e, t) {
                        return e.item = t, null === this._identityChangesTail ? this._identityChangesTail = this._identityChangesHead = e : this._identityChangesTail = this._identityChangesTail._nextIdentityChange = e, e
                    }
                }
                class eo {
                    constructor(e, t) {
                        this.item = e, this.trackById = t, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null
                    }
                }
                class to {
                    constructor() {
                        this._head = null, this._tail = null
                    }
                    add(e) {
                        null === this._head ? (this._head = this._tail = e, e._nextDup = null, e._prevDup = null) : (this._tail._nextDup = e, e._prevDup = this._tail, e._nextDup = null, this._tail = e)
                    }
                    get(e, t) {
                        let n;
                        for (n = this._head; null !== n; n = n._nextDup)
                            if ((null === t || t <= n.currentIndex) && Object.is(n.trackById, e)) return n;
                        return null
                    }
                    remove(e) {
                        const t = e._prevDup,
                            n = e._nextDup;
                        return null === t ? this._head = n : t._nextDup = n, null === n ? this._tail = t : n._prevDup = t, null === this._head
                    }
                }
                class no {
                    constructor() {
                        this.map = new Map
                    }
                    put(e) {
                        const t = e.trackById;
                        let n = this.map.get(t);
                        n || (n = new to, this.map.set(t, n)), n.add(e)
                    }
                    get(e, t) {
                        const n = e,
                            s = this.map.get(n);
                        return s ? s.get(e, t) : null
                    }
                    remove(e) {
                        const t = e.trackById;
                        return this.map.get(t).remove(e) && this.map.delete(t), e
                    }
                    get isEmpty() {
                        return 0 === this.map.size
                    }
                    clear() {
                        this.map.clear()
                    }
                }

                function so(e, t, n) {
                    const s = e.previousIndex;
                    if (null === s) return s;
                    let r = 0;
                    return n && s < n.length && (r = n[s]), s + t + r
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class ro {
                    constructor() {}
                    supports(e) {
                        return e instanceof Map || Gr(e)
                    }
                    create() {
                        return new io
                    }
                }
                class io {
                    constructor() {
                        this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null
                    }
                    get isDirty() {
                        return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead
                    }
                    forEachItem(e) {
                        let t;
                        for (t = this._mapHead; null !== t; t = t._next) e(t)
                    }
                    forEachPreviousItem(e) {
                        let t;
                        for (t = this._previousMapHead; null !== t; t = t._nextPrevious) e(t)
                    }
                    forEachChangedItem(e) {
                        let t;
                        for (t = this._changesHead; null !== t; t = t._nextChanged) e(t)
                    }
                    forEachAddedItem(e) {
                        let t;
                        for (t = this._additionsHead; null !== t; t = t._nextAdded) e(t)
                    }
                    forEachRemovedItem(e) {
                        let t;
                        for (t = this._removalsHead; null !== t; t = t._nextRemoved) e(t)
                    }
                    diff(e) {
                        if (e) {
                            if (!(e instanceof Map || Gr(e))) throw new Error(`Error trying to diff '${c(e)}'. Only maps and objects are allowed`)
                        } else e = new Map;
                        return this.check(e) ? this : null
                    }
                    onDestroy() {}
                    check(e) {
                        this._reset();
                        let t = this._mapHead;
                        if (this._appendAfter = null, this._forEach(e, (e, n) => {
                                if (t && t.key === n) this._maybeAddToChanges(t, e), this._appendAfter = t, t = t._next;
                                else {
                                    const s = this._getOrCreateRecordForKey(n, e);
                                    t = this._insertBeforeOrAppend(t, s)
                                }
                            }), t) {
                            t._prev && (t._prev._next = null), this._removalsHead = t;
                            for (let e = t; null !== e; e = e._nextRemoved) e === this._mapHead && (this._mapHead = null), this._records.delete(e.key), e._nextRemoved = e._next, e.previousValue = e.currentValue, e.currentValue = null, e._prev = null, e._next = null
                        }
                        return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty
                    }
                    _insertBeforeOrAppend(e, t) {
                        if (e) {
                            const n = e._prev;
                            return t._next = e, t._prev = n, e._prev = t, n && (n._next = t), e === this._mapHead && (this._mapHead = t), this._appendAfter = e, e
                        }
                        return this._appendAfter ? (this._appendAfter._next = t, t._prev = this._appendAfter) : this._mapHead = t, this._appendAfter = t, null
                    }
                    _getOrCreateRecordForKey(e, t) {
                        if (this._records.has(e)) {
                            const n = this._records.get(e);
                            this._maybeAddToChanges(n, t);
                            const s = n._prev,
                                r = n._next;
                            return s && (s._next = r), r && (r._prev = s), n._next = null, n._prev = null, n
                        }
                        const n = new oo(e);
                        return this._records.set(e, n), n.currentValue = t, this._addToAdditions(n), n
                    }
                    _reset() {
                        if (this.isDirty) {
                            let e;
                            for (this._previousMapHead = this._mapHead, e = this._previousMapHead; null !== e; e = e._next) e._nextPrevious = e._next;
                            for (e = this._changesHead; null !== e; e = e._nextChanged) e.previousValue = e.currentValue;
                            for (e = this._additionsHead; null != e; e = e._nextAdded) e.previousValue = e.currentValue;
                            this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null
                        }
                    }
                    _maybeAddToChanges(e, t) {
                        Object.is(t, e.currentValue) || (e.previousValue = e.currentValue, e.currentValue = t, this._addToChanges(e))
                    }
                    _addToAdditions(e) {
                        null === this._additionsHead ? this._additionsHead = this._additionsTail = e : (this._additionsTail._nextAdded = e, this._additionsTail = e)
                    }
                    _addToChanges(e) {
                        null === this._changesHead ? this._changesHead = this._changesTail = e : (this._changesTail._nextChanged = e, this._changesTail = e)
                    }
                    _forEach(e, t) {
                        e instanceof Map ? e.forEach(t) : Object.keys(e).forEach(n => t(e[n], n))
                    }
                }
                class oo {
                    constructor(e) {
                        this.key = e, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class ao {
                    constructor(e) {
                        this.factories = e
                    }
                    static create(e, t) {
                        if (null != t) {
                            const n = t.factories.slice();
                            e = e.concat(n)
                        }
                        return new ao(e)
                    }
                    static extend(e) {
                        return {
                            provide: ao,
                            useFactory: t => {
                                if (!t) throw new Error("Cannot extend IterableDiffers without a parent injector");
                                return ao.create(e, t)
                            },
                            deps: [
                                [ao, new Yt, new Jt]
                            ]
                        }
                    }
                    find(e) {
                        const t = this.factories.find(t => t.supports(e));
                        if (null != t) return t;
                        throw new Error(`Cannot find a differ supporting object '${e}' of type '${n=e,n.name||typeof n}'`);
                        var n;
                        /**
                         * @license
                         * Copyright Google LLC All Rights Reserved.
                         *
                         * Use of this source code is governed by an MIT-style license that can be
                         * found in the LICENSE file at https://angular.io/license
                         */
                    }
                }
                ao.\u0275prov = m({
                    token: ao,
                    providedIn: "root",
                    factory: () => new ao([new Ji])
                });
                class lo {
                    constructor(e) {
                        this.factories = e
                    }
                    static create(e, t) {
                        if (t) {
                            const n = t.factories.slice();
                            e = e.concat(n)
                        }
                        return new lo(e)
                    }
                    static extend(e) {
                        return {
                            provide: lo,
                            useFactory: t => {
                                if (!t) throw new Error("Cannot extend KeyValueDiffers without a parent injector");
                                return lo.create(e, t)
                            },
                            deps: [
                                [lo, new Yt, new Jt]
                            ]
                        }
                    }
                    find(e) {
                        const t = this.factories.find(t => t.supports(e));
                        if (t) return t;
                        throw new Error(`Cannot find a differ supporting object '${e}'`)
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function co(e, t, n, s, r = !1) {
                    for (; null !== n;) {
                        const i = t[n.index];
                        if (null !== i && s.push(he(i)), B(i))
                            for (let e = V; e < i.length; e++) {
                                const t = i[e],
                                    n = t[1].firstChild;
                                null !== n && co(t[1], t, n, s)
                            }
                        const o = n.type;
                        if (8 & o) co(e, t, n.child, s);
                        else if (32 & o) {
                            const e = bs(n, t);
                            let r;
                            for (; r = e();) s.push(r)
                        } else if (16 & o) {
                            const e = t[16],
                                r = e[6],
                                i = n.projection,
                                o = r.projection[i];
                            if (Array.isArray(o)) s.push(...o);
                            else {
                                const t = ws(e);
                                co(t[1], t, o, s, !0)
                            }
                        }
                        n = r ? n.projectionNext : n.next
                    }
                    return s
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                lo.\u0275prov = m({
                    token: lo,
                    providedIn: "root",
                    factory: () => new lo([new ro])
                });
                class uo {
                    constructor(e, t) {
                        this._lView = e, this._cdRefInjectingView = t, this._appRef = null, this._viewContainerRef = null
                    }
                    get rootNodes() {
                        const e = this._lView,
                            t = e[1];
                        return co(t, e, t.firstChild, [])
                    }
                    get context() {
                        return this._lView[8]
                    }
                    get destroyed() {
                        return 256 == (256 & this._lView[2])
                    }
                    destroy() {
                        if (this._appRef) this._appRef.detachView(this);
                        else if (this._viewContainerRef) {
                            const e = this._viewContainerRef.indexOf(this);
                            e > -1 && this._viewContainerRef.detach(e), this._viewContainerRef = null
                        }
                        Ds(this._lView[1], this._lView)
                    }
                    onDestroy(e) {
                        sr(this._lView[1], this._lView, null, e)
                    }
                    markForCheck() {
                        dr(this._cdRefInjectingView || this._lView)
                    }
                    detach() {
                        this._lView[2] &= -129
                    }
                    reattach() {
                        this._lView[2] |= 128
                    }
                    detectChanges() {
                        mr(this._lView[1], this._lView, this.context)
                    }
                    checkNoChanges() {
                        ! function(e, t, n) {
                            Pe(!0);
                            try {
                                mr(e, t, n)
                            } finally {
                                Pe(!1)
                            }
                        }(this._lView[1], this._lView, this.context)
                    }
                    attachToViewContainerRef(e) {
                        if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!");
                        this._viewContainerRef = e
                    }
                    detachFromAppRef() {
                        var e, t;
                        this._appRef = null, e = this._lView[1], t = this._lView, Fs(e, t, t[11], 2, null, null)
                    }
                    attachToAppRef(e) {
                        if (this._viewContainerRef) throw new Error("This view is already attached to a ViewContainer!");
                        this._appRef = e
                    }
                }
                class ho extends uo {
                    constructor(e) {
                        super(e), this._view = e
                    }
                    detectChanges() {
                        gr(this._view)
                    }
                    checkNoChanges() {
                        ! function(e) {
                            Pe(!0);
                            try {
                                gr(e)
                            } finally {
                                Pe(!1)
                            }
                        }(this._view)
                    }
                    get context() {
                        return null
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const po = Bi;
                class fo {}
                fo.__NG_ELEMENT_ID__ = po, fo.__ChangeDetectorRef__ = !0;
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const mo = [new ro],
                    go = [new Ji],
                    yo = new ao(go),
                    vo = new lo(mo),
                    _o = Bi;
                class bo {}
                bo.__NG_ELEMENT_ID__ = _o;
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class wo {}
                class Eo {}
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Co = Bi;
                class So {}
                So.__NG_ELEMENT_ID__ = Co;
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function xo(e, t, n, s) {
                    let r = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: '${t}'. Current value: '${n}'.`;
                    return s && (r += " It seems like the view has been created after its parent and its children have been dirty checked. Has it been created in a change detection hook ?"),
                        function(e, t) {
                            const n = new Error(e);
                            return To(n, t), n
                        }(r, e)
                }

                function To(e, t) {
                    e.ngDebugContext = t, e.ngErrorLogger = t.logError.bind(t)
                }

                function Ao(e) {
                    return new Error(`ViewDestroyedError: Attempt to use a destroyed view: ${e}`)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function Do(e, t, n) {
                    const s = e.state,
                        r = 1792 & s;
                    return r === t ? (e.state = -1793 & s | n, e.initIndex = -1, !0) : r === n
                }

                function Po(e, t, n) {
                    return (1792 & e.state) === t && e.initIndex <= n && (e.initIndex = n + 1, !0)
                }

                function ko(e, t) {
                    return e.nodes[t]
                }

                function Oo(e, t) {
                    return e.nodes[t]
                }

                function Io(e, t) {
                    return e.nodes[t]
                }

                function No(e, t) {
                    return e.nodes[t]
                }

                function Mo(e, t) {
                    return e.nodes[t]
                }
                const Fo = {
                        setCurrentNode: void 0,
                        createRootView: void 0,
                        createEmbeddedView: void 0,
                        createComponentView: void 0,
                        createNgModuleRef: void 0,
                        overrideProvider: void 0,
                        overrideComponentView: void 0,
                        clearOverrides: void 0,
                        checkAndUpdateView: void 0,
                        checkNoChangesView: void 0,
                        destroyView: void 0,
                        resolveDep: void 0,
                        createDebugContext: void 0,
                        handleEvent: void 0,
                        updateDirectives: void 0,
                        updateRenderer: void 0,
                        dirtyParentQueries: void 0
                    },
                    Ro = () => {},
                    jo = new Map;
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function Lo(e) {
                    let t = jo.get(e);
                    return t || (t = c(e) + "_" + jo.size, jo.set(e, t)), t
                }

                function Vo(e, t, n, s) {
                    if (zr.isWrapped(s)) {
                        s = zr.unwrap(s);
                        const r = e.def.nodes[t].bindingIndex + n,
                            i = zr.unwrap(e.oldValues[r]);
                        e.oldValues[r] = new zr(i)
                    }
                    return s
                }
                const $o = "$$undefined",
                    Bo = "$$empty";

                function Ho(e) {
                    return {
                        id: $o,
                        styles: e.styles,
                        encapsulation: e.encapsulation,
                        data: e.data
                    }
                }
                let Uo = 0;

                function qo(e, t, n, s) {
                    const r = e.oldValues;
                    return !(!(2 & e.state) && Object.is(r[t.bindingIndex + n], s))
                }

                function zo(e, t, n, s) {
                    return !!qo(e, t, n, s) && (e.oldValues[t.bindingIndex + n] = s, !0)
                }

                function Wo(e, t, n, s) {
                    const r = e.oldValues[t.bindingIndex + n];
                    if (1 & e.state || !qr(r, s)) {
                        const i = t.bindings[n].name;
                        throw xo(Fo.createDebugContext(e, t.nodeIndex), `${i}: ${r}`, `${i}: ${s}`, 0 != (1 & e.state))
                    }
                }

                function Go(e) {
                    let t = e;
                    for (; t;) 2 & t.def.flags && (t.state |= 8), t = t.viewContainerParent || t.parent
                }

                function Ko(e, t) {
                    let n = e;
                    for (; n && n !== t;) n.state |= 64, n = n.viewContainerParent || n.parent
                }

                function Qo(e, t, n, s) {
                    try {
                        const r = e.def.nodes[t];
                        return Go(33554432 & r.flags ? Oo(e, t).componentView : e), Fo.handleEvent(e, t, n, s)
                    } catch (r) {
                        e.root.errorHandler.handleError(r)
                    }
                }

                function Zo(e) {
                    if (e.parent) {
                        return Oo(e.parent, e.parentNodeDef.nodeIndex)
                    }
                    return null
                }

                function Jo(e) {
                    return e.parent ? e.parentNodeDef.parent : null
                }

                function Xo(e, t) {
                    switch (201347067 & t.flags) {
                        case 1:
                            return Oo(e, t.nodeIndex).renderElement;
                        case 2:
                            return ko(e, t.nodeIndex).renderText
                    }
                }

                function Yo(e) {
                    return !!e.parent && !!(32768 & e.parentNodeDef.flags)
                }

                function ea(e) {
                    return !(!e.parent || 32768 & e.parentNodeDef.flags)
                }

                function ta(e) {
                    return 1 << e % 32
                }

                function na(e) {
                    const t = {};
                    let n = 0;
                    const s = {};
                    return e && e.forEach(([e, r]) => {
                        "number" == typeof e ? (t[e] = r, n |= ta(e)) : s[e] = r
                    }), {
                        matchedQueries: t,
                        references: s,
                        matchedQueryIds: n
                    }
                }

                function sa(e, t) {
                    return e.map(e => {
                        let n, s;
                        return Array.isArray(e) ? [s, n] = e : (s = 0, n = e), n && ("function" == typeof n || "object" == typeof n) && t && Object.defineProperty(n, sn, {
                            value: t,
                            configurable: !0
                        }), {
                            flags: s,
                            token: n,
                            tokenKey: Lo(n)
                        }
                    })
                }

                function ra(e, t, n) {
                    let s = n.renderParent;
                    return s ? 0 == (1 & s.flags) || 0 == (33554432 & s.flags) || s.element.componentRendererType && (s.element.componentRendererType.encapsulation === D.ShadowDom || 1 === s.element.componentRendererType.encapsulation) ? Oo(e, n.renderParent.nodeIndex).renderElement : void 0 : t
                }
                const ia = new WeakMap;

                function oa(e) {
                    let t = ia.get(e);
                    return t || (t = e(() => Ro), t.factory = e, ia.set(e, t)), t
                }

                function aa(e, t, n, s, r) {
                    3 === t && (n = e.renderer.parentNode(Xo(e, e.def.lastRenderRootNode))), la(e, t, 0, e.def.nodes.length - 1, n, s, r)
                }

                function la(e, t, n, s, r, i, o) {
                    for (let a = n; a <= s; a++) {
                        const n = e.def.nodes[a];
                        11 & n.flags && ua(e, n, t, r, i, o), a += n.childCount
                    }
                }

                function ca(e, t, n, s, r, i) {
                    let o = e;
                    for (; o && !Yo(o);) o = o.parent;
                    const a = o.parent,
                        l = Jo(o),
                        c = l.nodeIndex + 1,
                        u = l.nodeIndex + l.childCount;
                    for (let h = c; h <= u; h++) {
                        const e = a.def.nodes[h];
                        e.ngContentIndex === t && ua(a, e, n, s, r, i), h += e.childCount
                    }
                    if (!a.parent) {
                        const o = e.root.projectableNodes[t];
                        if (o)
                            for (let t = 0; t < o.length; t++) ha(e, o[t], n, s, r, i)
                    }
                }

                function ua(e, t, n, s, r, i) {
                    if (8 & t.flags) ca(e, t.ngContent.index, n, s, r, i);
                    else {
                        const o = Xo(e, t);
                        if (3 === n && 33554432 & t.flags && 48 & t.bindingFlags) {
                            if (16 & t.bindingFlags && ha(e, o, n, s, r, i), 32 & t.bindingFlags) {
                                ha(Oo(e, t.nodeIndex).componentView, o, n, s, r, i)
                            }
                        } else ha(e, o, n, s, r, i);
                        if (16777216 & t.flags) {
                            const o = Oo(e, t.nodeIndex).viewContainer._embeddedViews;
                            for (let e = 0; e < o.length; e++) aa(o[e], n, s, r, i)
                        }
                        1 & t.flags && !t.element.name && la(e, n, t.nodeIndex + 1, t.nodeIndex + t.childCount, s, r, i)
                    }
                }

                function ha(e, t, n, s, r, i) {
                    const o = e.renderer;
                    switch (n) {
                        case 1:
                            o.appendChild(s, t);
                            break;
                        case 2:
                            o.insertBefore(s, t, r);
                            break;
                        case 3:
                            o.removeChild(s, t);
                            break;
                        case 0:
                            i.push(t)
                    }
                }
                const pa = /^:([^:]+):(.+)$/;

                function da(e) {
                    if (":" === e[0]) {
                        const t = e.match(pa);
                        return [t[1], t[2]]
                    }
                    return ["", e]
                }

                function fa(e) {
                    let t = 0;
                    for (let n = 0; n < e.length; n++) t |= e[n].flags;
                    return t
                }

                function ma(e, t) {
                    let n = "";
                    for (let s = 0; s < 2 * e; s += 2) n = n + t[s] + ya(t[s + 1]);
                    return n + t[2 * e]
                }

                function ga(e, t, n, s, r, i, o, a, l, c, u, h, p, d, f, m, g, y, v, _) {
                    switch (e) {
                        case 1:
                            return t + ya(n) + s;
                        case 2:
                            return t + ya(n) + s + ya(r) + i;
                        case 3:
                            return t + ya(n) + s + ya(r) + i + ya(o) + a;
                        case 4:
                            return t + ya(n) + s + ya(r) + i + ya(o) + a + ya(l) + c;
                        case 5:
                            return t + ya(n) + s + ya(r) + i + ya(o) + a + ya(l) + c + ya(u) + h;
                        case 6:
                            return t + ya(n) + s + ya(r) + i + ya(o) + a + ya(l) + c + ya(u) + h + ya(p) + d;
                        case 7:
                            return t + ya(n) + s + ya(r) + i + ya(o) + a + ya(l) + c + ya(u) + h + ya(p) + d + ya(f) + m;
                        case 8:
                            return t + ya(n) + s + ya(r) + i + ya(o) + a + ya(l) + c + ya(u) + h + ya(p) + d + ya(f) + m + ya(g) + y;
                        case 9:
                            return t + ya(n) + s + ya(r) + i + ya(o) + a + ya(l) + c + ya(u) + h + ya(p) + d + ya(f) + m + ya(g) + y + ya(v) + _;
                        default:
                            throw new Error("Does not support more than 9 expressions")
                    }
                }

                function ya(e) {
                    return null != e ? e.toString() : ""
                }
                const va = [],
                    _a = {},
                    ba = {},
                    wa = Lo(Ar),
                    Ea = Lo(Cr),
                    Ca = Lo(wo);

                function Sa(e, t, n, s) {
                    n = d(n);
                    return {
                        index: -1,
                        deps: sa(s, c(t)),
                        flags: e,
                        token: t,
                        value: n
                    }
                }

                function xa(e) {
                    const t = {},
                        n = [];
                    let s = null;
                    for (let r = 0; r < e.length; r++) {
                        const i = e[r];
                        i.token === xr && (s = i.value), 1073741824 & i.flags && n.push(i.token), i.index = r, t[Lo(i.token)] = i
                    }
                    return {
                        factory: null,
                        providersByKey: t,
                        providers: e,
                        modules: n,
                        scope: s
                    }
                }

                function Ta(e, t, n = Ar.THROW_IF_NOT_FOUND) {
                    const s = an(e);
                    try {
                        if (8 & t.flags) return t.token;
                        if (2 & t.flags && (n = null), 1 & t.flags) return e._parent.get(t.token, n);
                        const r = t.tokenKey;
                        switch (r) {
                            case wa:
                            case Ea:
                            case Ca:
                                return e
                        }
                        const i = e._def.providersByKey[r];
                        let o;
                        if (i) {
                            let t = e._providers[i.index];
                            return void 0 === t && (t = e._providers[i.index] = Aa(e, i)), t === ba ? void 0 : t
                        }
                        if ((o = y(t.token)) && function(e, t) {
                                const n = t.providedIn;
                                return null != n && ("any" === n || n === e._def.scope || function(e, t) {
                                    return e._def.modules.indexOf(t) > -1
                                }(e, n))
                            }(e, o)) {
                            const n = e._providers.length;
                            return e._def.providers[n] = e._def.providersByKey[t.tokenKey] = {
                                flags: 5120,
                                value: o.factory,
                                deps: [],
                                index: n,
                                token: t.token
                            }, e._providers[n] = ba, e._providers[n] = Aa(e, e._def.providersByKey[t.tokenKey])
                        }
                        return 4 & t.flags ? n : e._parent.get(t.token, n)
                    } finally {
                        an(s)
                    }
                }

                function Aa(e, t) {
                    let n;
                    switch (201347067 & t.flags) {
                        case 512:
                            n = function(e, t, n) {
                                const s = n.length;
                                switch (s) {
                                    case 0:
                                        return new t;
                                    case 1:
                                        return new t(Ta(e, n[0]));
                                    case 2:
                                        return new t(Ta(e, n[0]), Ta(e, n[1]));
                                    case 3:
                                        return new t(Ta(e, n[0]), Ta(e, n[1]), Ta(e, n[2]));
                                    default:
                                        const r = [];
                                        for (let t = 0; t < s; t++) r[t] = Ta(e, n[t]);
                                        return new t(...r)
                                }
                            }(e, t.value, t.deps);
                            break;
                        case 1024:
                            n = function(e, t, n) {
                                const s = n.length;
                                switch (s) {
                                    case 0:
                                        return t();
                                    case 1:
                                        return t(Ta(e, n[0]));
                                    case 2:
                                        return t(Ta(e, n[0]), Ta(e, n[1]));
                                    case 3:
                                        return t(Ta(e, n[0]), Ta(e, n[1]), Ta(e, n[2]));
                                    default:
                                        const r = [];
                                        for (let t = 0; t < s; t++) r[t] = Ta(e, n[t]);
                                        return t(...r)
                                }
                            }(e, t.value, t.deps);
                            break;
                        case 2048:
                            n = Ta(e, t.deps[0]);
                            break;
                        case 256:
                            n = t.value
                    }
                    return n === ba || null === n || "object" != typeof n || 131072 & t.flags || "function" != typeof n.ngOnDestroy || (t.flags |= 131072), void 0 === n ? ba : n
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function Da(e, t, n, s) {
                    let r = t.viewContainer._embeddedViews;
                    null == n && (n = r.length), s.viewContainerParent = e, $t(r, n, s),
                        function(e, t) {
                            const n = Zo(t);
                            if (!n || n === e || 16 & t.state) return;
                            t.state |= 16;
                            let s = n.template._projectedViews;
                            s || (s = n.template._projectedViews = []);
                            s.push(t),
                                function(e, t) {
                                    if (4 & t.flags) return;
                                    e.nodeFlags |= 4, t.flags |= 4;
                                    let n = t.parent;
                                    for (; n;) n.childFlags |= 4, n = n.parent
                                }(t.parent.def, t.parentNodeDef)
                        }(t, s), Fo.dirtyParentQueries(s);
                    ka(t, n > 0 ? r[n - 1] : null, s)
                }

                function Pa(e, t) {
                    const n = e.viewContainer._embeddedViews;
                    if ((null == t || t >= n.length) && (t = n.length - 1), t < 0) return null;
                    const s = n[t];
                    return s.viewContainerParent = null, Bt(n, t), Fo.dirtyParentQueries(s), Oa(s), s
                }

                function ka(e, t, n) {
                    const s = t ? Xo(t, t.def.lastRenderRootNode) : e.renderElement,
                        r = n.renderer.parentNode(s),
                        i = n.renderer.nextSibling(s);
                    aa(n, 2, r, i, void 0)
                }

                function Oa(e) {
                    aa(e, 3, null, null, void 0)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Ia = {};

                function Na(e, t, n, s, r, i) {
                    return new Ma(e, t, n, s, r, i)
                }
                class Ma extends Fi {
                    constructor(e, t, n, s, r, i) {
                        super(), this.selector = e, this.componentType = t, this._inputs = s, this._outputs = r, this.ngContentSelectors = i, this.viewDefFactory = n
                    }
                    get inputs() {
                        const e = [],
                            t = this._inputs;
                        for (let n in t) {
                            const s = t[n];
                            e.push({
                                propName: n,
                                templateName: s
                            })
                        }
                        return e
                    }
                    get outputs() {
                        const e = [];
                        for (let t in this._outputs) {
                            const n = this._outputs[t];
                            e.push({
                                propName: t,
                                templateName: n
                            })
                        }
                        return e
                    }
                    create(e, t, n, s) {
                        if (!s) throw new Error("ngModule should be provided");
                        const r = oa(this.viewDefFactory),
                            i = r.nodes[0].element.componentProvider.nodeIndex,
                            o = Fo.createRootView(e, t || [], n, r, s, Ia),
                            a = Io(o, i).instance;
                        return n && o.renderer.setAttribute(Oo(o, 0).renderElement, "ng-version", Zi.full), new Fa(o, new Va(o), a)
                    }
                }
                class Fa extends Mi {
                    constructor(e, t, n) {
                        super(), this._view = e, this._viewRef = t, this._component = n, this._elDef = this._view.def.nodes[0], this.hostView = t, this.changeDetectorRef = t, this.instance = n
                    }
                    get location() {
                        return new qi(Oo(this._view, this._elDef.nodeIndex).renderElement)
                    }
                    get injector() {
                        return new Ua(this._view, this._elDef)
                    }
                    get componentType() {
                        return this._component.constructor
                    }
                    destroy() {
                        this._viewRef.destroy()
                    }
                    onDestroy(e) {
                        this._viewRef.onDestroy(e)
                    }
                }

                function Ra(e, t, n) {
                    return new ja(e, t, n)
                }
                class ja {
                    constructor(e, t, n) {
                        this._view = e, this._elDef = t, this._data = n, this._embeddedViews = []
                    }
                    get element() {
                        return new qi(this._data.renderElement)
                    }
                    get injector() {
                        return new Ua(this._view, this._elDef)
                    }
                    get parentInjector() {
                        let e = this._view,
                            t = this._elDef.parent;
                        for (; !t && e;) t = Jo(e), e = e.parent;
                        return e ? new Ua(e, t) : new Ua(this._view, null)
                    }
                    clear() {
                        for (let e = this._embeddedViews.length - 1; e >= 0; e--) {
                            const t = Pa(this._data, e);
                            Fo.destroyView(t)
                        }
                    }
                    get(e) {
                        const t = this._embeddedViews[e];
                        if (t) {
                            const e = new Va(t);
                            return e.attachToViewContainerRef(this), e
                        }
                        return null
                    }
                    get length() {
                        return this._embeddedViews.length
                    }
                    createEmbeddedView(e, t, n) {
                        const s = e.createEmbeddedView(t || {});
                        return this.insert(s, n), s
                    }
                    createComponent(e, t, n, s, r) {
                        const i = n || this.parentInjector;
                        r || e instanceof $i || (r = i.get(wo));
                        const o = e.create(i, s, void 0, r);
                        return this.insert(o.hostView, t), o
                    }
                    insert(e, t) {
                        if (e.destroyed) throw new Error("Cannot insert a destroyed View in a ViewContainer!");
                        const n = e,
                            s = n._view;
                        return Da(this._view, this._data, t, s), n.attachToViewContainerRef(this), e
                    }
                    move(e, t) {
                        if (e.destroyed) throw new Error("Cannot move a destroyed View in a ViewContainer!");
                        const n = this._embeddedViews.indexOf(e._view);
                        return function(e, t, n) {
                            const s = e.viewContainer._embeddedViews,
                                r = s[t];
                            Bt(s, t), null == n && (n = s.length), $t(s, n, r), Fo.dirtyParentQueries(r), Oa(r), ka(e, n > 0 ? s[n - 1] : null, r)
                        }(this._data, n, t), e
                    }
                    indexOf(e) {
                        return this._embeddedViews.indexOf(e._view)
                    }
                    remove(e) {
                        const t = Pa(this._data, e);
                        t && Fo.destroyView(t)
                    }
                    detach(e) {
                        const t = Pa(this._data, e);
                        return t ? new Va(t) : null
                    }
                }

                function La(e) {
                    return new Va(e)
                }
                class Va {
                    constructor(e) {
                        this._view = e, this._viewContainerRef = null, this._appRef = null
                    }
                    get rootNodes() {
                        return function(e) {
                            const t = [];
                            return aa(e, 0, void 0, void 0, t), t
                        }(this._view)
                    }
                    get context() {
                        return this._view.context
                    }
                    get destroyed() {
                        return 0 != (128 & this._view.state)
                    }
                    markForCheck() {
                        Go(this._view)
                    }
                    detach() {
                        this._view.state &= -5
                    }
                    detectChanges() {
                        const e = this._view.root.rendererFactory;
                        e.begin && e.begin();
                        try {
                            Fo.checkAndUpdateView(this._view)
                        } finally {
                            e.end && e.end()
                        }
                    }
                    checkNoChanges() {
                        Fo.checkNoChangesView(this._view)
                    }
                    reattach() {
                        this._view.state |= 4
                    }
                    onDestroy(e) {
                        this._view.disposables || (this._view.disposables = []), this._view.disposables.push(e)
                    }
                    destroy() {
                        this._appRef ? this._appRef.detachView(this) : this._viewContainerRef && this._viewContainerRef.detach(this._viewContainerRef.indexOf(this)), Fo.destroyView(this._view)
                    }
                    detachFromAppRef() {
                        this._appRef = null, Oa(this._view), Fo.dirtyParentQueries(this._view)
                    }
                    attachToAppRef(e) {
                        if (this._viewContainerRef) throw new Error("This view is already attached to a ViewContainer!");
                        this._appRef = e
                    }
                    attachToViewContainerRef(e) {
                        if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!");
                        this._viewContainerRef = e
                    }
                }

                function $a(e, t) {
                    return new Ba(e, t)
                }
                class Ba extends bo {
                    constructor(e, t) {
                        super(), this._parentView = e, this._def = t
                    }
                    createEmbeddedView(e) {
                        return new Va(Fo.createEmbeddedView(this._parentView, this._def, this._def.element.template, e))
                    }
                    get elementRef() {
                        return new qi(Oo(this._parentView, this._def.nodeIndex).renderElement)
                    }
                }

                function Ha(e, t) {
                    return new Ua(e, t)
                }
                class Ua {
                    constructor(e, t) {
                        this.view = e, this.elDef = t
                    }
                    get(e, t = Ar.THROW_IF_NOT_FOUND) {
                        const n = !!this.elDef && 0 != (33554432 & this.elDef.flags);
                        return Fo.resolveDep(this.view, this.elDef, n, {
                            flags: 0,
                            token: e,
                            tokenKey: Lo(e)
                        }, t)
                    }
                }

                function qa(e, t) {
                    const n = e.def.nodes[t];
                    if (1 & n.flags) {
                        const t = Oo(e, n.nodeIndex);
                        return n.element.template ? t.template : t.renderElement
                    }
                    if (2 & n.flags) return ko(e, n.nodeIndex).renderText;
                    if (20240 & n.flags) return Io(e, n.nodeIndex).instance;
                    throw new Error(`Illegal state: read nodeValue for node index ${t}`)
                }

                function za(e, t, n, s) {
                    return new Wa(e, t, n, s)
                }
                class Wa {
                    constructor(e, t, n, s) {
                        this._moduleType = e, this._parent = t, this._bootstrapComponents = n, this._def = s, this._destroyListeners = [], this._destroyed = !1, this.injector = this,
                            function(e) {
                                const t = e._def,
                                    n = e._providers = Ht(t.providers.length);
                                for (let s = 0; s < t.providers.length; s++) {
                                    const r = t.providers[s];
                                    4096 & r.flags || void 0 === n[s] && (n[s] = Aa(e, r))
                                }
                            }(this)
                    }
                    get(e, t = Ar.THROW_IF_NOT_FOUND, n = w.Default) {
                        let s = 0;
                        return n & w.SkipSelf ? s |= 1 : n & w.Self && (s |= 4), Ta(this, {
                            token: e,
                            tokenKey: Lo(e),
                            flags: s
                        }, t)
                    }
                    get instance() {
                        return this.get(this._moduleType)
                    }
                    get componentFactoryResolver() {
                        return this.get(Li)
                    }
                    destroy() {
                        if (this._destroyed) throw new Error(`The ng module ${c(this.instance.constructor)} has already been destroyed.`);
                        this._destroyed = !0,
                            function(e, t) {
                                const n = e._def,
                                    s = new Set;
                                for (let r = 0; r < n.providers.length; r++)
                                    if (131072 & n.providers[r].flags) {
                                        const t = e._providers[r];
                                        if (t && t !== ba) {
                                            const e = t.ngOnDestroy;
                                            "function" != typeof e || s.has(t) || (e.apply(t), s.add(t))
                                        }
                                    }
                            }(this), this._destroyListeners.forEach(e => e())
                    }
                    onDestroy(e) {
                        this._destroyListeners.push(e)
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Ga = Lo(Wi),
                    Ka = Lo(qi),
                    Qa = Lo(So),
                    Za = Lo(bo),
                    Ja = Lo(fo),
                    Xa = Lo(Ar),
                    Ya = Lo(Cr);

                function el(e, t, n, s, r, i, o, a) {
                    const l = [];
                    if (o)
                        for (let u in o) {
                            const [e, t] = o[u];
                            l[e] = {
                                flags: 8,
                                name: u,
                                nonMinifiedName: t,
                                ns: null,
                                securityContext: null,
                                suffix: null
                            }
                        }
                    const c = [];
                    if (a)
                        for (let u in a) c.push({
                            type: 1,
                            propName: u,
                            target: null,
                            eventName: a[u]
                        });
                    return sl(e, t |= 16384, n, s, r, r, i, l, c)
                }

                function tl(e, t, n) {
                    return sl(-1, e |= 16, null, 0, t, t, n)
                }

                function nl(e, t, n, s, r) {
                    return sl(-1, e, t, 0, n, s, r)
                }

                function sl(e, t, n, s, r, i, o, a, l) {
                    const {
                        matchedQueries: u,
                        references: h,
                        matchedQueryIds: p
                    } = na(n);
                    l || (l = []), a || (a = []), i = d(i);
                    const f = sa(o, c(r));
                    return {
                        nodeIndex: -1,
                        parent: null,
                        renderParent: null,
                        bindingIndex: -1,
                        outputIndex: -1,
                        checkIndex: e,
                        flags: t,
                        childFlags: 0,
                        directChildFlags: 0,
                        childMatchedQueries: 0,
                        matchedQueries: u,
                        matchedQueryIds: p,
                        references: h,
                        ngContentIndex: -1,
                        childCount: s,
                        bindings: a,
                        bindingFlags: fa(a),
                        outputs: l,
                        element: null,
                        provider: {
                            token: r,
                            value: i,
                            deps: f
                        },
                        text: null,
                        query: null,
                        ngContent: null
                    }
                }

                function rl(e, t) {
                    return ll(e, t)
                }

                function il(e, t) {
                    let n = e;
                    for (; n.parent && !Yo(n);) n = n.parent;
                    return cl(n.parent, Jo(n), !0, t.provider.value, t.provider.deps)
                }

                function ol(e, t) {
                    const n = (32768 & t.flags) > 0,
                        s = cl(e, t.parent, n, t.provider.value, t.provider.deps);
                    if (t.outputs.length)
                        for (let r = 0; r < t.outputs.length; r++) {
                            const n = t.outputs[r],
                                i = s[n.propName];
                            if (!Ei(i)) throw new Error(`@Output ${n.propName} not initialized in '${s.constructor.name}'.`); {
                                const s = i.subscribe(al(e, t.parent.nodeIndex, n.eventName));
                                e.disposables[t.outputIndex + r] = s.unsubscribe.bind(s)
                            }
                        }
                    return s
                }

                function al(e, t, n) {
                    return s => Qo(e, t, n, s)
                }

                function ll(e, t) {
                    const n = (8192 & t.flags) > 0,
                        s = t.provider;
                    switch (201347067 & t.flags) {
                        case 512:
                            return cl(e, t.parent, n, s.value, s.deps);
                        case 1024:
                            return function(e, t, n, s, r) {
                                const i = r.length;
                                switch (i) {
                                    case 0:
                                        return s();
                                    case 1:
                                        return s(hl(e, t, n, r[0]));
                                    case 2:
                                        return s(hl(e, t, n, r[0]), hl(e, t, n, r[1]));
                                    case 3:
                                        return s(hl(e, t, n, r[0]), hl(e, t, n, r[1]), hl(e, t, n, r[2]));
                                    default:
                                        const o = [];
                                        for (let s = 0; s < i; s++) o.push(hl(e, t, n, r[s]));
                                        return s(...o)
                                }
                            }(e, t.parent, n, s.value, s.deps);
                        case 2048:
                            return hl(e, t.parent, n, s.deps[0]);
                        case 256:
                            return s.value
                    }
                }

                function cl(e, t, n, s, r) {
                    const i = r.length;
                    switch (i) {
                        case 0:
                            return new s;
                        case 1:
                            return new s(hl(e, t, n, r[0]));
                        case 2:
                            return new s(hl(e, t, n, r[0]), hl(e, t, n, r[1]));
                        case 3:
                            return new s(hl(e, t, n, r[0]), hl(e, t, n, r[1]), hl(e, t, n, r[2]));
                        default:
                            const o = [];
                            for (let s = 0; s < i; s++) o.push(hl(e, t, n, r[s]));
                            return new s(...o)
                    }
                }
                const ul = {};

                function hl(e, t, n, s, r = Ar.THROW_IF_NOT_FOUND) {
                    if (8 & s.flags) return s.token;
                    const i = e;
                    2 & s.flags && (r = null);
                    const o = s.tokenKey;
                    o === Ja && (n = !(!t || !t.element.componentView)), t && 1 & s.flags && (n = !1, t = t.parent);
                    let a = e;
                    for (; a;) {
                        if (t) switch (o) {
                            case Ga:
                                return pl(a, t, n).renderer;
                            case Ka:
                                return new qi(Oo(a, t.nodeIndex).renderElement);
                            case Qa:
                                return Oo(a, t.nodeIndex).viewContainer;
                            case Za:
                                if (t.element.template) return Oo(a, t.nodeIndex).template;
                                break;
                            case Ja:
                                return La(pl(a, t, n));
                            case Xa:
                            case Ya:
                                return Ha(a, t);
                            default:
                                const e = (n ? t.element.allProviders : t.element.publicProviders)[o];
                                if (e) {
                                    let t = Io(a, e.nodeIndex);
                                    return t || (t = {
                                        instance: ll(a, e)
                                    }, a.nodes[e.nodeIndex] = t), t.instance
                                }
                        }
                        n = Yo(a), t = Jo(a), a = a.parent, 4 & s.flags && (a = null)
                    }
                    const l = i.root.injector.get(s.token, ul);
                    return l !== ul || r === ul ? l : i.root.ngModule.injector.get(s.token, r)
                }

                function pl(e, t, n) {
                    let s;
                    if (n) s = Oo(e, t.nodeIndex).componentView;
                    else
                        for (s = e; s.parent && !Yo(s);) s = s.parent;
                    return s
                }

                function dl(e, t, n, s, r, i) {
                    if (32768 & n.flags) {
                        const t = Oo(e, n.parent.nodeIndex).componentView;
                        2 & t.def.flags && (t.state |= 8)
                    }
                    const o = n.bindings[s].name;
                    if (t.instance[o] = r, 524288 & n.flags) {
                        i = i || {};
                        const t = zr.unwrap(e.oldValues[n.bindingIndex + s]);
                        i[n.bindings[s].nonMinifiedName] = new J(t, r, 0 != (2 & e.state))
                    }
                    return e.oldValues[n.bindingIndex + s] = r, i
                }

                function fl(e, t) {
                    if (!(e.def.nodeFlags & t)) return;
                    const n = e.def.nodes;
                    let s = 0;
                    for (let r = 0; r < n.length; r++) {
                        const i = n[r];
                        let o = i.parent;
                        for (!o && i.flags & t && gl(e, r, i.flags & t, s++), 0 == (i.childFlags & t) && (r += i.childCount); o && 1 & o.flags && r === o.nodeIndex + o.childCount;) o.directChildFlags & t && (s = ml(e, o, t, s)), o = o.parent
                    }
                }

                function ml(e, t, n, s) {
                    for (let r = t.nodeIndex + 1; r <= t.nodeIndex + t.childCount; r++) {
                        const t = e.def.nodes[r];
                        t.flags & n && gl(e, r, t.flags & n, s++), r += t.childCount
                    }
                    return s
                }

                function gl(e, t, n, s) {
                    const r = Io(e, t);
                    if (!r) return;
                    const i = r.instance;
                    i && (Fo.setCurrentNode(e, t), 1048576 & n && Po(e, 512, s) && i.ngAfterContentInit(), 2097152 & n && i.ngAfterContentChecked(), 4194304 & n && Po(e, 768, s) && i.ngAfterViewInit(), 8388608 & n && i.ngAfterViewChecked(), 131072 & n && i.ngOnDestroy())
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class yl extends Li {
                    constructor(e) {
                        super(), this.ngModule = e
                    }
                    resolveComponentFactory(e) {
                        const t = j(e);
                        return new bl(t, this.ngModule)
                    }
                }

                function vl(e) {
                    const t = [];
                    for (let n in e)
                        if (e.hasOwnProperty(n)) {
                            const s = e[n];
                            t.push({
                                propName: s,
                                templateName: n
                            })
                        }
                    return t
                }
                const _l = new kt("SCHEDULER_TOKEN", {
                    providedIn: "root",
                    factory: () => ys
                });
                class bl extends Fi {
                    constructor(e, t) {
                        super(), this.componentDef = e, this.ngModule = t, this.componentType = e.type, this.selector = e.selectors.map(Bs).join(","), this.ngContentSelectors = e.ngContentSelectors ? e.ngContentSelectors : [], this.isBoundToModule = !!t
                    }
                    get inputs() {
                        return vl(this.componentDef.inputs)
                    }
                    get outputs() {
                        return vl(this.componentDef.outputs)
                    }
                    create(e, t, n, s) {
                        const r = (s = s || this.ngModule) ? function(e, t) {
                                return {
                                    get: (n, s, r) => {
                                        const i = e.get(n, ul, r);
                                        return i !== ul || s === ul ? i : t.get(n, s, r)
                                    }
                                }
                            }(e, s.injector) : e,
                            i = r.get(zi, ue),
                            o = r.get(Ki, null),
                            a = i.createRenderer(null, this.componentDef),
                            l = this.componentDef.selectors[0][0] || "div",
                            c = n ? nr(a, n, this.componentDef.encapsulation) : Ts(i.createRenderer(null, this.componentDef), l, function(e) {
                                const t = e.toLowerCase();
                                return "svg" === t ? se : "math" === t ? re : null
                            }(l)),
                            u = this.componentDef.onPush ? 576 : 528,
                            h = $r(),
                            p = tr(0, null, null, 1, 0, null, null, null, null, null),
                            d = Ws(null, p, h, u, null, null, i, a, o, r);
                        let f, m;
                        Re(d);
                        try {
                            const e = Lr(c, this.componentDef, d, i, a);
                            if (c)
                                if (n) Xe(a, c, ["ng-version", Zi.full]);
                                else {
                                    const {
                                        attrs: e,
                                        classes: t
                                    } = function(e) {
                                        const t = [],
                                            n = [];
                                        let s = 1,
                                            r = 2;
                                        for (; s < e.length;) {
                                            let i = e[s];
                                            if ("string" == typeof i) 2 === r ? "" !== i && t.push(i, e[++s]) : 8 === r && n.push(i);
                                            else {
                                                if (!Vs(r)) break;
                                                r = i
                                            }
                                            s++
                                        }
                                        return {
                                            attrs: t,
                                            classes: n
                                        }
                                    }(this.componentDef.selectors[0]);
                                    e && Xe(a, c, e), t && t.length > 0 && Ls(a, c, t.join(" "))
                                }
                            if (m = de(p, L), void 0 !== t) {
                                const e = m.projection = [];
                                for (let n = 0; n < this.ngContentSelectors.length; n++) {
                                    const s = t[n];
                                    e.push(null != s ? Array.from(s) : null)
                                }
                            }
                            f = Vr(e, this.componentDef, d, h, [Br]), Zs(p, d, null)
                        } finally {
                            Be()
                        }
                        return new wl(this.componentType, f, Hi(m, d), d, m)
                    }
                }
                new yl;
                class wl extends Mi {
                    constructor(e, t, n, s, r) {
                        super(), this.location = n, this._rootLView = s, this._tNode = r, this.instance = t, this.hostView = this.changeDetectorRef = new ho(s), this.componentType = e
                    }
                    get injector() {
                        return new wt(this._tNode, this._rootLView)
                    }
                    destroy() {
                        this.hostView.destroy()
                    }
                    onDestroy(e) {
                        this.hostView.onDestroy(e)
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const El = new Map;

                function Cl(e, t) {
                    const n = El.get(e);
                    Sl(e, n && n.moduleType, t.moduleType), El.set(e, t)
                }

                function Sl(e, t, n) {
                    if (t && t !== n) throw new Error(`Duplicate module registered for ${e} - ${c(t)} vs ${c(t.name)}`)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class xl extends s.a {
                    constructor(e = !1) {
                        super(), this.__isAsync = e
                    }
                    emit(e) {
                        super.next(e)
                    }
                    subscribe(e, t, n) {
                        let s, i = e => null,
                            o = () => null;
                        e && "object" == typeof e ? (s = this.__isAsync ? t => {
                            setTimeout(() => e.next(t))
                        } : t => {
                            e.next(t)
                        }, e.error && (i = this.__isAsync ? t => {
                            setTimeout(() => e.error(t))
                        } : t => {
                            e.error(t)
                        }), e.complete && (o = this.__isAsync ? () => {
                            setTimeout(() => e.complete())
                        } : () => {
                            e.complete()
                        })) : (s = this.__isAsync ? t => {
                            setTimeout(() => e(t))
                        } : t => {
                            e(t)
                        }, t && (i = this.__isAsync ? e => {
                            setTimeout(() => t(e))
                        } : e => {
                            t(e)
                        }), n && (o = this.__isAsync ? () => {
                            setTimeout(() => n())
                        } : () => {
                            n()
                        }));
                        const a = super.subscribe(s, i, o);
                        return e instanceof r.a && e.add(a), a
                    }
                }
                const Tl = xl;
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function Al() {
                    return this._results[Ur()]()
                }
                class Dl {
                    constructor() {
                        this.dirty = !0, this._results = [], this.changes = new Tl, this.length = 0;
                        const e = Ur(),
                            t = Dl.prototype;
                        t[e] || (t[e] = Al)
                    }
                    map(e) {
                        return this._results.map(e)
                    }
                    filter(e) {
                        return this._results.filter(e)
                    }
                    find(e) {
                        return this._results.find(e)
                    }
                    reduce(e, t) {
                        return this._results.reduce(e, t)
                    }
                    forEach(e) {
                        this._results.forEach(e)
                    }
                    some(e) {
                        return this._results.some(e)
                    }
                    toArray() {
                        return this._results.slice()
                    }
                    toString() {
                        return this._results.toString()
                    }
                    reset(e) {
                        this._results = Vt(e), this.dirty = !1, this.length = this._results.length, this.last = this._results[this.length - 1], this.first = this._results[0]
                    }
                    notifyOnChanges() {
                        this.changes.emit(this)
                    }
                    setDirty() {
                        this.dirty = !0
                    }
                    destroy() {
                        this.changes.complete(), this.changes.unsubscribe()
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                new Map, new Map;
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Pl = xt("Directive", (e = {}) => e, void 0, void 0, (e, t) => Rl(e, t)),
                    kl = xt("Component", (e = {}) => Object.assign({
                        changeDetection: T.Default
                    }, e), Pl, void 0, (e, t) => Fl(e, t)),
                    Ol = xt("Pipe", e => Object.assign({
                        pure: !0
                    }, e), void 0, void 0, (e, t) => jl(e, t)),
                    Il = Dt("Input", e => ({
                        bindingPropertyName: e
                    })),
                    Nl = Dt("Output", e => ({
                        bindingPropertyName: e
                    })),
                    Ml = (Dt("HostBinding", e => ({
                        hostPropertyName: e
                    })), Dt("HostListener", (e, t) => ({
                        eventName: e,
                        args: t
                    }))),
                    Fl = Bi,
                    Rl = Bi,
                    jl = Bi,
                    Ll = xt("NgModule", e => e, void 0, void 0, (e, t) => Vl(e, t));
                const Vl = function(e, t) {
                        let n = t && t.imports || [];
                        t && t.exports && (n = [...n, t.exports]), e.\u0275inj = g({
                            factory: Zr(e, {
                                useClass: e
                            }),
                            providers: t && t.providers,
                            imports: n
                        })
                    },
                    $l = new kt("Application Initializer");
                class Bl {
                    constructor(e) {
                        this.appInits = e, this.resolve = Bi, this.reject = Bi, this.initialized = !1, this.done = !1, this.donePromise = new Promise((e, t) => {
                            this.resolve = e, this.reject = t
                        })
                    }
                    runInitializers() {
                        if (this.initialized) return;
                        const e = [],
                            t = () => {
                                this.done = !0, this.resolve()
                            };
                        if (this.appInits)
                            for (let n = 0; n < this.appInits.length; n++) {
                                const t = this.appInits[n]();
                                wi(t) && e.push(t)
                            }
                        Promise.all(e).then(() => {
                            t()
                        }).catch(e => {
                            this.reject(e)
                        }), 0 === e.length && t(), this.initialized = !0
                    }
                }
                Bl.decorators = [{
                    type: Jr
                }], Bl.ctorParameters = () => [{
                    type: Array,
                    decorators: [{
                        type: Zt,
                        args: [$l]
                    }, {
                        type: Jt
                    }]
                }]
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                ;
                const Hl = new kt("AppId");
                const Ul = {
                    provide: Hl,
                    useFactory: function() {
                        return `${ql()}${ql()}${ql()}`
                    },
                    deps: []
                };

                function ql() {
                    return String.fromCharCode(97 + Math.floor(25 * Math.random()))
                }
                const zl = new kt("Platform Initializer"),
                    Wl = new kt("Platform ID"),
                    Gl = new kt("appBootstrapListener"),
                    Kl = new kt("Application Packages Root URL");
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Ql {
                    log(e) {
                        console.log(e)
                    }
                    warn(e) {
                        console.warn(e)
                    }
                }
                Ql.decorators = [{
                    type: Jr
                }];
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Zl = new kt("LocaleId"),
                    Jl = new kt("DefaultCurrencyCode"),
                    Xl = new kt("Translations"),
                    Yl = new kt("TranslationsFormat");
                var ec;
                ! function(e) {
                    e[e.Error = 0] = "Error", e[e.Warning = 1] = "Warning", e[e.Ignore = 2] = "Ignore"
                }(ec || (ec = {}));

                function tc() {
                    throw new Error("Runtime compiler is not loaded")
                }
                const nc = tc,
                    sc = tc,
                    rc = tc,
                    ic = tc;
                class oc {
                    constructor() {
                        this.compileModuleSync = nc, this.compileModuleAsync = sc, this.compileModuleAndAllComponentsSync = rc, this.compileModuleAndAllComponentsAsync = ic
                    }
                    clearCache() {}
                    clearCacheFor(e) {}
                    getModuleId(e) {}
                }
                oc.decorators = [{
                    type: Jr
                }];
                const ac = new kt("compilerOptions");
                class lc {}
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const cc = Promise.resolve(0);

                function uc(e) {
                    "undefined" == typeof Zone ? cc.then(() => {
                        e && e.apply(null, null)
                    }) : Zone.current.scheduleMicroTask("scheduleMicrotask", e)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class hc {
                    constructor({
                        enableLongStackTrace: e = !1,
                        shouldCoalesceEventChangeDetection: t = !1
                    }) {
                        if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new Tl(!1), this.onMicrotaskEmpty = new Tl(!1), this.onStable = new Tl(!1), this.onError = new Tl(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js");
                        Zone.assertZonePatched();
                        const n = this;
                        n._nesting = 0, n._outer = n._inner = Zone.current, Zone.TaskTrackingZoneSpec && (n._inner = n._inner.fork(new Zone.TaskTrackingZoneSpec)), e && Zone.longStackTraceZoneSpec && (n._inner = n._inner.fork(Zone.longStackTraceZoneSpec)), n.shouldCoalesceEventChangeDetection = t, n.lastRequestAnimationFrameId = -1, n.nativeRequestAnimationFrame = function() {
                                let e = I.requestAnimationFrame,
                                    t = I.cancelAnimationFrame;
                                if ("undefined" != typeof Zone && e && t) {
                                    const n = e[Zone.__symbol__("OriginalDelegate")];
                                    n && (e = n);
                                    const s = t[Zone.__symbol__("OriginalDelegate")];
                                    s && (t = s)
                                }
                                return {
                                    nativeRequestAnimationFrame: e,
                                    nativeCancelAnimationFrame: t
                                }
                            }().nativeRequestAnimationFrame,
                            function(e) {
                                const t = () => {
                                        ! function(e) {
                                            if (-1 !== e.lastRequestAnimationFrameId) return;
                                            e.lastRequestAnimationFrameId = e.nativeRequestAnimationFrame.call(I, () => {
                                                e.fakeTopEventTask || (e.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => {
                                                    e.lastRequestAnimationFrameId = -1, fc(e), dc(e)
                                                }, void 0, () => {}, () => {})), e.fakeTopEventTask.invoke()
                                            }), fc(e)
                                        }(e)
                                    },
                                    n = !!e.shouldCoalesceEventChangeDetection && e.nativeRequestAnimationFrame && t;
                                e._inner = e._inner.fork({
                                    name: "angular",
                                    properties: {
                                        isAngularZone: !0,
                                        maybeDelayChangeDetection: n
                                    },
                                    onInvokeTask: (t, s, r, i, o, a) => {
                                        try {
                                            return mc(e), t.invokeTask(r, i, o, a)
                                        } finally {
                                            n && "eventTask" === i.type && n(), gc(e)
                                        }
                                    },
                                    onInvoke: (t, n, s, r, i, o, a) => {
                                        try {
                                            return mc(e), t.invoke(s, r, i, o, a)
                                        } finally {
                                            gc(e)
                                        }
                                    },
                                    onHasTask: (t, n, s, r) => {
                                        t.hasTask(s, r), n === s && ("microTask" == r.change ? (e._hasPendingMicrotasks = r.microTask, fc(e), dc(e)) : "macroTask" == r.change && (e.hasPendingMacrotasks = r.macroTask))
                                    },
                                    onHandleError: (t, n, s, r) => (t.handleError(s, r), e.runOutsideAngular(() => e.onError.emit(r)), !1)
                                })
                            }(n)
                    }
                    static isInAngularZone() {
                        return !0 === Zone.current.get("isAngularZone")
                    }
                    static assertInAngularZone() {
                        if (!hc.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!")
                    }
                    static assertNotInAngularZone() {
                        if (hc.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!")
                    }
                    run(e, t, n) {
                        return this._inner.run(e, t, n)
                    }
                    runTask(e, t, n, s) {
                        const r = this._inner,
                            i = r.scheduleEventTask("NgZoneEvent: " + s, e, pc, Bi, Bi);
                        try {
                            return r.runTask(i, t, n)
                        } finally {
                            r.cancelTask(i)
                        }
                    }
                    runGuarded(e, t, n) {
                        return this._inner.runGuarded(e, t, n)
                    }
                    runOutsideAngular(e) {
                        return this._outer.run(e)
                    }
                }
                const pc = {};

                function dc(e) {
                    if (0 == e._nesting && !e.hasPendingMicrotasks && !e.isStable) try {
                        e._nesting++, e.onMicrotaskEmpty.emit(null)
                    } finally {
                        if (e._nesting--, !e.hasPendingMicrotasks) try {
                            e.runOutsideAngular(() => e.onStable.emit(null))
                        } finally {
                            e.isStable = !0
                        }
                    }
                }

                function fc(e) {
                    e._hasPendingMicrotasks || e.shouldCoalesceEventChangeDetection && -1 !== e.lastRequestAnimationFrameId ? e.hasPendingMicrotasks = !0 : e.hasPendingMicrotasks = !1
                }

                function mc(e) {
                    e._nesting++, e.isStable && (e.isStable = !1, e.onUnstable.emit(null))
                }

                function gc(e) {
                    e._nesting--, dc(e)
                }
                class yc {
                    constructor() {
                        this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new Tl, this.onMicrotaskEmpty = new Tl, this.onStable = new Tl, this.onError = new Tl
                    }
                    run(e, t, n) {
                        return e.apply(t, n)
                    }
                    runGuarded(e, t, n) {
                        return e.apply(t, n)
                    }
                    runOutsideAngular(e) {
                        return e()
                    }
                    runTask(e, t, n, s) {
                        return e.apply(t, n)
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class vc {
                    constructor(e) {
                        this._ngZone = e, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), e.run(() => {
                            this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone")
                        })
                    }
                    _watchAngularEvents() {
                        this._ngZone.onUnstable.subscribe({
                            next: () => {
                                this._didWork = !0, this._isZoneStable = !1
                            }
                        }), this._ngZone.runOutsideAngular(() => {
                            this._ngZone.onStable.subscribe({
                                next: () => {
                                    hc.assertNotInAngularZone(), uc(() => {
                                        this._isZoneStable = !0, this._runCallbacksIfReady()
                                    })
                                }
                            })
                        })
                    }
                    increasePendingRequestCount() {
                        return this._pendingCount += 1, this._didWork = !0, this._pendingCount
                    }
                    decreasePendingRequestCount() {
                        if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero");
                        return this._runCallbacksIfReady(), this._pendingCount
                    }
                    isStable() {
                        return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks
                    }
                    _runCallbacksIfReady() {
                        if (this.isStable()) uc(() => {
                            for (; 0 !== this._callbacks.length;) {
                                let e = this._callbacks.pop();
                                clearTimeout(e.timeoutId), e.doneCb(this._didWork)
                            }
                            this._didWork = !1
                        });
                        else {
                            let e = this.getPendingTasks();
                            this._callbacks = this._callbacks.filter(t => !t.updateCb || !t.updateCb(e) || (clearTimeout(t.timeoutId), !1)), this._didWork = !0
                        }
                    }
                    getPendingTasks() {
                        return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(e => ({
                            source: e.source,
                            creationLocation: e.creationLocation,
                            data: e.data
                        })) : []
                    }
                    addCallback(e, t, n) {
                        let s = -1;
                        t && t > 0 && (s = setTimeout(() => {
                            this._callbacks = this._callbacks.filter(e => e.timeoutId !== s), e(this._didWork, this.getPendingTasks())
                        }, t)), this._callbacks.push({
                            doneCb: e,
                            timeoutId: s,
                            updateCb: n
                        })
                    }
                    whenStable(e, t, n) {
                        if (n && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?');
                        this.addCallback(e, t, n), this._runCallbacksIfReady()
                    }
                    getPendingRequestCount() {
                        return this._pendingCount
                    }
                    findProviders(e, t, n) {
                        return []
                    }
                }
                vc.decorators = [{
                    type: Jr
                }], vc.ctorParameters = () => [{
                    type: hc
                }];
                class _c {
                    constructor() {
                        this._applications = new Map, Ec.addToWindow(this)
                    }
                    registerApplication(e, t) {
                        this._applications.set(e, t)
                    }
                    unregisterApplication(e) {
                        this._applications.delete(e)
                    }
                    unregisterAllApplications() {
                        this._applications.clear()
                    }
                    getTestability(e) {
                        return this._applications.get(e) || null
                    }
                    getAllTestabilities() {
                        return Array.from(this._applications.values())
                    }
                    getAllRootElements() {
                        return Array.from(this._applications.keys())
                    }
                    findTestabilityInTree(e, t = !0) {
                        return Ec.findTestabilityInTree(this, e, t)
                    }
                }
                _c.decorators = [{
                    type: Jr
                }], _c.ctorParameters = () => [];

                function bc(e) {
                    Ec = e
                }
                let wc, Ec = new class {
                        addToWindow(e) {}
                        findTestabilityInTree(e, t, n) {
                            return null
                        }
                    },
                    Cc = !0,
                    Sc = !1;
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function xc() {
                    return Sc = !0, Cc
                }

                function Tc() {
                    if (Sc) throw new Error("Cannot enable prod mode after platform setup.");
                    Cc = !1
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                let Ac = function(e, t, n) {
                    const s = e.get(lc);
                    return s.createCompiler([t]).compileModuleAsync(n)
                };
                let Dc = function() {},
                    Pc = function(e) {
                        return e instanceof $i
                    };
                const kc = new kt("AllowMultipleToken");
                class Oc {
                    constructor(e, t) {
                        this.name = e, this.token = t
                    }
                }

                function Ic(e, t, n = []) {
                    const s = `Platform: ${t}`,
                        r = new kt(s);
                    return (t = []) => {
                        let i = Nc();
                        if (!i || i.injector.get(kc, !1))
                            if (e) e(n.concat(t).concat({
                                provide: r,
                                useValue: !0
                            }));
                            else {
                                const e = n.concat(t).concat({
                                    provide: r,
                                    useValue: !0
                                }, {
                                    provide: xr,
                                    useValue: "platform"
                                });
                                ! function(e) {
                                    if (wc && !wc.destroyed && !wc.injector.get(kc, !1)) throw new Error("There can be only one platform. Destroy the previous one to create a new one.");
                                    Dc(), wc = e.get(Mc);
                                    const t = e.get(zl, null);
                                    t && t.forEach(e => e())
                                }(Ar.create({
                                    providers: e,
                                    name: s
                                }))
                            }
                        return function(e) {
                            const t = Nc();
                            if (!t) throw new Error("No platform exists!");
                            if (!t.injector.get(e, null)) throw new Error("A platform with a different configuration has been created. Please destroy it first.");
                            return t
                        }(r)
                    }
                }

                function Nc() {
                    return wc && !wc.destroyed ? wc : null
                }
                class Mc {
                    constructor(e) {
                        this._injector = e, this._modules = [], this._destroyListeners = [], this._destroyed = !1
                    }
                    bootstrapModuleFactory(e, t) {
                        const n = function(e, t) {
                                let n;
                                n = "noop" === e ? new yc : ("zone.js" === e ? void 0 : e) || new hc({
                                    enableLongStackTrace: xc(),
                                    shouldCoalesceEventChangeDetection: t
                                });
                                return n
                            }(t ? t.ngZone : void 0, t && t.ngZoneEventCoalescing || !1),
                            s = [{
                                provide: hc,
                                useValue: n
                            }];
                        return n.run(() => {
                            const t = Ar.create({
                                    providers: s,
                                    parent: this.injector,
                                    name: e.moduleType.name
                                }),
                                r = e.create(t),
                                i = r.injector.get(cs, null);
                            if (!i) throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");
                            return n.runOutsideAngular(() => {
                                    const e = n.onError.subscribe({
                                        next: e => {
                                            i.handleError(e)
                                        }
                                    });
                                    r.onDestroy(() => {
                                        jc(this._modules, r), e.unsubscribe()
                                    })
                                }),
                                function(e, t, n) {
                                    try {
                                        const s = n();
                                        return wi(s) ? s.catch(n => {
                                            throw t.runOutsideAngular(() => e.handleError(n)), n
                                        }) : s
                                    } catch (s) {
                                        throw t.runOutsideAngular(() => e.handleError(s)), s
                                    }
                                }(i, n, () => {
                                    const e = r.injector.get(Bl);
                                    return e.runInitializers(), e.donePromise.then(() => (this._moduleDoBootstrap(r), r))
                                })
                        })
                    }
                    bootstrapModule(e, t = []) {
                        const n = Fc({}, t);
                        return Ac(this.injector, n, e).then(e => this.bootstrapModuleFactory(e, n))
                    }
                    _moduleDoBootstrap(e) {
                        const t = e.injector.get(Rc);
                        if (e._bootstrapComponents.length > 0) e._bootstrapComponents.forEach(e => t.bootstrap(e));
                        else {
                            if (!e.instance.ngDoBootstrap) throw new Error(`The module ${c(e.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);
                            e.instance.ngDoBootstrap(t)
                        }
                        this._modules.push(e)
                    }
                    onDestroy(e) {
                        this._destroyListeners.push(e)
                    }
                    get injector() {
                        return this._injector
                    }
                    destroy() {
                        if (this._destroyed) throw new Error("The platform has already been destroyed!");
                        this._modules.slice().forEach(e => e.destroy()), this._destroyListeners.forEach(e => e()), this._destroyed = !0
                    }
                    get destroyed() {
                        return this._destroyed
                    }
                }

                function Fc(e, t) {
                    return e = Array.isArray(t) ? t.reduce(Fc, e) : Object.assign(Object.assign({}, e), t)
                }
                Mc.decorators = [{
                    type: Jr
                }], Mc.ctorParameters = () => [{
                    type: Ar
                }];
                class Rc {
                    constructor(e, t, n, s, r, l) {
                        this._zone = e, this._console = t, this._injector = n, this._exceptionHandler = s, this._componentFactoryResolver = r, this._initStatus = l, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({
                            next: () => {
                                this._zone.run(() => {
                                    this.tick()
                                })
                            }
                        });
                        const c = new i.a(e => {
                                this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => {
                                    e.next(this._stable), e.complete()
                                })
                            }),
                            u = new i.a(e => {
                                let t;
                                this._zone.runOutsideAngular(() => {
                                    t = this._zone.onStable.subscribe(() => {
                                        hc.assertNotInAngularZone(), uc(() => {
                                            this._stable || this._zone.hasPendingMacrotasks || this._zone.hasPendingMicrotasks || (this._stable = !0, e.next(!0))
                                        })
                                    })
                                });
                                const n = this._zone.onUnstable.subscribe(() => {
                                    hc.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => {
                                        e.next(!1)
                                    }))
                                });
                                return () => {
                                    t.unsubscribe(), n.unsubscribe()
                                }
                            });
                        this.isStable = Object(o.a)(c, u.pipe(Object(a.a)()))
                    }
                    bootstrap(e, t) {
                        if (!this._initStatus.done) throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");
                        let n;
                        n = e instanceof Fi ? e : this._componentFactoryResolver.resolveComponentFactory(e), this.componentTypes.push(n.componentType);
                        const s = Pc(n) ? void 0 : this._injector.get(wo),
                            r = t || n.selector,
                            i = n.create(Ar.NULL, [], r, s),
                            o = i.location.nativeElement,
                            a = i.injector.get(vc, null),
                            l = a && i.injector.get(_c);
                        return a && l && l.registerApplication(o, a), i.onDestroy(() => {
                            this.detachView(i.hostView), jc(this.components, i), l && l.unregisterApplication(o)
                        }), this._loadComponent(i), xc() && this._console.log("Angular is running in development mode. Call enableProdMode() to enable production mode."), i
                    }
                    tick() {
                        if (this._runningTick) throw new Error("ApplicationRef.tick is called recursively");
                        try {
                            this._runningTick = !0;
                            for (let e of this._views) e.detectChanges();
                            0
                        } catch (e) {
                            this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(e))
                        } finally {
                            this._runningTick = !1
                        }
                    }
                    attachView(e) {
                        const t = e;
                        this._views.push(t), t.attachToAppRef(this)
                    }
                    detachView(e) {
                        const t = e;
                        jc(this._views, t), t.detachFromAppRef()
                    }
                    _loadComponent(e) {
                        this.attachView(e.hostView), this.tick(), this.components.push(e);
                        this._injector.get(Gl, []).concat(this._bootstrapListeners).forEach(t => t(e))
                    }
                    ngOnDestroy() {
                        this._views.slice().forEach(e => e.destroy()), this._onMicrotaskEmptySubscription.unsubscribe()
                    }
                    get viewCount() {
                        return this._views.length
                    }
                }

                function jc(e, t) {
                    const n = e.indexOf(t);
                    n > -1 && e.splice(n, 1)
                }
                Rc.decorators = [{
                    type: Jr
                }], Rc.ctorParameters = () => [{
                    type: hc
                }, {
                    type: Ql
                }, {
                    type: Ar
                }, {
                    type: cs
                }, {
                    type: Li
                }, {
                    type: Bl
                }];
                class Lc {}
                const Vc = {
                    factoryPathPrefix: "",
                    factoryPathSuffix: ".ngfactory"
                };
                class $c {
                    constructor(e, t) {
                        this._compiler = e, this._config = t || Vc
                    }
                    load(e) {
                        return this._compiler instanceof oc ? this.loadFactory(e) : this.loadAndCompile(e)
                    }
                    loadAndCompile(e) {
                        let [t, s] = e.split("#");
                        return void 0 === s && (s = "default"), n("zn8P")(t).then(e => e[s]).then(e => Bc(e, t, s)).then(e => this._compiler.compileModuleAsync(e))
                    }
                    loadFactory(e) {
                        let [t, s] = e.split("#"), r = "NgFactory";
                        return void 0 === s && (s = "default", r = ""), n("zn8P")(this._config.factoryPathPrefix + t + this._config.factoryPathSuffix).then(e => e[s + r]).then(e => Bc(e, t, s))
                    }
                }

                function Bc(e, t, n) {
                    if (!e) throw new Error(`Cannot find '${n}' in '${t}'`);
                    return e
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                $c.decorators = [{
                    type: Jr
                }], $c.ctorParameters = () => [{
                    type: oc
                }, {
                    type: Lc,
                    decorators: [{
                        type: Jt
                    }]
                }];
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Hc {
                    constructor(e, t) {
                        this.name = e, this.callback = t
                    }
                }
                class Uc {
                    constructor(e, t, n) {
                        this.listeners = [], this.parent = null, this._debugContext = n, this.nativeNode = e, t && t instanceof qc && t.addChild(this)
                    }
                    get injector() {
                        return this._debugContext.injector
                    }
                    get componentInstance() {
                        return this._debugContext.component
                    }
                    get context() {
                        return this._debugContext.context
                    }
                    get references() {
                        return this._debugContext.references
                    }
                    get providerTokens() {
                        return this._debugContext.providerTokens
                    }
                }
                class qc extends Uc {
                    constructor(e, t, n) {
                        super(e, t, n), this.properties = {}, this.attributes = {}, this.classes = {}, this.styles = {}, this.childNodes = [], this.nativeElement = e
                    }
                    addChild(e) {
                        e && (this.childNodes.push(e), e.parent = this)
                    }
                    removeChild(e) {
                        const t = this.childNodes.indexOf(e); - 1 !== t && (e.parent = null, this.childNodes.splice(t, 1))
                    }
                    insertChildrenAfter(e, t) {
                        const n = this.childNodes.indexOf(e); - 1 !== n && (this.childNodes.splice(n + 1, 0, ...t), t.forEach(t => {
                            t.parent && t.parent.removeChild(t), e.parent = this
                        }))
                    }
                    insertBefore(e, t) {
                        const n = this.childNodes.indexOf(e); - 1 === n ? this.addChild(t) : (t.parent && t.parent.removeChild(t), t.parent = this, this.childNodes.splice(n, 0, t))
                    }
                    query(e) {
                        return this.queryAll(e)[0] || null
                    }
                    queryAll(e) {
                        const t = [];
                        return zc(this, e, t), t
                    }
                    queryAllNodes(e) {
                        const t = [];
                        return Wc(this, e, t), t
                    }
                    get children() {
                        return this.childNodes.filter(e => e instanceof qc)
                    }
                    triggerEventHandler(e, t) {
                        this.listeners.forEach(n => {
                            n.name == e && n.callback(t)
                        })
                    }
                }

                function zc(e, t, n) {
                    e.childNodes.forEach(e => {
                        e instanceof qc && (t(e) && n.push(e), zc(e, t, n))
                    })
                }

                function Wc(e, t, n) {
                    e instanceof qc && e.childNodes.forEach(e => {
                        t(e) && n.push(e), e instanceof qc && Wc(e, t, n)
                    })
                }
                const Gc = new Map;

                function Kc(e) {
                    return Gc.get(e) || null
                }
                const Qc = Kc;
                const Zc = function(e) {
                    return Kc(e)
                };

                function Jc(e) {
                    Gc.set(e.nativeNode, e)
                }
                const Xc = Ic(null, "core", [{
                    provide: Wl,
                    useValue: "unknown"
                }, {
                    provide: Mc,
                    deps: [Ar]
                }, {
                    provide: _c,
                    deps: []
                }, {
                    provide: Ql,
                    deps: []
                }]);
                const Yc = [{
                    provide: Rc,
                    useClass: Rc,
                    deps: [hc, Ql, Ar, cs, Li, Bl]
                }, {
                    provide: _l,
                    deps: [hc],
                    useFactory: function(e) {
                        let t = [];
                        return e.onStable.subscribe(() => {
                                for (; t.length;) t.pop()()
                            }),
                            function(e) {
                                t.push(e)
                            }
                    }
                }, {
                    provide: Bl,
                    useClass: Bl,
                    deps: [
                        [new Jt, $l]
                    ]
                }, {
                    provide: oc,
                    useClass: oc,
                    deps: []
                }, Ul, {
                    provide: ao,
                    useFactory:
                        /**
                         * @license
                         * Copyright Google LLC All Rights Reserved.
                         *
                         * Use of this source code is governed by an MIT-style license that can be
                         * found in the LICENSE file at https://angular.io/license
                         */
                        function() {
                            return yo
                        },
                    deps: []
                }, {
                    provide: lo,
                    useFactory: function() {
                        return vo
                    },
                    deps: []
                }, {
                    provide: Zl,
                    useFactory: function(e) {
                        return e = e || Ii
                    },
                    deps: [
                        [new Zt(Zl), new Jt, new Yt]
                    ]
                }, {
                    provide: Jl,
                    useValue: "USD"
                }];
                class eu {
                    constructor(e) {}
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function tu(e, t, n, s, r, i) {
                    e |= 1;
                    const {
                        matchedQueries: o,
                        references: a,
                        matchedQueryIds: l
                    } = na(t);
                    return {
                        nodeIndex: -1,
                        parent: null,
                        renderParent: null,
                        bindingIndex: -1,
                        outputIndex: -1,
                        flags: e,
                        checkIndex: -1,
                        childFlags: 0,
                        directChildFlags: 0,
                        childMatchedQueries: 0,
                        matchedQueries: o,
                        matchedQueryIds: l,
                        references: a,
                        ngContentIndex: n,
                        childCount: s,
                        bindings: [],
                        bindingFlags: 0,
                        outputs: [],
                        element: {
                            ns: null,
                            name: null,
                            attrs: null,
                            template: i ? oa(i) : null,
                            componentProvider: null,
                            componentView: null,
                            componentRendererType: null,
                            publicProviders: null,
                            allProviders: null,
                            handleEvent: r || Ro
                        },
                        provider: null,
                        text: null,
                        query: null,
                        ngContent: null
                    }
                }

                function nu(e, t, n, s, r, i, o = [], a, l, c, u, h) {
                    c || (c = Ro);
                    const {
                        matchedQueries: p,
                        references: d,
                        matchedQueryIds: f
                    } = na(n);
                    let m = null,
                        g = null;
                    i && ([m, g] = da(i)), a = a || [];
                    const y = [];
                    for (let b = 0; b < a.length; b++) {
                        const [e, t, n] = a[b], [s, r] = da(t);
                        let i, o;
                        switch (15 & e) {
                            case 4:
                                o = n;
                                break;
                            case 1:
                            case 8:
                                i = n
                        }
                        y[b] = {
                            flags: e,
                            ns: s,
                            name: r,
                            nonMinifiedName: r,
                            securityContext: i,
                            suffix: o
                        }
                    }
                    l = l || [];
                    const v = [];
                    for (let b = 0; b < l.length; b++) {
                        const [e, t] = l[b];
                        v[b] = {
                            type: 0,
                            target: e,
                            eventName: t,
                            propName: null
                        }
                    }
                    const _ = (o = o || []).map(([e, t]) => {
                        const [n, s] = da(e);
                        return [n, s, t]
                    });
                    return h = function(e) {
                        if (e && e.id === $o) {
                            const t = null != e.encapsulation && e.encapsulation !== D.None || e.styles.length || Object.keys(e.data).length;
                            e.id = t ? "c" + Uo++ : Bo
                        }
                        return e && e.id === Bo && (e = null), e || null
                    }(h), u && (t |= 33554432), {
                        nodeIndex: -1,
                        parent: null,
                        renderParent: null,
                        bindingIndex: -1,
                        outputIndex: -1,
                        checkIndex: e,
                        flags: t |= 1,
                        childFlags: 0,
                        directChildFlags: 0,
                        childMatchedQueries: 0,
                        matchedQueries: p,
                        matchedQueryIds: f,
                        references: d,
                        ngContentIndex: s,
                        childCount: r,
                        bindings: y,
                        bindingFlags: fa(y),
                        outputs: v,
                        element: {
                            ns: m,
                            name: g,
                            attrs: _,
                            template: null,
                            componentProvider: null,
                            componentView: u || null,
                            componentRendererType: h,
                            publicProviders: null,
                            allProviders: null,
                            handleEvent: c || Ro
                        },
                        provider: null,
                        text: null,
                        query: null,
                        ngContent: null
                    }
                }

                function su(e, t, n) {
                    const s = n.element,
                        r = e.root.selectorOrNode,
                        i = e.renderer;
                    let o;
                    if (e.parent || !r) {
                        o = s.name ? i.createElement(s.name, s.ns) : i.createComment("");
                        const r = ra(e, t, n);
                        r && i.appendChild(r, o)
                    } else {
                        const e = !!s.componentRendererType && s.componentRendererType.encapsulation === D.ShadowDom;
                        o = i.selectRootElement(r, e)
                    }
                    if (s.attrs)
                        for (let a = 0; a < s.attrs.length; a++) {
                            const [e, t, n] = s.attrs[a];
                            i.setAttribute(o, t, n, e)
                        }
                    return o
                }

                function ru(e, t, n, s) {
                    for (let o = 0; o < n.outputs.length; o++) {
                        const a = n.outputs[o],
                            l = iu(e, n.nodeIndex, (r = a.target, i = a.eventName, r ? `${r}:${i}` : i));
                        let c = a.target,
                            u = e;
                        "component" === a.target && (c = null, u = t);
                        const h = u.renderer.listen(c || s, a.eventName, l);
                        e.disposables[n.outputIndex + o] = h
                    }
                    var r, i
                }

                function iu(e, t, n) {
                    return s => Qo(e, t, n, s)
                }

                function ou(e, t, n, s) {
                    if (!zo(e, t, n, s)) return !1;
                    const r = t.bindings[n],
                        i = Oo(e, t.nodeIndex),
                        o = i.renderElement,
                        a = r.name;
                    switch (15 & r.flags) {
                        case 1:
                            ! function(e, t, n, s, r, i) {
                                const o = t.securityContext;
                                let a = o ? e.root.sanitizer.sanitize(o, i) : i;
                                a = null != a ? a.toString() : null;
                                const l = e.renderer;
                                null != i ? l.setAttribute(n, r, a, s) : l.removeAttribute(n, r, s)
                            }(e, r, o, r.ns, a, s);
                            break;
                        case 2:
                            ! function(e, t, n, s) {
                                const r = e.renderer;
                                s ? r.addClass(t, n) : r.removeClass(t, n)
                            }(e, o, a, s);
                            break;
                        case 4:
                            ! function(e, t, n, s, r) {
                                let i = e.root.sanitizer.sanitize(is.STYLE, r);
                                if (null != i) {
                                    i = i.toString();
                                    const e = t.suffix;
                                    null != e && (i += e)
                                } else i = null;
                                const o = e.renderer;
                                null != i ? o.setStyle(n, s, i) : o.removeStyle(n, s)
                            }(e, r, o, a, s);
                            break;
                        case 8:
                            ! function(e, t, n, s, r) {
                                const i = t.securityContext;
                                let o = i ? e.root.sanitizer.sanitize(i, r) : r;
                                e.renderer.setProperty(n, s, o)
                            }
                            /**
                             * @license
                             * Copyright Google LLC All Rights Reserved.
                             *
                             * Use of this source code is governed by an MIT-style license that can be
                             * found in the LICENSE file at https://angular.io/license
                             */
                            (33554432 & t.flags && 32 & r.flags ? i.componentView : e, r, o, a, s)
                    }
                    return !0
                }

                function au(e, t, n) {
                    let s = [];
                    for (let r in n) {
                        const e = n[r];
                        s.push({
                            propName: r,
                            bindingType: e
                        })
                    }
                    return {
                        nodeIndex: -1,
                        parent: null,
                        renderParent: null,
                        bindingIndex: -1,
                        outputIndex: -1,
                        checkIndex: -1,
                        flags: e,
                        childFlags: 0,
                        directChildFlags: 0,
                        childMatchedQueries: 0,
                        ngContentIndex: -1,
                        matchedQueries: {},
                        matchedQueryIds: 0,
                        references: {},
                        childCount: 0,
                        bindings: [],
                        bindingFlags: 0,
                        outputs: [],
                        element: null,
                        provider: null,
                        text: null,
                        query: {
                            id: t,
                            filterId: ta(t),
                            bindings: s
                        },
                        ngContent: null
                    }
                }

                function lu(e) {
                    const t = e.def.nodeMatchedQueries;
                    for (; e.parent && ea(e);) {
                        let n = e.parentNodeDef;
                        e = e.parent;
                        const s = n.nodeIndex + n.childCount;
                        for (let r = 0; r <= s; r++) {
                            const s = e.def.nodes[r];
                            67108864 & s.flags && 536870912 & s.flags && (s.query.filterId & t) === s.query.filterId && Mo(e, r).setDirty(), !(1 & s.flags && r + s.childCount < n.nodeIndex) && 67108864 & s.childFlags && 536870912 & s.childFlags || (r += s.childCount)
                        }
                    }
                    if (134217728 & e.def.nodeFlags)
                        for (let n = 0; n < e.def.nodes.length; n++) {
                            const t = e.def.nodes[n];
                            134217728 & t.flags && 536870912 & t.flags && Mo(e, n).setDirty(), n += t.childCount
                        }
                }

                function cu(e, t) {
                    const n = Mo(e, t.nodeIndex);
                    if (!n.dirty) return;
                    let s, r;
                    if (67108864 & t.flags) {
                        const n = t.parent.parent;
                        r = uu(e, n.nodeIndex, n.nodeIndex + n.childCount, t.query, []), s = Io(e, t.parent.nodeIndex).instance
                    } else 134217728 & t.flags && (r = uu(e, 0, e.def.nodes.length - 1, t.query, []), s = e.component);
                    n.reset(r);
                    const i = t.query.bindings;
                    let o = !1;
                    for (let a = 0; a < i.length; a++) {
                        const e = i[a];
                        let t;
                        switch (e.bindingType) {
                            case 0:
                                t = n.first;
                                break;
                            case 1:
                                t = n, o = !0
                        }
                        s[e.propName] = t
                    }
                    o && n.notifyOnChanges()
                }

                function uu(e, t, n, s, r) {
                    for (let i = t; i <= n; i++) {
                        const t = e.def.nodes[i],
                            n = t.matchedQueries[s.id];
                        if (null != n && r.push(hu(e, t, n)), 1 & t.flags && t.element.template && (t.element.template.nodeMatchedQueries & s.filterId) === s.filterId) {
                            const n = Oo(e, i);
                            if ((t.childMatchedQueries & s.filterId) === s.filterId && (uu(e, i + 1, i + t.childCount, s, r), i += t.childCount), 16777216 & t.flags) {
                                const e = n.viewContainer._embeddedViews;
                                for (let t = 0; t < e.length; t++) {
                                    const i = e[t],
                                        o = Zo(i);
                                    o && o === n && uu(i, 0, i.def.nodes.length - 1, s, r)
                                }
                            }
                            const o = n.template._projectedViews;
                            if (o)
                                for (let e = 0; e < o.length; e++) {
                                    const t = o[e];
                                    uu(t, 0, t.def.nodes.length - 1, s, r)
                                }
                        }(t.childMatchedQueries & s.filterId) !== s.filterId && (i += t.childCount)
                    }
                    return r
                }

                function hu(e, t, n) {
                    if (null != n) switch (n) {
                        case 1:
                            return Oo(e, t.nodeIndex).renderElement;
                        case 0:
                            return new qi(Oo(e, t.nodeIndex).renderElement);
                        case 2:
                            return Oo(e, t.nodeIndex).template;
                        case 3:
                            return Oo(e, t.nodeIndex).viewContainer;
                        case 4:
                            return Io(e, t.nodeIndex).instance
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function pu(e, t) {
                    return {
                        nodeIndex: -1,
                        parent: null,
                        renderParent: null,
                        bindingIndex: -1,
                        outputIndex: -1,
                        checkIndex: -1,
                        flags: 8,
                        childFlags: 0,
                        directChildFlags: 0,
                        childMatchedQueries: 0,
                        matchedQueries: {},
                        matchedQueryIds: 0,
                        references: {},
                        ngContentIndex: e,
                        childCount: 0,
                        bindings: [],
                        bindingFlags: 0,
                        outputs: [],
                        element: null,
                        provider: null,
                        text: null,
                        query: null,
                        ngContent: {
                            index: t
                        }
                    }
                }

                function du(e, t, n) {
                    const s = ra(e, t, n);
                    if (!s) return;
                    ca(e, n.ngContent.index, 1, s, null, void 0)
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function fu(e, t) {
                    return yu(128, e, Ht(t + 1))
                }

                function mu(e, t) {
                    return yu(32, e, Ht(t))
                }

                function gu(e, t) {
                    const n = Object.keys(t),
                        s = n.length,
                        r = [];
                    for (let i = 0; i < s; i++) {
                        const e = n[i];
                        t[e];
                        r.push(e)
                    }
                    return yu(64, e, r)
                }

                function yu(e, t, n) {
                    const s = [];
                    for (let r = 0; r < n.length; r++) {
                        const e = n[r];
                        s.push({
                            flags: 8,
                            name: e,
                            ns: null,
                            nonMinifiedName: e,
                            securityContext: null,
                            suffix: null
                        })
                    }
                    return {
                        nodeIndex: -1,
                        parent: null,
                        renderParent: null,
                        bindingIndex: -1,
                        outputIndex: -1,
                        checkIndex: t,
                        flags: e,
                        childFlags: 0,
                        directChildFlags: 0,
                        childMatchedQueries: 0,
                        matchedQueries: {},
                        matchedQueryIds: 0,
                        references: {},
                        ngContentIndex: -1,
                        childCount: 0,
                        bindings: s,
                        bindingFlags: fa(s),
                        outputs: [],
                        element: null,
                        provider: null,
                        text: null,
                        query: null,
                        ngContent: null
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function vu(e, t, n) {
                    const s = [];
                    for (let r = 1; r < n.length; r++) s[r - 1] = {
                        flags: 8,
                        name: null,
                        ns: null,
                        nonMinifiedName: null,
                        securityContext: null,
                        suffix: n[r]
                    };
                    return {
                        nodeIndex: -1,
                        parent: null,
                        renderParent: null,
                        bindingIndex: -1,
                        outputIndex: -1,
                        checkIndex: e,
                        flags: 2,
                        childFlags: 0,
                        directChildFlags: 0,
                        childMatchedQueries: 0,
                        matchedQueries: {},
                        matchedQueryIds: 0,
                        references: {},
                        ngContentIndex: t,
                        childCount: 0,
                        bindings: s,
                        bindingFlags: 8,
                        outputs: [],
                        element: null,
                        provider: null,
                        text: {
                            prefix: n[0]
                        },
                        query: null,
                        ngContent: null
                    }
                }

                function _u(e, t, n) {
                    let s;
                    const r = e.renderer;
                    s = r.createText(n.text.prefix);
                    const i = ra(e, t, n);
                    return i && r.appendChild(i, s), {
                        renderText: s
                    }
                }

                function bu(e, t) {
                    return (null != e ? e.toString() : "") + t.suffix
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function wu(e, t, n, s) {
                    let r = 0,
                        i = 0,
                        o = 0,
                        a = 0,
                        l = 0,
                        c = null,
                        u = null,
                        h = !1,
                        p = !1,
                        d = null;
                    for (let f = 0; f < t.length; f++) {
                        const e = t[f];
                        if (e.nodeIndex = f, e.parent = c, e.bindingIndex = r, e.outputIndex = i, e.renderParent = u, o |= e.flags, l |= e.matchedQueryIds, e.element) {
                            const t = e.element;
                            t.publicProviders = c ? c.element.publicProviders : Object.create(null), t.allProviders = t.publicProviders, h = !1, p = !1, e.element.template && (l |= e.element.template.nodeMatchedQueries)
                        }
                        if (Cu(c, e, t.length), r += e.bindings.length, i += e.outputs.length, !u && 3 & e.flags && (d = e), 20224 & e.flags) {
                            h || (h = !0, c.element.publicProviders = Object.create(c.element.publicProviders), c.element.allProviders = c.element.publicProviders);
                            const t = 0 != (8192 & e.flags),
                                n = 0 != (32768 & e.flags);
                            !t || n ? c.element.publicProviders[Lo(e.provider.token)] = e : (p || (p = !0, c.element.allProviders = Object.create(c.element.publicProviders)), c.element.allProviders[Lo(e.provider.token)] = e), n && (c.element.componentProvider = e)
                        }
                        if (c ? (c.childFlags |= e.flags, c.directChildFlags |= e.flags, c.childMatchedQueries |= e.matchedQueryIds, e.element && e.element.template && (c.childMatchedQueries |= e.element.template.nodeMatchedQueries)) : a |= e.flags, e.childCount > 0) c = e, Eu(e) || (u = e);
                        else
                            for (; c && f === c.nodeIndex + c.childCount;) {
                                const e = c.parent;
                                e && (e.childFlags |= c.childFlags, e.childMatchedQueries |= c.childMatchedQueries), c = e, u = c && Eu(c) ? c.renderParent : c
                            }
                    }
                    return {
                        factory: null,
                        nodeFlags: o,
                        rootNodeFlags: a,
                        nodeMatchedQueries: l,
                        flags: e,
                        nodes: t,
                        updateDirectives: n || Ro,
                        updateRenderer: s || Ro,
                        handleEvent: (e, n, s, r) => t[n].element.handleEvent(e, s, r),
                        bindingCount: r,
                        outputCount: i,
                        lastRenderRootNode: d
                    }
                }

                function Eu(e) {
                    return 0 != (1 & e.flags) && null === e.element.name
                }

                function Cu(e, t, n) {
                    const s = t.element && t.element.template;
                    if (s) {
                        if (!s.lastRenderRootNode) throw new Error("Illegal State: Embedded templates without nodes are not allowed!");
                        if (s.lastRenderRootNode && 16777216 & s.lastRenderRootNode.flags) throw new Error(`Illegal State: Last root node of a template can't have embedded views, at index ${t.nodeIndex}!`)
                    }
                    if (20224 & t.flags) {
                        if (0 == (1 & (e ? e.flags : 0))) throw new Error(`Illegal State: StaticProvider/Directive nodes need to be children of elements or anchors, at index ${t.nodeIndex}!`)
                    }
                    if (t.query) {
                        if (67108864 & t.flags && (!e || 0 == (16384 & e.flags))) throw new Error(`Illegal State: Content Query nodes need to be children of directives, at index ${t.nodeIndex}!`);
                        if (134217728 & t.flags && e) throw new Error(`Illegal State: View Query nodes have to be top level nodes, at index ${t.nodeIndex}!`)
                    }
                    if (t.childCount) {
                        const s = e ? e.nodeIndex + e.childCount : n - 1;
                        if (t.nodeIndex <= s && t.nodeIndex + t.childCount > s) throw new Error(`Illegal State: childCount of node leads outside of parent, at index ${t.nodeIndex}!`)
                    }
                }

                function Su(e, t, n, s) {
                    const r = Au(e.root, e.renderer, e, t, n);
                    return Du(r, e.component, s), Pu(r), r
                }

                function xu(e, t, n) {
                    const s = Au(e, e.renderer, null, null, t);
                    return Du(s, n, n), Pu(s), s
                }

                function Tu(e, t, n, s) {
                    const r = t.element.componentRendererType;
                    let i;
                    return i = r ? e.root.rendererFactory.createRenderer(s, r) : e.root.renderer, Au(e.root, i, e, t.element.componentProvider, n)
                }

                function Au(e, t, n, s, r) {
                    const i = new Array(r.nodes.length),
                        o = r.outputCount ? new Array(r.outputCount) : null;
                    return {
                        def: r,
                        parent: n,
                        viewContainerParent: null,
                        parentNodeDef: s,
                        context: null,
                        component: null,
                        nodes: i,
                        state: 13,
                        root: e,
                        renderer: t,
                        oldValues: new Array(r.bindingCount),
                        disposables: o,
                        initIndex: -1
                    }
                }

                function Du(e, t, n) {
                    e.component = t, e.context = n
                }

                function Pu(e) {
                    let t;
                    if (Yo(e)) {
                        const n = e.parentNodeDef;
                        t = Oo(e.parent, n.parent.nodeIndex).renderElement
                    }
                    const n = e.def,
                        s = e.nodes;
                    for (let r = 0; r < n.nodes.length; r++) {
                        const i = n.nodes[r];
                        let o;
                        switch (Fo.setCurrentNode(e, r), 201347067 & i.flags) {
                            case 1:
                                const n = su(e, t, i);
                                let a;
                                if (33554432 & i.flags) {
                                    const t = oa(i.element.componentView);
                                    a = Fo.createComponentView(e, i, t, n)
                                }
                                ru(e, a, i, n), o = {
                                    renderElement: n,
                                    componentView: a,
                                    viewContainer: null,
                                    template: i.element.template ? $a(e, i) : void 0
                                }, 16777216 & i.flags && (o.viewContainer = Ra(e, i, o));
                                break;
                            case 2:
                                o = _u(e, t, i);
                                break;
                            case 512:
                            case 1024:
                            case 2048:
                            case 256:
                                if (o = s[r], !(o || 4096 & i.flags)) {
                                    o = {
                                        instance: rl(e, i)
                                    }
                                }
                                break;
                            case 16:
                                o = {
                                    instance: il(e, i)
                                };
                                break;
                            case 16384:
                                if (o = s[r], !o) {
                                    o = {
                                        instance: ol(e, i)
                                    }
                                }
                                if (32768 & i.flags) {
                                    Du(Oo(e, i.parent.nodeIndex).componentView, o.instance, o.instance)
                                }
                                break;
                            case 32:
                            case 64:
                            case 128:
                                o = {
                                    value: void 0
                                };
                                break;
                            case 67108864:
                            case 134217728:
                                o = new Dl;
                                break;
                            case 8:
                                du(e, t, i), o = void 0
                        }
                        s[r] = o
                    }
                    Lu(e, ju.CreateViewNodes), Hu(e, 201326592, 268435456, 0)
                }

                function ku(e) {
                    Nu(e), Fo.updateDirectives(e, 1), Vu(e, ju.CheckNoChanges), Fo.updateRenderer(e, 1), Lu(e, ju.CheckNoChanges), e.state &= -97
                }

                function Ou(e) {
                    1 & e.state ? (e.state &= -2, e.state |= 2) : e.state &= -3, Do(e, 0, 256), Nu(e), Fo.updateDirectives(e, 0), Vu(e, ju.CheckAndUpdate), Hu(e, 67108864, 536870912, 0);
                    let t = Do(e, 256, 512);
                    fl(e, 2097152 | (t ? 1048576 : 0)), Fo.updateRenderer(e, 0), Lu(e, ju.CheckAndUpdate), Hu(e, 134217728, 536870912, 0), t = Do(e, 512, 768), fl(e, 8388608 | (t ? 4194304 : 0)), 2 & e.def.flags && (e.state &= -9), e.state &= -97, Do(e, 768, 1024)
                }

                function Iu(e, t, n, s, r, i, o, a, l, c, u, h, p) {
                    return 0 === n ? function(e, t, n, s, r, i, o, a, l, c, u, h) {
                        switch (201347067 & t.flags) {
                            case 1:
                                return function(e, t, n, s, r, i, o, a, l, c, u, h) {
                                    const p = t.bindings.length;
                                    let d = !1;
                                    return p > 0 && ou(e, t, 0, n) && (d = !0), p > 1 && ou(e, t, 1, s) && (d = !0), p > 2 && ou(e, t, 2, r) && (d = !0), p > 3 && ou(e, t, 3, i) && (d = !0), p > 4 && ou(e, t, 4, o) && (d = !0), p > 5 && ou(e, t, 5, a) && (d = !0), p > 6 && ou(e, t, 6, l) && (d = !0), p > 7 && ou(e, t, 7, c) && (d = !0), p > 8 && ou(e, t, 8, u) && (d = !0), p > 9 && ou(e, t, 9, h) && (d = !0), d
                                }(e, t, n, s, r, i, o, a, l, c, u, h);
                            case 2:
                                return function(e, t, n, s, r, i, o, a, l, c, u, h) {
                                    let p = !1;
                                    const d = t.bindings,
                                        f = d.length;
                                    if (f > 0 && zo(e, t, 0, n) && (p = !0), f > 1 && zo(e, t, 1, s) && (p = !0), f > 2 && zo(e, t, 2, r) && (p = !0), f > 3 && zo(e, t, 3, i) && (p = !0), f > 4 && zo(e, t, 4, o) && (p = !0), f > 5 && zo(e, t, 5, a) && (p = !0), f > 6 && zo(e, t, 6, l) && (p = !0), f > 7 && zo(e, t, 7, c) && (p = !0), f > 8 && zo(e, t, 8, u) && (p = !0), f > 9 && zo(e, t, 9, h) && (p = !0), p) {
                                        let p = t.text.prefix;
                                        f > 0 && (p += bu(n, d[0])), f > 1 && (p += bu(s, d[1])), f > 2 && (p += bu(r, d[2])), f > 3 && (p += bu(i, d[3])), f > 4 && (p += bu(o, d[4])), f > 5 && (p += bu(a, d[5])), f > 6 && (p += bu(l, d[6])), f > 7 && (p += bu(c, d[7])), f > 8 && (p += bu(u, d[8])), f > 9 && (p += bu(h, d[9]));
                                        const m = ko(e, t.nodeIndex).renderText;
                                        e.renderer.setValue(m, p)
                                    }
                                    return p
                                }(e, t, n, s, r, i, o, a, l, c, u, h);
                            case 16384:
                                return function(e, t, n, s, r, i, o, a, l, c, u, h) {
                                    const p = Io(e, t.nodeIndex),
                                        d = p.instance;
                                    let f, m = !1;
                                    const g = t.bindings.length;
                                    return g > 0 && qo(e, t, 0, n) && (m = !0, f = dl(e, p, t, 0, n, f)), g > 1 && qo(e, t, 1, s) && (m = !0, f = dl(e, p, t, 1, s, f)), g > 2 && qo(e, t, 2, r) && (m = !0, f = dl(e, p, t, 2, r, f)), g > 3 && qo(e, t, 3, i) && (m = !0, f = dl(e, p, t, 3, i, f)), g > 4 && qo(e, t, 4, o) && (m = !0, f = dl(e, p, t, 4, o, f)), g > 5 && qo(e, t, 5, a) && (m = !0, f = dl(e, p, t, 5, a, f)), g > 6 && qo(e, t, 6, l) && (m = !0, f = dl(e, p, t, 6, l, f)), g > 7 && qo(e, t, 7, c) && (m = !0, f = dl(e, p, t, 7, c, f)), g > 8 && qo(e, t, 8, u) && (m = !0, f = dl(e, p, t, 8, u, f)), g > 9 && qo(e, t, 9, h) && (m = !0, f = dl(e, p, t, 9, h, f)), f && d.ngOnChanges(f), 65536 & t.flags && Po(e, 256, t.nodeIndex) && d.ngOnInit(), 262144 & t.flags && d.ngDoCheck(), m
                                }(e, t, n, s, r, i, o, a, l, c, u, h);
                            case 32:
                            case 64:
                            case 128:
                                return function(e, t, n, s, r, i, o, a, l, c, u, h) {
                                    const p = t.bindings;
                                    let d = !1;
                                    const f = p.length;
                                    if (f > 0 && zo(e, t, 0, n) && (d = !0), f > 1 && zo(e, t, 1, s) && (d = !0), f > 2 && zo(e, t, 2, r) && (d = !0), f > 3 && zo(e, t, 3, i) && (d = !0), f > 4 && zo(e, t, 4, o) && (d = !0), f > 5 && zo(e, t, 5, a) && (d = !0), f > 6 && zo(e, t, 6, l) && (d = !0), f > 7 && zo(e, t, 7, c) && (d = !0), f > 8 && zo(e, t, 8, u) && (d = !0), f > 9 && zo(e, t, 9, h) && (d = !0), d) {
                                        const d = No(e, t.nodeIndex);
                                        let m;
                                        switch (201347067 & t.flags) {
                                            case 32:
                                                m = [], f > 0 && m.push(n), f > 1 && m.push(s), f > 2 && m.push(r), f > 3 && m.push(i), f > 4 && m.push(o), f > 5 && m.push(a), f > 6 && m.push(l), f > 7 && m.push(c), f > 8 && m.push(u), f > 9 && m.push(h);
                                                break;
                                            case 64:
                                                m = {}, f > 0 && (m[p[0].name] = n), f > 1 && (m[p[1].name] = s), f > 2 && (m[p[2].name] = r), f > 3 && (m[p[3].name] = i), f > 4 && (m[p[4].name] = o), f > 5 && (m[p[5].name] = a), f > 6 && (m[p[6].name] = l), f > 7 && (m[p[7].name] = c), f > 8 && (m[p[8].name] = u), f > 9 && (m[p[9].name] = h);
                                                break;
                                            case 128:
                                                const e = n;
                                                switch (f) {
                                                    case 1:
                                                        m = e.transform(n);
                                                        break;
                                                    case 2:
                                                        m = e.transform(s);
                                                        break;
                                                    case 3:
                                                        m = e.transform(s, r);
                                                        break;
                                                    case 4:
                                                        m = e.transform(s, r, i);
                                                        break;
                                                    case 5:
                                                        m = e.transform(s, r, i, o);
                                                        break;
                                                    case 6:
                                                        m = e.transform(s, r, i, o, a);
                                                        break;
                                                    case 7:
                                                        m = e.transform(s, r, i, o, a, l);
                                                        break;
                                                    case 8:
                                                        m = e.transform(s, r, i, o, a, l, c);
                                                        break;
                                                    case 9:
                                                        m = e.transform(s, r, i, o, a, l, c, u);
                                                        break;
                                                    case 10:
                                                        m = e.transform(s, r, i, o, a, l, c, u, h)
                                                }
                                        }
                                        d.value = m
                                    }
                                    return d
                                }(e, t, n, s, r, i, o, a, l, c, u, h);
                            default:
                                throw "unreachable"
                        }
                    }(e, t, s, r, i, o, a, l, c, u, h, p) : function(e, t, n) {
                        switch (201347067 & t.flags) {
                            case 1:
                                return function(e, t, n) {
                                    let s = !1;
                                    for (let r = 0; r < n.length; r++) ou(e, t, r, n[r]) && (s = !0);
                                    return s
                                }(e, t, n);
                            case 2:
                                return function(e, t, n) {
                                    const s = t.bindings;
                                    let r = !1;
                                    for (let i = 0; i < n.length; i++) zo(e, t, i, n[i]) && (r = !0);
                                    if (r) {
                                        let r = "";
                                        for (let e = 0; e < n.length; e++) r += bu(n[e], s[e]);
                                        r = t.text.prefix + r;
                                        const i = ko(e, t.nodeIndex).renderText;
                                        e.renderer.setValue(i, r)
                                    }
                                    return r
                                }(e, t, n);
                            case 16384:
                                return function(e, t, n) {
                                    const s = Io(e, t.nodeIndex),
                                        r = s.instance;
                                    let i, o = !1;
                                    for (let a = 0; a < n.length; a++) qo(e, t, a, n[a]) && (o = !0, i = dl(e, s, t, a, n[a], i));
                                    return i && r.ngOnChanges(i), 65536 & t.flags && Po(e, 256, t.nodeIndex) && r.ngOnInit(), 262144 & t.flags && r.ngDoCheck(), o
                                }(e, t, n);
                            case 32:
                            case 64:
                            case 128:
                                return function(e, t, n) {
                                    const s = t.bindings;
                                    let r = !1;
                                    for (let i = 0; i < n.length; i++) zo(e, t, i, n[i]) && (r = !0);
                                    if (r) {
                                        const r = No(e, t.nodeIndex);
                                        let i;
                                        switch (201347067 & t.flags) {
                                            case 32:
                                                i = n;
                                                break;
                                            case 64:
                                                i = {};
                                                for (let r = 0; r < n.length; r++) i[s[r].name] = n[r];
                                                break;
                                            case 128:
                                                const e = n[0],
                                                    t = n.slice(1);
                                                i = e.transform(...t)
                                        }
                                        r.value = i
                                    }
                                    return r
                                }(e, t, n);
                            default:
                                throw "unreachable"
                        }
                    }(e, t, s)
                }

                function Nu(e) {
                    const t = e.def;
                    if (4 & t.nodeFlags)
                        for (let n = 0; n < t.nodes.length; n++) {
                            const s = t.nodes[n];
                            if (4 & s.flags) {
                                const t = Oo(e, n).template._projectedViews;
                                if (t)
                                    for (let n = 0; n < t.length; n++) {
                                        const s = t[n];
                                        s.state |= 32, Ko(s, e)
                                    }
                            } else 0 == (4 & s.childFlags) && (n += s.childCount)
                        }
                }

                function Mu(e, t, n, s, r, i, o, a, l, c, u, h, p) {
                    return 0 === n ? function(e, t, n, s, r, i, o, a, l, c, u, h) {
                        const p = t.bindings.length;
                        p > 0 && Wo(e, t, 0, n);
                        p > 1 && Wo(e, t, 1, s);
                        p > 2 && Wo(e, t, 2, r);
                        p > 3 && Wo(e, t, 3, i);
                        p > 4 && Wo(e, t, 4, o);
                        p > 5 && Wo(e, t, 5, a);
                        p > 6 && Wo(e, t, 6, l);
                        p > 7 && Wo(e, t, 7, c);
                        p > 8 && Wo(e, t, 8, u);
                        p > 9 && Wo(e, t, 9, h)
                    }(e, t, s, r, i, o, a, l, c, u, h, p) : function(e, t, n) {
                        for (let s = 0; s < n.length; s++) Wo(e, t, s, n[s])
                    }(e, t, s), !1
                }

                function Fu(e, t) {
                    if (Mo(e, t.nodeIndex).dirty) throw xo(Fo.createDebugContext(e, t.nodeIndex), `Query ${t.query.id} not dirty`, `Query ${t.query.id} dirty`, 0 != (1 & e.state))
                }

                function Ru(e) {
                    if (!(128 & e.state)) {
                        if (Vu(e, ju.Destroy), Lu(e, ju.Destroy), fl(e, 131072), e.disposables)
                            for (let t = 0; t < e.disposables.length; t++) e.disposables[t]();
                        ! function(e) {
                            if (!(16 & e.state)) return;
                            const t = Zo(e);
                            if (t) {
                                const n = t.template._projectedViews;
                                n && (Bt(n, n.indexOf(e)), Fo.dirtyParentQueries(e))
                            }
                        }(e), e.renderer.destroyNode && function(e) {
                            const t = e.def.nodes.length;
                            for (let n = 0; n < t; n++) {
                                const t = e.def.nodes[n];
                                1 & t.flags ? e.renderer.destroyNode(Oo(e, n).renderElement) : 2 & t.flags ? e.renderer.destroyNode(ko(e, n).renderText) : (67108864 & t.flags || 134217728 & t.flags) && Mo(e, n).destroy()
                            }
                        }(e), Yo(e) && e.renderer.destroy(), e.state |= 128
                    }
                }
                var ju;

                function Lu(e, t) {
                    const n = e.def;
                    if (33554432 & n.nodeFlags)
                        for (let s = 0; s < n.nodes.length; s++) {
                            const r = n.nodes[s];
                            33554432 & r.flags ? $u(Oo(e, s).componentView, t) : 0 == (33554432 & r.childFlags) && (s += r.childCount)
                        }
                }

                function Vu(e, t) {
                    const n = e.def;
                    if (16777216 & n.nodeFlags)
                        for (let s = 0; s < n.nodes.length; s++) {
                            const r = n.nodes[s];
                            if (16777216 & r.flags) {
                                const n = Oo(e, s).viewContainer._embeddedViews;
                                for (let e = 0; e < n.length; e++) $u(n[e], t)
                            } else 0 == (16777216 & r.childFlags) && (s += r.childCount)
                        }
                }

                function $u(e, t) {
                    const n = e.state;
                    switch (t) {
                        case ju.CheckNoChanges:
                            0 == (128 & n) && (12 == (12 & n) ? ku(e) : 64 & n && Bu(e, ju.CheckNoChangesProjectedViews));
                            break;
                        case ju.CheckNoChangesProjectedViews:
                            0 == (128 & n) && (32 & n ? ku(e) : 64 & n && Bu(e, t));
                            break;
                        case ju.CheckAndUpdate:
                            0 == (128 & n) && (12 == (12 & n) ? Ou(e) : 64 & n && Bu(e, ju.CheckAndUpdateProjectedViews));
                            break;
                        case ju.CheckAndUpdateProjectedViews:
                            0 == (128 & n) && (32 & n ? Ou(e) : 64 & n && Bu(e, t));
                            break;
                        case ju.Destroy:
                            Ru(e);
                            break;
                        case ju.CreateViewNodes:
                            Pu(e)
                    }
                }

                function Bu(e, t) {
                    Vu(e, t), Lu(e, t)
                }

                function Hu(e, t, n, s) {
                    if (!(e.def.nodeFlags & t && e.def.nodeFlags & n)) return;
                    const r = e.def.nodes.length;
                    for (let i = 0; i < r; i++) {
                        const r = e.def.nodes[i];
                        if (r.flags & t && r.flags & n) switch (Fo.setCurrentNode(e, r.nodeIndex), s) {
                            case 0:
                                cu(e, r);
                                break;
                            case 1:
                                Fu(e, r)
                        }
                        r.childFlags & t && r.childFlags & n || (i += r.childCount)
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                eu.decorators = [{
                        type: Ll,
                        args: [{
                            providers: Yc
                        }]
                    }], eu.ctorParameters = () => [{
                        type: Rc
                    }],
                    function(e) {
                        e[e.CreateViewNodes = 0] = "CreateViewNodes", e[e.CheckNoChanges = 1] = "CheckNoChanges", e[e.CheckNoChangesProjectedViews = 2] = "CheckNoChangesProjectedViews", e[e.CheckAndUpdate = 3] = "CheckAndUpdate", e[e.CheckAndUpdateProjectedViews = 4] = "CheckAndUpdateProjectedViews", e[e.Destroy = 5] = "Destroy"
                    }(ju || (ju = {}));
                let Uu = !1;

                function qu() {
                    if (Uu) return;
                    Uu = !0;
                    const e = xc() ? {
                        setCurrentNode: dh,
                        createRootView: Wu,
                        createEmbeddedView: Ku,
                        createComponentView: Qu,
                        createNgModuleRef: Zu,
                        overrideProvider: eh,
                        overrideComponentView: th,
                        clearOverrides: nh,
                        checkAndUpdateView: oh,
                        checkNoChangesView: ah,
                        destroyView: lh,
                        createDebugContext: (e, t) => new wh(e, t),
                        handleEvent: fh,
                        updateDirectives: mh,
                        updateRenderer: gh
                    } : {
                        setCurrentNode: () => {},
                        createRootView: zu,
                        createEmbeddedView: Su,
                        createComponentView: Tu,
                        createNgModuleRef: za,
                        overrideProvider: Ro,
                        overrideComponentView: Ro,
                        clearOverrides: Ro,
                        checkAndUpdateView: Ou,
                        checkNoChangesView: ku,
                        destroyView: Ru,
                        createDebugContext: (e, t) => new wh(e, t),
                        handleEvent: (e, t, n, s) => e.def.handleEvent(e, t, n, s),
                        updateDirectives: (e, t) => e.def.updateDirectives(0 === t ? rh : ih, e),
                        updateRenderer: (e, t) => e.def.updateRenderer(0 === t ? rh : ih, e)
                    };
                    Fo.setCurrentNode = e.setCurrentNode, Fo.createRootView = e.createRootView, Fo.createEmbeddedView = e.createEmbeddedView, Fo.createComponentView = e.createComponentView, Fo.createNgModuleRef = e.createNgModuleRef, Fo.overrideProvider = e.overrideProvider, Fo.overrideComponentView = e.overrideComponentView, Fo.clearOverrides = e.clearOverrides, Fo.checkAndUpdateView = e.checkAndUpdateView, Fo.checkNoChangesView = e.checkNoChangesView, Fo.destroyView = e.destroyView, Fo.resolveDep = hl, Fo.createDebugContext = e.createDebugContext, Fo.handleEvent = e.handleEvent, Fo.updateDirectives = e.updateDirectives, Fo.updateRenderer = e.updateRenderer, Fo.dirtyParentQueries = lu
                }

                function zu(e, t, n, s, r, i) {
                    const o = r.injector.get(zi);
                    return xu(Gu(e, r, o, t, n), s, i)
                }

                function Wu(e, t, n, s, r, i) {
                    const o = r.injector.get(zi),
                        a = Gu(e, r, new xh(o), t, n),
                        l = sh(s);
                    return Ch(ch.create, xu, null, [a, l, i])
                }

                function Gu(e, t, n, s, r) {
                    const i = t.injector.get(Ki),
                        o = t.injector.get(cs),
                        a = n.createRenderer(null, null);
                    return {
                        ngModule: t,
                        injector: e,
                        projectableNodes: s,
                        selectorOrNode: r,
                        sanitizer: i,
                        rendererFactory: n,
                        renderer: a,
                        errorHandler: o
                    }
                }

                function Ku(e, t, n, s) {
                    const r = sh(n);
                    return Ch(ch.create, Su, null, [e, t, r, s])
                }

                function Qu(e, t, n, s) {
                    const r = Yu.get(t.element.componentProvider.provider.token);
                    return n = r || sh(n), Ch(ch.create, Tu, null, [e, t, n, s])
                }

                function Zu(e, t, n, s) {
                    return za(e, t, n, function(e) {
                        const {
                            hasOverrides: t,
                            hasDeprecatedOverrides: n
                        } = s(e);
                        if (!t) return e;
                        return r(e = e.factory(() => Ro)), e;

                        function s(e) {
                            let t = !1,
                                n = !1;
                            return 0 === Ju.size || (e.providers.forEach(e => {
                                const s = Ju.get(e.token);
                                3840 & e.flags && s && (t = !0, n = n || s.deprecatedBehavior)
                            }), e.modules.forEach(e => {
                                Xu.forEach((s, r) => {
                                    y(r).providedIn === e && (t = !0, n = n || s.deprecatedBehavior)
                                })
                            })), {
                                hasOverrides: t,
                                hasDeprecatedOverrides: n
                            }
                        }

                        function r(e) {
                            for (let t = 0; t < e.providers.length; t++) {
                                const s = e.providers[t];
                                n && (s.flags |= 4096);
                                const r = Ju.get(s.token);
                                r && (s.flags = -3841 & s.flags | r.flags, s.deps = sa(r.deps), s.value = r.value)
                            }
                            if (Xu.size > 0) {
                                let t = new Set(e.modules);
                                Xu.forEach((s, r) => {
                                    if (t.has(y(r).providedIn)) {
                                        let t = {
                                            token: r,
                                            flags: s.flags | (n ? 4096 : 0),
                                            deps: sa(s.deps),
                                            value: s.value,
                                            index: e.providers.length
                                        };
                                        e.providers.push(t), e.providersByKey[Lo(r)] = t
                                    }
                                })
                            }
                        }
                    }(s))
                }
                const Ju = new Map,
                    Xu = new Map,
                    Yu = new Map;

                function eh(e) {
                    let t;
                    Ju.set(e.token, e), "function" == typeof e.token && (t = y(e.token)) && "function" == typeof t.providedIn && Xu.set(e.token, e)
                }

                function th(e, t) {
                    const n = oa(t.viewDefFactory);
                    const s = oa(n.nodes[0].element.componentView);
                    Yu.set(e, s)
                }

                function nh() {
                    Ju.clear(), Xu.clear(), Yu.clear()
                }

                function sh(e) {
                    if (0 === Ju.size) return e;
                    const t = function(e) {
                        const t = [];
                        let n = null;
                        for (let s = 0; s < e.nodes.length; s++) {
                            const r = e.nodes[s];
                            1 & r.flags && (n = r), n && 3840 & r.flags && Ju.has(r.provider.token) && (t.push(n.nodeIndex), n = null)
                        }
                        return t
                    }(e);
                    if (0 === t.length) return e;
                    e = e.factory(() => Ro);
                    for (let s = 0; s < t.length; s++) n(e, t[s]);
                    return e;

                    function n(e, t) {
                        for (let n = t + 1; n < e.nodes.length; n++) {
                            const t = e.nodes[n];
                            if (1 & t.flags) return;
                            if (3840 & t.flags) {
                                const e = t.provider,
                                    n = Ju.get(e.token);
                                n && (t.flags = -3841 & t.flags | n.flags, e.deps = sa(n.deps), e.value = n.value)
                            }
                        }
                    }
                }

                function rh(e, t, n, s, r, i, o, a, l, c, u, h, p) {
                    const d = e.def.nodes[t];
                    return Iu(e, d, n, s, r, i, o, a, l, c, u, h, p), 224 & d.flags ? No(e, t).value : void 0
                }

                function ih(e, t, n, s, r, i, o, a, l, c, u, h, p) {
                    const d = e.def.nodes[t];
                    return Mu(e, d, n, s, r, i, o, a, l, c, u, h, p), 224 & d.flags ? No(e, t).value : void 0
                }

                function oh(e) {
                    return Ch(ch.detectChanges, Ou, null, [e])
                }

                function ah(e) {
                    return Ch(ch.checkNoChanges, ku, null, [e])
                }

                function lh(e) {
                    return Ch(ch.destroy, Ru, null, [e])
                }
                var ch;
                let uh, hh, ph;

                function dh(e, t) {
                    hh = e, ph = t
                }

                function fh(e, t, n, s) {
                    return dh(e, t), Ch(ch.handleEvent, e.def.handleEvent, null, [e, t, n, s])
                }

                function mh(e, t) {
                    if (128 & e.state) throw Ao(ch[uh]);
                    return dh(e, _h(e, 0)), e.def.updateDirectives(function(e, n, s, ...r) {
                        const i = e.def.nodes[n];
                        0 === t ? yh(e, i, s, r) : vh(e, i, s, r);
                        16384 & i.flags && dh(e, _h(e, n));
                        return 224 & i.flags ? No(e, i.nodeIndex).value : void 0
                    }, e)
                }

                function gh(e, t) {
                    if (128 & e.state) throw Ao(ch[uh]);
                    return dh(e, bh(e, 0)), e.def.updateRenderer(function(e, n, s, ...r) {
                        const i = e.def.nodes[n];
                        0 === t ? yh(e, i, s, r) : vh(e, i, s, r);
                        3 & i.flags && dh(e, bh(e, n));
                        return 224 & i.flags ? No(e, i.nodeIndex).value : void 0
                    }, e)
                }

                function yh(e, t, n, s) {
                    if (Iu(e, t, n, ...s)) {
                        const r = 1 === n ? s[0] : s;
                        if (16384 & t.flags) {
                            const n = {};
                            for (let e = 0; e < t.bindings.length; e++) {
                                const s = t.bindings[e],
                                    i = r[e];
                                8 & s.flags && (n[ds(s.nonMinifiedName)] = ms(i))
                            }
                            const s = t.parent,
                                i = Oo(e, s.nodeIndex).renderElement;
                            if (s.element.name)
                                for (let t in n) {
                                    const s = n[t];
                                    null != s ? e.renderer.setAttribute(i, t, s) : e.renderer.removeAttribute(i, t)
                                } else e.renderer.setValue(i, ps(`bindings=${JSON.stringify(n,null,2)}`))
                        }
                    }
                }

                function vh(e, t, n, s) {
                    Mu(e, t, n, ...s)
                }

                function _h(e, t) {
                    for (let n = t; n < e.def.nodes.length; n++) {
                        const t = e.def.nodes[n];
                        if (16384 & t.flags && t.bindings && t.bindings.length) return n
                    }
                    return null
                }

                function bh(e, t) {
                    for (let n = t; n < e.def.nodes.length; n++) {
                        const t = e.def.nodes[n];
                        if (3 & t.flags && t.bindings && t.bindings.length) return n
                    }
                    return null
                }! function(e) {
                    e[e.create = 0] = "create", e[e.detectChanges = 1] = "detectChanges", e[e.checkNoChanges = 2] = "checkNoChanges", e[e.destroy = 3] = "destroy", e[e.handleEvent = 4] = "handleEvent"
                }(ch || (ch = {}));
                class wh {
                    constructor(e, t) {
                        this.view = e, this.nodeIndex = t, null == t && (this.nodeIndex = t = 0), this.nodeDef = e.def.nodes[t];
                        let n = this.nodeDef,
                            s = e;
                        for (; n && 0 == (1 & n.flags);) n = n.parent;
                        if (!n)
                            for (; !n && s;) n = Jo(s), s = s.parent;
                        this.elDef = n, this.elView = s
                    }
                    get elOrCompView() {
                        return Oo(this.elView, this.elDef.nodeIndex).componentView || this.view
                    }
                    get injector() {
                        return Ha(this.elView, this.elDef)
                    }
                    get component() {
                        return this.elOrCompView.component
                    }
                    get context() {
                        return this.elOrCompView.context
                    }
                    get providerTokens() {
                        const e = [];
                        if (this.elDef)
                            for (let t = this.elDef.nodeIndex + 1; t <= this.elDef.nodeIndex + this.elDef.childCount; t++) {
                                const n = this.elView.def.nodes[t];
                                20224 & n.flags && e.push(n.provider.token), t += n.childCount
                            }
                        return e
                    }
                    get references() {
                        const e = {};
                        if (this.elDef) {
                            Eh(this.elView, this.elDef, e);
                            for (let t = this.elDef.nodeIndex + 1; t <= this.elDef.nodeIndex + this.elDef.childCount; t++) {
                                const n = this.elView.def.nodes[t];
                                20224 & n.flags && Eh(this.elView, n, e), t += n.childCount
                            }
                        }
                        return e
                    }
                    get componentRenderElement() {
                        const e = function(e) {
                            for (; e && !Yo(e);) e = e.parent;
                            if (e.parent) return Oo(e.parent, Jo(e).nodeIndex);
                            return null
                        }(this.elOrCompView);
                        return e ? e.renderElement : void 0
                    }
                    get renderNode() {
                        return 2 & this.nodeDef.flags ? Xo(this.view, this.nodeDef) : Xo(this.elView, this.elDef)
                    }
                    logError(e, ...t) {
                        let n, s;
                        2 & this.nodeDef.flags ? (n = this.view.def, s = this.nodeDef.nodeIndex) : (n = this.elView.def, s = this.elDef.nodeIndex);
                        const r = function(e, t) {
                            let n = -1;
                            for (let s = 0; s <= t; s++) {
                                3 & e.nodes[s].flags && n++
                            }
                            return n
                        }(n, s);
                        let i = -1;
                        n.factory(() => (i++, i === r ? e.error.bind(e, ...t) : Ro)), i < r && (e.error("Illegal state: the ViewDefinitionFactory did not call the logger!"), e.error(...t))
                    }
                }

                function Eh(e, t, n) {
                    for (let s in t.references) n[s] = hu(e, t, t.references[s])
                }

                function Ch(e, t, n, s) {
                    const r = uh,
                        i = hh,
                        o = ph;
                    try {
                        uh = e;
                        const a = t.apply(n, s);
                        return hh = i, ph = o, uh = r, a
                    } catch (a) {
                        if (os(a) || !hh) throw a;
                        throw function(e, t) {
                            return e instanceof Error || (e = new Error(e.toString())), To(e, t), e
                        }(a, Sh())
                    }
                }

                function Sh() {
                    return hh ? new wh(hh, ph) : null
                }
                class xh {
                    constructor(e) {
                        this.delegate = e
                    }
                    createRenderer(e, t) {
                        return new Th(this.delegate.createRenderer(e, t))
                    }
                    begin() {
                        this.delegate.begin && this.delegate.begin()
                    }
                    end() {
                        this.delegate.end && this.delegate.end()
                    }
                    whenRenderingDone() {
                        return this.delegate.whenRenderingDone ? this.delegate.whenRenderingDone() : Promise.resolve(null)
                    }
                }
                class Th {
                    constructor(e) {
                        this.delegate = e, this.debugContextFactory = Sh, this.data = this.delegate.data
                    }
                    createDebugContext(e) {
                        return this.debugContextFactory(e)
                    }
                    destroyNode(e) {
                        const t = Qc(e);
                        ! function(e) {
                            Gc.delete(e.nativeNode)
                        }(t), t instanceof Uc && (t.listeners.length = 0), this.delegate.destroyNode && this.delegate.destroyNode(e)
                    }
                    destroy() {
                        this.delegate.destroy()
                    }
                    createElement(e, t) {
                        const n = this.delegate.createElement(e, t),
                            s = this.createDebugContext(n);
                        if (s) {
                            const t = new qc(n, null, s);
                            t.name = e, Jc(t)
                        }
                        return n
                    }
                    createComment(e) {
                        const t = this.delegate.createComment(ps(e)),
                            n = this.createDebugContext(t);
                        return n && Jc(new Uc(t, null, n)), t
                    }
                    createText(e) {
                        const t = this.delegate.createText(e),
                            n = this.createDebugContext(t);
                        return n && Jc(new Uc(t, null, n)), t
                    }
                    appendChild(e, t) {
                        const n = Qc(e),
                            s = Qc(t);
                        n && s && n instanceof qc && n.addChild(s), this.delegate.appendChild(e, t)
                    }
                    insertBefore(e, t, n, s) {
                        const r = Qc(e),
                            i = Qc(t),
                            o = Qc(n);
                        r && i && r instanceof qc && r.insertBefore(o, i), this.delegate.insertBefore(e, t, n, s)
                    }
                    removeChild(e, t) {
                        const n = Qc(e),
                            s = Qc(t);
                        n && s && n instanceof qc && n.removeChild(s), this.delegate.removeChild(e, t)
                    }
                    selectRootElement(e, t) {
                        const n = this.delegate.selectRootElement(e, t),
                            s = Sh();
                        return s && Jc(new qc(n, null, s)), n
                    }
                    setAttribute(e, t, n, s) {
                        const r = Qc(e);
                        if (r && r instanceof qc) {
                            const e = s ? s + ":" + t : t;
                            r.attributes[e] = n
                        }
                        this.delegate.setAttribute(e, t, n, s)
                    }
                    removeAttribute(e, t, n) {
                        const s = Qc(e);
                        if (s && s instanceof qc) {
                            const e = n ? n + ":" + t : t;
                            s.attributes[e] = null
                        }
                        this.delegate.removeAttribute(e, t, n)
                    }
                    addClass(e, t) {
                        const n = Qc(e);
                        n && n instanceof qc && (n.classes[t] = !0), this.delegate.addClass(e, t)
                    }
                    removeClass(e, t) {
                        const n = Qc(e);
                        n && n instanceof qc && (n.classes[t] = !1), this.delegate.removeClass(e, t)
                    }
                    setStyle(e, t, n, s) {
                        const r = Qc(e);
                        r && r instanceof qc && (r.styles[t] = n), this.delegate.setStyle(e, t, n, s)
                    }
                    removeStyle(e, t, n) {
                        const s = Qc(e);
                        s && s instanceof qc && (s.styles[t] = null), this.delegate.removeStyle(e, t, n)
                    }
                    setProperty(e, t, n) {
                        const s = Qc(e);
                        s && s instanceof qc && (s.properties[t] = n), this.delegate.setProperty(e, t, n)
                    }
                    listen(e, t, n) {
                        if ("string" != typeof e) {
                            const s = Qc(e);
                            s && s.listeners.push(new Hc(t, n))
                        }
                        return this.delegate.listen(e, t, n)
                    }
                    parentNode(e) {
                        return this.delegate.parentNode(e)
                    }
                    nextSibling(e) {
                        return this.delegate.nextSibling(e)
                    }
                    setValue(e, t) {
                        return this.delegate.setValue(e, t)
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function Ah(e, t, n) {
                    return new Dh(e, t, n)
                }
                class Dh extends Eo {
                    constructor(e, t, n) {
                        super(), this.moduleType = e, this._bootstrapComponents = t, this._ngModuleDefFactory = n
                    }
                    create(e) {
                        qu();
                        const t = function(e) {
                            const t = Array.from(e.providers),
                                n = Array.from(e.modules),
                                s = {};
                            for (const r in e.providersByKey) s[r] = e.providersByKey[r];
                            return {
                                factory: e.factory,
                                scope: e.scope,
                                providers: t,
                                modules: n,
                                providersByKey: s
                            }
                        }(oa(this._ngModuleDefFactory));
                        return Fo.createNgModuleRef(this.moduleType, e || Ar.NULL, this._bootstrapComponents, t)
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
            }).call(this, n("yLpj"))
        },
        "8oxB": function(e, t) {
            var n, s, r = e.exports = {};

            function i() {
                throw new Error("setTimeout has not been defined")
            }

            function o() {
                throw new Error("clearTimeout has not been defined")
            }

            function a(e) {
                if (n === setTimeout) return setTimeout(e, 0);
                if ((n === i || !n) && setTimeout) return n = setTimeout, setTimeout(e, 0);
                try {
                    return n(e, 0)
                } catch (t) {
                    try {
                        return n.call(null, e, 0)
                    } catch (t) {
                        return n.call(this, e, 0)
                    }
                }
            }! function() {
                try {
                    n = "function" == typeof setTimeout ? setTimeout : i
                } catch (e) {
                    n = i
                }
                try {
                    s = "function" == typeof clearTimeout ? clearTimeout : o
                } catch (e) {
                    s = o
                }
            }();
            var l, c = [],
                u = !1,
                h = -1;

            function p() {
                u && l && (u = !1, l.length ? c = l.concat(c) : h = -1, c.length && d())
            }

            function d() {
                if (!u) {
                    var e = a(p);
                    u = !0;
                    for (var t = c.length; t;) {
                        for (l = c, c = []; ++h < t;) l && l[h].run();
                        h = -1, t = c.length
                    }
                    l = null, u = !1,
                        function(e) {
                            if (s === clearTimeout) return clearTimeout(e);
                            if ((s === o || !s) && clearTimeout) return s = clearTimeout, clearTimeout(e);
                            try {
                                s(e)
                            } catch (t) {
                                try {
                                    return s.call(null, e)
                                } catch (t) {
                                    return s.call(this, e)
                                }
                            }
                        }(e)
                }
            }

            function f(e, t) {
                this.fun = e, this.array = t
            }

            function m() {}
            r.nextTick = function(e) {
                var t = new Array(arguments.length - 1);
                if (arguments.length > 1)
                    for (var n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
                c.push(new f(e, t)), 1 !== c.length || u || a(d)
            }, f.prototype.run = function() {
                this.fun.apply(null, this.array)
            }, r.title = "browser", r.browser = !0, r.env = {}, r.argv = [], r.version = "", r.versions = {}, r.on = m, r.addListener = m, r.once = m, r.off = m, r.removeListener = m, r.removeAllListeners = m, r.emit = m, r.prependListener = m, r.prependOnceListener = m, r.listeners = function(e) {
                return []
            }, r.binding = function(e) {
                throw new Error("process.binding is not supported")
            }, r.cwd = function() {
                return "/"
            }, r.chdir = function(e) {
                throw new Error("process.chdir is not supported")
            }, r.umask = function() {
                return 0
            }
        },
        "8zgK": function(e, t, n) {
            "use strict";
            e.exports = function(e) {
                return null !== e && "object" == typeof e
            }
        },
        "9ppp": function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return s
            });
            const s = (() => {
                function e() {
                    return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this
                }
                return e.prototype = Object.create(Error.prototype), e
            })()
        },
        AM7I: function(e, t, n) {
            "use strict";
            var s, r = SyntaxError,
                i = Function,
                o = TypeError,
                a = function(e) {
                    try {
                        return i('"use strict"; return (' + e + ").constructor;")()
                    } catch (t) {}
                },
                l = Object.getOwnPropertyDescriptor;
            if (l) try {
                l({}, "")
            } catch (P) {
                l = null
            }
            var c = function() {
                    throw new o
                },
                u = l ? function() {
                    try {
                        return arguments.callee, c
                    } catch (e) {
                        try {
                            return l(arguments, "callee").get
                        } catch (t) {
                            return c
                        }
                    }
                }() : c,
                h = n("UVaH")(),
                p = Object.getPrototypeOf || function(e) {
                    return e.__proto__
                },
                d = {},
                f = "undefined" == typeof Uint8Array ? s : p(Uint8Array),
                m = {
                    "%AggregateError%": "undefined" == typeof AggregateError ? s : AggregateError,
                    "%Array%": Array,
                    "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? s : ArrayBuffer,
                    "%ArrayIteratorPrototype%": h ? p([][Symbol.iterator]()) : s,
                    "%AsyncFromSyncIteratorPrototype%": s,
                    "%AsyncFunction%": d,
                    "%AsyncGenerator%": d,
                    "%AsyncGeneratorFunction%": d,
                    "%AsyncIteratorPrototype%": d,
                    "%Atomics%": "undefined" == typeof Atomics ? s : Atomics,
                    "%BigInt%": "undefined" == typeof BigInt ? s : BigInt,
                    "%Boolean%": Boolean,
                    "%DataView%": "undefined" == typeof DataView ? s : DataView,
                    "%Date%": Date,
                    "%decodeURI%": decodeURI,
                    "%decodeURIComponent%": decodeURIComponent,
                    "%encodeURI%": encodeURI,
                    "%encodeURIComponent%": encodeURIComponent,
                    "%Error%": Error,
                    "%eval%": eval,
                    "%EvalError%": EvalError,
                    "%Float32Array%": "undefined" == typeof Float32Array ? s : Float32Array,
                    "%Float64Array%": "undefined" == typeof Float64Array ? s : Float64Array,
                    "%FinalizationRegistry%": "undefined" == typeof FinalizationRegistry ? s : FinalizationRegistry,
                    "%Function%": i,
                    "%GeneratorFunction%": d,
                    "%Int8Array%": "undefined" == typeof Int8Array ? s : Int8Array,
                    "%Int16Array%": "undefined" == typeof Int16Array ? s : Int16Array,
                    "%Int32Array%": "undefined" == typeof Int32Array ? s : Int32Array,
                    "%isFinite%": isFinite,
                    "%isNaN%": isNaN,
                    "%IteratorPrototype%": h ? p(p([][Symbol.iterator]())) : s,
                    "%JSON%": "object" == typeof JSON ? JSON : s,
                    "%Map%": "undefined" == typeof Map ? s : Map,
                    "%MapIteratorPrototype%": "undefined" != typeof Map && h ? p((new Map)[Symbol.iterator]()) : s,
                    "%Math%": Math,
                    "%Number%": Number,
                    "%Object%": Object,
                    "%parseFloat%": parseFloat,
                    "%parseInt%": parseInt,
                    "%Promise%": "undefined" == typeof Promise ? s : Promise,
                    "%Proxy%": "undefined" == typeof Proxy ? s : Proxy,
                    "%RangeError%": RangeError,
                    "%ReferenceError%": ReferenceError,
                    "%Reflect%": "undefined" == typeof Reflect ? s : Reflect,
                    "%RegExp%": RegExp,
                    "%Set%": "undefined" == typeof Set ? s : Set,
                    "%SetIteratorPrototype%": "undefined" != typeof Set && h ? p((new Set)[Symbol.iterator]()) : s,
                    "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? s : SharedArrayBuffer,
                    "%String%": String,
                    "%StringIteratorPrototype%": h ? p("" [Symbol.iterator]()) : s,
                    "%Symbol%": h ? Symbol : s,
                    "%SyntaxError%": r,
                    "%ThrowTypeError%": u,
                    "%TypedArray%": f,
                    "%TypeError%": o,
                    "%Uint8Array%": "undefined" == typeof Uint8Array ? s : Uint8Array,
                    "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? s : Uint8ClampedArray,
                    "%Uint16Array%": "undefined" == typeof Uint16Array ? s : Uint16Array,
                    "%Uint32Array%": "undefined" == typeof Uint32Array ? s : Uint32Array,
                    "%URIError%": URIError,
                    "%WeakMap%": "undefined" == typeof WeakMap ? s : WeakMap,
                    "%WeakRef%": "undefined" == typeof WeakRef ? s : WeakRef,
                    "%WeakSet%": "undefined" == typeof WeakSet ? s : WeakSet
                },
                g = function e(t) {
                    var n;
                    if ("%AsyncFunction%" === t) n = a("async function () {}");
                    else if ("%GeneratorFunction%" === t) n = a("function* () {}");
                    else if ("%AsyncGeneratorFunction%" === t) n = a("async function* () {}");
                    else if ("%AsyncGenerator%" === t) {
                        var s = e("%AsyncGeneratorFunction%");
                        s && (n = s.prototype)
                    } else if ("%AsyncIteratorPrototype%" === t) {
                        var r = e("%AsyncGenerator%");
                        r && (n = p(r.prototype))
                    }
                    return m[t] = n, n
                },
                y = {
                    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
                    "%ArrayPrototype%": ["Array", "prototype"],
                    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
                    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
                    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
                    "%ArrayProto_values%": ["Array", "prototype", "values"],
                    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
                    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
                    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
                    "%BooleanPrototype%": ["Boolean", "prototype"],
                    "%DataViewPrototype%": ["DataView", "prototype"],
                    "%DatePrototype%": ["Date", "prototype"],
                    "%ErrorPrototype%": ["Error", "prototype"],
                    "%EvalErrorPrototype%": ["EvalError", "prototype"],
                    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
                    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
                    "%FunctionPrototype%": ["Function", "prototype"],
                    "%Generator%": ["GeneratorFunction", "prototype"],
                    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
                    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
                    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
                    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
                    "%JSONParse%": ["JSON", "parse"],
                    "%JSONStringify%": ["JSON", "stringify"],
                    "%MapPrototype%": ["Map", "prototype"],
                    "%NumberPrototype%": ["Number", "prototype"],
                    "%ObjectPrototype%": ["Object", "prototype"],
                    "%ObjProto_toString%": ["Object", "prototype", "toString"],
                    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
                    "%PromisePrototype%": ["Promise", "prototype"],
                    "%PromiseProto_then%": ["Promise", "prototype", "then"],
                    "%Promise_all%": ["Promise", "all"],
                    "%Promise_reject%": ["Promise", "reject"],
                    "%Promise_resolve%": ["Promise", "resolve"],
                    "%RangeErrorPrototype%": ["RangeError", "prototype"],
                    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
                    "%RegExpPrototype%": ["RegExp", "prototype"],
                    "%SetPrototype%": ["Set", "prototype"],
                    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
                    "%StringPrototype%": ["String", "prototype"],
                    "%SymbolPrototype%": ["Symbol", "prototype"],
                    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
                    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
                    "%TypeErrorPrototype%": ["TypeError", "prototype"],
                    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
                    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
                    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
                    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
                    "%URIErrorPrototype%": ["URIError", "prototype"],
                    "%WeakMapPrototype%": ["WeakMap", "prototype"],
                    "%WeakSetPrototype%": ["WeakSet", "prototype"]
                },
                v = n("D3zA"),
                _ = n("oNNP"),
                b = v.call(Function.call, Array.prototype.concat),
                w = v.call(Function.apply, Array.prototype.splice),
                E = v.call(Function.call, String.prototype.replace),
                C = v.call(Function.call, String.prototype.slice),
                S = v.call(Function.call, RegExp.prototype.exec),
                x = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
                T = /\\(\\)?/g,
                A = function(e) {
                    var t = C(e, 0, 1),
                        n = C(e, -1);
                    if ("%" === t && "%" !== n) throw new r("invalid intrinsic syntax, expected closing `%`");
                    if ("%" === n && "%" !== t) throw new r("invalid intrinsic syntax, expected opening `%`");
                    var s = [];
                    return E(e, x, function(e, t, n, r) {
                        s[s.length] = n ? E(r, T, "$1") : t || e
                    }), s
                },
                D = function(e, t) {
                    var n, s = e;
                    if (_(y, s) && (s = "%" + (n = y[s])[0] + "%"), _(m, s)) {
                        var i = m[s];
                        if (i === d && (i = g(s)), void 0 === i && !t) throw new o("intrinsic " + e + " exists, but is not available. Please file an issue!");
                        return {
                            alias: n,
                            name: s,
                            value: i
                        }
                    }
                    throw new r("intrinsic " + e + " does not exist!")
                };
            e.exports = function(e, t) {
                if ("string" != typeof e || 0 === e.length) throw new o("intrinsic name must be a non-empty string");
                if (arguments.length > 1 && "boolean" != typeof t) throw new o('"allowMissing" argument must be a boolean');
                if (null === S(/^%?[^%]*%?$/, e)) throw new r("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
                var n = A(e),
                    s = n.length > 0 ? n[0] : "",
                    i = D("%" + s + "%", t),
                    a = i.name,
                    c = i.value,
                    u = !1,
                    h = i.alias;
                h && (s = h[0], w(n, b([0, 1], h)));
                for (var p = 1, d = !0; p < n.length; p += 1) {
                    var f = n[p],
                        g = C(f, 0, 1),
                        y = C(f, -1);
                    if (('"' === g || "'" === g || "`" === g || '"' === y || "'" === y || "`" === y) && g !== y) throw new r("property names with quotes must have matching quotes");
                    if ("constructor" !== f && d || (u = !0), _(m, a = "%" + (s += "." + f) + "%")) c = m[a];
                    else if (null != c) {
                        if (!(f in c)) {
                            if (!t) throw new o("base intrinsic for " + e + " exists, but the property is not available.");
                            return
                        }
                        if (l && p + 1 >= n.length) {
                            var v = l(c, f);
                            c = (d = !!v) && "get" in v && !("originalValue" in v.get) ? v.get : c[f]
                        } else d = _(c, f), c = c[f];
                        d && !u && (m[a] = c)
                    }
                }
                return c
            }
        },
        BhAj: function(e, t, n) {
            "use strict";
            e.exports = (e, t, n) => {
                "function" != typeof n || e[t] || (e[t] = n)
            }
        },
        Cfvw: function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return p
            });
            var s = n("HDdC"),
                r = n("SeVD"),
                i = n("quSY"),
                o = n("kJWO");
            var a = n("jZKg"),
                l = n("Lhse");
            var c = n("c2HN"),
                u = n("I55L");

            function h(e, t) {
                if (null != e) {
                    if (function(e) {
                            return e && "function" == typeof e[o.a]
                        }(e)) return function(e, t) {
                        return new s.a(n => {
                            const s = new i.a;
                            return s.add(t.schedule(() => {
                                const r = e[o.a]();
                                s.add(r.subscribe({
                                    next(e) {
                                        s.add(t.schedule(() => n.next(e)))
                                    },
                                    error(e) {
                                        s.add(t.schedule(() => n.error(e)))
                                    },
                                    complete() {
                                        s.add(t.schedule(() => n.complete()))
                                    }
                                }))
                            })), s
                        })
                    }(e, t);
                    if (Object(c.a)(e)) return function(e, t) {
                        return new s.a(n => {
                            const s = new i.a;
                            return s.add(t.schedule(() => e.then(e => {
                                s.add(t.schedule(() => {
                                    n.next(e), s.add(t.schedule(() => n.complete()))
                                }))
                            }, e => {
                                s.add(t.schedule(() => n.error(e)))
                            }))), s
                        })
                    }(e, t);
                    if (Object(u.a)(e)) return Object(a.a)(e, t);
                    if (function(e) {
                            return e && "function" == typeof e[l.a]
                        }(e) || "string" == typeof e) return function(e, t) {
                        if (!e) throw new Error("Iterable cannot be null");
                        return new s.a(n => {
                            const s = new i.a;
                            let r;
                            return s.add(() => {
                                r && "function" == typeof r.return && r.return()
                            }), s.add(t.schedule(() => {
                                r = e[l.a](), s.add(t.schedule(function() {
                                    if (n.closed) return;
                                    let e, t;
                                    try {
                                        const n = r.next();
                                        e = n.value, t = n.done
                                    } catch (s) {
                                        return void n.error(s)
                                    }
                                    t ? n.complete() : (n.next(e), this.schedule())
                                }))
                            })), s
                        })
                    }(e, t)
                }
                throw new TypeError((null !== e && typeof e || e) + " is not observable")
            }

            function p(e, t) {
                return t ? h(e, t) : e instanceof s.a ? e : new s.a(Object(r.a)(e))
            }
        },
        CuLW: function(e) {
            e.exports = JSON.parse('{"/":{"namespace":"","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"context":{}}}]},"/oembed/1.0":{"namespace":"oembed/1.0","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"namespace":{},"context":{}}}]},"/oembed/1.0/embed":{"namespace":"oembed/1.0","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"url":{},"format":{},"maxwidth":{}}}]},"/oembed/1.0/proxy":{"namespace":"oembed/1.0","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"url":{},"format":{},"maxwidth":{},"maxheight":{},"discover":{}}}]},"/wp/v2":{"namespace":"wp/v2","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"namespace":{},"context":{}}}]},"/wp/v2/posts":{"namespace":"wp/v2","methods":["GET","POST"],"endpoints":[{"methods":["GET"],"args":{"context":{},"page":{},"per_page":{},"search":{},"after":{},"author":{},"author_exclude":{},"before":{},"exclude":{},"include":{},"offset":{},"order":{},"orderby":{},"slug":{},"status":{},"categories":{},"categories_exclude":{},"tags":{},"tags_exclude":{},"sticky":{}}},{"methods":["POST"],"args":{}}]},"/wp/v2/posts/(?P<id>[\\\\d]+)":{"namespace":"wp/v2","methods":["GET","POST","PUT","PATCH","DELETE"],"endpoints":[{"methods":["GET"],"args":{"id":{},"context":{},"password":{}}},{"methods":["POST","PUT","PATCH"],"args":{}},{"methods":["DELETE"],"args":{}}]},"/wp/v2/posts/(?P<parent>[\\\\d]+)/revisions":{"namespace":"wp/v2","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"parent":{},"context":{},"page":{},"per_page":{},"search":{},"exclude":{},"include":{},"offset":{},"order":{},"orderby":{}}}]},"/wp/v2/posts/(?P<parent>[\\\\d]+)/revisions/(?P<id>[\\\\d]+)":{"namespace":"wp/v2","methods":["GET","DELETE"],"endpoints":[{"methods":["GET"],"args":{"parent":{},"id":{},"context":{}}},{"methods":["DELETE"],"args":{}}]},"/wp/v2/posts/(?P<id>[\\\\d]+)/autosaves":{"namespace":"wp/v2","methods":["GET","POST"],"endpoints":[{"methods":["GET"],"args":{"parent":{},"context":{}}},{"methods":["POST"],"args":{}}]},"/wp/v2/posts/(?P<parent>[\\\\d]+)/autosaves/(?P<id>[\\\\d]+)":{"namespace":"wp/v2","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"parent":{},"id":{},"context":{}}}]},"/wp/v2/pages":{"namespace":"wp/v2","methods":["GET","POST"],"endpoints":[{"methods":["GET"],"args":{"context":{},"page":{},"per_page":{},"search":{},"after":{},"author":{},"author_exclude":{},"before":{},"exclude":{},"include":{},"menu_order":{},"offset":{},"order":{},"orderby":{},"parent":{},"parent_exclude":{},"slug":{},"status":{}}},{"methods":["POST"],"args":{}}]},"/wp/v2/pages/(?P<id>[\\\\d]+)":{"namespace":"wp/v2","methods":["GET","POST","PUT","PATCH","DELETE"],"endpoints":[{"methods":["GET"],"args":{"id":{},"context":{},"password":{}}},{"methods":["POST","PUT","PATCH"],"args":{}},{"methods":["DELETE"],"args":{}}]},"/wp/v2/pages/(?P<parent>[\\\\d]+)/revisions":{"namespace":"wp/v2","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"parent":{},"context":{},"page":{},"per_page":{},"search":{},"exclude":{},"include":{},"offset":{},"order":{},"orderby":{}}}]},"/wp/v2/pages/(?P<parent>[\\\\d]+)/revisions/(?P<id>[\\\\d]+)":{"namespace":"wp/v2","methods":["GET","DELETE"],"endpoints":[{"methods":["GET"],"args":{"parent":{},"id":{},"context":{}}},{"methods":["DELETE"],"args":{}}]},"/wp/v2/pages/(?P<id>[\\\\d]+)/autosaves":{"namespace":"wp/v2","methods":["GET","POST"],"endpoints":[{"methods":["GET"],"args":{"parent":{},"context":{}}},{"methods":["POST"],"args":{}}]},"/wp/v2/pages/(?P<parent>[\\\\d]+)/autosaves/(?P<id>[\\\\d]+)":{"namespace":"wp/v2","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"parent":{},"id":{},"context":{}}}]},"/wp/v2/media":{"namespace":"wp/v2","methods":["GET","POST"],"endpoints":[{"methods":["GET"],"args":{"context":{},"page":{},"per_page":{},"search":{},"after":{},"author":{},"author_exclude":{},"before":{},"exclude":{},"include":{},"offset":{},"order":{},"orderby":{},"parent":{},"parent_exclude":{},"slug":{},"status":{},"media_type":{},"mime_type":{}}},{"methods":["POST"],"args":{}}]},"/wp/v2/media/(?P<id>[\\\\d]+)":{"namespace":"wp/v2","methods":["GET","POST","PUT","PATCH","DELETE"],"endpoints":[{"methods":["GET"],"args":{"id":{},"context":{}}},{"methods":["POST","PUT","PATCH"],"args":{}},{"methods":["DELETE"],"args":{}}]},"/wp/v2/blocks":{"namespace":"wp/v2","methods":["GET","POST"],"endpoints":[{"methods":["GET"],"args":{"context":{},"page":{},"per_page":{},"search":{},"after":{},"before":{},"exclude":{},"include":{},"offset":{},"order":{},"orderby":{},"slug":{},"status":{}}},{"methods":["POST"],"args":{}}]},"/wp/v2/blocks/(?P<id>[\\\\d]+)":{"namespace":"wp/v2","methods":["GET","POST","PUT","PATCH","DELETE"],"endpoints":[{"methods":["GET"],"args":{"id":{},"context":{},"password":{}}},{"methods":["POST","PUT","PATCH"],"args":{}},{"methods":["DELETE"],"args":{}}]},"/wp/v2/blocks/(?P<id>[\\\\d]+)/autosaves":{"namespace":"wp/v2","methods":["GET","POST"],"endpoints":[{"methods":["GET"],"args":{"parent":{},"context":{}}},{"methods":["POST"],"args":{}}]},"/wp/v2/blocks/(?P<parent>[\\\\d]+)/autosaves/(?P<id>[\\\\d]+)":{"namespace":"wp/v2","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"parent":{},"id":{},"context":{}}}]},"/wp/v2/types":{"namespace":"wp/v2","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"context":{}}}]},"/wp/v2/types/(?P<type>[\\\\w-]+)":{"namespace":"wp/v2","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"type":{},"context":{}}}]},"/wp/v2/statuses":{"namespace":"wp/v2","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"context":{}}}]},"/wp/v2/statuses/(?P<status>[\\\\w-]+)":{"namespace":"wp/v2","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"status":{},"context":{}}}]},"/wp/v2/taxonomies":{"namespace":"wp/v2","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"context":{},"type":{}}}]},"/wp/v2/taxonomies/(?P<taxonomy>[\\\\w-]+)":{"namespace":"wp/v2","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"taxonomy":{},"context":{}}}]},"/wp/v2/categories":{"namespace":"wp/v2","methods":["GET","POST"],"endpoints":[{"methods":["GET"],"args":{"context":{},"page":{},"per_page":{},"search":{},"exclude":{},"include":{},"order":{},"orderby":{},"hide_empty":{},"parent":{},"post":{},"slug":{}}},{"methods":["POST"],"args":{}}]},"/wp/v2/categories/(?P<id>[\\\\d]+)":{"namespace":"wp/v2","methods":["GET","POST","PUT","PATCH","DELETE"],"endpoints":[{"methods":["GET"],"args":{"id":{},"context":{}}},{"methods":["POST","PUT","PATCH"],"args":{}},{"methods":["DELETE"],"args":{}}]},"/wp/v2/tags":{"namespace":"wp/v2","methods":["GET","POST"],"endpoints":[{"methods":["GET"],"args":{"context":{},"page":{},"per_page":{},"search":{},"exclude":{},"include":{},"offset":{},"order":{},"orderby":{},"hide_empty":{},"post":{},"slug":{}}},{"methods":["POST"],"args":{}}]},"/wp/v2/tags/(?P<id>[\\\\d]+)":{"namespace":"wp/v2","methods":["GET","POST","PUT","PATCH","DELETE"],"endpoints":[{"methods":["GET"],"args":{"id":{},"context":{}}},{"methods":["POST","PUT","PATCH"],"args":{}},{"methods":["DELETE"],"args":{}}]},"/wp/v2/users":{"namespace":"wp/v2","methods":["GET","POST"],"endpoints":[{"methods":["GET"],"args":{"context":{},"page":{},"per_page":{},"search":{},"exclude":{},"include":{},"offset":{},"order":{},"orderby":{},"slug":{},"roles":{},"who":{}}},{"methods":["POST"],"args":{}}]},"/wp/v2/users/(?P<id>[\\\\d]+)":{"namespace":"wp/v2","methods":["GET","POST","PUT","PATCH","DELETE"],"endpoints":[{"methods":["GET"],"args":{"id":{},"context":{}}},{"methods":["POST","PUT","PATCH"],"args":{}},{"methods":["DELETE"],"args":{}}]},"/wp/v2/users/me":{"namespace":"wp/v2","methods":["GET","POST","PUT","PATCH","DELETE"],"endpoints":[{"methods":["GET"],"args":{"context":{}}},{"methods":["POST","PUT","PATCH"],"args":{}},{"methods":["DELETE"],"args":{}}]},"/wp/v2/comments":{"namespace":"wp/v2","methods":["GET","POST"],"endpoints":[{"methods":["GET"],"args":{"context":{},"page":{},"per_page":{},"search":{},"after":{},"author":{},"author_exclude":{},"author_email":{},"before":{},"exclude":{},"include":{},"offset":{},"order":{},"orderby":{},"parent":{},"parent_exclude":{},"post":{},"status":{},"type":{},"password":{}}},{"methods":["POST"],"args":{}}]},"/wp/v2/comments/(?P<id>[\\\\d]+)":{"namespace":"wp/v2","methods":["GET","POST","PUT","PATCH","DELETE"],"endpoints":[{"methods":["GET"],"args":{"id":{},"context":{},"password":{}}},{"methods":["POST","PUT","PATCH"],"args":{}},{"methods":["DELETE"],"args":{}}]},"/wp/v2/search":{"namespace":"wp/v2","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"context":{},"page":{},"per_page":{},"search":{},"type":{},"subtype":{}}}]},"/wp/v2/block-renderer/(?P<name>core/block)":{"namespace":"wp/v2","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"name":{},"context":{},"attributes":{},"post_id":{}}}]},"/wp/v2/block-renderer/(?P<name>core/latest-comments)":{"namespace":"wp/v2","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"name":{},"context":{},"attributes":{},"post_id":{}}}]},"/wp/v2/block-renderer/(?P<name>core/archives)":{"namespace":"wp/v2","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"name":{},"context":{},"attributes":{},"post_id":{}}}]},"/wp/v2/block-renderer/(?P<name>core/categories)":{"namespace":"wp/v2","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"name":{},"context":{},"attributes":{},"post_id":{}}}]},"/wp/v2/block-renderer/(?P<name>core/latest-posts)":{"namespace":"wp/v2","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"name":{},"context":{},"attributes":{},"post_id":{}}}]},"/wp/v2/block-renderer/(?P<name>core/shortcode)":{"namespace":"wp/v2","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"name":{},"context":{},"attributes":{},"post_id":{}}}]},"/wp/v2/settings":{"namespace":"wp/v2","methods":["GET","POST","PUT","PATCH"],"endpoints":[{"methods":["GET"],"args":{}},{"methods":["POST","PUT","PATCH"],"args":{}}]},"/wp/v2/themes":{"namespace":"wp/v2","methods":["GET"],"endpoints":[{"methods":["GET"],"args":{"context":{},"page":{},"per_page":{},"search":{},"status":{}}}]}}')
        },
        D3zA: function(e, t, n) {
            "use strict";
            var s = n("aI7X");
            e.exports = Function.prototype.bind || s
        },
        DH7j: function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return s
            });
            const s = Array.isArray || (e => e && "number" == typeof e.length)
        },
        E58G: function(e, t, n) {
            "use strict";
            const s = n("24Ii"),
                r = n("/fTC").parse,
                i = n("ml1J"),
                o = n("U8la"),
                a = n("iJE/"),
                l = n("Gm0T");

            function c(e, t) {
                return t.headers ? a(t.headers, (e, t, n) => e.set(n, t), e) : e
            }

            function u(e, t, n) {
                if (!n && !t.auth && !t.nonce) return e;
                if (t.nonce) return e.set("X-WP-Nonce", t.nonce), e;
                const s = t.username,
                    r = t.password;
                return s && r ? e.auth(s, r) : e
            }

            function h(e, t, n) {
                return new Promise((t, n) => {
                    e.end((e, s) => {
                        e || s.error ? n(e || s.error) : t(s)
                    })
                }).then(n).then(e => (t && "function" == typeof t && t(null, e), e), e => {
                    if (e.response && e.response.body && e.response.body.code && (e = e.response.body), !t || "function" != typeof t) throw e;
                    t(e)
                })
            }

            function p(e, t) {
                const n = function(e) {
                        let t = e.body;
                        if (l(t) && "text/html" === e.type) try {
                            t = JSON.parse(e.text)
                        } catch (n) {}
                        return t
                    }(t),
                    s = function(e, t, n) {
                        let s = null;
                        if (!e.headers) return s;
                        if (Object.keys(e.headers).forEach(t => {
                                e.headers[t.toLowerCase()] = e.headers[t]
                            }), !e.headers["x-wp-totalpages"]) return s;
                        const o = +e.headers["x-wp-totalpages"];
                        if (!o || 0 === o) return s;
                        const a = e.headers.link ? r(e.headers.link) : {};
                        return s = {
                            total: +e.headers["x-wp-total"],
                            totalPages: o,
                            links: a
                        }, a.next && (s.next = new i({ ...t,
                            transport: n,
                            endpoint: a.next
                        })), a.prev && (s.prev = new i({ ...t,
                            transport: n,
                            endpoint: a.prev
                        })), s
                    }(t, e._options, e.transport);
                return s && (n._paging = s), n
            }

            function d(e) {
                return e.headers
            }
            e.exports = {
                delete: function(e, t, n) {
                    n || "function" != typeof t || (n = t, t = null), o("delete", e);
                    const r = e.toString();
                    let i = u(s.del(r), e._options, !0).send(t);
                    return i = c(i, e._options), h(i, n, p.bind(null, e))
                },
                get: function(e, t) {
                    o("get", e);
                    const n = e.toString();
                    let r = u(s.get(n), e._options);
                    return r = c(r, e._options), h(r, t, p.bind(null, e))
                },
                head: function(e, t) {
                    o("head", e);
                    const n = e.toString();
                    let r = u(s.head(n), e._options);
                    return r = c(r, e._options), h(r, t, d)
                },
                post: function(e, t, n) {
                    o("post", e);
                    const r = e.toString();
                    t = t || {};
                    let i = u(s.post(r), e._options, !0);
                    return i = c(i, e._options), i = e._attachment ? a(t, (e, t, n) => e.field(n, t), i.attach("file", e._attachment, e._attachmentName)) : i.send(t), h(i, n, p.bind(null, e))
                },
                put: function(e, t, n) {
                    o("put", e);
                    const r = e.toString();
                    t = t || {};
                    let i = u(s.put(r), e._options, !0).send(t);
                    return i = c(i, e._options), h(i, n, p.bind(null, e))
                }
            }
        },
        EI6l: function(e, t, n) {
            (function(n) {
                var s, r, i; /*! smooth-scroll v12.1.5 | (c) 2017 Chris Ferdinandi | MIT License | http://github.com/cferdinandi/smooth-scroll */
                i = void 0 !== n ? n : "undefined" != typeof window ? window : this, s = [], void 0 === (r = (function() {
                    return function(e) {
                        "use strict";
                        var t = "querySelector" in document && "addEventListener" in e && "requestAnimationFrame" in e && "closest" in e.Element.prototype,
                            n = {
                                ignore: "[data-scroll-ignore]",
                                header: null,
                                speed: 500,
                                offset: 0,
                                easing: "easeInOutCubic",
                                customEasing: null,
                                before: function() {},
                                after: function() {}
                            },
                            s = function() {
                                for (var e = {}, t = 0, n = arguments.length; t < n; t++) ! function(t) {
                                    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n])
                                }(arguments[t]);
                                return e
                            },
                            r = function(t) {
                                return parseInt(e.getComputedStyle(t).height, 10)
                            },
                            i = function(e) {
                                "#" === e.charAt(0) && (e = e.substr(1));
                                for (var t, n = String(e), s = n.length, r = -1, i = "", o = n.charCodeAt(0); ++r < s;) {
                                    if (0 === (t = n.charCodeAt(r))) throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
                                    i += t >= 1 && t <= 31 || 127 == t || 0 === r && t >= 48 && t <= 57 || 1 === r && t >= 48 && t <= 57 && 45 === o ? "\\" + t.toString(16) + " " : t >= 128 || 45 === t || 95 === t || t >= 48 && t <= 57 || t >= 65 && t <= 90 || t >= 97 && t <= 122 ? n.charAt(r) : "\\" + n.charAt(r)
                                }
                                return "#" + i
                            },
                            o = function(e, t) {
                                var n;
                                return "easeInQuad" === e.easing && (n = t * t), "easeOutQuad" === e.easing && (n = t * (2 - t)), "easeInOutQuad" === e.easing && (n = t < .5 ? 2 * t * t : (4 - 2 * t) * t - 1), "easeInCubic" === e.easing && (n = t * t * t), "easeOutCubic" === e.easing && (n = --t * t * t + 1), "easeInOutCubic" === e.easing && (n = t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1), "easeInQuart" === e.easing && (n = t * t * t * t), "easeOutQuart" === e.easing && (n = 1 - --t * t * t * t), "easeInOutQuart" === e.easing && (n = t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t), "easeInQuint" === e.easing && (n = t * t * t * t * t), "easeOutQuint" === e.easing && (n = 1 + --t * t * t * t * t), "easeInOutQuint" === e.easing && (n = t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t), e.customEasing && (n = e.customEasing(t)), n || t
                            },
                            a = function() {
                                return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight)
                            },
                            l = function(e, t, n) {
                                var s = 0;
                                if (e.offsetParent)
                                    do {
                                        s += e.offsetTop, e = e.offsetParent
                                    } while (e);
                                return Math.max(s - t - n, 0)
                            },
                            c = function(e) {
                                return e ? r(e) + e.offsetTop : 0
                            },
                            u = function(t, n, s) {
                                s || (t.focus(), document.activeElement.id !== t.id && (t.setAttribute("tabindex", "-1"), t.focus(), t.style.outline = "none"), e.scrollTo(0, n))
                            },
                            h = function(t) {
                                return !(!("matchMedia" in e) || !e.matchMedia("(prefers-reduced-motion)").matches)
                            };
                        return function(r, p) {
                            var d, f, m, g, y, v, _, b = {
                                    cancelScroll: function() {
                                        cancelAnimationFrame(_)
                                    },
                                    animateScroll: function(t, r, i) {
                                        var h = s(d || n, i || {}),
                                            p = "[object Number]" === Object.prototype.toString.call(t),
                                            f = p || !t.tagName ? null : t;
                                        if (p || f) {
                                            var m = e.pageYOffset;
                                            h.header && !g && (g = document.querySelector(h.header)), y || (y = c(g));
                                            var v, _, w, E = p ? t : l(f, y, parseInt("function" == typeof h.offset ? h.offset() : h.offset, 10)),
                                                C = E - m,
                                                S = a(),
                                                x = 0,
                                                T = function(n, s) {
                                                    var i = e.pageYOffset;
                                                    if (n == s || i == s || (m < s && e.innerHeight + i) >= S) return b.cancelScroll(), u(t, s, p), h.after(t, r), v = null, !0
                                                },
                                                A = function(t) {
                                                    v || (v = t), _ = (x += t - v) / parseInt(h.speed, 10), w = m + C * o(h, _ = _ > 1 ? 1 : _), e.scrollTo(0, Math.floor(w)), T(w, E) || (e.requestAnimationFrame(A), v = t)
                                                };
                                            0 === e.pageYOffset && e.scrollTo(0, 0), h.before(t, r), b.cancelScroll(), e.requestAnimationFrame(A)
                                        }
                                    }
                                },
                                w = function(e) {
                                    f && (f.id = f.getAttribute("data-scroll-id"), b.animateScroll(f, m), f = null, m = null)
                                },
                                E = function(t) {
                                    if (!h() && 0 === t.button && !t.metaKey && !t.ctrlKey && (m = t.target.closest(r)) && "a" === m.tagName.toLowerCase() && !t.target.closest(d.ignore) && m.hostname === e.location.hostname && m.pathname === e.location.pathname && /#/.test(m.href)) {
                                        var n;
                                        try {
                                            n = i(decodeURIComponent(m.hash))
                                        } catch (e) {
                                            n = i(m.hash)
                                        }
                                        if ("#" === n) {
                                            t.preventDefault();
                                            var s = (f = document.body).id ? f.id : "smooth-scroll-top";
                                            return f.setAttribute("data-scroll-id", s), f.id = "", void(e.location.hash.substring(1) === s ? w() : e.location.hash = s)
                                        }(f = document.querySelector(n)) && (f.setAttribute("data-scroll-id", f.id), f.id = "", m.hash === e.location.hash && (t.preventDefault(), w()))
                                    }
                                },
                                C = function(e) {
                                    v || (v = setTimeout(function() {
                                        v = null, y = c(g)
                                    }, 66))
                                };
                            return b.destroy = function() {
                                d && (document.removeEventListener("click", E, !1), e.removeEventListener("resize", C, !1), b.cancelScroll(), d = null, f = null, m = null, g = null, y = null, v = null, _ = null)
                            }, b.init = function(r) {
                                t && (b.destroy(), d = s(n, r || {}), g = d.header ? document.querySelector(d.header) : null, y = c(g), document.addEventListener("click", E, !1), e.addEventListener("hashchange", w, !1), g && e.addEventListener("resize", C, !1))
                            }, b.init(p), b
                        }
                    }(i)
                }).apply(t, s)) || (e.exports = r)
            }).call(this, n("yLpj"))
        },
        FpZJ: function(e, t, n) {
            "use strict";
            e.exports = function() {
                if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols) return !1;
                if ("symbol" == typeof Symbol.iterator) return !0;
                var e = {},
                    t = Symbol("test"),
                    n = Object(t);
                if ("string" == typeof t) return !1;
                if ("[object Symbol]" !== Object.prototype.toString.call(t)) return !1;
                if ("[object Symbol]" !== Object.prototype.toString.call(n)) return !1;
                for (t in e[t] = 42, e) return !1;
                if ("function" == typeof Object.keys && 0 !== Object.keys(e).length) return !1;
                if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(e).length) return !1;
                var s = Object.getOwnPropertySymbols(e);
                if (1 !== s.length || s[0] !== t) return !1;
                if (!Object.prototype.propertyIsEnumerable.call(e, t)) return !1;
                if ("function" == typeof Object.getOwnPropertyDescriptor) {
                    var r = Object.getOwnPropertyDescriptor(e, t);
                    if (42 !== r.value || !0 !== r.enumerable) return !1
                }
                return !0
            }
        },
        GS7A: function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return i
            }), n.d(t, "b", function() {
                return s
            }), n.d(t, "c", function() {
                return r
            }), n.d(t, "d", function() {
                return p
            }), n.d(t, "e", function() {
                return a
            }), n.d(t, "f", function() {
                return l
            }), n.d(t, "g", function() {
                return c
            }), n.d(t, "h", function() {
                return u
            }), n.d(t, "i", function() {
                return o
            }), n.d(t, "j", function() {
                return d
            }), n.d(t, "k", function() {
                return f
            });
            /**
             * @license Angular v11.0.7
             * (c) 2010-2020 Google LLC. https://angular.io/
             * License: MIT
             */
            class s {}
            class r {}
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const i = "*";

            function o(e, t) {
                return {
                    type: 7,
                    name: e,
                    definitions: t,
                    options: {}
                }
            }

            function a(e, t = null) {
                return {
                    type: 4,
                    styles: t,
                    timings: e
                }
            }

            function l(e, t = null) {
                return {
                    type: 2,
                    steps: e,
                    options: t
                }
            }

            function c(e) {
                return {
                    type: 6,
                    styles: e,
                    offset: null
                }
            }

            function u(e, t, n = null) {
                return {
                    type: 1,
                    expr: e,
                    animation: t,
                    options: n
                }
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            function h(e) {
                Promise.resolve(null).then(e)
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class p {
                constructor(e = 0, t = 0) {
                    this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this._position = 0, this.parentPlayer = null, this.totalTime = e + t
                }
                _onFinish() {
                    this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = [])
                }
                onStart(e) {
                    this._onStartFns.push(e)
                }
                onDone(e) {
                    this._onDoneFns.push(e)
                }
                onDestroy(e) {
                    this._onDestroyFns.push(e)
                }
                hasStarted() {
                    return this._started
                }
                init() {}
                play() {
                    this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0
                }
                triggerMicrotask() {
                    h(() => this._onFinish())
                }
                _onStart() {
                    this._onStartFns.forEach(e => e()), this._onStartFns = []
                }
                pause() {}
                restart() {}
                finish() {
                    this._onFinish()
                }
                destroy() {
                    this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = [])
                }
                reset() {}
                setPosition(e) {
                    this._position = this.totalTime ? e * this.totalTime : 1
                }
                getPosition() {
                    return this.totalTime ? this._position / this.totalTime : 1
                }
                triggerCallback(e) {
                    const t = "start" == e ? this._onStartFns : this._onDoneFns;
                    t.forEach(e => e()), t.length = 0
                }
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class d {
                constructor(e) {
                    this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = e;
                    let t = 0,
                        n = 0,
                        s = 0;
                    const r = this.players.length;
                    0 == r ? h(() => this._onFinish()) : this.players.forEach(e => {
                        e.onDone(() => {
                            ++t == r && this._onFinish()
                        }), e.onDestroy(() => {
                            ++n == r && this._onDestroy()
                        }), e.onStart(() => {
                            ++s == r && this._onStart()
                        })
                    }), this.totalTime = this.players.reduce((e, t) => Math.max(e, t.totalTime), 0)
                }
                _onFinish() {
                    this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = [])
                }
                init() {
                    this.players.forEach(e => e.init())
                }
                onStart(e) {
                    this._onStartFns.push(e)
                }
                _onStart() {
                    this.hasStarted() || (this._started = !0, this._onStartFns.forEach(e => e()), this._onStartFns = [])
                }
                onDone(e) {
                    this._onDoneFns.push(e)
                }
                onDestroy(e) {
                    this._onDestroyFns.push(e)
                }
                hasStarted() {
                    return this._started
                }
                play() {
                    this.parentPlayer || this.init(), this._onStart(), this.players.forEach(e => e.play())
                }
                pause() {
                    this.players.forEach(e => e.pause())
                }
                restart() {
                    this.players.forEach(e => e.restart())
                }
                finish() {
                    this._onFinish(), this.players.forEach(e => e.finish())
                }
                destroy() {
                    this._onDestroy()
                }
                _onDestroy() {
                    this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(e => e.destroy()), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = [])
                }
                reset() {
                    this.players.forEach(e => e.reset()), this._destroyed = !1, this._finished = !1, this._started = !1
                }
                setPosition(e) {
                    const t = e * this.totalTime;
                    this.players.forEach(e => {
                        const n = e.totalTime ? Math.min(1, t / e.totalTime) : 1;
                        e.setPosition(n)
                    })
                }
                getPosition() {
                    const e = this.players.reduce((e, t) => null === e || t.totalTime > e.totalTime ? t : e, null);
                    return null != e ? e.getPosition() : 0
                }
                beforeDestroy() {
                    this.players.forEach(e => {
                        e.beforeDestroy && e.beforeDestroy()
                    })
                }
                triggerCallback(e) {
                    const t = "start" == e ? this._onStartFns : this._onDoneFns;
                    t.forEach(e => e()), t.length = 0
                }
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const f = "!";
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
        },
        Gm0T: function(e, t, n) {
            "use strict";
            e.exports = e => {
                if ("object" != typeof e) return !1;
                if (Array.isArray(e)) return !1;
                for (const t in e)
                    if (e.hasOwnProperty(t)) return !1;
                return !0
            }
        },
        HDdC: function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return u
            });
            var s = n("7o/Q");
            var r = n("2QA8"),
                i = n("gRHU");
            var o = n("kJWO"),
                a = n("SpAZ");

            function l(e) {
                return 0 === e.length ? a.a : 1 === e.length ? e[0] : function(t) {
                    return e.reduce((e, t) => t(e), t)
                }
            }
            var c = n("2fFW");
            class u {
                constructor(e) {
                    this._isScalar = !1, e && (this._subscribe = e)
                }
                lift(e) {
                    const t = new u;
                    return t.source = this, t.operator = e, t
                }
                subscribe(e, t, n) {
                    const {
                        operator: o
                    } = this, a = function(e, t, n) {
                        if (e) {
                            if (e instanceof s.a) return e;
                            if (e[r.a]) return e[r.a]()
                        }
                        return e || t || n ? new s.a(e, t, n) : new s.a(i.a)
                    }(e, t, n);
                    if (o ? a.add(o.call(a, this.source)) : a.add(this.source || c.a.useDeprecatedSynchronousErrorHandling && !a.syncErrorThrowable ? this._subscribe(a) : this._trySubscribe(a)), c.a.useDeprecatedSynchronousErrorHandling && a.syncErrorThrowable && (a.syncErrorThrowable = !1, a.syncErrorThrown)) throw a.syncErrorValue;
                    return a
                }
                _trySubscribe(e) {
                    try {
                        return this._subscribe(e)
                    } catch (t) {
                        c.a.useDeprecatedSynchronousErrorHandling && (e.syncErrorThrown = !0, e.syncErrorValue = t), ! function(e) {
                            for (; e;) {
                                const {
                                    closed: t,
                                    destination: n,
                                    isStopped: r
                                } = e;
                                if (t || r) return !1;
                                e = n && n instanceof s.a ? n : null
                            }
                            return !0
                        }(e) ? console.warn(t) : e.error(t)
                    }
                }
                forEach(e, t) {
                    return new(t = h(t))((t, n) => {
                        let s;
                        s = this.subscribe(t => {
                            try {
                                e(t)
                            } catch (r) {
                                n(r), s && s.unsubscribe()
                            }
                        }, n, t)
                    })
                }
                _subscribe(e) {
                    const {
                        source: t
                    } = this;
                    return t && t.subscribe(e)
                }[o.a]() {
                    return this
                }
                pipe(...e) {
                    return 0 === e.length ? this : l(e)(this)
                }
                toPromise(e) {
                    return new(e = h(e))((e, t) => {
                        let n;
                        this.subscribe(e => n = e, e => t(e), () => e(n))
                    })
                }
            }

            function h(e) {
                if (e || (e = c.a.Promise || Promise), !e) throw new Error("no Promise impl found");
                return e
            }
            u.create = e => new u(e)
        },
        I55L: function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return s
            });
            const s = e => e && "number" == typeof e.length && "function" != typeof e
        },
        IvIj: function(e, t, n) {
            "use strict";
            const s = n("6rNy"),
                r = n("Tell"),
                i = {
                    categories: {
                        categories: r.categories,
                        category: r.category
                    },
                    categories_exclude: {
                        excludeCategories: r.excludeCategories
                    },
                    tags: {
                        tags: r.tags,
                        tag: r.tag
                    },
                    tags_exclude: {
                        excludeTags: r.excludeTags
                    },
                    filter: s,
                    post: {
                        post: r.post,
                        forPost: r.post
                    }
                };
            ["after", "author", "before", "parent", "password", "status", "sticky"].forEach(e => {
                i[e] = {}, i[e][e] = r[e]
            }), e.exports = i
        },
        JxQ3: function(e, t, n) {
            var s = "function" == typeof Map && Map.prototype,
                r = Object.getOwnPropertyDescriptor && s ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null,
                i = s && r && "function" == typeof r.get ? r.get : null,
                o = s && Map.prototype.forEach,
                a = "function" == typeof Set && Set.prototype,
                l = Object.getOwnPropertyDescriptor && a ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null,
                c = a && l && "function" == typeof l.get ? l.get : null,
                u = a && Set.prototype.forEach,
                h = "function" == typeof WeakMap && WeakMap.prototype ? WeakMap.prototype.has : null,
                p = "function" == typeof WeakSet && WeakSet.prototype ? WeakSet.prototype.has : null,
                d = "function" == typeof WeakRef && WeakRef.prototype ? WeakRef.prototype.deref : null,
                f = Boolean.prototype.valueOf,
                m = Object.prototype.toString,
                g = Function.prototype.toString,
                y = String.prototype.match,
                v = String.prototype.slice,
                _ = String.prototype.replace,
                b = String.prototype.toUpperCase,
                w = String.prototype.toLowerCase,
                E = RegExp.prototype.test,
                C = Array.prototype.concat,
                S = Array.prototype.join,
                x = Array.prototype.slice,
                T = Math.floor,
                A = "function" == typeof BigInt ? BigInt.prototype.valueOf : null,
                D = Object.getOwnPropertySymbols,
                P = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? Symbol.prototype.toString : null,
                k = "function" == typeof Symbol && "object" == typeof Symbol.iterator,
                O = "function" == typeof Symbol && Symbol.toStringTag && (typeof Symbol.toStringTag === k || "symbol") ? Symbol.toStringTag : null,
                I = Object.prototype.propertyIsEnumerable,
                N = ("function" == typeof Reflect ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(e) {
                    return e.__proto__
                } : null);

            function M(e, t) {
                if (e === 1 / 0 || e === -1 / 0 || e != e || e && e > -1e3 && e < 1e3 || E.call(/e/, t)) return t;
                var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
                if ("number" == typeof e) {
                    var s = e < 0 ? -T(-e) : T(e);
                    if (s !== e) {
                        var r = String(s),
                            i = v.call(t, r.length + 1);
                        return _.call(r, n, "$&_") + "." + _.call(_.call(i, /([0-9]{3})/g, "$&_"), /_$/, "")
                    }
                }
                return _.call(t, n, "$&_")
            }
            var F = n(1),
                R = F.custom,
                j = H(R) ? R : null;

            function L(e, t, n) {
                var s = "double" === (n.quoteStyle || t) ? '"' : "'";
                return s + e + s
            }

            function V(e) {
                return _.call(String(e), /"/g, "&quot;")
            }

            function $(e) {
                return !("[object Array]" !== z(e) || O && "object" == typeof e && O in e)
            }

            function B(e) {
                return !("[object RegExp]" !== z(e) || O && "object" == typeof e && O in e)
            }

            function H(e) {
                if (k) return e && "object" == typeof e && e instanceof Symbol;
                if ("symbol" == typeof e) return !0;
                if (!e || "object" != typeof e || !P) return !1;
                try {
                    return P.call(e), !0
                } catch (t) {}
                return !1
            }
            e.exports = function e(t, n, s, r) {
                var a = n || {};
                if (q(a, "quoteStyle") && "single" !== a.quoteStyle && "double" !== a.quoteStyle) throw new TypeError('option "quoteStyle" must be "single" or "double"');
                if (q(a, "maxStringLength") && ("number" == typeof a.maxStringLength ? a.maxStringLength < 0 && a.maxStringLength !== 1 / 0 : null !== a.maxStringLength)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
                var l = !q(a, "customInspect") || a.customInspect;
                if ("boolean" != typeof l && "symbol" !== l) throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
                if (q(a, "indent") && null !== a.indent && "\t" !== a.indent && !(parseInt(a.indent, 10) === a.indent && a.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
                if (q(a, "numericSeparator") && "boolean" != typeof a.numericSeparator) throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
                var m = a.numericSeparator;
                if (void 0 === t) return "undefined";
                if (null === t) return "null";
                if ("boolean" == typeof t) return t ? "true" : "false";
                if ("string" == typeof t) return G(t, a);
                if ("number" == typeof t) {
                    if (0 === t) return 1 / 0 / t > 0 ? "0" : "-0";
                    var b = String(t);
                    return m ? M(t, b) : b
                }
                if ("bigint" == typeof t) {
                    var E = String(t) + "n";
                    return m ? M(t, E) : E
                }
                var T = void 0 === a.depth ? 5 : a.depth;
                if (void 0 === s && (s = 0), s >= T && T > 0 && "object" == typeof t) return $(t) ? "[Array]" : "[Object]";
                var D = function(e, t) {
                    var n;
                    if ("\t" === e.indent) n = "\t";
                    else {
                        if (!("number" == typeof e.indent && e.indent > 0)) return null;
                        n = S.call(Array(e.indent + 1), " ")
                    }
                    return {
                        base: n,
                        prev: S.call(Array(t + 1), n)
                    }
                }(a, s);
                if (void 0 === r) r = [];
                else if (W(r, t) >= 0) return "[Circular]";

                function R(t, n, i) {
                    if (n && (r = x.call(r)).push(n), i) {
                        var o = {
                            depth: a.depth
                        };
                        return q(a, "quoteStyle") && (o.quoteStyle = a.quoteStyle), e(t, o, s + 1, r)
                    }
                    return e(t, a, s + 1, r)
                }
                if ("function" == typeof t && !B(t)) {
                    var U = function(e) {
                            if (e.name) return e.name;
                            var t = y.call(g.call(e), /^function\s*([\w$]+)/);
                            if (t) return t[1];
                            return null
                        }(t),
                        K = Y(t, R);
                    return "[Function" + (U ? ": " + U : " (anonymous)") + "]" + (K.length > 0 ? " { " + S.call(K, ", ") + " }" : "")
                }
                if (H(t)) {
                    var ee = k ? _.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1") : P.call(t);
                    return "object" != typeof t || k ? ee : Q(ee)
                }
                if (function(e) {
                        if (!e || "object" != typeof e) return !1;
                        if ("undefined" != typeof HTMLElement && e instanceof HTMLElement) return !0;
                        return "string" == typeof e.nodeName && "function" == typeof e.getAttribute
                    }(t)) {
                    for (var te = "<" + w.call(String(t.nodeName)), ne = t.attributes || [], se = 0; se < ne.length; se++) te += " " + ne[se].name + "=" + L(V(ne[se].value), "double", a);
                    return te += ">", t.childNodes && t.childNodes.length && (te += "..."), te += "</" + w.call(String(t.nodeName)) + ">"
                }
                if ($(t)) {
                    if (0 === t.length) return "[]";
                    var re = Y(t, R);
                    return D && ! function(e) {
                        for (var t = 0; t < e.length; t++)
                            if (W(e[t], "\n") >= 0) return !1;
                        return !0
                    }(re) ? "[" + X(re, D) + "]" : "[ " + S.call(re, ", ") + " ]"
                }
                if (function(e) {
                        return !("[object Error]" !== z(e) || O && "object" == typeof e && O in e)
                    }(t)) {
                    var ie = Y(t, R);
                    return "cause" in Error.prototype || !("cause" in t) || I.call(t, "cause") ? 0 === ie.length ? "[" + String(t) + "]" : "{ [" + String(t) + "] " + S.call(ie, ", ") + " }" : "{ [" + String(t) + "] " + S.call(C.call("[cause]: " + R(t.cause), ie), ", ") + " }"
                }
                if ("object" == typeof t && l) {
                    if (j && "function" == typeof t[j] && F) return F(t, {
                        depth: T - s
                    });
                    if ("symbol" !== l && "function" == typeof t.inspect) return t.inspect()
                }
                if (function(e) {
                        if (!i || !e || "object" != typeof e) return !1;
                        try {
                            i.call(e);
                            try {
                                c.call(e)
                            } catch (te) {
                                return !0
                            }
                            return e instanceof Map
                        } catch (t) {}
                        return !1
                    }(t)) {
                    var oe = [];
                    return o.call(t, function(e, n) {
                        oe.push(R(n, t, !0) + " => " + R(e, t))
                    }), J("Map", i.call(t), oe, D)
                }
                if (function(e) {
                        if (!c || !e || "object" != typeof e) return !1;
                        try {
                            c.call(e);
                            try {
                                i.call(e)
                            } catch (t) {
                                return !0
                            }
                            return e instanceof Set
                        } catch (n) {}
                        return !1
                    }(t)) {
                    var ae = [];
                    return u.call(t, function(e) {
                        ae.push(R(e, t))
                    }), J("Set", c.call(t), ae, D)
                }
                if (function(e) {
                        if (!h || !e || "object" != typeof e) return !1;
                        try {
                            h.call(e, h);
                            try {
                                p.call(e, p)
                            } catch (te) {
                                return !0
                            }
                            return e instanceof WeakMap
                        } catch (t) {}
                        return !1
                    }(t)) return Z("WeakMap");
                if (function(e) {
                        if (!p || !e || "object" != typeof e) return !1;
                        try {
                            p.call(e, p);
                            try {
                                h.call(e, h)
                            } catch (te) {
                                return !0
                            }
                            return e instanceof WeakSet
                        } catch (t) {}
                        return !1
                    }(t)) return Z("WeakSet");
                if (function(e) {
                        if (!d || !e || "object" != typeof e) return !1;
                        try {
                            return d.call(e), !0
                        } catch (t) {}
                        return !1
                    }(t)) return Z("WeakRef");
                if (function(e) {
                        return !("[object Number]" !== z(e) || O && "object" == typeof e && O in e)
                    }(t)) return Q(R(Number(t)));
                if (function(e) {
                        if (!e || "object" != typeof e || !A) return !1;
                        try {
                            return A.call(e), !0
                        } catch (t) {}
                        return !1
                    }(t)) return Q(R(A.call(t)));
                if (function(e) {
                        return !("[object Boolean]" !== z(e) || O && "object" == typeof e && O in e)
                    }(t)) return Q(f.call(t));
                if (function(e) {
                        return !("[object String]" !== z(e) || O && "object" == typeof e && O in e)
                    }(t)) return Q(R(String(t)));
                if (! function(e) {
                        return !("[object Date]" !== z(e) || O && "object" == typeof e && O in e)
                    }(t) && !B(t)) {
                    var le = Y(t, R),
                        ce = N ? N(t) === Object.prototype : t instanceof Object || t.constructor === Object,
                        ue = t instanceof Object ? "" : "null prototype",
                        he = !ce && O && Object(t) === t && O in t ? v.call(z(t), 8, -1) : ue ? "Object" : "",
                        pe = (ce || "function" != typeof t.constructor ? "" : t.constructor.name ? t.constructor.name + " " : "") + (he || ue ? "[" + S.call(C.call([], he || [], ue || []), ": ") + "] " : "");
                    return 0 === le.length ? pe + "{}" : D ? pe + "{" + X(le, D) + "}" : pe + "{ " + S.call(le, ", ") + " }"
                }
                return String(t)
            };
            var U = Object.prototype.hasOwnProperty || function(e) {
                return e in this
            };

            function q(e, t) {
                return U.call(e, t)
            }

            function z(e) {
                return m.call(e)
            }

            function W(e, t) {
                if (e.indexOf) return e.indexOf(t);
                for (var n = 0, s = e.length; n < s; n++)
                    if (e[n] === t) return n;
                return -1
            }

            function G(e, t) {
                if (e.length > t.maxStringLength) {
                    var n = e.length - t.maxStringLength,
                        s = "... " + n + " more character" + (n > 1 ? "s" : "");
                    return G(v.call(e, 0, t.maxStringLength), t) + s
                }
                return L(_.call(_.call(e, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, K), "single", t)
            }

            function K(e) {
                var t = e.charCodeAt(0),
                    n = {
                        8: "b",
                        9: "t",
                        10: "n",
                        12: "f",
                        13: "r"
                    }[t];
                return n ? "\\" + n : "\\x" + (t < 16 ? "0" : "") + b.call(t.toString(16))
            }

            function Q(e) {
                return "Object(" + e + ")"
            }

            function Z(e) {
                return e + " { ? }"
            }

            function J(e, t, n, s) {
                return e + " (" + t + ") {" + (s ? X(n, s) : S.call(n, ", ")) + "}"
            }

            function X(e, t) {
                if (0 === e.length) return "";
                var n = "\n" + t.prev + t.base;
                return n + S.call(e, "," + n) + "\n" + t.prev
            }

            function Y(e, t) {
                var n = $(e),
                    s = [];
                if (n) {
                    s.length = e.length;
                    for (var r = 0; r < e.length; r++) s[r] = q(e, r) ? t(e[r], e) : ""
                }
                var i, o = "function" == typeof D ? D(e) : [];
                if (k) {
                    i = {};
                    for (var a = 0; a < o.length; a++) i["$" + o[a]] = o[a]
                }
                for (var l in e) q(e, l) && (n && String(Number(l)) === l && l < e.length || k && i["$" + l] instanceof Symbol || (E.call(/[^\w$]/, l) ? s.push(t(l, e) + ": " + t(e[l], e)) : s.push(l + ": " + t(e[l], e))));
                if ("function" == typeof D)
                    for (var c = 0; c < o.length; c++) I.call(e, o[c]) && s.push("[" + t(o[c]) + "]: " + t(e[o[c]], e));
                return s
            }
        },
        Lhse: function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return s
            });
            const s = "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator"
        },
        Mj6V: function(e, t, n) {
            var s, r;
            /* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
             * @license MIT */
            void 0 === (r = "function" == typeof(s = function() {
                var e, t, n = {
                        version: "0.2.0"
                    },
                    s = n.settings = {
                        minimum: .08,
                        easing: "ease",
                        positionUsing: "",
                        speed: 200,
                        trickle: !0,
                        trickleRate: .02,
                        trickleSpeed: 800,
                        showSpinner: !0,
                        barSelector: '[role="bar"]',
                        spinnerSelector: '[role="spinner"]',
                        parent: "body",
                        template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
                    };

                function r(e, t, n) {
                    return e < t ? t : e > n ? n : e
                }

                function i(e) {
                    return 100 * (-1 + e)
                }

                function o(e, t, n) {
                    var r;
                    return (r = "translate3d" === s.positionUsing ? {
                        transform: "translate3d(" + i(e) + "%,0,0)"
                    } : "translate" === s.positionUsing ? {
                        transform: "translate(" + i(e) + "%,0)"
                    } : {
                        "margin-left": i(e) + "%"
                    }).transition = "all " + t + "ms " + n, r
                }
                n.configure = function(e) {
                    var t, n;
                    for (t in e) void 0 !== (n = e[t]) && e.hasOwnProperty(t) && (s[t] = n);
                    return this
                }, n.status = null, n.set = function(e) {
                    var t = n.isStarted();
                    e = r(e, s.minimum, 1), n.status = 1 === e ? null : e;
                    var i = n.render(!t),
                        c = i.querySelector(s.barSelector),
                        u = s.speed,
                        h = s.easing;
                    return i.offsetWidth, a(function(t) {
                        "" === s.positionUsing && (s.positionUsing = n.getPositioningCSS()), l(c, o(e, u, h)), 1 === e ? (l(i, {
                            transition: "none",
                            opacity: 1
                        }), i.offsetWidth, setTimeout(function() {
                            l(i, {
                                transition: "all " + u + "ms linear",
                                opacity: 0
                            }), setTimeout(function() {
                                n.remove(), t()
                            }, u)
                        }, u)) : setTimeout(t, u)
                    }), this
                }, n.isStarted = function() {
                    return "number" == typeof n.status
                }, n.start = function() {
                    n.status || n.set(0);
                    var e = function() {
                        setTimeout(function() {
                            n.status && (n.trickle(), e())
                        }, s.trickleSpeed)
                    };
                    return s.trickle && e(), this
                }, n.done = function(e) {
                    return e || n.status ? n.inc(.3 + .5 * Math.random()).set(1) : this
                }, n.inc = function(e) {
                    var t = n.status;
                    return t ? ("number" != typeof e && (e = (1 - t) * r(Math.random() * t, .1, .95)), t = r(t + e, 0, .994), n.set(t)) : n.start()
                }, n.trickle = function() {
                    return n.inc(Math.random() * s.trickleRate)
                }, e = 0, t = 0, n.promise = function(s) {
                    return s && "resolved" !== s.state() ? (0 === t && n.start(), e++, t++, s.always(function() {
                        0 == --t ? (e = 0, n.done()) : n.set((e - t) / e)
                    }), this) : this
                }, n.render = function(e) {
                    if (n.isRendered()) return document.getElementById("nprogress");
                    u(document.documentElement, "nprogress-busy");
                    var t = document.createElement("div");
                    t.id = "nprogress", t.innerHTML = s.template;
                    var r, o = t.querySelector(s.barSelector),
                        a = e ? "-100" : i(n.status || 0),
                        c = document.querySelector(s.parent);
                    return l(o, {
                        transition: "all 0 linear",
                        transform: "translate3d(" + a + "%,0,0)"
                    }), s.showSpinner || (r = t.querySelector(s.spinnerSelector)) && d(r), c != document.body && u(c, "nprogress-custom-parent"), c.appendChild(t), t
                }, n.remove = function() {
                    h(document.documentElement, "nprogress-busy"), h(document.querySelector(s.parent), "nprogress-custom-parent");
                    var e = document.getElementById("nprogress");
                    e && d(e)
                }, n.isRendered = function() {
                    return !!document.getElementById("nprogress")
                }, n.getPositioningCSS = function() {
                    var e = document.body.style,
                        t = "WebkitTransform" in e ? "Webkit" : "MozTransform" in e ? "Moz" : "msTransform" in e ? "ms" : "OTransform" in e ? "O" : "";
                    return t + "Perspective" in e ? "translate3d" : t + "Transform" in e ? "translate" : "margin"
                };
                var a = function() {
                        var e = [];

                        function t() {
                            var n = e.shift();
                            n && n(t)
                        }
                        return function(n) {
                            e.push(n), 1 == e.length && t()
                        }
                    }(),
                    l = function() {
                        var e = ["Webkit", "O", "Moz", "ms"],
                            t = {};

                        function n(e) {
                            return e.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(e, t) {
                                return t.toUpperCase()
                            })
                        }

                        function s(t) {
                            var n = document.body.style;
                            if (t in n) return t;
                            for (var s, r = e.length, i = t.charAt(0).toUpperCase() + t.slice(1); r--;)
                                if ((s = e[r] + i) in n) return s;
                            return t
                        }

                        function r(e) {
                            return e = n(e), t[e] || (t[e] = s(e))
                        }

                        function i(e, t, n) {
                            t = r(t), e.style[t] = n
                        }
                        return function(e, t) {
                            var n, s, r = arguments;
                            if (2 == r.length)
                                for (n in t) void 0 !== (s = t[n]) && t.hasOwnProperty(n) && i(e, n, s);
                            else i(e, r[1], r[2])
                        }
                    }();

                function c(e, t) {
                    return ("string" == typeof e ? e : p(e)).indexOf(" " + t + " ") >= 0
                }

                function u(e, t) {
                    var n = p(e),
                        s = n + t;
                    c(n, t) || (e.className = s.substring(1))
                }

                function h(e, t) {
                    var n, s = p(e);
                    c(e, t) && (n = s.replace(" " + t + " ", " "), e.className = n.substring(1, n.length - 1))
                }

                function p(e) {
                    return (" " + (e.className || "") + " ").replace(/\s+/gi, " ")
                }

                function d(e) {
                    e && e.parentNode && e.parentNode.removeChild(e)
                }
                return n
            }) ? s.call(t, n, t, e) : s) || (e.exports = r)
        },
        NJ4a: function(e, t, n) {
            "use strict";

            function s(e) {
                setTimeout(() => {
                    throw e
                }, 0)
            }
            n.d(t, "a", function() {
                return s
            })
        },
        PrET: function(e, t, n) {
            "use strict";
            var s = n("D3zA"),
                r = n("AM7I"),
                i = r("%Function.prototype.apply%"),
                o = r("%Function.prototype.call%"),
                a = r("%Reflect.apply%", !0) || s.call(o, i),
                l = r("%Object.getOwnPropertyDescriptor%", !0),
                c = r("%Object.defineProperty%", !0),
                u = r("%Math.max%");
            if (c) try {
                c({}, "a", {
                    value: 1
                })
            } catch (p) {
                c = null
            }
            e.exports = function(e) {
                var t = a(s, o, arguments);
                if (l && c) {
                    var n = l(t, "length");
                    n.configurable && c(t, "length", {
                        value: 1 + u(0, e.length - (arguments.length - 1))
                    })
                }
                return t
            };
            var h = function() {
                return a(s, i, arguments)
            };
            c ? c(e.exports, "apply", {
                value: h
            }) : e.exports.apply = h
        },
        QSc6: function(e, t, n) {
            "use strict";
            var s = n("VAJa"),
                r = n("0jNN"),
                i = n("sxOR"),
                o = Object.prototype.hasOwnProperty,
                a = {
                    brackets: function(e) {
                        return e + "[]"
                    },
                    comma: "comma",
                    indices: function(e, t) {
                        return e + "[" + t + "]"
                    },
                    repeat: function(e) {
                        return e
                    }
                },
                l = Array.isArray,
                c = String.prototype.split,
                u = Array.prototype.push,
                h = function(e, t) {
                    u.apply(e, l(t) ? t : [t])
                },
                p = Date.prototype.toISOString,
                d = i.default,
                f = {
                    addQueryPrefix: !1,
                    allowDots: !1,
                    charset: "utf-8",
                    charsetSentinel: !1,
                    delimiter: "&",
                    encode: !0,
                    encoder: r.encode,
                    encodeValuesOnly: !1,
                    format: d,
                    formatter: i.formatters[d],
                    indices: !1,
                    serializeDate: function(e) {
                        return p.call(e)
                    },
                    skipNulls: !1,
                    strictNullHandling: !1
                },
                m = {},
                g = function e(t, n, i, o, a, u, p, d, g, y, v, _, b, w, E, C) {
                    for (var S, x = t, T = C, A = 0, D = !1; void 0 !== (T = T.get(m)) && !D;) {
                        var P = T.get(t);
                        if (A += 1, void 0 !== P) {
                            if (P === A) throw new RangeError("Cyclic object value");
                            D = !0
                        }
                        void 0 === T.get(m) && (A = 0)
                    }
                    if ("function" == typeof d ? x = d(n, x) : x instanceof Date ? x = v(x) : "comma" === i && l(x) && (x = r.maybeMap(x, function(e) {
                            return e instanceof Date ? v(e) : e
                        })), null === x) {
                        if (a) return p && !w ? p(n, f.encoder, E, "key", _) : n;
                        x = ""
                    }
                    if ("string" == typeof(S = x) || "number" == typeof S || "boolean" == typeof S || "symbol" == typeof S || "bigint" == typeof S || r.isBuffer(x)) {
                        if (p) {
                            var k = w ? n : p(n, f.encoder, E, "key", _);
                            if ("comma" === i && w) {
                                for (var O = c.call(String(x), ","), I = "", N = 0; N < O.length; ++N) I += (0 === N ? "" : ",") + b(p(O[N], f.encoder, E, "value", _));
                                return [b(k) + (o && l(x) && 1 === O.length ? "[]" : "") + "=" + I]
                            }
                            return [b(k) + "=" + b(p(x, f.encoder, E, "value", _))]
                        }
                        return [b(n) + "=" + b(String(x))]
                    }
                    var M, F = [];
                    if (void 0 === x) return F;
                    if ("comma" === i && l(x)) M = [{
                        value: x.length > 0 ? x.join(",") || null : void 0
                    }];
                    else if (l(d)) M = d;
                    else {
                        var R = Object.keys(x);
                        M = g ? R.sort(g) : R
                    }
                    for (var j = o && l(x) && 1 === x.length ? n + "[]" : n, L = 0; L < M.length; ++L) {
                        var V = M[L],
                            $ = "object" == typeof V && void 0 !== V.value ? V.value : x[V];
                        if (!u || null !== $) {
                            var B = l(x) ? "function" == typeof i ? i(j, V) : j : j + (y ? "." + V : "[" + V + "]");
                            C.set(t, A);
                            var H = s();
                            H.set(m, C), h(F, e($, B, i, o, a, u, p, d, g, y, v, _, b, w, E, H))
                        }
                    }
                    return F
                };
            e.exports = function(e, t) {
                var n, r = e,
                    c = function(e) {
                        if (!e) return f;
                        if (null !== e.encoder && void 0 !== e.encoder && "function" != typeof e.encoder) throw new TypeError("Encoder has to be a function.");
                        var t = e.charset || f.charset;
                        if (void 0 !== e.charset && "utf-8" !== e.charset && "iso-8859-1" !== e.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
                        var n = i.default;
                        if (void 0 !== e.format) {
                            if (!o.call(i.formatters, e.format)) throw new TypeError("Unknown format option provided.");
                            n = e.format
                        }
                        var s = i.formatters[n],
                            r = f.filter;
                        return ("function" == typeof e.filter || l(e.filter)) && (r = e.filter), {
                            addQueryPrefix: "boolean" == typeof e.addQueryPrefix ? e.addQueryPrefix : f.addQueryPrefix,
                            allowDots: void 0 === e.allowDots ? f.allowDots : !!e.allowDots,
                            charset: t,
                            charsetSentinel: "boolean" == typeof e.charsetSentinel ? e.charsetSentinel : f.charsetSentinel,
                            delimiter: void 0 === e.delimiter ? f.delimiter : e.delimiter,
                            encode: "boolean" == typeof e.encode ? e.encode : f.encode,
                            encoder: "function" == typeof e.encoder ? e.encoder : f.encoder,
                            encodeValuesOnly: "boolean" == typeof e.encodeValuesOnly ? e.encodeValuesOnly : f.encodeValuesOnly,
                            filter: r,
                            format: n,
                            formatter: s,
                            serializeDate: "function" == typeof e.serializeDate ? e.serializeDate : f.serializeDate,
                            skipNulls: "boolean" == typeof e.skipNulls ? e.skipNulls : f.skipNulls,
                            sort: "function" == typeof e.sort ? e.sort : null,
                            strictNullHandling: "boolean" == typeof e.strictNullHandling ? e.strictNullHandling : f.strictNullHandling
                        }
                    }(t);
                "function" == typeof c.filter ? r = (0, c.filter)("", r) : l(c.filter) && (n = c.filter);
                var u, p = [];
                if ("object" != typeof r || null === r) return "";
                u = t && t.arrayFormat in a ? t.arrayFormat : t && "indices" in t ? t.indices ? "indices" : "repeat" : "indices";
                var d = a[u];
                if (t && "commaRoundTrip" in t && "boolean" != typeof t.commaRoundTrip) throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
                var m = "comma" === d && t && t.commaRoundTrip;
                n || (n = Object.keys(r)), c.sort && n.sort(c.sort);
                for (var y = s(), v = 0; v < n.length; ++v) {
                    var _ = n[v];
                    c.skipNulls && null === r[_] || h(p, g(r[_], _, d, m, c.strictNullHandling, c.skipNulls, c.encode ? c.encoder : null, c.filter, c.sort, c.allowDots, c.serializeDate, c.format, c.formatter, c.encodeValuesOnly, c.charset, y))
                }
                var b = p.join(c.delimiter),
                    w = !0 === c.addQueryPrefix ? "?" : "";
                return c.charsetSentinel && ("iso-8859-1" === c.charset ? w += "utf8=%26%2310003%3B&" : w += "utf8=%E2%9C%93&"), b.length > 0 ? w + b : ""
            }
        },
        Qup9: function(e, t, n) {
            "use strict";
            e.exports = (e, t) => e > t ? 1 : e < t ? -1 : 0
        },
        Qwta: function(e, t, n) {
            "use strict";
            e.exports = (e, t) => {
                const n = {};
                return n[e] = t, n
            }
        },
        Qyje: function(e, t, n) {
            "use strict";
            var s = n("QSc6"),
                r = n("nmq7"),
                i = n("sxOR");
            e.exports = {
                formats: i,
                parse: r,
                stringify: s
            }
        },
        SeVD: function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return u
            });
            var s = n("ngJS"),
                r = n("NJ4a");
            var i = n("Lhse");
            var o = n("kJWO");
            var a = n("I55L"),
                l = n("c2HN"),
                c = n("XoHu");
            const u = e => {
                if (e && "function" == typeof e[o.a]) return u = e, e => {
                    const t = u[o.a]();
                    if ("function" != typeof t.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable");
                    return t.subscribe(e)
                };
                if (Object(a.a)(e)) return Object(s.a)(e);
                if (Object(l.a)(e)) return n = e, e => (n.then(t => {
                    e.closed || (e.next(t), e.complete())
                }, t => e.error(t)).then(null, r.a), e);
                if (e && "function" == typeof e[i.a]) return t = e, e => {
                    const n = t[i.a]();
                    for (;;) {
                        let t;
                        try {
                            t = n.next()
                        } catch (s) {
                            return e.error(s), e
                        }
                        if (t.done) {
                            e.complete();
                            break
                        }
                        if (e.next(t.value), e.closed) break
                    }
                    return "function" == typeof n.return && e.add(() => {
                        n.return && n.return()
                    }), e
                }; {
                    const t = Object(c.a)(e) ? "an invalid object" : `'${e}'`;
                    throw new TypeError(`You provided ${t} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`)
                }
                var t, n, u
            }
        },
        SpAZ: function(e, t, n) {
            "use strict";

            function s(e) {
                return e
            }
            n.d(t, "a", function() {
                return s
            })
        },
        Tell: function(e, t, n) {
            "use strict";
            const s = n("0KBE"),
                r = n("zHhn"),
                i = {},
                o = n("6rNy"),
                a = o.filter,
                l = o.taxonomy;
            i.author = function(e) {
                if (void 0 === e) return this;
                if ("string" == typeof e) return this.param("author", null), a.call(this, "author_name", e);
                if ("number" == typeof e) return a.call(this, "author_name", null), this.param("author", e);
                if (null === e) return a.call(this, "author_name", null), this.param("author", null);
                throw new Error("author must be either a nicename string or numeric ID")
            }, i.parent = s("parent"), i.post = s("post"), i.password = s("password"), i.status = s("status"), i.sticky = s("sticky"), i.categories = s("categories"), i.category = function(e) {
                return r(e) ? i.categories.call(this, e) : l.call(this, "category", e)
            }, i.excludeCategories = s("categories_exclude"), i.tags = s("tags"), i.tag = function(e) {
                return r(e) ? i.tags.call(this, e) : l.call(this, "tag", e)
            }, i.excludeTags = s("tags_exclude"), i.before = function(e) {
                return this.param("before", new Date(e).toISOString())
            }, i.after = function(e) {
                return this.param("after", new Date(e).toISOString())
            }, e.exports = i
        },
        U6FE: function(e, t, n) {
            "use strict";
            const s = n("akRX").pattern.replace(/([^\\])\(([^?])/g, "$1(?:$2"),
                r = new RegExp("([^/]*" + s + "[^/]*)");
            e.exports = e => e.split(r).reduce((e, t) => t ? r.test(t) ? e.concat(t) : e.concat(t.split("/").filter(Boolean)) : e, [])
        },
        U8la: function(e, t, n) {
            "use strict";
            e.exports = (e, t) => {
                if (-1 === t._supportedMethods.indexOf(e.toLowerCase())) throw new Error("Unsupported method; supported methods are: " + t._supportedMethods.join(", "));
                return !0
            }
        },
        UVaH: function(e, t, n) {
            "use strict";
            var s = "undefined" != typeof Symbol && Symbol,
                r = n("FpZJ");
            e.exports = function() {
                return "function" == typeof s && ("function" == typeof Symbol && ("symbol" == typeof s("foo") && ("symbol" == typeof Symbol("bar") && r())))
            }
        },
        VAJa: function(e, t, n) {
            "use strict";
            var s = n("AM7I"),
                r = n("VF6F"),
                i = n("JxQ3"),
                o = s("%TypeError%"),
                a = s("%WeakMap%", !0),
                l = s("%Map%", !0),
                c = r("WeakMap.prototype.get", !0),
                u = r("WeakMap.prototype.set", !0),
                h = r("WeakMap.prototype.has", !0),
                p = r("Map.prototype.get", !0),
                d = r("Map.prototype.set", !0),
                f = r("Map.prototype.has", !0),
                m = function(e, t) {
                    for (var n, s = e; null !== (n = s.next); s = n)
                        if (n.key === t) return s.next = n.next, n.next = e.next, e.next = n, n
                };
            e.exports = function() {
                var e, t, n, s = {
                    assert: function(e) {
                        if (!s.has(e)) throw new o("Side channel does not contain " + i(e))
                    },
                    get: function(s) {
                        if (a && s && ("object" == typeof s || "function" == typeof s)) {
                            if (e) return c(e, s)
                        } else if (l) {
                            if (t) return p(t, s)
                        } else if (n) return function(e, t) {
                            var n = m(e, t);
                            return n && n.value
                        }(n, s)
                    },
                    has: function(s) {
                        if (a && s && ("object" == typeof s || "function" == typeof s)) {
                            if (e) return h(e, s)
                        } else if (l) {
                            if (t) return f(t, s)
                        } else if (n) return function(e, t) {
                            return !!m(e, t)
                        }(n, s);
                        return !1
                    },
                    set: function(s, r) {
                        a && s && ("object" == typeof s || "function" == typeof s) ? (e || (e = new a), u(e, s, r)) : l ? (t || (t = new l), d(t, s, r)) : (n || (n = {
                            key: {},
                            next: null
                        }), function(e, t, n) {
                            var s = m(e, t);
                            s ? s.value = n : e.next = {
                                key: t,
                                next: e.next,
                                value: n
                            }
                        }(n, s, r))
                    }
                };
                return s
            }
        },
        VF6F: function(e, t, n) {
            "use strict";
            var s = n("AM7I"),
                r = n("PrET"),
                i = r(s("String.prototype.indexOf"));
            e.exports = function(e, t) {
                var n = s(e, !!t);
                return "function" == typeof n && i(e, ".prototype.") > -1 ? r(n) : n
            }
        },
        VRyK: function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return l
            });
            var s = n("HDdC"),
                r = n("z+Ro"),
                i = n("5+tZ"),
                o = n("SpAZ");
            var a = n("yCtX");

            function l(...e) {
                let t = Number.POSITIVE_INFINITY,
                    n = null,
                    l = e[e.length - 1];
                return Object(r.a)(l) ? (n = e.pop(), e.length > 1 && "number" == typeof e[e.length - 1] && (t = e.pop())) : "number" == typeof l && (t = e.pop()), null === n && 1 === e.length && e[0] instanceof s.a ? e[0] : function(e = Number.POSITIVE_INFINITY) {
                    return Object(i.a)(o.a, e)
                }(t)(Object(a.a)(e, n))
            }
        },
        XNiG: function(e, t, n) {
            "use strict";
            n.d(t, "b", function() {
                return c
            }), n.d(t, "a", function() {
                return u
            });
            var s = n("HDdC"),
                r = n("7o/Q"),
                i = n("quSY"),
                o = n("9ppp");
            class a extends i.a {
                constructor(e, t) {
                    super(), this.subject = e, this.subscriber = t, this.closed = !1
                }
                unsubscribe() {
                    if (this.closed) return;
                    this.closed = !0;
                    const e = this.subject,
                        t = e.observers;
                    if (this.subject = null, !t || 0 === t.length || e.isStopped || e.closed) return;
                    const n = t.indexOf(this.subscriber); - 1 !== n && t.splice(n, 1)
                }
            }
            var l = n("2QA8");
            class c extends r.a {
                constructor(e) {
                    super(e), this.destination = e
                }
            }
            class u extends s.a {
                constructor() {
                    super(), this.observers = [], this.closed = !1, this.isStopped = !1, this.hasError = !1, this.thrownError = null
                }[l.a]() {
                    return new c(this)
                }
                lift(e) {
                    const t = new h(this, this);
                    return t.operator = e, t
                }
                next(e) {
                    if (this.closed) throw new o.a;
                    if (!this.isStopped) {
                        const {
                            observers: t
                        } = this, n = t.length, s = t.slice();
                        for (let r = 0; r < n; r++) s[r].next(e)
                    }
                }
                error(e) {
                    if (this.closed) throw new o.a;
                    this.hasError = !0, this.thrownError = e, this.isStopped = !0;
                    const {
                        observers: t
                    } = this, n = t.length, s = t.slice();
                    for (let r = 0; r < n; r++) s[r].error(e);
                    this.observers.length = 0
                }
                complete() {
                    if (this.closed) throw new o.a;
                    this.isStopped = !0;
                    const {
                        observers: e
                    } = this, t = e.length, n = e.slice();
                    for (let s = 0; s < t; s++) n[s].complete();
                    this.observers.length = 0
                }
                unsubscribe() {
                    this.isStopped = !0, this.closed = !0, this.observers = null
                }
                _trySubscribe(e) {
                    if (this.closed) throw new o.a;
                    return super._trySubscribe(e)
                }
                _subscribe(e) {
                    if (this.closed) throw new o.a;
                    return this.hasError ? (e.error(this.thrownError), i.a.EMPTY) : this.isStopped ? (e.complete(), i.a.EMPTY) : (this.observers.push(e), new a(this, e))
                }
                asObservable() {
                    const e = new s.a;
                    return e.source = this, e
                }
            }
            u.create = (e, t) => new h(e, t);
            class h extends u {
                constructor(e, t) {
                    super(), this.destination = e, this.source = t
                }
                next(e) {
                    const {
                        destination: t
                    } = this;
                    t && t.next && t.next(e)
                }
                error(e) {
                    const {
                        destination: t
                    } = this;
                    t && t.error && this.destination.error(e)
                }
                complete() {
                    const {
                        destination: e
                    } = this;
                    e && e.complete && this.destination.complete()
                }
                _subscribe(e) {
                    const {
                        source: t
                    } = this;
                    return t ? this.source.subscribe(e) : i.a.EMPTY
                }
            }
        },
        XoHu: function(e, t, n) {
            "use strict";

            function s(e) {
                return null !== e && "object" == typeof e
            }
            n.d(t, "a", function() {
                return s
            })
        },
        YTqf: function(e, t, n) {
            "use strict";
            const s = n("akRX").namedGroupRE,
                r = n("U6FE"),
                i = n("56io"),
                o = n("iJE/");

            function a(e, t, n, r, i, o) {
                const a = r.match(s),
                    l = a && a[1],
                    c = a && a[2],
                    u = a ? c || l : r,
                    h = a ? l : r,
                    p = n[u] || {
                        component: r,
                        namedGroup: !!a,
                        level: i,
                        names: []
                    };
                p.names.indexOf(h) < 0 && p.names.push(h);
                const d = "" === c ? /.*/ : new RegExp(c ? "^" + c + "$" : r, "i");
                return p.validate = e => d.test(e), o[i + 1] ? p.children = p.children || {} : (p.methods = (e.methods || []).map(e => e.toLowerCase()), p.methods.indexOf("get") > -1 && -1 === p.methods.indexOf("head") && p.methods.push("head"), e.endpoints && (t._getArgs = t._getArgs || {}, e.endpoints.forEach(e => {
                    e.methods.forEach(n => {
                        "get" === n.toLowerCase() && Object.keys(e.args).forEach(n => {
                            t._getArgs[n] = e.args[n]
                        })
                    })
                }))), n[u] = p, p.children
            }

            function l(e, t, n) {
                const s = t.namespace,
                    o = n.replace("/" + s + "/", "").replace(/\/\?$/, ""),
                    l = r(o);
                if (!s || "/" + s === n || !o) return e;
                i(e, s, {});
                const c = e[s],
                    u = l[0];
                i(c, u, {});
                const h = c[u];
                return l.reduce(a.bind(null, t, h), h), e
            }
            e.exports = {
                build: function(e) {
                    return o(e, l, {})
                }
            }
        },
        ZUHj: function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return o
            });
            var s = n("51Dv"),
                r = n("SeVD"),
                i = n("HDdC");

            function o(e, t, n, o, a = new s.a(e, n, o)) {
                if (!a.closed) return t instanceof i.a ? t.subscribe(a) : Object(r.a)(t)(a)
            }
        },
        aI7X: function(e, t, n) {
            "use strict";
            var s = "Function.prototype.bind called on incompatible ",
                r = Array.prototype.slice,
                i = Object.prototype.toString,
                o = "[object Function]";
            e.exports = function(e) {
                var t = this;
                if ("function" != typeof t || i.call(t) !== o) throw new TypeError(s + t);
                for (var n, a = r.call(arguments, 1), l = function() {
                        if (this instanceof n) {
                            var s = t.apply(this, a.concat(r.call(arguments)));
                            return Object(s) === s ? s : this
                        }
                        return t.apply(e, a.concat(r.call(arguments)))
                    }, c = Math.max(0, t.length - a.length), u = [], h = 0; h < c; h++) u.push("$" + h);
                if (n = Function("binder", "return function (" + u.join(",") + "){ return binder.apply(this,arguments); }")(l), t.prototype) {
                    var p = function() {};
                    p.prototype = t.prototype, n.prototype = new p, p.prototype = null
                }
                return n
            }
        },
        akRX: function(e, t, n) {
            "use strict";
            const s = ["\\(\\?", "(?:P<|<|')", "([^>']+)", "[>']", "([^\\)]*(\\))?\\??)", "\\)"].join("");
            e.exports = {
                pattern: s,
                namedGroupRE: new RegExp(s)
            }
        },
        c2HN: function(e, t, n) {
            "use strict";

            function s(e) {
                return !!e && "function" != typeof e.subscribe && "function" == typeof e.then
            }
            n.d(t, "a", function() {
                return s
            })
        },
        cpXB: function(e, t, n) {
            "use strict";
            e.exports = {
                create: function(e) {
                    const t = e.level,
                        n = e.names[0],
                        s = e.methods || [],
                        r = e.children ? Object.keys(e.children).map(t => e.children[t]).filter(e => !0 === e.namedGroup) : [],
                        i = 1 === r.length && r[0],
                        o = i && i.level;
                    return e.namedGroup ? function(e) {
                        return this.setPathPart(t, e), s.length && (this._supportedMethods = s), this
                    } : function(e) {
                        return this.setPathPart(t, n), void 0 !== e && o && this.setPathPart(o, e), this
                    }
                }
            }
        },
        cpc2: function(e, t, n) {
            function s(e) {
                if (e) return function(e) {
                    for (var t in s.prototype) e[t] = s.prototype[t];
                    return e
                }(e)
            }
            e.exports = s, s.prototype.on = s.prototype.addEventListener = function(e, t) {
                return this._callbacks = this._callbacks || {}, (this._callbacks["$" + e] = this._callbacks["$" + e] || []).push(t), this
            }, s.prototype.once = function(e, t) {
                function n() {
                    this.off(e, n), t.apply(this, arguments)
                }
                return n.fn = t, this.on(e, n), this
            }, s.prototype.off = s.prototype.removeListener = s.prototype.removeAllListeners = s.prototype.removeEventListener = function(e, t) {
                if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;
                var n, s = this._callbacks["$" + e];
                if (!s) return this;
                if (1 == arguments.length) return delete this._callbacks["$" + e], this;
                for (var r = 0; r < s.length; r++)
                    if ((n = s[r]) === t || n.fn === t) {
                        s.splice(r, 1);
                        break
                    }
                return 0 === s.length && delete this._callbacks["$" + e], this
            }, s.prototype.emit = function(e) {
                this._callbacks = this._callbacks || {};
                for (var t = new Array(arguments.length - 1), n = this._callbacks["$" + e], s = 1; s < arguments.length; s++) t[s - 1] = arguments[s];
                if (n) {
                    s = 0;
                    for (var r = (n = n.slice(0)).length; s < r; ++s) n[s].apply(this, t)
                }
                return this
            }, s.prototype.listeners = function(e) {
                return this._callbacks = this._callbacks || {}, this._callbacks["$" + e] || []
            }, s.prototype.hasListeners = function(e) {
                return !!this.listeners(e).length
            }
        },
        fDlF: function(e, t, n) {
            "use strict";
            (function(e) {
                n.d(t, "a", function() {
                    return x
                }), n.d(t, "b", function() {
                    return et
                }), n.d(t, "c", function() {
                    return Ee
                }), n.d(t, "d", function() {
                    return gt
                }), n.d(t, "e", function() {
                    return S
                }), n.d(t, "f", function() {
                    return vt
                }), n.d(t, "g", function() {
                    return Ce
                }), n.d(t, "h", function() {
                    return _t
                });
                var s = n("GS7A"),
                    r = n("8Y7J");

                function i() {
                    return void 0 !== e && "[object process]" === {}.toString.call(e)
                }

                function o(e) {
                    switch (e.length) {
                        case 0:
                            return new s.d;
                        case 1:
                            return e[0];
                        default:
                            return new s.j(e)
                    }
                }

                function a(e, t, n, r, i = {}, o = {}) {
                    const a = [],
                        l = [];
                    let c = -1,
                        u = null;
                    if (r.forEach(e => {
                            const n = e.offset,
                                r = n == c,
                                h = r && u || {};
                            Object.keys(e).forEach(n => {
                                let r = n,
                                    l = e[n];
                                if ("offset" !== n) switch (r = t.normalizePropertyName(r, a), l) {
                                    case s.k:
                                        l = i[n];
                                        break;
                                    case s.a:
                                        l = o[n];
                                        break;
                                    default:
                                        l = t.normalizeStyleValue(n, r, l, a)
                                }
                                h[r] = l
                            }), r || l.push(h), u = h, c = n
                        }), a.length) {
                        const e = "\n - ";
                        throw new Error(`Unable to animate due to the following errors:${e}${a.join(e)}`)
                    }
                    return l
                }

                function l(e, t, n, s) {
                    switch (t) {
                        case "start":
                            e.onStart(() => s(n && c(n, "start", e)));
                            break;
                        case "done":
                            e.onDone(() => s(n && c(n, "done", e)));
                            break;
                        case "destroy":
                            e.onDestroy(() => s(n && c(n, "destroy", e)))
                    }
                }

                function c(e, t, n) {
                    const s = n.totalTime,
                        r = !!n.disabled,
                        i = u(e.element, e.triggerName, e.fromState, e.toState, t || e.phaseName, null == s ? e.totalTime : s, r),
                        o = e._data;
                    return null != o && (i._data = o), i
                }

                function u(e, t, n, s, r = "", i = 0, o) {
                    return {
                        element: e,
                        triggerName: t,
                        fromState: n,
                        toState: s,
                        phaseName: r,
                        totalTime: i,
                        disabled: !!o
                    }
                }

                function h(e, t, n) {
                    let s;
                    return e instanceof Map ? (s = e.get(t), s || e.set(t, s = n)) : (s = e[t], s || (s = e[t] = n)), s
                }

                function p(e) {
                    const t = e.indexOf(":");
                    return [e.substring(1, t), e.substr(t + 1)]
                }
                let d = (e, t) => !1;
                let f = (e, t) => !1;
                let m = (e, t, n) => [];
                const g = i();
                (g || "undefined" != typeof Element) && (d = (e, t) => e.contains(t), f = (() => {
                    if (g || Element.prototype.matches) return (e, t) => e.matches(t); {
                        const e = Element.prototype,
                            t = e.matchesSelector || e.mozMatchesSelector || e.msMatchesSelector || e.oMatchesSelector || e.webkitMatchesSelector;
                        return t ? (e, n) => t.apply(e, [n]) : f
                    }
                })(), m = (e, t, n) => {
                    let s = [];
                    if (n) {
                        const n = e.querySelectorAll(t);
                        for (let e = 0; e < n.length; e++) s.push(n[e])
                    } else {
                        const n = e.querySelector(t);
                        n && s.push(n)
                    }
                    return s
                });
                let y = null,
                    v = !1;

                function _(e) {
                    y || (y = function() {
                        if ("undefined" != typeof document) return document.body;
                        return null
                    }() || {}, v = !!y.style && "WebkitAppearance" in y.style);
                    let t = !0;
                    if (y.style && ! function(e) {
                            return "ebkit" == e.substring(1, 6)
                        }(e) && (t = e in y.style, !t && v)) {
                        t = "Webkit" + e.charAt(0).toUpperCase() + e.substr(1) in y.style
                    }
                    return t
                }
                const b = f,
                    w = d,
                    E = m;

                function C(e) {
                    const t = {};
                    return Object.keys(e).forEach(n => {
                        const s = n.replace(/([a-z])([A-Z])/g, "$1-$2");
                        t[s] = e[n]
                    }), t
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class S {
                    validateStyleProperty(e) {
                        return _(e)
                    }
                    matchesElement(e, t) {
                        return b(e, t)
                    }
                    containsElement(e, t) {
                        return w(e, t)
                    }
                    query(e, t, n) {
                        return E(e, t, n)
                    }
                    computeStyle(e, t, n) {
                        return n || ""
                    }
                    animate(e, t, n, r, i, o = [], a) {
                        return new s.d(n, r)
                    }
                }
                S.decorators = [{
                    type: r.A
                }];
                class x {}
                x.NOOP = new S;
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const T = "ng-enter",
                    A = "ng-leave",
                    D = "ng-trigger",
                    P = ".ng-trigger",
                    k = "ng-animating",
                    O = ".ng-animating";

                function I(e) {
                    if ("number" == typeof e) return e;
                    const t = e.match(/^(-?[\.\d]+)(m?s)/);
                    return !t || t.length < 2 ? 0 : N(parseFloat(t[1]), t[2])
                }

                function N(e, t) {
                    switch (t) {
                        case "s":
                            return 1e3 * e;
                        default:
                            return e
                    }
                }

                function M(e, t, n) {
                    return e.hasOwnProperty("duration") ? e : function(e, t, n) {
                        const s = /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i;
                        let r, i = 0,
                            o = "";
                        if ("string" == typeof e) {
                            const n = e.match(s);
                            if (null === n) return t.push(`The provided timing value "${e}" is invalid.`), {
                                duration: 0,
                                delay: 0,
                                easing: ""
                            };
                            r = N(parseFloat(n[1]), n[2]);
                            const a = n[3];
                            null != a && (i = N(parseFloat(a), n[4]));
                            const l = n[5];
                            l && (o = l)
                        } else r = e;
                        if (!n) {
                            let n = !1,
                                s = t.length;
                            r < 0 && (t.push("Duration values below 0 are not allowed for this animation step."), n = !0), i < 0 && (t.push("Delay values below 0 are not allowed for this animation step."), n = !0), n && t.splice(s, 0, `The provided timing value "${e}" is invalid.`)
                        }
                        return {
                            duration: r,
                            delay: i,
                            easing: o
                        }
                    }(e, t, n)
                }

                function F(e, t = {}) {
                    return Object.keys(e).forEach(n => {
                        t[n] = e[n]
                    }), t
                }

                function R(e, t, n = {}) {
                    if (t)
                        for (let s in e) n[s] = e[s];
                    else F(e, n);
                    return n
                }

                function j(e, t, n) {
                    return n ? t + ":" + n + ";" : ""
                }

                function L(e) {
                    let t = "";
                    for (let n = 0; n < e.style.length; n++) {
                        const s = e.style.item(n);
                        t += j(0, s, e.style.getPropertyValue(s))
                    }
                    for (const n in e.style) {
                        if (!e.style.hasOwnProperty(n) || n.startsWith("_")) continue;
                        t += j(0, n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), e.style[n])
                    }
                    e.setAttribute("style", t)
                }

                function V(e, t, n) {
                    e.style && (Object.keys(t).forEach(s => {
                        const r = G(s);
                        n && !n.hasOwnProperty(s) && (n[s] = e.style[r]), e.style[r] = t[s]
                    }), i() && L(e))
                }

                function $(e, t) {
                    e.style && (Object.keys(t).forEach(t => {
                        const n = G(t);
                        e.style[n] = ""
                    }), i() && L(e))
                }

                function B(e) {
                    return Array.isArray(e) ? 1 == e.length ? e[0] : Object(s.f)(e) : e
                }
                const H = new RegExp("{{\\s*(.+?)\\s*}}", "g");

                function U(e) {
                    let t = [];
                    if ("string" == typeof e) {
                        let n;
                        for (; n = H.exec(e);) t.push(n[1]);
                        H.lastIndex = 0
                    }
                    return t
                }

                function q(e, t, n) {
                    const s = e.toString(),
                        r = s.replace(H, (e, s) => {
                            let r = t[s];
                            return t.hasOwnProperty(s) || (n.push(`Please provide a value for the animation param ${s}`), r = ""), r.toString()
                        });
                    return r == s ? e : r
                }

                function z(e) {
                    const t = [];
                    let n = e.next();
                    for (; !n.done;) t.push(n.value), n = e.next();
                    return t
                }
                const W = /-+([a-z0-9])/g;

                function G(e) {
                    return e.replace(W, (...e) => e[1].toUpperCase())
                }

                function K(e, t) {
                    return 0 === e || 0 === t
                }

                function Q(e, t, n) {
                    const s = Object.keys(n);
                    if (s.length && t.length) {
                        let i = t[0],
                            o = [];
                        if (s.forEach(e => {
                                i.hasOwnProperty(e) || o.push(e), i[e] = n[e]
                            }), o.length)
                            for (var r = 1; r < t.length; r++) {
                                let n = t[r];
                                o.forEach(function(t) {
                                    n[t] = J(e, t)
                                })
                            }
                    }
                    return t
                }

                function Z(e, t, n) {
                    switch (t.type) {
                        case 7:
                            return e.visitTrigger(t, n);
                        case 0:
                            return e.visitState(t, n);
                        case 1:
                            return e.visitTransition(t, n);
                        case 2:
                            return e.visitSequence(t, n);
                        case 3:
                            return e.visitGroup(t, n);
                        case 4:
                            return e.visitAnimate(t, n);
                        case 5:
                            return e.visitKeyframes(t, n);
                        case 6:
                            return e.visitStyle(t, n);
                        case 8:
                            return e.visitReference(t, n);
                        case 9:
                            return e.visitAnimateChild(t, n);
                        case 10:
                            return e.visitAnimateRef(t, n);
                        case 11:
                            return e.visitQuery(t, n);
                        case 12:
                            return e.visitStagger(t, n);
                        default:
                            throw new Error(`Unable to resolve animation metadata node #${t.type}`)
                    }
                }

                function J(e, t) {
                    return window.getComputedStyle(e)[t]
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const X = "*";

                function Y(e, t) {
                    const n = [];
                    return "string" == typeof e ? e.split(/\s*,\s*/).forEach(e => function(e, t, n) {
                        if (":" == e[0]) {
                            const s = function(e, t) {
                                switch (e) {
                                    case ":enter":
                                        return "void => *";
                                    case ":leave":
                                        return "* => void";
                                    case ":increment":
                                        return (e, t) => parseFloat(t) > parseFloat(e);
                                    case ":decrement":
                                        return (e, t) => parseFloat(t) < parseFloat(e);
                                    default:
                                        return t.push(`The transition alias value "${e}" is not supported`), "* => *"
                                }
                            }(e, n);
                            if ("function" == typeof s) return void t.push(s);
                            e = s
                        }
                        const s = e.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
                        if (null == s || s.length < 4) return n.push(`The provided transition expression "${e}" is not supported`), t;
                        const r = s[1],
                            i = s[2],
                            o = s[3];
                        t.push(ne(r, o));
                        const a = r == X && o == X;
                        "<" != i[0] || a || t.push(ne(o, r))
                    }(e, n, t)) : n.push(e), n
                }
                const ee = new Set(["true", "1"]),
                    te = new Set(["false", "0"]);

                function ne(e, t) {
                    const n = ee.has(e) || te.has(e),
                        s = ee.has(t) || te.has(t);
                    return (r, i) => {
                        let o = e == X || e == r,
                            a = t == X || t == i;
                        return !o && n && "boolean" == typeof r && (o = r ? ee.has(e) : te.has(e)), !a && s && "boolean" == typeof i && (a = i ? ee.has(t) : te.has(t)), o && a
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const se = ":self",
                    re = new RegExp("s*:selfs*,?", "g");

                function ie(e, t, n) {
                    return new oe(e).build(t, n)
                }
                class oe {
                    constructor(e) {
                        this._driver = e
                    }
                    build(e, t) {
                        const n = new ae(t);
                        return this._resetContextStyleTimingState(n), Z(this, B(e), n)
                    }
                    _resetContextStyleTimingState(e) {
                        e.currentQuerySelector = "", e.collectedStyles = {}, e.collectedStyles[""] = {}, e.currentTime = 0
                    }
                    visitTrigger(e, t) {
                        let n = t.queryCount = 0,
                            s = t.depCount = 0;
                        const r = [],
                            i = [];
                        return "@" == e.name.charAt(0) && t.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"), e.definitions.forEach(e => {
                            if (this._resetContextStyleTimingState(t), 0 == e.type) {
                                const n = e,
                                    s = n.name;
                                s.toString().split(/\s*,\s*/).forEach(e => {
                                    n.name = e, r.push(this.visitState(n, t))
                                }), n.name = s
                            } else if (1 == e.type) {
                                const r = this.visitTransition(e, t);
                                n += r.queryCount, s += r.depCount, i.push(r)
                            } else t.errors.push("only state() and transition() definitions can sit inside of a trigger()")
                        }), {
                            type: 7,
                            name: e.name,
                            states: r,
                            transitions: i,
                            queryCount: n,
                            depCount: s,
                            options: null
                        }
                    }
                    visitState(e, t) {
                        const n = this.visitStyle(e.styles, t),
                            s = e.options && e.options.params || null;
                        if (n.containsDynamicStyles) {
                            const r = new Set,
                                i = s || {};
                            if (n.styles.forEach(e => {
                                    if (le(e)) {
                                        const t = e;
                                        Object.keys(t).forEach(e => {
                                            U(t[e]).forEach(e => {
                                                i.hasOwnProperty(e) || r.add(e)
                                            })
                                        })
                                    }
                                }), r.size) {
                                const n = z(r.values());
                                t.errors.push(`state("${e.name}", ...) must define default values for all the following style substitutions: ${n.join(", ")}`)
                            }
                        }
                        return {
                            type: 0,
                            name: e.name,
                            style: n,
                            options: s ? {
                                params: s
                            } : null
                        }
                    }
                    visitTransition(e, t) {
                        t.queryCount = 0, t.depCount = 0;
                        const n = Z(this, B(e.animation), t);
                        return {
                            type: 1,
                            matchers: Y(e.expr, t.errors),
                            animation: n,
                            queryCount: t.queryCount,
                            depCount: t.depCount,
                            options: ce(e.options)
                        }
                    }
                    visitSequence(e, t) {
                        return {
                            type: 2,
                            steps: e.steps.map(e => Z(this, e, t)),
                            options: ce(e.options)
                        }
                    }
                    visitGroup(e, t) {
                        const n = t.currentTime;
                        let s = 0;
                        const r = e.steps.map(e => {
                            t.currentTime = n;
                            const r = Z(this, e, t);
                            return s = Math.max(s, t.currentTime), r
                        });
                        return t.currentTime = s, {
                            type: 3,
                            steps: r,
                            options: ce(e.options)
                        }
                    }
                    visitAnimate(e, t) {
                        const n = function(e, t) {
                            let n = null;
                            if (e.hasOwnProperty("duration")) n = e;
                            else if ("number" == typeof e) {
                                return ue(M(e, t).duration, 0, "")
                            }
                            const s = e;
                            if (s.split(/\s+/).some(e => "{" == e.charAt(0) && "{" == e.charAt(1))) {
                                const e = ue(0, 0, "");
                                return e.dynamic = !0, e.strValue = s, e
                            }
                            return n = n || M(s, t), ue(n.duration, n.delay, n.easing)
                        }(e.timings, t.errors);
                        let r;
                        t.currentAnimateTimings = n;
                        let i = e.styles ? e.styles : Object(s.g)({});
                        if (5 == i.type) r = this.visitKeyframes(i, t);
                        else {
                            let i = e.styles,
                                o = !1;
                            if (!i) {
                                o = !0;
                                const e = {};
                                n.easing && (e.easing = n.easing), i = Object(s.g)(e)
                            }
                            t.currentTime += n.duration + n.delay;
                            const a = this.visitStyle(i, t);
                            a.isEmptyStep = o, r = a
                        }
                        return t.currentAnimateTimings = null, {
                            type: 4,
                            timings: n,
                            style: r,
                            options: null
                        }
                    }
                    visitStyle(e, t) {
                        const n = this._makeStyleAst(e, t);
                        return this._validateStyleAst(n, t), n
                    }
                    _makeStyleAst(e, t) {
                        const n = [];
                        Array.isArray(e.styles) ? e.styles.forEach(e => {
                            "string" == typeof e ? e == s.a ? n.push(e) : t.errors.push(`The provided style string value ${e} is not allowed.`) : n.push(e)
                        }) : n.push(e.styles);
                        let r = !1,
                            i = null;
                        return n.forEach(e => {
                            if (le(e)) {
                                const t = e,
                                    n = t.easing;
                                if (n && (i = n, delete t.easing), !r)
                                    for (let e in t) {
                                        if (t[e].toString().indexOf("{{") >= 0) {
                                            r = !0;
                                            break
                                        }
                                    }
                            }
                        }), {
                            type: 6,
                            styles: n,
                            easing: i,
                            offset: e.offset,
                            containsDynamicStyles: r,
                            options: null
                        }
                    }
                    _validateStyleAst(e, t) {
                        const n = t.currentAnimateTimings;
                        let s = t.currentTime,
                            r = t.currentTime;
                        n && r > 0 && (r -= n.duration + n.delay), e.styles.forEach(e => {
                            "string" != typeof e && Object.keys(e).forEach(n => {
                                if (!this._driver.validateStyleProperty(n)) return void t.errors.push(`The provided animation property "${n}" is not a supported CSS property for animations`);
                                const i = t.collectedStyles[t.currentQuerySelector],
                                    o = i[n];
                                let a = !0;
                                o && (r != s && r >= o.startTime && s <= o.endTime && (t.errors.push(`The CSS property "${n}" that exists between the times of "${o.startTime}ms" and "${o.endTime}ms" is also being animated in a parallel animation between the times of "${r}ms" and "${s}ms"`), a = !1), r = o.startTime), a && (i[n] = {
                                    startTime: r,
                                    endTime: s
                                }), t.options && function(e, t, n) {
                                    const s = t.params || {},
                                        r = U(e);
                                    r.length && r.forEach(e => {
                                        s.hasOwnProperty(e) || n.push(`Unable to resolve the local animation param ${e} in the given list of values`)
                                    })
                                }(e[n], t.options, t.errors)
                            })
                        })
                    }
                    visitKeyframes(e, t) {
                        const n = {
                            type: 5,
                            styles: [],
                            options: null
                        };
                        if (!t.currentAnimateTimings) return t.errors.push("keyframes() must be placed inside of a call to animate()"), n;
                        let s = 0;
                        const r = [];
                        let i = !1,
                            o = !1,
                            a = 0;
                        const l = e.steps.map(e => {
                            const n = this._makeStyleAst(e, t);
                            let l = null != n.offset ? n.offset : function(e) {
                                    if ("string" == typeof e) return null;
                                    let t = null;
                                    if (Array.isArray(e)) e.forEach(e => {
                                        if (le(e) && e.hasOwnProperty("offset")) {
                                            const n = e;
                                            t = parseFloat(n.offset), delete n.offset
                                        }
                                    });
                                    else if (le(e) && e.hasOwnProperty("offset")) {
                                        const n = e;
                                        t = parseFloat(n.offset), delete n.offset
                                    }
                                    return t
                                }(n.styles),
                                c = 0;
                            return null != l && (s++, c = n.offset = l), o = o || c < 0 || c > 1, i = i || c < a, a = c, r.push(c), n
                        });
                        o && t.errors.push("Please ensure that all keyframe offsets are between 0 and 1"), i && t.errors.push("Please ensure that all keyframe offsets are in order");
                        const c = e.steps.length;
                        let u = 0;
                        s > 0 && s < c ? t.errors.push("Not all style() steps within the declared keyframes() contain offsets") : 0 == s && (u = 1 / (c - 1));
                        const h = c - 1,
                            p = t.currentTime,
                            d = t.currentAnimateTimings,
                            f = d.duration;
                        return l.forEach((e, s) => {
                            const i = u > 0 ? s == h ? 1 : u * s : r[s],
                                o = i * f;
                            t.currentTime = p + d.delay + o, d.duration = o, this._validateStyleAst(e, t), e.offset = i, n.styles.push(e)
                        }), n
                    }
                    visitReference(e, t) {
                        return {
                            type: 8,
                            animation: Z(this, B(e.animation), t),
                            options: ce(e.options)
                        }
                    }
                    visitAnimateChild(e, t) {
                        return t.depCount++, {
                            type: 9,
                            options: ce(e.options)
                        }
                    }
                    visitAnimateRef(e, t) {
                        return {
                            type: 10,
                            animation: this.visitReference(e.animation, t),
                            options: ce(e.options)
                        }
                    }
                    visitQuery(e, t) {
                        const n = t.currentQuerySelector,
                            s = e.options || {};
                        t.queryCount++, t.currentQuery = e;
                        const [r, i] = function(e) {
                            const t = !!e.split(/\s*,\s*/).find(e => e == se);
                            t && (e = e.replace(re, ""));
                            return [e = e.replace(/@\*/g, P).replace(/@\w+/g, e => ".ng-trigger-" + e.substr(1)).replace(/:animating/g, O), t]
                        }(e.selector);
                        t.currentQuerySelector = n.length ? n + " " + r : r, h(t.collectedStyles, t.currentQuerySelector, {});
                        const o = Z(this, B(e.animation), t);
                        return t.currentQuery = null, t.currentQuerySelector = n, {
                            type: 11,
                            selector: r,
                            limit: s.limit || 0,
                            optional: !!s.optional,
                            includeSelf: i,
                            animation: o,
                            originalSelector: e.selector,
                            options: ce(e.options)
                        }
                    }
                    visitStagger(e, t) {
                        t.currentQuery || t.errors.push("stagger() can only be used inside of query()");
                        const n = "full" === e.timings ? {
                            duration: 0,
                            delay: 0,
                            easing: "full"
                        } : M(e.timings, t.errors, !0);
                        return {
                            type: 12,
                            animation: Z(this, B(e.animation), t),
                            timings: n,
                            options: null
                        }
                    }
                }
                class ae {
                    constructor(e) {
                        this.errors = e, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = {}, this.options = null
                    }
                }

                function le(e) {
                    return !Array.isArray(e) && "object" == typeof e
                }

                function ce(e) {
                    var t;
                    return e ? (e = F(e)).params && (e.params = (t = e.params) ? F(t) : null) : e = {}, e
                }

                function ue(e, t, n) {
                    return {
                        duration: e,
                        delay: t,
                        easing: n
                    }
                }

                function he(e, t, n, s, r, i, o = null, a = !1) {
                    return {
                        type: 1,
                        element: e,
                        keyframes: t,
                        preStyleProps: n,
                        postStyleProps: s,
                        duration: r,
                        delay: i,
                        totalTime: r + i,
                        easing: o,
                        subTimeline: a
                    }
                }
                class pe {
                    constructor() {
                        this._map = new Map
                    }
                    consume(e) {
                        let t = this._map.get(e);
                        return t ? this._map.delete(e) : t = [], t
                    }
                    append(e, t) {
                        let n = this._map.get(e);
                        n || this._map.set(e, n = []), n.push(...t)
                    }
                    has(e) {
                        return this._map.has(e)
                    }
                    clear() {
                        this._map.clear()
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const de = new RegExp(":enter", "g"),
                    fe = new RegExp(":leave", "g");

                function me(e, t, n, s, r, i = {}, o = {}, a, l, c = []) {
                    return (new ge).buildKeyframes(e, t, n, s, r, i, o, a, l, c)
                }
                class ge {
                    buildKeyframes(e, t, n, s, r, i, o, a, l, c = []) {
                        l = l || new pe;
                        const u = new ve(e, t, l, s, r, c, []);
                        u.options = a, u.currentTimeline.setStyles([i], null, u.errors, a), Z(this, n, u);
                        const h = u.timelines.filter(e => e.containsAnimation());
                        if (h.length && Object.keys(o).length) {
                            const e = h[h.length - 1];
                            e.allowOnlyTimelineStyles() || e.setStyles([o], null, u.errors, a)
                        }
                        return h.length ? h.map(e => e.buildKeyframes()) : [he(t, [], [], [], 0, 0, "", !1)]
                    }
                    visitTrigger(e, t) {}
                    visitState(e, t) {}
                    visitTransition(e, t) {}
                    visitAnimateChild(e, t) {
                        const n = t.subInstructions.consume(t.element);
                        if (n) {
                            const s = t.createSubContext(e.options),
                                r = t.currentTimeline.currentTime,
                                i = this._visitSubInstructions(n, s, s.options);
                            r != i && t.transformIntoNewTimeline(i)
                        }
                        t.previousNode = e
                    }
                    visitAnimateRef(e, t) {
                        const n = t.createSubContext(e.options);
                        n.transformIntoNewTimeline(), this.visitReference(e.animation, n), t.transformIntoNewTimeline(n.currentTimeline.currentTime), t.previousNode = e
                    }
                    _visitSubInstructions(e, t, n) {
                        let s = t.currentTimeline.currentTime;
                        const r = null != n.duration ? I(n.duration) : null,
                            i = null != n.delay ? I(n.delay) : null;
                        return 0 !== r && e.forEach(e => {
                            const n = t.appendInstructionToTimeline(e, r, i);
                            s = Math.max(s, n.duration + n.delay)
                        }), s
                    }
                    visitReference(e, t) {
                        t.updateOptions(e.options, !0), Z(this, e.animation, t), t.previousNode = e
                    }
                    visitSequence(e, t) {
                        const n = t.subContextCount;
                        let s = t;
                        const r = e.options;
                        if (r && (r.params || r.delay) && (s = t.createSubContext(r), s.transformIntoNewTimeline(), null != r.delay)) {
                            6 == s.previousNode.type && (s.currentTimeline.snapshotCurrentStyles(), s.previousNode = ye);
                            const e = I(r.delay);
                            s.delayNextStep(e)
                        }
                        e.steps.length && (e.steps.forEach(e => Z(this, e, s)), s.currentTimeline.applyStylesToKeyframe(), s.subContextCount > n && s.transformIntoNewTimeline()), t.previousNode = e
                    }
                    visitGroup(e, t) {
                        const n = [];
                        let s = t.currentTimeline.currentTime;
                        const r = e.options && e.options.delay ? I(e.options.delay) : 0;
                        e.steps.forEach(i => {
                            const o = t.createSubContext(e.options);
                            r && o.delayNextStep(r), Z(this, i, o), s = Math.max(s, o.currentTimeline.currentTime), n.push(o.currentTimeline)
                        }), n.forEach(e => t.currentTimeline.mergeTimelineCollectedStyles(e)), t.transformIntoNewTimeline(s), t.previousNode = e
                    }
                    _visitTiming(e, t) {
                        if (e.dynamic) {
                            const n = e.strValue;
                            return M(t.params ? q(n, t.params, t.errors) : n, t.errors)
                        }
                        return {
                            duration: e.duration,
                            delay: e.delay,
                            easing: e.easing
                        }
                    }
                    visitAnimate(e, t) {
                        const n = t.currentAnimateTimings = this._visitTiming(e.timings, t),
                            s = t.currentTimeline;
                        n.delay && (t.incrementTime(n.delay), s.snapshotCurrentStyles());
                        const r = e.style;
                        5 == r.type ? this.visitKeyframes(r, t) : (t.incrementTime(n.duration), this.visitStyle(r, t), s.applyStylesToKeyframe()), t.currentAnimateTimings = null, t.previousNode = e
                    }
                    visitStyle(e, t) {
                        const n = t.currentTimeline,
                            s = t.currentAnimateTimings;
                        !s && n.getCurrentStyleProperties().length && n.forwardFrame();
                        const r = s && s.easing || e.easing;
                        e.isEmptyStep ? n.applyEmptyStep(r) : n.setStyles(e.styles, r, t.errors, t.options), t.previousNode = e
                    }
                    visitKeyframes(e, t) {
                        const n = t.currentAnimateTimings,
                            s = t.currentTimeline.duration,
                            r = n.duration,
                            i = t.createSubContext().currentTimeline;
                        i.easing = n.easing, e.styles.forEach(e => {
                            const n = e.offset || 0;
                            i.forwardTime(n * r), i.setStyles(e.styles, e.easing, t.errors, t.options), i.applyStylesToKeyframe()
                        }), t.currentTimeline.mergeTimelineCollectedStyles(i), t.transformIntoNewTimeline(s + r), t.previousNode = e
                    }
                    visitQuery(e, t) {
                        const n = t.currentTimeline.currentTime,
                            s = e.options || {},
                            r = s.delay ? I(s.delay) : 0;
                        r && (6 === t.previousNode.type || 0 == n && t.currentTimeline.getCurrentStyleProperties().length) && (t.currentTimeline.snapshotCurrentStyles(), t.previousNode = ye);
                        let i = n;
                        const o = t.invokeQuery(e.selector, e.originalSelector, e.limit, e.includeSelf, !!s.optional, t.errors);
                        t.currentQueryTotal = o.length;
                        let a = null;
                        o.forEach((n, s) => {
                            t.currentQueryIndex = s;
                            const o = t.createSubContext(e.options, n);
                            r && o.delayNextStep(r), n === t.element && (a = o.currentTimeline), Z(this, e.animation, o), o.currentTimeline.applyStylesToKeyframe();
                            const l = o.currentTimeline.currentTime;
                            i = Math.max(i, l)
                        }), t.currentQueryIndex = 0, t.currentQueryTotal = 0, t.transformIntoNewTimeline(i), a && (t.currentTimeline.mergeTimelineCollectedStyles(a), t.currentTimeline.snapshotCurrentStyles()), t.previousNode = e
                    }
                    visitStagger(e, t) {
                        const n = t.parentContext,
                            s = t.currentTimeline,
                            r = e.timings,
                            i = Math.abs(r.duration),
                            o = i * (t.currentQueryTotal - 1);
                        let a = i * t.currentQueryIndex;
                        switch (r.duration < 0 ? "reverse" : r.easing) {
                            case "reverse":
                                a = o - a;
                                break;
                            case "full":
                                a = n.currentStaggerTime
                        }
                        const l = t.currentTimeline;
                        a && l.delayNextStep(a);
                        const c = l.currentTime;
                        Z(this, e.animation, t), t.previousNode = e, n.currentStaggerTime = s.currentTime - c + (s.startTime - n.currentTimeline.startTime)
                    }
                }
                const ye = {};
                class ve {
                    constructor(e, t, n, s, r, i, o, a) {
                        this._driver = e, this.element = t, this.subInstructions = n, this._enterClassName = s, this._leaveClassName = r, this.errors = i, this.timelines = o, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = ye, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = a || new _e(this._driver, t, 0), o.push(this.currentTimeline)
                    }
                    get params() {
                        return this.options.params
                    }
                    updateOptions(e, t) {
                        if (!e) return;
                        const n = e;
                        let s = this.options;
                        null != n.duration && (s.duration = I(n.duration)), null != n.delay && (s.delay = I(n.delay));
                        const r = n.params;
                        if (r) {
                            let e = s.params;
                            e || (e = this.options.params = {}), Object.keys(r).forEach(n => {
                                t && e.hasOwnProperty(n) || (e[n] = q(r[n], e, this.errors))
                            })
                        }
                    }
                    _copyOptions() {
                        const e = {};
                        if (this.options) {
                            const t = this.options.params;
                            if (t) {
                                const n = e.params = {};
                                Object.keys(t).forEach(e => {
                                    n[e] = t[e]
                                })
                            }
                        }
                        return e
                    }
                    createSubContext(e = null, t, n) {
                        const s = t || this.element,
                            r = new ve(this._driver, s, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(s, n || 0));
                        return r.previousNode = this.previousNode, r.currentAnimateTimings = this.currentAnimateTimings, r.options = this._copyOptions(), r.updateOptions(e), r.currentQueryIndex = this.currentQueryIndex, r.currentQueryTotal = this.currentQueryTotal, r.parentContext = this, this.subContextCount++, r
                    }
                    transformIntoNewTimeline(e) {
                        return this.previousNode = ye, this.currentTimeline = this.currentTimeline.fork(this.element, e), this.timelines.push(this.currentTimeline), this.currentTimeline
                    }
                    appendInstructionToTimeline(e, t, n) {
                        const s = {
                                duration: null != t ? t : e.duration,
                                delay: this.currentTimeline.currentTime + (null != n ? n : 0) + e.delay,
                                easing: ""
                            },
                            r = new be(this._driver, e.element, e.keyframes, e.preStyleProps, e.postStyleProps, s, e.stretchStartingKeyframe);
                        return this.timelines.push(r), s
                    }
                    incrementTime(e) {
                        this.currentTimeline.forwardTime(this.currentTimeline.duration + e)
                    }
                    delayNextStep(e) {
                        e > 0 && this.currentTimeline.delayNextStep(e)
                    }
                    invokeQuery(e, t, n, s, r, i) {
                        let o = [];
                        if (s && o.push(this.element), e.length > 0) {
                            e = (e = e.replace(de, "." + this._enterClassName)).replace(fe, "." + this._leaveClassName);
                            const t = 1 != n;
                            let s = this._driver.query(this.element, e, t);
                            0 !== n && (s = n < 0 ? s.slice(s.length + n, s.length) : s.slice(0, n)), o.push(...s)
                        }
                        return r || 0 != o.length || i.push(`\`query("${t}")\` returned zero elements. (Use \`query("${t}", { optional: true })\` if you wish to allow this.)`), o
                    }
                }
                class _e {
                    constructor(e, t, n, s) {
                        this._driver = e, this.element = t, this.startTime = n, this._elementTimelineStylesLookup = s, this.duration = 0, this._previousKeyframe = {}, this._currentKeyframe = {}, this._keyframes = new Map, this._styleSummary = {}, this._pendingStyles = {}, this._backFill = {}, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._localTimelineStyles = Object.create(this._backFill, {}), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(t), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(t, this._localTimelineStyles)), this._loadKeyframe()
                    }
                    containsAnimation() {
                        switch (this._keyframes.size) {
                            case 0:
                                return !1;
                            case 1:
                                return this.getCurrentStyleProperties().length > 0;
                            default:
                                return !0
                        }
                    }
                    getCurrentStyleProperties() {
                        return Object.keys(this._currentKeyframe)
                    }
                    get currentTime() {
                        return this.startTime + this.duration
                    }
                    delayNextStep(e) {
                        const t = 1 == this._keyframes.size && Object.keys(this._pendingStyles).length;
                        this.duration || t ? (this.forwardTime(this.currentTime + e), t && this.snapshotCurrentStyles()) : this.startTime += e
                    }
                    fork(e, t) {
                        return this.applyStylesToKeyframe(), new _e(this._driver, e, t || this.currentTime, this._elementTimelineStylesLookup)
                    }
                    _loadKeyframe() {
                        this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = Object.create(this._backFill, {}), this._keyframes.set(this.duration, this._currentKeyframe))
                    }
                    forwardFrame() {
                        this.duration += 1, this._loadKeyframe()
                    }
                    forwardTime(e) {
                        this.applyStylesToKeyframe(), this.duration = e, this._loadKeyframe()
                    }
                    _updateStyle(e, t) {
                        this._localTimelineStyles[e] = t, this._globalTimelineStyles[e] = t, this._styleSummary[e] = {
                            time: this.currentTime,
                            value: t
                        }
                    }
                    allowOnlyTimelineStyles() {
                        return this._currentEmptyStepKeyframe !== this._currentKeyframe
                    }
                    applyEmptyStep(e) {
                        e && (this._previousKeyframe.easing = e), Object.keys(this._globalTimelineStyles).forEach(e => {
                            this._backFill[e] = this._globalTimelineStyles[e] || s.a, this._currentKeyframe[e] = s.a
                        }), this._currentEmptyStepKeyframe = this._currentKeyframe
                    }
                    setStyles(e, t, n, r) {
                        t && (this._previousKeyframe.easing = t);
                        const i = r && r.params || {},
                            o = function(e, t) {
                                const n = {};
                                let r;
                                return e.forEach(e => {
                                    "*" === e ? (r = r || Object.keys(t), r.forEach(e => {
                                        n[e] = s.a
                                    })) : R(e, !1, n)
                                }), n
                            }(e, this._globalTimelineStyles);
                        Object.keys(o).forEach(e => {
                            const t = q(o[e], i, n);
                            this._pendingStyles[e] = t, this._localTimelineStyles.hasOwnProperty(e) || (this._backFill[e] = this._globalTimelineStyles.hasOwnProperty(e) ? this._globalTimelineStyles[e] : s.a), this._updateStyle(e, t)
                        })
                    }
                    applyStylesToKeyframe() {
                        const e = this._pendingStyles,
                            t = Object.keys(e);
                        0 != t.length && (this._pendingStyles = {}, t.forEach(t => {
                            const n = e[t];
                            this._currentKeyframe[t] = n
                        }), Object.keys(this._localTimelineStyles).forEach(e => {
                            this._currentKeyframe.hasOwnProperty(e) || (this._currentKeyframe[e] = this._localTimelineStyles[e])
                        }))
                    }
                    snapshotCurrentStyles() {
                        Object.keys(this._localTimelineStyles).forEach(e => {
                            const t = this._localTimelineStyles[e];
                            this._pendingStyles[e] = t, this._updateStyle(e, t)
                        })
                    }
                    getFinalKeyframe() {
                        return this._keyframes.get(this.duration)
                    }
                    get properties() {
                        const e = [];
                        for (let t in this._currentKeyframe) e.push(t);
                        return e
                    }
                    mergeTimelineCollectedStyles(e) {
                        Object.keys(e._styleSummary).forEach(t => {
                            const n = this._styleSummary[t],
                                s = e._styleSummary[t];
                            (!n || s.time > n.time) && this._updateStyle(t, s.value)
                        })
                    }
                    buildKeyframes() {
                        this.applyStylesToKeyframe();
                        const e = new Set,
                            t = new Set,
                            n = 1 === this._keyframes.size && 0 === this.duration;
                        let r = [];
                        this._keyframes.forEach((i, o) => {
                            const a = R(i, !0);
                            Object.keys(a).forEach(n => {
                                const r = a[n];
                                r == s.k ? e.add(n) : r == s.a && t.add(n)
                            }), n || (a.offset = o / this.duration), r.push(a)
                        });
                        const i = e.size ? z(e.values()) : [],
                            o = t.size ? z(t.values()) : [];
                        if (n) {
                            const e = r[0],
                                t = F(e);
                            e.offset = 0, t.offset = 1, r = [e, t]
                        }
                        return he(this.element, r, i, o, this.duration, this.startTime, this.easing, !1)
                    }
                }
                class be extends _e {
                    constructor(e, t, n, s, r, i, o = !1) {
                        super(e, t, i.delay), this.element = t, this.keyframes = n, this.preStyleProps = s, this.postStyleProps = r, this._stretchStartingKeyframe = o, this.timings = {
                            duration: i.duration,
                            delay: i.delay,
                            easing: i.easing
                        }
                    }
                    containsAnimation() {
                        return this.keyframes.length > 1
                    }
                    buildKeyframes() {
                        let e = this.keyframes,
                            {
                                delay: t,
                                duration: n,
                                easing: s
                            } = this.timings;
                        if (this._stretchStartingKeyframe && t) {
                            const r = [],
                                i = n + t,
                                o = t / i,
                                a = R(e[0], !1);
                            a.offset = 0, r.push(a);
                            const l = R(e[0], !1);
                            l.offset = we(o), r.push(l);
                            const c = e.length - 1;
                            for (let s = 1; s <= c; s++) {
                                let o = R(e[s], !1);
                                const a = t + o.offset * n;
                                o.offset = we(a / i), r.push(o)
                            }
                            n = i, t = 0, s = "", e = r
                        }
                        return he(this.element, e, this.preStyleProps, this.postStyleProps, n, t, s, !0)
                    }
                }

                function we(e, t = 3) {
                    const n = Math.pow(10, t - 1);
                    return Math.round(e * n) / n
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Ee {}
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class Ce extends Ee {
                    normalizePropertyName(e, t) {
                        return G(e)
                    }
                    normalizeStyleValue(e, t, n, s) {
                        let r = "";
                        const i = n.toString().trim();
                        if (Se[t] && 0 !== n && "0" !== n)
                            if ("number" == typeof n) r = "px";
                            else {
                                const t = n.match(/^[+-]?[\d\.]+([a-z]*)$/);
                                t && 0 == t[1].length && s.push(`Please provide a CSS unit value for ${e}:${n}`)
                            }
                        return i + r
                    }
                }
                const Se = function(e) {
                    const t = {};
                    return e.forEach(e => t[e] = !0), t
                }("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(","));

                function xe(e, t, n, s, r, i, o, a, l, c, u, h, p) {
                    return {
                        type: 0,
                        element: e,
                        triggerName: t,
                        isRemovalTransition: r,
                        fromState: n,
                        fromStyles: i,
                        toState: s,
                        toStyles: o,
                        timelines: a,
                        queriedElements: l,
                        preStyleProps: c,
                        postStyleProps: u,
                        totalTime: h,
                        errors: p
                    }
                }
                const Te = {};
                class Ae {
                    constructor(e, t, n) {
                        this._triggerName = e, this.ast = t, this._stateStyles = n
                    }
                    match(e, t, n, s) {
                        return function(e, t, n, s, r) {
                            return e.some(e => e(t, n, s, r))
                        }(this.ast.matchers, e, t, n, s)
                    }
                    buildStyles(e, t, n) {
                        const s = this._stateStyles["*"],
                            r = this._stateStyles[e],
                            i = s ? s.buildStyles(t, n) : {};
                        return r ? r.buildStyles(t, n) : i
                    }
                    build(e, t, n, s, r, i, o, a, l, c) {
                        const u = [],
                            p = this.ast.options && this.ast.options.params || Te,
                            d = o && o.params || Te,
                            f = this.buildStyles(n, d, u),
                            m = a && a.params || Te,
                            g = this.buildStyles(s, m, u),
                            y = new Set,
                            v = new Map,
                            _ = new Map,
                            b = "void" === s,
                            w = {
                                params: Object.assign(Object.assign({}, p), m)
                            },
                            E = c ? [] : me(e, t, this.ast.animation, r, i, f, g, w, l, u);
                        let C = 0;
                        if (E.forEach(e => {
                                C = Math.max(e.duration + e.delay, C)
                            }), u.length) return xe(t, this._triggerName, n, s, b, f, g, [], [], v, _, C, u);
                        E.forEach(e => {
                            const n = e.element,
                                s = h(v, n, {});
                            e.preStyleProps.forEach(e => s[e] = !0);
                            const r = h(_, n, {});
                            e.postStyleProps.forEach(e => r[e] = !0), n !== t && y.add(n)
                        });
                        const S = z(y.values());
                        return xe(t, this._triggerName, n, s, b, f, g, E, S, v, _, C)
                    }
                }
                class De {
                    constructor(e, t) {
                        this.styles = e, this.defaultParams = t
                    }
                    buildStyles(e, t) {
                        const n = {},
                            s = F(this.defaultParams);
                        return Object.keys(e).forEach(t => {
                            const n = e[t];
                            null != n && (s[t] = n)
                        }), this.styles.styles.forEach(e => {
                            if ("string" != typeof e) {
                                const r = e;
                                Object.keys(r).forEach(e => {
                                    let i = r[e];
                                    i.length > 1 && (i = q(i, s, t)), n[e] = i
                                })
                            }
                        }), n
                    }
                }
                class Pe {
                    constructor(e, t) {
                        var n, s;
                        this.name = e, this.ast = t, this.transitionFactories = [], this.states = {}, t.states.forEach(e => {
                            const t = e.options && e.options.params || {};
                            this.states[e.name] = new De(e.style, t)
                        }), ke(this.states, "true", "1"), ke(this.states, "false", "0"), t.transitions.forEach(t => {
                            this.transitionFactories.push(new Ae(e, t, this.states))
                        }), this.fallbackTransition = (n = e, s = this.states, new Ae(n, {
                            type: 1,
                            animation: {
                                type: 2,
                                steps: [],
                                options: null
                            },
                            matchers: [(e, t) => !0],
                            options: null,
                            queryCount: 0,
                            depCount: 0
                        }, s))
                    }
                    get containsQueries() {
                        return this.ast.queryCount > 0
                    }
                    matchTransition(e, t, n, s) {
                        return this.transitionFactories.find(r => r.match(e, t, n, s)) || null
                    }
                    matchStyles(e, t, n) {
                        return this.fallbackTransition.buildStyles(e, t, n)
                    }
                }

                function ke(e, t, n) {
                    e.hasOwnProperty(t) ? e.hasOwnProperty(n) || (e[n] = e[t]) : e.hasOwnProperty(n) && (e[t] = e[n])
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Oe = new pe;
                class Ie {
                    constructor(e, t, n) {
                        this.bodyNode = e, this._driver = t, this._normalizer = n, this._animations = {}, this._playersById = {}, this.players = []
                    }
                    register(e, t) {
                        const n = [],
                            s = ie(this._driver, t, n);
                        if (n.length) throw new Error(`Unable to build the animation due to the following errors: ${n.join("\n")}`);
                        this._animations[e] = s
                    }
                    _buildPlayer(e, t, n) {
                        const s = e.element,
                            r = a(this._driver, this._normalizer, 0, e.keyframes, t, n);
                        return this._driver.animate(s, r, e.duration, e.delay, e.easing, [], !0)
                    }
                    create(e, t, n = {}) {
                        const r = [],
                            i = this._animations[e];
                        let a;
                        const l = new Map;
                        if (i ? (a = me(this._driver, t, i, T, A, {}, {}, n, Oe, r), a.forEach(e => {
                                const t = h(l, e.element, {});
                                e.postStyleProps.forEach(e => t[e] = null)
                            })) : (r.push("The requested animation doesn't exist or has already been destroyed"), a = []), r.length) throw new Error(`Unable to create the animation due to the following errors: ${r.join("\n")}`);
                        l.forEach((e, t) => {
                            Object.keys(e).forEach(n => {
                                e[n] = this._driver.computeStyle(t, n, s.a)
                            })
                        });
                        const c = o(a.map(e => {
                            const t = l.get(e.element);
                            return this._buildPlayer(e, {}, t)
                        }));
                        return this._playersById[e] = c, c.onDestroy(() => this.destroy(e)), this.players.push(c), c
                    }
                    destroy(e) {
                        const t = this._getPlayer(e);
                        t.destroy(), delete this._playersById[e];
                        const n = this.players.indexOf(t);
                        n >= 0 && this.players.splice(n, 1)
                    }
                    _getPlayer(e) {
                        const t = this._playersById[e];
                        if (!t) throw new Error(`Unable to find the timeline player referenced by ${e}`);
                        return t
                    }
                    listen(e, t, n, s) {
                        const r = u(t, "", "", "");
                        return l(this._getPlayer(e), n, r, s), () => {}
                    }
                    command(e, t, n, s) {
                        if ("register" == n) return void this.register(e, s[0]);
                        if ("create" == n) {
                            const n = s[0] || {};
                            return void this.create(e, t, n)
                        }
                        const r = this._getPlayer(e);
                        switch (n) {
                            case "play":
                                r.play();
                                break;
                            case "pause":
                                r.pause();
                                break;
                            case "reset":
                                r.reset();
                                break;
                            case "restart":
                                r.restart();
                                break;
                            case "finish":
                                r.finish();
                                break;
                            case "init":
                                r.init();
                                break;
                            case "setPosition":
                                r.setPosition(parseFloat(s[0]));
                                break;
                            case "destroy":
                                this.destroy(e)
                        }
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                const Ne = "ng-animate-queued",
                    Me = "ng-animate-disabled",
                    Fe = ".ng-animate-disabled",
                    Re = [],
                    je = {
                        namespaceId: "",
                        setForRemoval: !1,
                        setForMove: !1,
                        hasAnimation: !1,
                        removedBeforeQueried: !1
                    },
                    Le = {
                        namespaceId: "",
                        setForMove: !1,
                        setForRemoval: !1,
                        hasAnimation: !1,
                        removedBeforeQueried: !0
                    };
                class Ve {
                    constructor(e, t = "") {
                        this.namespaceId = t;
                        const n = e && e.hasOwnProperty("value"),
                            s = n ? e.value : e;
                        if (this.value = function(e) {
                                return null != e ? e : null
                            }(s), n) {
                            const t = F(e);
                            delete t.value, this.options = t
                        } else this.options = {};
                        this.options.params || (this.options.params = {})
                    }
                    get params() {
                        return this.options.params
                    }
                    absorbOptions(e) {
                        const t = e.params;
                        if (t) {
                            const e = this.options.params;
                            Object.keys(t).forEach(n => {
                                null == e[n] && (e[n] = t[n])
                            })
                        }
                    }
                }
                const $e = "void",
                    Be = new Ve($e);
                class He {
                    constructor(e, t, n) {
                        this.id = e, this.hostElement = t, this._engine = n, this.players = [], this._triggers = {}, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + e, Qe(t, this._hostClassName)
                    }
                    listen(e, t, n, s) {
                        if (!this._triggers.hasOwnProperty(t)) throw new Error(`Unable to listen on the animation trigger event "${n}" because the animation trigger "${t}" doesn't exist!`);
                        if (null == n || 0 == n.length) throw new Error(`Unable to listen on the animation trigger "${t}" because the provided event is undefined!`);
                        if ("start" != (r = n) && "done" != r) throw new Error(`The provided animation trigger event "${n}" for the animation trigger "${t}" is not supported!`);
                        var r;
                        const i = h(this._elementListeners, e, []),
                            o = {
                                name: t,
                                phase: n,
                                callback: s
                            };
                        i.push(o);
                        const a = h(this._engine.statesByElement, e, {});
                        return a.hasOwnProperty(t) || (Qe(e, D), Qe(e, "ng-trigger-" + t), a[t] = Be), () => {
                            this._engine.afterFlush(() => {
                                const e = i.indexOf(o);
                                e >= 0 && i.splice(e, 1), this._triggers[t] || delete a[t]
                            })
                        }
                    }
                    register(e, t) {
                        return !this._triggers[e] && (this._triggers[e] = t, !0)
                    }
                    _getTrigger(e) {
                        const t = this._triggers[e];
                        if (!t) throw new Error(`The provided animation trigger "${e}" has not been registered!`);
                        return t
                    }
                    trigger(e, t, n, s = !0) {
                        const r = this._getTrigger(t),
                            i = new qe(this.id, t, e);
                        let o = this._engine.statesByElement.get(e);
                        o || (Qe(e, D), Qe(e, "ng-trigger-" + t), this._engine.statesByElement.set(e, o = {}));
                        let a = o[t];
                        const l = new Ve(n, this.id);
                        !(n && n.hasOwnProperty("value")) && a && l.absorbOptions(a.options), o[t] = l, a || (a = Be);
                        if (!(l.value === $e) && a.value === l.value) {
                            if (! function(e, t) {
                                    const n = Object.keys(e),
                                        s = Object.keys(t);
                                    if (n.length != s.length) return !1;
                                    for (let r = 0; r < n.length; r++) {
                                        const s = n[r];
                                        if (!t.hasOwnProperty(s) || e[s] !== t[s]) return !1
                                    }
                                    return !0
                                }(a.params, l.params)) {
                                const t = [],
                                    n = r.matchStyles(a.value, a.params, t),
                                    s = r.matchStyles(l.value, l.params, t);
                                t.length ? this._engine.reportError(t) : this._engine.afterFlush(() => {
                                    $(e, n), V(e, s)
                                })
                            }
                            return
                        }
                        const c = h(this._engine.playersByElement, e, []);
                        c.forEach(e => {
                            e.namespaceId == this.id && e.triggerName == t && e.queued && e.destroy()
                        });
                        let u = r.matchTransition(a.value, l.value, e, l.params),
                            p = !1;
                        if (!u) {
                            if (!s) return;
                            u = r.fallbackTransition, p = !0
                        }
                        return this._engine.totalQueuedPlayers++, this._queue.push({
                            element: e,
                            triggerName: t,
                            transition: u,
                            fromState: a,
                            toState: l,
                            player: i,
                            isFallbackTransition: p
                        }), p || (Qe(e, Ne), i.onStart(() => {
                            Ze(e, Ne)
                        })), i.onDone(() => {
                            let t = this.players.indexOf(i);
                            t >= 0 && this.players.splice(t, 1);
                            const n = this._engine.playersByElement.get(e);
                            if (n) {
                                let e = n.indexOf(i);
                                e >= 0 && n.splice(e, 1)
                            }
                        }), this.players.push(i), c.push(i), i
                    }
                    deregister(e) {
                        delete this._triggers[e], this._engine.statesByElement.forEach((t, n) => {
                            delete t[e]
                        }), this._elementListeners.forEach((t, n) => {
                            this._elementListeners.set(n, t.filter(t => t.name != e))
                        })
                    }
                    clearElementCache(e) {
                        this._engine.statesByElement.delete(e), this._elementListeners.delete(e);
                        const t = this._engine.playersByElement.get(e);
                        t && (t.forEach(e => e.destroy()), this._engine.playersByElement.delete(e))
                    }
                    _signalRemovalForInnerTriggers(e, t) {
                        const n = this._engine.driver.query(e, P, !0);
                        n.forEach(e => {
                            if (e.__ng_removed) return;
                            const n = this._engine.fetchNamespacesByElement(e);
                            n.size ? n.forEach(n => n.triggerLeaveAnimation(e, t, !1, !0)) : this.clearElementCache(e)
                        }), this._engine.afterFlushAnimationsDone(() => n.forEach(e => this.clearElementCache(e)))
                    }
                    triggerLeaveAnimation(e, t, n, s) {
                        const r = this._engine.statesByElement.get(e);
                        if (r) {
                            const i = [];
                            if (Object.keys(r).forEach(t => {
                                    if (this._triggers[t]) {
                                        const n = this.trigger(e, t, $e, s);
                                        n && i.push(n)
                                    }
                                }), i.length) return this._engine.markElementAsRemoved(this.id, e, !0, t), n && o(i).onDone(() => this._engine.processLeaveNode(e)), !0
                        }
                        return !1
                    }
                    prepareLeaveAnimationListeners(e) {
                        const t = this._elementListeners.get(e);
                        if (t) {
                            const n = new Set;
                            t.forEach(t => {
                                const s = t.name;
                                if (n.has(s)) return;
                                n.add(s);
                                const r = this._triggers[s].fallbackTransition,
                                    i = this._engine.statesByElement.get(e)[s] || Be,
                                    o = new Ve($e),
                                    a = new qe(this.id, s, e);
                                this._engine.totalQueuedPlayers++, this._queue.push({
                                    element: e,
                                    triggerName: s,
                                    transition: r,
                                    fromState: i,
                                    toState: o,
                                    player: a,
                                    isFallbackTransition: !0
                                })
                            })
                        }
                    }
                    removeNode(e, t) {
                        const n = this._engine;
                        if (e.childElementCount && this._signalRemovalForInnerTriggers(e, t), this.triggerLeaveAnimation(e, t, !0)) return;
                        let s = !1;
                        if (n.totalAnimations) {
                            const t = n.players.length ? n.playersByQueriedElement.get(e) : [];
                            if (t && t.length) s = !0;
                            else {
                                let t = e;
                                for (; t = t.parentNode;) {
                                    if (n.statesByElement.get(t)) {
                                        s = !0;
                                        break
                                    }
                                }
                            }
                        }
                        if (this.prepareLeaveAnimationListeners(e), s) n.markElementAsRemoved(this.id, e, !1, t);
                        else {
                            const s = e.__ng_removed;
                            s && s !== je || (n.afterFlush(() => this.clearElementCache(e)), n.destroyInnerAnimations(e), n._onRemovalComplete(e, t))
                        }
                    }
                    insertNode(e, t) {
                        Qe(e, this._hostClassName)
                    }
                    drainQueuedTransitions(e) {
                        const t = [];
                        return this._queue.forEach(n => {
                            const s = n.player;
                            if (s.destroyed) return;
                            const r = n.element,
                                i = this._elementListeners.get(r);
                            i && i.forEach(t => {
                                if (t.name == n.triggerName) {
                                    const s = u(r, n.triggerName, n.fromState.value, n.toState.value);
                                    s._data = e, l(n.player, t.phase, s, t.callback)
                                }
                            }), s.markedForDestroy ? this._engine.afterFlush(() => {
                                s.destroy()
                            }) : t.push(n)
                        }), this._queue = [], t.sort((e, t) => {
                            const n = e.transition.ast.depCount,
                                s = t.transition.ast.depCount;
                            return 0 == n || 0 == s ? n - s : this._engine.driver.containsElement(e.element, t.element) ? 1 : -1
                        })
                    }
                    destroy(e) {
                        this.players.forEach(e => e.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, e)
                    }
                    elementContainsData(e) {
                        let t = !1;
                        return this._elementListeners.has(e) && (t = !0), t = !!this._queue.find(t => t.element === e) || t, t
                    }
                }
                class Ue {
                    constructor(e, t, n) {
                        this.bodyNode = e, this.driver = t, this._normalizer = n, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (e, t) => {}
                    }
                    _onRemovalComplete(e, t) {
                        this.onRemovalComplete(e, t)
                    }
                    get queuedPlayers() {
                        const e = [];
                        return this._namespaceList.forEach(t => {
                            t.players.forEach(t => {
                                t.queued && e.push(t)
                            })
                        }), e
                    }
                    createNamespace(e, t) {
                        const n = new He(e, t, this);
                        return t.parentNode ? this._balanceNamespaceList(n, t) : (this.newHostElements.set(t, n), this.collectEnterElement(t)), this._namespaceLookup[e] = n
                    }
                    _balanceNamespaceList(e, t) {
                        const n = this._namespaceList.length - 1;
                        if (n >= 0) {
                            let s = !1;
                            for (let r = n; r >= 0; r--) {
                                const n = this._namespaceList[r];
                                if (this.driver.containsElement(n.hostElement, t)) {
                                    this._namespaceList.splice(r + 1, 0, e), s = !0;
                                    break
                                }
                            }
                            s || this._namespaceList.splice(0, 0, e)
                        } else this._namespaceList.push(e);
                        return this.namespacesByHostElement.set(t, e), e
                    }
                    register(e, t) {
                        let n = this._namespaceLookup[e];
                        return n || (n = this.createNamespace(e, t)), n
                    }
                    registerTrigger(e, t, n) {
                        let s = this._namespaceLookup[e];
                        s && s.register(t, n) && this.totalAnimations++
                    }
                    destroy(e, t) {
                        if (!e) return;
                        const n = this._fetchNamespace(e);
                        this.afterFlush(() => {
                            this.namespacesByHostElement.delete(n.hostElement), delete this._namespaceLookup[e];
                            const t = this._namespaceList.indexOf(n);
                            t >= 0 && this._namespaceList.splice(t, 1)
                        }), this.afterFlushAnimationsDone(() => n.destroy(t))
                    }
                    _fetchNamespace(e) {
                        return this._namespaceLookup[e]
                    }
                    fetchNamespacesByElement(e) {
                        const t = new Set,
                            n = this.statesByElement.get(e);
                        if (n) {
                            const e = Object.keys(n);
                            for (let s = 0; s < e.length; s++) {
                                const r = n[e[s]].namespaceId;
                                if (r) {
                                    const e = this._fetchNamespace(r);
                                    e && t.add(e)
                                }
                            }
                        }
                        return t
                    }
                    trigger(e, t, n, s) {
                        if (ze(t)) {
                            const r = this._fetchNamespace(e);
                            if (r) return r.trigger(t, n, s), !0
                        }
                        return !1
                    }
                    insertNode(e, t, n, s) {
                        if (!ze(t)) return;
                        const r = t.__ng_removed;
                        if (r && r.setForRemoval) {
                            r.setForRemoval = !1, r.setForMove = !0;
                            const e = this.collectedLeaveElements.indexOf(t);
                            e >= 0 && this.collectedLeaveElements.splice(e, 1)
                        }
                        if (e) {
                            const s = this._fetchNamespace(e);
                            s && s.insertNode(t, n)
                        }
                        s && this.collectEnterElement(t)
                    }
                    collectEnterElement(e) {
                        this.collectedEnterElements.push(e)
                    }
                    markElementAsDisabled(e, t) {
                        t ? this.disabledNodes.has(e) || (this.disabledNodes.add(e), Qe(e, Me)) : this.disabledNodes.has(e) && (this.disabledNodes.delete(e), Ze(e, Me))
                    }
                    removeNode(e, t, n, s) {
                        if (ze(t)) {
                            const r = e ? this._fetchNamespace(e) : null;
                            if (r ? r.removeNode(t, s) : this.markElementAsRemoved(e, t, !1, s), n) {
                                const n = this.namespacesByHostElement.get(t);
                                n && n.id !== e && n.removeNode(t, s)
                            }
                        } else this._onRemovalComplete(t, s)
                    }
                    markElementAsRemoved(e, t, n, s) {
                        this.collectedLeaveElements.push(t), t.__ng_removed = {
                            namespaceId: e,
                            setForRemoval: s,
                            hasAnimation: n,
                            removedBeforeQueried: !1
                        }
                    }
                    listen(e, t, n, s, r) {
                        return ze(t) ? this._fetchNamespace(e).listen(t, n, s, r) : () => {}
                    }
                    _buildInstruction(e, t, n, s, r) {
                        return e.transition.build(this.driver, e.element, e.fromState.value, e.toState.value, n, s, e.fromState.options, e.toState.options, t, r)
                    }
                    destroyInnerAnimations(e) {
                        let t = this.driver.query(e, P, !0);
                        t.forEach(e => this.destroyActiveAnimationsForElement(e)), 0 != this.playersByQueriedElement.size && (t = this.driver.query(e, O, !0), t.forEach(e => this.finishActiveQueriedAnimationOnElement(e)))
                    }
                    destroyActiveAnimationsForElement(e) {
                        const t = this.playersByElement.get(e);
                        t && t.forEach(e => {
                            e.queued ? e.markedForDestroy = !0 : e.destroy()
                        })
                    }
                    finishActiveQueriedAnimationOnElement(e) {
                        const t = this.playersByQueriedElement.get(e);
                        t && t.forEach(e => e.finish())
                    }
                    whenRenderingDone() {
                        return new Promise(e => {
                            if (this.players.length) return o(this.players).onDone(() => e());
                            e()
                        })
                    }
                    processLeaveNode(e) {
                        const t = e.__ng_removed;
                        if (t && t.setForRemoval) {
                            if (e.__ng_removed = je, t.namespaceId) {
                                this.destroyInnerAnimations(e);
                                const n = this._fetchNamespace(t.namespaceId);
                                n && n.clearElementCache(e)
                            }
                            this._onRemovalComplete(e, t.setForRemoval)
                        }
                        this.driver.matchesElement(e, Fe) && this.markElementAsDisabled(e, !1), this.driver.query(e, Fe, !0).forEach(e => {
                            this.markElementAsDisabled(e, !1)
                        })
                    }
                    flush(e = -1) {
                        let t = [];
                        if (this.newHostElements.size && (this.newHostElements.forEach((e, t) => this._balanceNamespaceList(e, t)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length)
                            for (let n = 0; n < this.collectedEnterElements.length; n++) {
                                Qe(this.collectedEnterElements[n], "ng-star-inserted")
                            }
                        if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {
                            const n = [];
                            try {
                                t = this._flushAnimations(n, e)
                            } finally {
                                for (let e = 0; e < n.length; e++) n[e]()
                            }
                        } else
                            for (let n = 0; n < this.collectedLeaveElements.length; n++) {
                                const e = this.collectedLeaveElements[n];
                                this.processLeaveNode(e)
                            }
                        if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(e => e()), this._flushFns = [], this._whenQuietFns.length) {
                            const e = this._whenQuietFns;
                            this._whenQuietFns = [], t.length ? o(t).onDone(() => {
                                e.forEach(e => e())
                            }) : e.forEach(e => e())
                        }
                    }
                    reportError(e) {
                        throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${e.join("\n")}`)
                    }
                    _flushAnimations(e, t) {
                        const n = new pe,
                            r = [],
                            i = new Map,
                            a = [],
                            l = new Map,
                            c = new Map,
                            u = new Map,
                            p = new Set;
                        this.disabledNodes.forEach(e => {
                            p.add(e);
                            const t = this.driver.query(e, ".ng-animate-queued", !0);
                            for (let n = 0; n < t.length; n++) p.add(t[n])
                        });
                        const d = this.bodyNode,
                            f = Array.from(this.statesByElement.keys()),
                            m = Ke(f, this.collectedEnterElements),
                            g = new Map;
                        let y = 0;
                        m.forEach((e, t) => {
                            const n = T + y++;
                            g.set(t, n), e.forEach(e => Qe(e, n))
                        });
                        const v = [],
                            _ = new Set,
                            b = new Set;
                        for (let s = 0; s < this.collectedLeaveElements.length; s++) {
                            const e = this.collectedLeaveElements[s],
                                t = e.__ng_removed;
                            t && t.setForRemoval && (v.push(e), _.add(e), t.hasAnimation ? this.driver.query(e, ".ng-star-inserted", !0).forEach(e => _.add(e)) : b.add(e))
                        }
                        const w = new Map,
                            E = Ke(f, Array.from(_));
                        E.forEach((e, t) => {
                            const n = A + y++;
                            w.set(t, n), e.forEach(e => Qe(e, n))
                        }), e.push(() => {
                            m.forEach((e, t) => {
                                const n = g.get(t);
                                e.forEach(e => Ze(e, n))
                            }), E.forEach((e, t) => {
                                const n = w.get(t);
                                e.forEach(e => Ze(e, n))
                            }), v.forEach(e => {
                                this.processLeaveNode(e)
                            })
                        });
                        const C = [],
                            S = [];
                        for (let s = this._namespaceList.length - 1; s >= 0; s--) {
                            this._namespaceList[s].drainQueuedTransitions(t).forEach(e => {
                                const t = e.player,
                                    s = e.element;
                                if (C.push(t), this.collectedEnterElements.length) {
                                    const e = s.__ng_removed;
                                    if (e && e.setForMove) return void t.destroy()
                                }
                                const i = !d || !this.driver.containsElement(d, s),
                                    o = w.get(s),
                                    p = g.get(s),
                                    f = this._buildInstruction(e, n, p, o, i);
                                if (f.errors && f.errors.length) return void S.push(f);
                                if (i) return t.onStart(() => $(s, f.fromStyles)), t.onDestroy(() => V(s, f.toStyles)), void r.push(t);
                                if (e.isFallbackTransition) return t.onStart(() => $(s, f.fromStyles)), t.onDestroy(() => V(s, f.toStyles)), void r.push(t);
                                f.timelines.forEach(e => e.stretchStartingKeyframe = !0), n.append(s, f.timelines);
                                const m = {
                                    instruction: f,
                                    player: t,
                                    element: s
                                };
                                a.push(m), f.queriedElements.forEach(e => h(l, e, []).push(t)), f.preStyleProps.forEach((e, t) => {
                                    const n = Object.keys(e);
                                    if (n.length) {
                                        let e = c.get(t);
                                        e || c.set(t, e = new Set), n.forEach(t => e.add(t))
                                    }
                                }), f.postStyleProps.forEach((e, t) => {
                                    const n = Object.keys(e);
                                    let s = u.get(t);
                                    s || u.set(t, s = new Set), n.forEach(e => s.add(e))
                                })
                            })
                        }
                        if (S.length) {
                            const e = [];
                            S.forEach(t => {
                                e.push(`@${t.triggerName} has failed due to:\n`), t.errors.forEach(t => e.push(`- ${t}\n`))
                            }), C.forEach(e => e.destroy()), this.reportError(e)
                        }
                        const x = new Map,
                            D = new Map;
                        a.forEach(e => {
                            const t = e.element;
                            n.has(t) && (D.set(t, t), this._beforeAnimationBuild(e.player.namespaceId, e.instruction, x))
                        }), r.forEach(e => {
                            const t = e.element;
                            this._getPreviousPlayers(t, !1, e.namespaceId, e.triggerName, null).forEach(e => {
                                h(x, t, []).push(e), e.destroy()
                            })
                        });
                        const P = v.filter(e => Ye(e, c, u)),
                            k = new Map;
                        Ge(k, this.driver, b, u, s.a).forEach(e => {
                            Ye(e, c, u) && P.push(e)
                        });
                        const I = new Map;
                        m.forEach((e, t) => {
                            Ge(I, this.driver, new Set(e), c, s.k)
                        }), P.forEach(e => {
                            const t = k.get(e),
                                n = I.get(e);
                            k.set(e, Object.assign(Object.assign({}, t), n))
                        });
                        const N = [],
                            M = [],
                            F = {};
                        a.forEach(e => {
                            const {
                                element: t,
                                player: s,
                                instruction: a
                            } = e;
                            if (n.has(t)) {
                                if (p.has(t)) return s.onDestroy(() => V(t, a.toStyles)), s.disabled = !0, s.overrideTotalTime(a.totalTime), void r.push(s);
                                let e = F;
                                if (D.size > 1) {
                                    let n = t;
                                    const s = [];
                                    for (; n = n.parentNode;) {
                                        const t = D.get(n);
                                        if (t) {
                                            e = t;
                                            break
                                        }
                                        s.push(n)
                                    }
                                    s.forEach(t => D.set(t, e))
                                }
                                const n = this._buildAnimation(s.namespaceId, a, x, i, I, k);
                                if (s.setRealPlayer(n), e === F) N.push(s);
                                else {
                                    const t = this.playersByElement.get(e);
                                    t && t.length && (s.parentPlayer = o(t)), r.push(s)
                                }
                            } else $(t, a.fromStyles), s.onDestroy(() => V(t, a.toStyles)), M.push(s), p.has(t) && r.push(s)
                        }), M.forEach(e => {
                            const t = i.get(e.element);
                            if (t && t.length) {
                                const n = o(t);
                                e.setRealPlayer(n)
                            }
                        }), r.forEach(e => {
                            e.parentPlayer ? e.syncPlayerEvents(e.parentPlayer) : e.destroy()
                        });
                        for (let s = 0; s < v.length; s++) {
                            const e = v[s],
                                t = e.__ng_removed;
                            if (Ze(e, A), t && t.hasAnimation) continue;
                            let n = [];
                            if (l.size) {
                                let t = l.get(e);
                                t && t.length && n.push(...t);
                                let s = this.driver.query(e, O, !0);
                                for (let e = 0; e < s.length; e++) {
                                    let t = l.get(s[e]);
                                    t && t.length && n.push(...t)
                                }
                            }
                            const r = n.filter(e => !e.destroyed);
                            r.length ? Je(this, e, r) : this.processLeaveNode(e)
                        }
                        return v.length = 0, N.forEach(e => {
                            this.players.push(e), e.onDone(() => {
                                e.destroy();
                                const t = this.players.indexOf(e);
                                this.players.splice(t, 1)
                            }), e.play()
                        }), N
                    }
                    elementContainsData(e, t) {
                        let n = !1;
                        const s = t.__ng_removed;
                        return s && s.setForRemoval && (n = !0), this.playersByElement.has(t) && (n = !0), this.playersByQueriedElement.has(t) && (n = !0), this.statesByElement.has(t) && (n = !0), this._fetchNamespace(e).elementContainsData(t) || n
                    }
                    afterFlush(e) {
                        this._flushFns.push(e)
                    }
                    afterFlushAnimationsDone(e) {
                        this._whenQuietFns.push(e)
                    }
                    _getPreviousPlayers(e, t, n, s, r) {
                        let i = [];
                        if (t) {
                            const t = this.playersByQueriedElement.get(e);
                            t && (i = t)
                        } else {
                            const t = this.playersByElement.get(e);
                            if (t) {
                                const e = !r || r == $e;
                                t.forEach(t => {
                                    t.queued || (e || t.triggerName == s) && i.push(t)
                                })
                            }
                        }
                        return (n || s) && (i = i.filter(e => (!n || n == e.namespaceId) && (!s || s == e.triggerName))), i
                    }
                    _beforeAnimationBuild(e, t, n) {
                        const s = t.triggerName,
                            r = t.element,
                            i = t.isRemovalTransition ? void 0 : e,
                            o = t.isRemovalTransition ? void 0 : s;
                        for (const a of t.timelines) {
                            const e = a.element,
                                s = e !== r,
                                l = h(n, e, []);
                            this._getPreviousPlayers(e, s, i, o, t.toState).forEach(e => {
                                const t = e.getRealPlayer();
                                t.beforeDestroy && t.beforeDestroy(), e.destroy(), l.push(e)
                            })
                        }
                        $(r, t.fromStyles)
                    }
                    _buildAnimation(e, t, n, r, i, l) {
                        const c = t.triggerName,
                            u = t.element,
                            p = [],
                            d = new Set,
                            f = new Set,
                            m = t.timelines.map(t => {
                                const o = t.element;
                                d.add(o);
                                const h = o.__ng_removed;
                                if (h && h.removedBeforeQueried) return new s.d(t.duration, t.delay);
                                const m = o !== u,
                                    g = function(e) {
                                        const t = [];
                                        return Xe(e, t), t
                                    }((n.get(o) || Re).map(e => e.getRealPlayer())).filter(e => {
                                        const t = e;
                                        return !!t.element && t.element === o
                                    }),
                                    y = i.get(o),
                                    v = l.get(o),
                                    _ = a(this.driver, this._normalizer, 0, t.keyframes, y, v),
                                    b = this._buildPlayer(t, _, g);
                                if (t.subTimeline && r && f.add(o), m) {
                                    const t = new qe(e, c, o);
                                    t.setRealPlayer(b), p.push(t)
                                }
                                return b
                            });
                        p.forEach(e => {
                            h(this.playersByQueriedElement, e.element, []).push(e), e.onDone(() => function(e, t, n) {
                                let s;
                                if (e instanceof Map) {
                                    if (s = e.get(t), s) {
                                        if (s.length) {
                                            const e = s.indexOf(n);
                                            s.splice(e, 1)
                                        }
                                        0 == s.length && e.delete(t)
                                    }
                                } else if (s = e[t], s) {
                                    if (s.length) {
                                        const e = s.indexOf(n);
                                        s.splice(e, 1)
                                    }
                                    0 == s.length && delete e[t]
                                }
                                return s
                            }(this.playersByQueriedElement, e.element, e))
                        }), d.forEach(e => Qe(e, k));
                        const g = o(m);
                        return g.onDestroy(() => {
                            d.forEach(e => Ze(e, k)), V(u, t.toStyles)
                        }), f.forEach(e => {
                            h(r, e, []).push(g)
                        }), g
                    }
                    _buildPlayer(e, t, n) {
                        return t.length > 0 ? this.driver.animate(e.element, t, e.duration, e.delay, e.easing, n) : new s.d(e.duration, e.delay)
                    }
                }
                class qe {
                    constructor(e, t, n) {
                        this.namespaceId = e, this.triggerName = t, this.element = n, this._player = new s.d, this._containsRealPlayer = !1, this._queuedCallbacks = {}, this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0
                    }
                    setRealPlayer(e) {
                        this._containsRealPlayer || (this._player = e, Object.keys(this._queuedCallbacks).forEach(t => {
                            this._queuedCallbacks[t].forEach(n => l(e, t, void 0, n))
                        }), this._queuedCallbacks = {}, this._containsRealPlayer = !0, this.overrideTotalTime(e.totalTime), this.queued = !1)
                    }
                    getRealPlayer() {
                        return this._player
                    }
                    overrideTotalTime(e) {
                        this.totalTime = e
                    }
                    syncPlayerEvents(e) {
                        const t = this._player;
                        t.triggerCallback && e.onStart(() => t.triggerCallback("start")), e.onDone(() => this.finish()), e.onDestroy(() => this.destroy())
                    }
                    _queueEvent(e, t) {
                        h(this._queuedCallbacks, e, []).push(t)
                    }
                    onDone(e) {
                        this.queued && this._queueEvent("done", e), this._player.onDone(e)
                    }
                    onStart(e) {
                        this.queued && this._queueEvent("start", e), this._player.onStart(e)
                    }
                    onDestroy(e) {
                        this.queued && this._queueEvent("destroy", e), this._player.onDestroy(e)
                    }
                    init() {
                        this._player.init()
                    }
                    hasStarted() {
                        return !this.queued && this._player.hasStarted()
                    }
                    play() {
                        !this.queued && this._player.play()
                    }
                    pause() {
                        !this.queued && this._player.pause()
                    }
                    restart() {
                        !this.queued && this._player.restart()
                    }
                    finish() {
                        this._player.finish()
                    }
                    destroy() {
                        this.destroyed = !0, this._player.destroy()
                    }
                    reset() {
                        !this.queued && this._player.reset()
                    }
                    setPosition(e) {
                        this.queued || this._player.setPosition(e)
                    }
                    getPosition() {
                        return this.queued ? 0 : this._player.getPosition()
                    }
                    triggerCallback(e) {
                        const t = this._player;
                        t.triggerCallback && t.triggerCallback(e)
                    }
                }

                function ze(e) {
                    return e && 1 === e.nodeType
                }

                function We(e, t) {
                    const n = e.style.display;
                    return e.style.display = null != t ? t : "none", n
                }

                function Ge(e, t, n, s, r) {
                    const i = [];
                    n.forEach(e => i.push(We(e)));
                    const o = [];
                    s.forEach((n, s) => {
                        const i = {};
                        n.forEach(e => {
                            const n = i[e] = t.computeStyle(s, e, r);
                            n && 0 != n.length || (s.__ng_removed = Le, o.push(s))
                        }), e.set(s, i)
                    });
                    let a = 0;
                    return n.forEach(e => We(e, i[a++])), o
                }

                function Ke(e, t) {
                    const n = new Map;
                    if (e.forEach(e => n.set(e, [])), 0 == t.length) return n;
                    const s = new Set(t),
                        r = new Map;

                    function i(e) {
                        if (!e) return 1;
                        let t = r.get(e);
                        if (t) return t;
                        const o = e.parentNode;
                        return t = n.has(o) ? o : s.has(o) ? 1 : i(o), r.set(e, t), t
                    }
                    return t.forEach(e => {
                        const t = i(e);
                        1 !== t && n.get(t).push(e)
                    }), n
                }

                function Qe(e, t) {
                    if (e.classList) e.classList.add(t);
                    else {
                        let n = e.$$classes;
                        n || (n = e.$$classes = {}), n[t] = !0
                    }
                }

                function Ze(e, t) {
                    if (e.classList) e.classList.remove(t);
                    else {
                        let n = e.$$classes;
                        n && delete n[t]
                    }
                }

                function Je(e, t, n) {
                    o(n).onDone(() => e.processLeaveNode(t))
                }

                function Xe(e, t) {
                    for (let n = 0; n < e.length; n++) {
                        const r = e[n];
                        r instanceof s.j ? Xe(r.players, t) : t.push(r)
                    }
                }

                function Ye(e, t, n) {
                    const s = n.get(e);
                    if (!s) return !1;
                    let r = t.get(e);
                    return r ? s.forEach(e => r.add(e)) : t.set(e, s), n.delete(e), !0
                }
                class et {
                    constructor(e, t, n) {
                        this.bodyNode = e, this._driver = t, this._triggerCache = {}, this.onRemovalComplete = (e, t) => {}, this._transitionEngine = new Ue(e, t, n), this._timelineEngine = new Ie(e, t, n), this._transitionEngine.onRemovalComplete = (e, t) => this.onRemovalComplete(e, t)
                    }
                    registerTrigger(e, t, n, s, r) {
                        const i = e + "-" + s;
                        let o = this._triggerCache[i];
                        if (!o) {
                            const e = [],
                                t = ie(this._driver, r, e);
                            if (e.length) throw new Error(`The animation trigger "${s}" has failed to build due to the following errors:\n - ${e.join("\n - ")}`);
                            o = function(e, t) {
                                return new Pe(e, t)
                            }(s, t), this._triggerCache[i] = o
                        }
                        this._transitionEngine.registerTrigger(t, s, o)
                    }
                    register(e, t) {
                        this._transitionEngine.register(e, t)
                    }
                    destroy(e, t) {
                        this._transitionEngine.destroy(e, t)
                    }
                    onInsert(e, t, n, s) {
                        this._transitionEngine.insertNode(e, t, n, s)
                    }
                    onRemove(e, t, n, s) {
                        this._transitionEngine.removeNode(e, t, s || !1, n)
                    }
                    disableAnimations(e, t) {
                        this._transitionEngine.markElementAsDisabled(e, t)
                    }
                    process(e, t, n, s) {
                        if ("@" == n.charAt(0)) {
                            const [e, r] = p(n), i = s;
                            this._timelineEngine.command(e, t, r, i)
                        } else this._transitionEngine.trigger(e, t, n, s)
                    }
                    listen(e, t, n, s, r) {
                        if ("@" == n.charAt(0)) {
                            const [e, s] = p(n);
                            return this._timelineEngine.listen(e, t, s, r)
                        }
                        return this._transitionEngine.listen(e, t, n, s, r)
                    }
                    flush(e = -1) {
                        this._transitionEngine.flush(e)
                    }
                    get players() {
                        return this._transitionEngine.players.concat(this._timelineEngine.players)
                    }
                    whenRenderingDone() {
                        return this._transitionEngine.whenRenderingDone()
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                function tt(e, t) {
                    let n = null,
                        s = null;
                    return Array.isArray(t) && t.length ? (n = st(t[0]), t.length > 1 && (s = st(t[t.length - 1]))) : t && (n = st(t)), n || s ? new nt(e, n, s) : null
                }
                class nt {
                    constructor(e, t, n) {
                        this._element = e, this._startStyles = t, this._endStyles = n, this._state = 0;
                        let s = nt.initialStylesByElement.get(e);
                        s || nt.initialStylesByElement.set(e, s = {}), this._initialStyles = s
                    }
                    start() {
                        this._state < 1 && (this._startStyles && V(this._element, this._startStyles, this._initialStyles), this._state = 1)
                    }
                    finish() {
                        this.start(), this._state < 2 && (V(this._element, this._initialStyles), this._endStyles && (V(this._element, this._endStyles), this._endStyles = null), this._state = 1)
                    }
                    destroy() {
                        this.finish(), this._state < 3 && (nt.initialStylesByElement.delete(this._element), this._startStyles && ($(this._element, this._startStyles), this._endStyles = null), this._endStyles && ($(this._element, this._endStyles), this._endStyles = null), V(this._element, this._initialStyles), this._state = 3)
                    }
                }

                function st(e) {
                    let t = null;
                    const n = Object.keys(e);
                    for (let s = 0; s < n.length; s++) {
                        const r = n[s];
                        rt(r) && (t = t || {}, t[r] = e[r])
                    }
                    return t
                }

                function rt(e) {
                    return "display" === e || "position" === e
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                nt.initialStylesByElement = new WeakMap;
                const it = "animation",
                    ot = "animationend";
                class at {
                    constructor(e, t, n, s, r, i, o) {
                        this._element = e, this._name = t, this._duration = n, this._delay = s, this._easing = r, this._fillMode = i, this._onDoneFn = o, this._finished = !1, this._destroyed = !1, this._startTime = 0, this._position = 0, this._eventFn = e => this._handleCallback(e)
                    }
                    apply() {
                        ! function(e, t) {
                            const n = dt(e, "").trim();
                            let s = 0;
                            n.length && (s = function(e, t) {
                                let n = 0;
                                for (let s = 0; s < e.length; s++) {
                                    e.charAt(s) === t && n++
                                }
                                return n
                            }(n, ",") + 1, t = `${n}, ${t}`);
                            pt(e, "", t)
                        }(this._element, `${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`), ht(this._element, this._eventFn, !1), this._startTime = Date.now()
                    }
                    pause() {
                        lt(this._element, this._name, "paused")
                    }
                    resume() {
                        lt(this._element, this._name, "running")
                    }
                    setPosition(e) {
                        const t = ct(this._element, this._name);
                        this._position = e * this._duration, pt(this._element, "Delay", `-${this._position}ms`, t)
                    }
                    getPosition() {
                        return this._position
                    }
                    _handleCallback(e) {
                        const t = e._ngTestManualTimestamp || Date.now(),
                            n = 1e3 * parseFloat(e.elapsedTime.toFixed(3));
                        e.animationName == this._name && Math.max(t - this._startTime, 0) >= this._delay && n >= this._duration && this.finish()
                    }
                    finish() {
                        this._finished || (this._finished = !0, this._onDoneFn(), ht(this._element, this._eventFn, !0))
                    }
                    destroy() {
                        this._destroyed || (this._destroyed = !0, this.finish(), function(e, t) {
                            const n = dt(e, "").split(","),
                                s = ut(n, t);
                            if (s >= 0) {
                                n.splice(s, 1);
                                pt(e, "", n.join(","))
                            }
                        }(this._element, this._name))
                    }
                }

                function lt(e, t, n) {
                    pt(e, "PlayState", n, ct(e, t))
                }

                function ct(e, t) {
                    const n = dt(e, "");
                    if (n.indexOf(",") > 0) {
                        return ut(n.split(","), t)
                    }
                    return ut([n], t)
                }

                function ut(e, t) {
                    for (let n = 0; n < e.length; n++)
                        if (e[n].indexOf(t) >= 0) return n;
                    return -1
                }

                function ht(e, t, n) {
                    n ? e.removeEventListener(ot, t) : e.addEventListener(ot, t)
                }

                function pt(e, t, n, s) {
                    const r = it + t;
                    if (null != s) {
                        const t = e.style[r];
                        if (t.length) {
                            const e = t.split(",");
                            e[s] = n, n = e.join(",")
                        }
                    }
                    e.style[r] = n
                }

                function dt(e, t) {
                    return e.style[it + t] || ""
                }
                class ft {
                    constructor(e, t, n, s, r, i, o, a) {
                        this.element = e, this.keyframes = t, this.animationName = n, this._duration = s, this._delay = r, this._finalStyles = o, this._specialStyles = a, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this.currentSnapshot = {}, this._state = 0, this.easing = i || "linear", this.totalTime = s + r, this._buildStyler()
                    }
                    onStart(e) {
                        this._onStartFns.push(e)
                    }
                    onDone(e) {
                        this._onDoneFns.push(e)
                    }
                    onDestroy(e) {
                        this._onDestroyFns.push(e)
                    }
                    destroy() {
                        this.init(), this._state >= 4 || (this._state = 4, this._styler.destroy(), this._flushStartFns(), this._flushDoneFns(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = [])
                    }
                    _flushDoneFns() {
                        this._onDoneFns.forEach(e => e()), this._onDoneFns = []
                    }
                    _flushStartFns() {
                        this._onStartFns.forEach(e => e()), this._onStartFns = []
                    }
                    finish() {
                        this.init(), this._state >= 3 || (this._state = 3, this._styler.finish(), this._flushStartFns(), this._specialStyles && this._specialStyles.finish(), this._flushDoneFns())
                    }
                    setPosition(e) {
                        this._styler.setPosition(e)
                    }
                    getPosition() {
                        return this._styler.getPosition()
                    }
                    hasStarted() {
                        return this._state >= 2
                    }
                    init() {
                        if (this._state >= 1) return;
                        this._state = 1;
                        this.element;
                        this._styler.apply(), this._delay && this._styler.pause()
                    }
                    play() {
                        this.init(), this.hasStarted() || (this._flushStartFns(), this._state = 2, this._specialStyles && this._specialStyles.start()), this._styler.resume()
                    }
                    pause() {
                        this.init(), this._styler.pause()
                    }
                    restart() {
                        this.reset(), this.play()
                    }
                    reset() {
                        this._styler.destroy(), this._buildStyler(), this._styler.apply()
                    }
                    _buildStyler() {
                        this._styler = new at(this.element, this.animationName, this._duration, this._delay, this.easing, "forwards", () => this.finish())
                    }
                    triggerCallback(e) {
                        const t = "start" == e ? this._onStartFns : this._onDoneFns;
                        t.forEach(e => e()), t.length = 0
                    }
                    beforeDestroy() {
                        this.init();
                        const e = {};
                        if (this.hasStarted()) {
                            const t = this._state >= 3;
                            Object.keys(this._finalStyles).forEach(n => {
                                "offset" != n && (e[n] = t ? this._finalStyles[n] : J(this.element, n))
                            })
                        }
                        this.currentSnapshot = e
                    }
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                class mt extends s.d {
                    constructor(e, t) {
                        super(), this.element = e, this._startingStyles = {}, this.__initialized = !1, this._styles = C(t)
                    }
                    init() {
                        !this.__initialized && this._startingStyles && (this.__initialized = !0, Object.keys(this._styles).forEach(e => {
                            this._startingStyles[e] = this.element.style[e]
                        }), super.init())
                    }
                    play() {
                        this._startingStyles && (this.init(), Object.keys(this._styles).forEach(e => this.element.style.setProperty(e, this._styles[e])), super.play())
                    }
                    destroy() {
                        this._startingStyles && (Object.keys(this._startingStyles).forEach(e => {
                            const t = this._startingStyles[e];
                            t ? this.element.style.setProperty(e, t) : this.element.style.removeProperty(e)
                        }), this._startingStyles = null, super.destroy())
                    }
                }
                class gt {
                    constructor() {
                        this._count = 0, this._head = document.querySelector("head")
                    }
                    validateStyleProperty(e) {
                        return _(e)
                    }
                    matchesElement(e, t) {
                        return b(e, t)
                    }
                    containsElement(e, t) {
                        return w(e, t)
                    }
                    query(e, t, n) {
                        return E(e, t, n)
                    }
                    computeStyle(e, t, n) {
                        return window.getComputedStyle(e)[t]
                    }
                    buildKeyframeElement(e, t, n) {
                        n = n.map(e => C(e));
                        let s = `@keyframes ${t} {\n`,
                            r = "";
                        n.forEach(e => {
                            r = " ";
                            const t = parseFloat(e.offset);
                            s += `${r}${100*t}% {\n`, r += " ", Object.keys(e).forEach(t => {
                                const n = e[t];
                                switch (t) {
                                    case "offset":
                                        return;
                                    case "easing":
                                        return void(n && (s += `${r}animation-timing-function: ${n};\n`));
                                    default:
                                        return void(s += `${r}${t}: ${n};\n`)
                                }
                            }), s += `${r}}\n`
                        }), s += "}\n";
                        const i = document.createElement("style");
                        return i.textContent = s, i
                    }
                    animate(e, t, n, s, r, i = [], o) {
                        const a = i.filter(e => e instanceof ft),
                            l = {};
                        K(n, s) && a.forEach(e => {
                            let t = e.currentSnapshot;
                            Object.keys(t).forEach(e => l[e] = t[e])
                        });
                        const c = function(e) {
                            let t = {};
                            if (e) {
                                (Array.isArray(e) ? e : [e]).forEach(e => {
                                    Object.keys(e).forEach(n => {
                                        "offset" != n && "easing" != n && (t[n] = e[n])
                                    })
                                })
                            }
                            return t
                        }(t = Q(e, t, l));
                        if (0 == n) return new mt(e, c);
                        const u = "gen_css_kf_" + this._count++,
                            h = this.buildKeyframeElement(e, u, t);
                        document.querySelector("head").appendChild(h);
                        const p = tt(e, t),
                            d = new ft(e, t, u, n, s, r, c, p);
                        return d.onDestroy(() => {
                            var e;
                            (e = h).parentNode.removeChild(e)
                        }), d
                    }
                }
                class yt {
                    constructor(e, t, n, s) {
                        this.element = e, this.keyframes = t, this.options = n, this._specialStyles = s, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this.time = 0, this.parentPlayer = null, this.currentSnapshot = {}, this._duration = n.duration, this._delay = n.delay || 0, this.time = this._duration + this._delay
                    }
                    _onFinish() {
                        this._finished || (this._finished = !0, this._onDoneFns.forEach(e => e()), this._onDoneFns = [])
                    }
                    init() {
                        this._buildPlayer(), this._preparePlayerBeforeStart()
                    }
                    _buildPlayer() {
                        if (this._initialized) return;
                        this._initialized = !0;
                        const e = this.keyframes;
                        this.domPlayer = this._triggerWebAnimation(this.element, e, this.options), this._finalKeyframe = e.length ? e[e.length - 1] : {}, this.domPlayer.addEventListener("finish", () => this._onFinish())
                    }
                    _preparePlayerBeforeStart() {
                        this._delay ? this._resetDomPlayerState() : this.domPlayer.pause()
                    }
                    _triggerWebAnimation(e, t, n) {
                        return e.animate(t, n)
                    }
                    onStart(e) {
                        this._onStartFns.push(e)
                    }
                    onDone(e) {
                        this._onDoneFns.push(e)
                    }
                    onDestroy(e) {
                        this._onDestroyFns.push(e)
                    }
                    play() {
                        this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(e => e()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play()
                    }
                    pause() {
                        this.init(), this.domPlayer.pause()
                    }
                    finish() {
                        this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish()
                    }
                    reset() {
                        this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1
                    }
                    _resetDomPlayerState() {
                        this.domPlayer && this.domPlayer.cancel()
                    }
                    restart() {
                        this.reset(), this.play()
                    }
                    hasStarted() {
                        return this._started
                    }
                    destroy() {
                        this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(e => e()), this._onDestroyFns = [])
                    }
                    setPosition(e) {
                        this.domPlayer.currentTime = e * this.time
                    }
                    getPosition() {
                        return this.domPlayer.currentTime / this.time
                    }
                    get totalTime() {
                        return this._delay + this._duration
                    }
                    beforeDestroy() {
                        const e = {};
                        this.hasStarted() && Object.keys(this._finalKeyframe).forEach(t => {
                            "offset" != t && (e[t] = this._finished ? this._finalKeyframe[t] : J(this.element, t))
                        }), this.currentSnapshot = e
                    }
                    triggerCallback(e) {
                        const t = "start" == e ? this._onStartFns : this._onDoneFns;
                        t.forEach(e => e()), t.length = 0
                    }
                }
                class vt {
                    constructor() {
                        this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(bt().toString()), this._cssKeyframesDriver = new gt
                    }
                    validateStyleProperty(e) {
                        return _(e)
                    }
                    matchesElement(e, t) {
                        return b(e, t)
                    }
                    containsElement(e, t) {
                        return w(e, t)
                    }
                    query(e, t, n) {
                        return E(e, t, n)
                    }
                    computeStyle(e, t, n) {
                        return window.getComputedStyle(e)[t]
                    }
                    overrideWebAnimationsSupport(e) {
                        this._isNativeImpl = e
                    }
                    animate(e, t, n, s, r, i = [], o) {
                        if (!o && !this._isNativeImpl) return this._cssKeyframesDriver.animate(e, t, n, s, r, i);
                        const a = {
                            duration: n,
                            delay: s,
                            fill: 0 == s ? "both" : "forwards"
                        };
                        r && (a.easing = r);
                        const l = {},
                            c = i.filter(e => e instanceof yt);
                        K(n, s) && c.forEach(e => {
                            let t = e.currentSnapshot;
                            Object.keys(t).forEach(e => l[e] = t[e])
                        });
                        const u = tt(e, t = Q(e, t = t.map(e => R(e, !1)), l));
                        return new yt(e, t, a, u)
                    }
                }

                function _t() {
                    return "function" == typeof bt()
                }

                function bt() {
                    return "undefined" != typeof window && void 0 !== window.document && Element.prototype.animate || {}
                }
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
                /**
                 * @license
                 * Copyright Google LLC All Rights Reserved.
                 *
                 * Use of this source code is governed by an MIT-style license that can be
                 * found in the LICENSE file at https://angular.io/license
                 */
            }).call(this, n("8oxB"))
        },
        gRHU: function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return i
            });
            var s = n("2fFW"),
                r = n("NJ4a");
            const i = {
                closed: !0,
                next(e) {},
                error(e) {
                    if (s.a.useDeprecatedSynchronousErrorHandling) throw e;
                    Object(r.a)(e)
                },
                complete() {}
            }
        },
        "iJE/": function(e, t, n) {
            "use strict";
            e.exports = (e, t, n) => Object.keys(e).reduce((n, s) => t(n, e[s], s), n)
        },
        jZKg: function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return i
            });
            var s = n("HDdC"),
                r = n("quSY");

            function i(e, t) {
                return new s.a(n => {
                    const s = new r.a;
                    let i = 0;
                    return s.add(t.schedule(function() {
                        i !== e.length ? (n.next(e[i++]), n.closed || s.add(this.schedule())) : n.complete()
                    })), s
                })
            }
        },
        kJWO: function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return s
            });
            const s = "function" == typeof Symbol && Symbol.observable || "@@observable"
        },
        kMlx: function(e, t, n) {
            "use strict";
            const s = n("8zgK");

            function r(e) {
                if (e) return function(e) {
                    for (const t in r.prototype) e[t] = r.prototype[t];
                    return e
                }(e)
            }
            e.exports = r, r.prototype.clearTimeout = function() {
                return clearTimeout(this._timer), clearTimeout(this._responseTimeoutTimer), delete this._timer, delete this._responseTimeoutTimer, this
            }, r.prototype.parse = function(e) {
                return this._parser = e, this
            }, r.prototype.responseType = function(e) {
                return this._responseType = e, this
            }, r.prototype.serialize = function(e) {
                return this._serializer = e, this
            }, r.prototype.timeout = function(e) {
                if (!e || "object" != typeof e) return this._timeout = e, this._responseTimeout = 0, this;
                for (const t in e) switch (t) {
                    case "deadline":
                        this._timeout = e.deadline;
                        break;
                    case "response":
                        this._responseTimeout = e.response;
                        break;
                    default:
                        console.warn("Unknown timeout option", t)
                }
                return this
            }, r.prototype.retry = function(e, t) {
                return 0 !== arguments.length && !0 !== e || (e = 1), e <= 0 && (e = 0), this._maxRetries = e, this._retries = 0, this._retryCallback = t, this
            };
            const i = ["ECONNRESET", "ETIMEDOUT", "EADDRINFO", "ESOCKETTIMEDOUT"];
            r.prototype._shouldRetry = function(e, t) {
                if (!this._maxRetries || this._retries++ >= this._maxRetries) return !1;
                if (this._retryCallback) try {
                    const n = this._retryCallback(e, t);
                    if (!0 === n) return !0;
                    if (!1 === n) return !1
                } catch (n) {
                    console.error(n)
                }
                if (t && t.status && t.status >= 500 && 501 != t.status) return !0;
                if (e) {
                    if (e.code && ~i.indexOf(e.code)) return !0;
                    if (e.timeout && "ECONNABORTED" == e.code) return !0;
                    if (e.crossDomain) return !0
                }
                return !1
            }, r.prototype._retry = function() {
                return this.clearTimeout(), this.req && (this.req = null, this.req = this.request()), this._aborted = !1, this.timedout = !1, this._end()
            }, r.prototype.then = function(e, t) {
                if (!this._fullfilledPromise) {
                    const e = this;
                    this._endCalled && console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises"), this._fullfilledPromise = new Promise((t, n) => {
                        e.on("error", n), e.on("abort", () => {
                            const e = new Error("Aborted");
                            e.code = "ABORTED", e.status = this.status, e.method = this.method, e.url = this.url, n(e)
                        }), e.end((e, s) => {
                            e ? n(e) : t(s)
                        })
                    })
                }
                return this._fullfilledPromise.then(e, t)
            }, r.prototype.catch = function(e) {
                return this.then(void 0, e)
            }, r.prototype.use = function(e) {
                return e(this), this
            }, r.prototype.ok = function(e) {
                if ("function" != typeof e) throw Error("Callback required");
                return this._okCallback = e, this
            }, r.prototype._isResponseOK = function(e) {
                return !!e && (this._okCallback ? this._okCallback(e) : e.status >= 200 && e.status < 300)
            }, r.prototype.get = function(e) {
                return this._header[e.toLowerCase()]
            }, r.prototype.getHeader = r.prototype.get, r.prototype.set = function(e, t) {
                if (s(e)) {
                    for (const t in e) this.set(t, e[t]);
                    return this
                }
                return this._header[e.toLowerCase()] = t, this.header[e] = t, this
            }, r.prototype.unset = function(e) {
                return delete this._header[e.toLowerCase()], delete this.header[e], this
            }, r.prototype.field = function(e, t) {
                if (null == e) throw new Error(".field(name, val) name can not be empty");
                if (this._data) throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
                if (s(e)) {
                    for (const t in e) this.field(t, e[t]);
                    return this
                }
                if (Array.isArray(t)) {
                    for (const n in t) this.field(e, t[n]);
                    return this
                }
                if (null == t) throw new Error(".field(name, val) val can not be empty");
                return "boolean" == typeof t && (t = "" + t), this._getFormData().append(e, t), this
            }, r.prototype.abort = function() {
                return this._aborted || (this._aborted = !0, this.xhr && this.xhr.abort(), this.req && this.req.abort(), this.clearTimeout(), this.emit("abort")), this
            }, r.prototype._auth = function(e, t, n, s) {
                switch (n.type) {
                    case "basic":
                        this.set("Authorization", `Basic ${s(`${e}:${t}`)}`);
                        break;
                    case "auto":
                        this.username = e, this.password = t;
                        break;
                    case "bearer":
                        this.set("Authorization", `Bearer ${e}`)
                }
                return this
            }, r.prototype.withCredentials = function(e) {
                return null == e && (e = !0), this._withCredentials = e, this
            }, r.prototype.redirects = function(e) {
                return this._maxRedirects = e, this
            }, r.prototype.maxResponseSize = function(e) {
                if ("number" != typeof e) throw TypeError("Invalid argument");
                return this._maxResponseSize = e, this
            }, r.prototype.toJSON = function() {
                return {
                    method: this.method,
                    url: this.url,
                    data: this._data,
                    headers: this._header
                }
            }, r.prototype.send = function(e) {
                const t = s(e);
                let n = this._header["content-type"];
                if (this._formData) throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
                if (t && !this._data) Array.isArray(e) ? this._data = [] : this._isHost(e) || (this._data = {});
                else if (e && this._data && this._isHost(this._data)) throw Error("Can't merge these send calls");
                if (t && s(this._data))
                    for (const s in e) this._data[s] = e[s];
                else "string" == typeof e ? (n || this.type("form"), n = this._header["content-type"], this._data = "application/x-www-form-urlencoded" == n ? this._data ? `${this._data}&${e}` : e : (this._data || "") + e) : this._data = e;
                return !t || this._isHost(e) || n || this.type("json"), this
            }, r.prototype.sortQuery = function(e) {
                return this._sort = void 0 === e || e, this
            }, r.prototype._finalizeQueryString = function() {
                const e = this._query.join("&");
                if (e && (this.url += (this.url.indexOf("?") >= 0 ? "&" : "?") + e), this._query.length = 0, this._sort) {
                    const e = this.url.indexOf("?");
                    if (e >= 0) {
                        const t = this.url.substring(e + 1).split("&");
                        "function" == typeof this._sort ? t.sort(this._sort) : t.sort(), this.url = this.url.substring(0, e) + "?" + t.join("&")
                    }
                }
            }, r.prototype._appendQueryString = () => {
                console.trace("Unsupported")
            }, r.prototype._timeoutError = function(e, t, n) {
                if (this._aborted) return;
                const s = new Error(`${e+t}ms exceeded`);
                s.timeout = t, s.code = "ECONNABORTED", s.errno = n, this.timedout = !0, this.abort(), this.callback(s)
            }, r.prototype._setTimeouts = function() {
                const e = this;
                this._timeout && !this._timer && (this._timer = setTimeout(() => {
                    e._timeoutError("Timeout of ", e._timeout, "ETIME")
                }, this._timeout)), this._responseTimeout && !this._responseTimeoutTimer && (this._responseTimeoutTimer = setTimeout(() => {
                    e._timeoutError("Response timeout of ", e._responseTimeout, "ETIMEDOUT")
                }, this._responseTimeout))
            }
        },
        l7GE: function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return r
            });
            var s = n("7o/Q");
            class r extends s.a {
                notifyNext(e, t, n, s, r) {
                    this.destination.next(t)
                }
                notifyError(e, t) {
                    this.destination.error(e)
                }
                notifyComplete(e) {
                    this.destination.complete()
                }
            }
        },
        lJxs: function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return r
            });
            var s = n("7o/Q");

            function r(e, t) {
                return function(n) {
                    if ("function" != typeof e) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
                    return n.lift(new i(e, t))
                }
            }
            class i {
                constructor(e, t) {
                    this.project = e, this.thisArg = t
                }
                call(e, t) {
                    return t.subscribe(new o(e, this.project, this.thisArg))
                }
            }
            class o extends s.a {
                constructor(e, t, n) {
                    super(e), this.project = t, this.count = 0, this.thisArg = n || this
                }
                _next(e) {
                    let t;
                    try {
                        t = this.project.call(this.thisArg, e, this.count++)
                    } catch (n) {
                        return void this.destination.error(n)
                    }
                    this.destination.next(t)
                }
            }
        },
        ml1J: function(e, t, n) {
            "use strict";
            (function(t) {
                const s = n("Qyje"),
                    r = n("Qup9"),
                    i = n("Qwta"),
                    o = n("0KBE"),
                    a = n("iJE/"),
                    l = n("3t9w");

                function c(e) {
                    this._options = ["auth", "endpoint", "headers", "username", "password", "nonce"].reduce((t, n) => (e && e[n] && (t[n] = e[n]), t), {}), this.transport = e && e.transport, this._params = {}, this._supportedMethods = ["head", "get", "put", "post", "delete"], this._path = {}
                }
                const u = e => e;
                const h = e => e ? a(e, (e, t, n) => (null != t && "" !== t && (e[n] = t), e), {}) : e,
                    p = (e, t) => {
                        if (!e.reduce((e, n) => !n.validate || (e || n.validate(t)), !1)) throw new Error(["Invalid path component:", t, "does not match" + (e.length > 1 ? " any of" : ""), e.reduce((e, t) => e.concat(t.component), []).join(", ")].join(" "))
                    };
                c.prototype._renderQuery = function() {
                    const e = { ...h(this._params)
                        },
                        t = (n = this._taxonomyFilters) ? a(n, (e, t, n) => (e[n] = t.map(e => (e + "").trim().toLowerCase()).join("+"), e), {}) : {};
                    var n;
                    e.filter = { ...h(this._filters),
                        ...t
                    };
                    const r = s.stringify(e, {
                            arrayFormat: "brackets"
                        }).split("&").sort().join("&"),
                        i = /\?/.test(this._options.endpoint) ? "&" : "?";
                    return "" === r ? "" : i + r
                }, c.prototype._renderPath = function() {
                    this.validatePath();
                    const e = this._path,
                        t = Object.keys(e).sort((e, t) => parseInt(e, 10) - parseInt(t, 10)).map(t => e[t]);
                    return [this._namespace].concat(t).filter(u).join("/")
                }, c.prototype.toString = function() {
                    const e = this._renderPath(),
                        t = this._renderQuery();
                    return this._options.endpoint + e + t
                }, c.prototype.setPathPart = function(e, t) {
                    if (this._path[e]) throw new Error("Cannot overwrite value " + this._path[e]);
                    return this._path[e] = t, this
                }, c.prototype.validatePath = function() {
                    const e = Object.keys(this._path).map(e => parseInt(e, 10)).filter(e => !isNaN(e)),
                        t = Math.max.apply(null, e),
                        n = [];
                    let s = !0;
                    for (let r = 0; r <= t; r++) this._levels && this._levels[r] && (this._path[r] ? (p(this._levels[r], this._path[r]), n.push(this._path[r])) : (n.push(" ??? "), s = !1));
                    if (!s) throw new Error("Incomplete URL! Missing component: /" + n.join("/"));
                    return this
                }, c.prototype.param = function(e, t) {
                    return !e || "string" == typeof e && void 0 === t || ("string" == typeof e && (e = i(e, t)), Object.keys(e).forEach(t => {
                        let n = e[t];
                        Array.isArray(n) && (n = l(n).sort(r)), this._params[t] = n
                    })), this
                }, c.prototype.context = o("context"), c.prototype.edit = function() {
                    return this.context("edit")
                }, c.prototype.embed = function() {
                    return this.param("_embed", !0)
                }, c.prototype.page = o("page"), c.prototype.perPage = o("per_page"), c.prototype.offset = o("offset"), c.prototype.order = o("order"), c.prototype.orderby = o("orderby"), c.prototype.search = o("search"), c.prototype.include = o("include"), c.prototype.exclude = o("exclude"), c.prototype.slug = o("slug"), c.prototype.namespace = function(e) {
                    return this._namespace = e, this
                }, c.prototype.auth = function(e) {
                    return "object" == typeof e && ("string" == typeof e.username && (this._options.username = e.username), "string" == typeof e.password && (this._options.password = e.password), e.nonce && (this._options.nonce = e.nonce)), this._options.auth = !0, this
                }, c.prototype.file = function(e, n) {
                    if (t.Buffer && e instanceof t.Buffer && !n) throw new Error(".file(): File name is a required argument when uploading a Buffer");
                    return this._attachment = e, this._attachmentName = n || void 0, this
                }, c.prototype.setHeaders = function(e, t) {
                    return "string" == typeof e && (e = i(e, t)), this._options.headers = { ...this._options.headers || {},
                        ...e
                    }, this
                }, c.prototype.get = function(e) {
                    return this.transport.get(this, e)
                }, c.prototype.headers = function(e) {
                    return this.transport.head(this, e)
                }, c.prototype.create = function(e, t) {
                    return this.transport.post(this, e, t)
                }, c.prototype.update = function(e, t) {
                    return this.transport.put(this, e, t)
                }, c.prototype.delete = function(e, t) {
                    return this.transport.delete(this, e, t)
                }, c.prototype.then = function(e, t) {
                    return this.transport.get(this).then(e, t)
                }, e.exports = c
            }).call(this, n("yLpj"))
        },
        n6bG: function(e, t, n) {
            "use strict";

            function s(e) {
                return "function" == typeof e
            }
            n.d(t, "a", function() {
                return s
            })
        },
        nZbv: function(e, t) {
            function n() {
                this._defaults = []
            }["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects", "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert"].forEach(e => {
                n.prototype[e] = function(...t) {
                    return this._defaults.push({
                        fn: e,
                        args: t
                    }), this
                }
            }), n.prototype._setDefaults = function(e) {
                this._defaults.forEach(t => {
                    e[t.fn].apply(e, t.args)
                })
            }, e.exports = n
        },
        ngJS: function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return s
            });
            const s = e => t => {
                for (let n = 0, s = e.length; n < s && !t.closed; n++) t.next(e[n]);
                t.complete()
            }
        },
        nmq7: function(e, t, n) {
            "use strict";
            var s = n("0jNN"),
                r = Object.prototype.hasOwnProperty,
                i = Array.isArray,
                o = {
                    allowDots: !1,
                    allowPrototypes: !1,
                    allowSparse: !1,
                    arrayLimit: 20,
                    charset: "utf-8",
                    charsetSentinel: !1,
                    comma: !1,
                    decoder: s.decode,
                    delimiter: "&",
                    depth: 5,
                    ignoreQueryPrefix: !1,
                    interpretNumericEntities: !1,
                    parameterLimit: 1e3,
                    parseArrays: !0,
                    plainObjects: !1,
                    strictNullHandling: !1
                },
                a = function(e) {
                    return e.replace(/&#(\d+);/g, function(e, t) {
                        return String.fromCharCode(parseInt(t, 10))
                    })
                },
                l = function(e, t) {
                    return e && "string" == typeof e && t.comma && e.indexOf(",") > -1 ? e.split(",") : e
                },
                c = function(e, t, n, s) {
                    if (e) {
                        var i = n.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e,
                            o = /(\[[^[\]]*])/g,
                            a = n.depth > 0 && /(\[[^[\]]*])/.exec(i),
                            c = a ? i.slice(0, a.index) : i,
                            u = [];
                        if (c) {
                            if (!n.plainObjects && r.call(Object.prototype, c) && !n.allowPrototypes) return;
                            u.push(c)
                        }
                        for (var h = 0; n.depth > 0 && null !== (a = o.exec(i)) && h < n.depth;) {
                            if (h += 1, !n.plainObjects && r.call(Object.prototype, a[1].slice(1, -1)) && !n.allowPrototypes) return;
                            u.push(a[1])
                        }
                        return a && u.push("[" + i.slice(a.index) + "]"),
                            function(e, t, n, s) {
                                for (var r = s ? t : l(t, n), i = e.length - 1; i >= 0; --i) {
                                    var o, a = e[i];
                                    if ("[]" === a && n.parseArrays) o = [].concat(r);
                                    else {
                                        o = n.plainObjects ? Object.create(null) : {};
                                        var c = "[" === a.charAt(0) && "]" === a.charAt(a.length - 1) ? a.slice(1, -1) : a,
                                            u = parseInt(c, 10);
                                        n.parseArrays || "" !== c ? !isNaN(u) && a !== c && String(u) === c && u >= 0 && n.parseArrays && u <= n.arrayLimit ? (o = [])[u] = r : "__proto__" !== c && (o[c] = r) : o = {
                                            0: r
                                        }
                                    }
                                    r = o
                                }
                                return r
                            }(u, t, n, s)
                    }
                };
            e.exports = function(e, t) {
                var n = function(e) {
                    if (!e) return o;
                    if (null !== e.decoder && void 0 !== e.decoder && "function" != typeof e.decoder) throw new TypeError("Decoder has to be a function.");
                    if (void 0 !== e.charset && "utf-8" !== e.charset && "iso-8859-1" !== e.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
                    var t = void 0 === e.charset ? o.charset : e.charset;
                    return {
                        allowDots: void 0 === e.allowDots ? o.allowDots : !!e.allowDots,
                        allowPrototypes: "boolean" == typeof e.allowPrototypes ? e.allowPrototypes : o.allowPrototypes,
                        allowSparse: "boolean" == typeof e.allowSparse ? e.allowSparse : o.allowSparse,
                        arrayLimit: "number" == typeof e.arrayLimit ? e.arrayLimit : o.arrayLimit,
                        charset: t,
                        charsetSentinel: "boolean" == typeof e.charsetSentinel ? e.charsetSentinel : o.charsetSentinel,
                        comma: "boolean" == typeof e.comma ? e.comma : o.comma,
                        decoder: "function" == typeof e.decoder ? e.decoder : o.decoder,
                        delimiter: "string" == typeof e.delimiter || s.isRegExp(e.delimiter) ? e.delimiter : o.delimiter,
                        depth: "number" == typeof e.depth || !1 === e.depth ? +e.depth : o.depth,
                        ignoreQueryPrefix: !0 === e.ignoreQueryPrefix,
                        interpretNumericEntities: "boolean" == typeof e.interpretNumericEntities ? e.interpretNumericEntities : o.interpretNumericEntities,
                        parameterLimit: "number" == typeof e.parameterLimit ? e.parameterLimit : o.parameterLimit,
                        parseArrays: !1 !== e.parseArrays,
                        plainObjects: "boolean" == typeof e.plainObjects ? e.plainObjects : o.plainObjects,
                        strictNullHandling: "boolean" == typeof e.strictNullHandling ? e.strictNullHandling : o.strictNullHandling
                    }
                }(t);
                if ("" === e || null == e) return n.plainObjects ? Object.create(null) : {};
                for (var u = "string" == typeof e ? function(e, t) {
                        var n, c = {},
                            u = t.ignoreQueryPrefix ? e.replace(/^\?/, "") : e,
                            h = t.parameterLimit === 1 / 0 ? void 0 : t.parameterLimit,
                            p = u.split(t.delimiter, h),
                            d = -1,
                            f = t.charset;
                        if (t.charsetSentinel)
                            for (n = 0; n < p.length; ++n) 0 === p[n].indexOf("utf8=") && ("utf8=%E2%9C%93" === p[n] ? f = "utf-8" : "utf8=%26%2310003%3B" === p[n] && (f = "iso-8859-1"), d = n, n = p.length);
                        for (n = 0; n < p.length; ++n)
                            if (n !== d) {
                                var m, g, y = p[n],
                                    v = y.indexOf("]="),
                                    _ = -1 === v ? y.indexOf("=") : v + 1; - 1 === _ ? (m = t.decoder(y, o.decoder, f, "key"), g = t.strictNullHandling ? null : "") : (m = t.decoder(y.slice(0, _), o.decoder, f, "key"), g = s.maybeMap(l(y.slice(_ + 1), t), function(e) {
                                    return t.decoder(e, o.decoder, f, "value")
                                })), g && t.interpretNumericEntities && "iso-8859-1" === f && (g = a(g)), y.indexOf("[]=") > -1 && (g = i(g) ? [g] : g), r.call(c, m) ? c[m] = s.combine(c[m], g) : c[m] = g
                            }
                        return c
                    }(e, n) : e, h = n.plainObjects ? Object.create(null) : {}, p = Object.keys(u), d = 0; d < p.length; ++d) {
                    var f = p[d],
                        m = c(f, u[f], n, "string" == typeof e);
                    h = s.merge(h, m, n)
                }
                return !0 === n.allowSparse ? h : s.compact(h)
            }
        },
        o2Ax: function(e, t, n) {
            "use strict";
            const s = n("oy1u").create,
                r = n("uPqc").create,
                i = n("iJE/");
            e.exports = {
                generate: function(e) {
                    return i(e, (e, t, n) => (e[n] = i(t, (e, t, i) => {
                        const o = s(t, i),
                            a = r(o, i, n);
                        return e[i] = function(e) {
                            return new a({ ...this._options,
                                ...e
                            })
                        }, e[i].Ctor = a, e
                    }, {}), e), {})
                }
            }
        },
        oHnp: function(e, t, n) {
            "use strict";
            t.type = e => e.split(/ *; */).shift(), t.params = e => e.split(/ *; */).reduce((e, t) => {
                const n = t.split(/ *= */),
                    s = n.shift(),
                    r = n.shift();
                return s && r && (e[s] = r), e
            }, {}), t.parseLinks = e => e.split(/ *, */).reduce((e, t) => {
                const n = t.split(/ *; */),
                    s = n[0].slice(1, -1);
                return e[n[1].split(/ *= */)[1].slice(1, -1)] = s, e
            }, {}), t.cleanHeader = (e, t) => (delete e["content-type"], delete e["content-length"], delete e["transfer-encoding"], delete e.host, t && (delete e.authorization, delete e.cookie), e)
        },
        oNNP: function(e, t, n) {
            "use strict";
            var s = n("D3zA");
            e.exports = s.call(Function.call, Object.prototype.hasOwnProperty)
        },
        oy1u: function(e, t, n) {
            "use strict";
            const s = n("cpXB").create;

            function r(e, t) {
                ! function(e, t) {
                    let n;
                    var r, i, o;
                    r = e._levels, i = t.level, o = {
                        component: t.component,
                        validate: t.validate,
                        methods: t.methods
                    }, r[i] = r[i] || [], r[i].push(o), t.level > 0 && (n = s(t), t.names.forEach(t => {
                        const s = t.replace(/[_-]+\w/g, e => e.replace(/[_-]+/, "").toUpperCase());
                        e._setters[s] || (e._setters[s] = n)
                    }))
                }(e, t), t.children && Object.keys(t.children).forEach(n => {
                    r(e, t.children[n])
                })
            }
            e.exports = {
                create: function(e, t) {
                    const n = {
                        _path: {
                            0: t
                        },
                        _levels: {},
                        _setters: {},
                        _getArgs: e._getArgs
                    };
                    return Object.keys(e).forEach(t => {
                        "_getArgs" !== t && r(n, e[t])
                    }), n
                }
            }
        },
        quSY: function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return a
            });
            var s = n("DH7j"),
                r = n("XoHu"),
                i = n("n6bG");
            const o = (() => {
                function e(e) {
                    return Error.call(this), this.message = e ? `${e.length} errors occurred during unsubscription:\n${e.map((e,t)=>`${t+1}) ${e.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = e, this
                }
                return e.prototype = Object.create(Error.prototype), e
            })();
            class a {
                constructor(e) {
                    this.closed = !1, this._parentOrParents = null, this._subscriptions = null, e && (this._unsubscribe = e)
                }
                unsubscribe() {
                    let e;
                    if (this.closed) return;
                    let {
                        _parentOrParents: t,
                        _unsubscribe: n,
                        _subscriptions: l
                    } = this;
                    if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, t instanceof a) t.remove(this);
                    else if (null !== t)
                        for (let s = 0; s < t.length; ++s) {
                            t[s].remove(this)
                        }
                    if (Object(i.a)(n)) try {
                        n.call(this)
                    } catch (u) {
                        e = u instanceof o ? c(u.errors) : [u]
                    }
                    if (Object(s.a)(l)) {
                        let t = -1,
                            n = l.length;
                        for (; ++t < n;) {
                            const n = l[t];
                            if (Object(r.a)(n)) try {
                                n.unsubscribe()
                            } catch (u) {
                                e = e || [], u instanceof o ? e = e.concat(c(u.errors)) : e.push(u)
                            }
                        }
                    }
                    if (e) throw new o(e)
                }
                add(e) {
                    let t = e;
                    if (!e) return a.EMPTY;
                    switch (typeof e) {
                        case "function":
                            t = new a(e);
                        case "object":
                            if (t === this || t.closed || "function" != typeof t.unsubscribe) return t;
                            if (this.closed) return t.unsubscribe(), t;
                            if (!(t instanceof a)) {
                                const e = t;
                                t = new a, t._subscriptions = [e]
                            }
                            break;
                        default:
                            throw new Error("unrecognized teardown " + e + " added to Subscription.")
                    }
                    let {
                        _parentOrParents: n
                    } = t;
                    if (null === n) t._parentOrParents = this;
                    else if (n instanceof a) {
                        if (n === this) return t;
                        t._parentOrParents = [n, this]
                    } else {
                        if (-1 !== n.indexOf(this)) return t;
                        n.push(this)
                    }
                    const s = this._subscriptions;
                    return null === s ? this._subscriptions = [t] : s.push(t), t
                }
                remove(e) {
                    const t = this._subscriptions;
                    if (t) {
                        const n = t.indexOf(e); - 1 !== n && t.splice(n, 1)
                    }
                }
            }
            var l;

            function c(e) {
                return e.reduce((e, t) => e.concat(t instanceof o ? t.errors : t), [])
            }
            a.EMPTY = ((l = new a).closed = !0, l)
        },
        sxOR: function(e, t, n) {
            "use strict";
            var s = String.prototype.replace,
                r = /%20/g,
                i = "RFC1738",
                o = "RFC3986";
            e.exports = {
                default: o,
                formatters: {
                    RFC1738: function(e) {
                        return s.call(e, r, "+")
                    },
                    RFC3986: function(e) {
                        return String(e)
                    }
                },
                RFC1738: i,
                RFC3986: o
            }
        },
        uPqc: function(e, t, n) {
            "use strict";
            const s = n("ml1J"),
                r = n("IvIj"),
                i = n("BhAj");
            e.exports = {
                create: function(e, t, n) {
                    class o extends s {
                        constructor(s) {
                            super(s), this._levels = e._levels, this.setPathPart(0, t).namespace(n)
                        }
                    }
                    return "object" == typeof e._getArgs && Object.keys(e._getArgs).forEach(e => {
                        const t = r[e];
                        "object" == typeof t && Object.keys(t).forEach(e => {
                            i(o.prototype, e, t[e])
                        })
                    }), Object.keys(e._setters).forEach(t => {
                        o.prototype[t] || (o.prototype[t] = e._setters[t])
                    }), o
                }
            }
        },
        w1tV: function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return m
            });
            var s = n("XNiG"),
                r = n("HDdC"),
                i = n("7o/Q"),
                o = n("quSY");

            function a() {
                return function(e) {
                    return e.lift(new l(e))
                }
            }
            class l {
                constructor(e) {
                    this.connectable = e
                }
                call(e, t) {
                    const {
                        connectable: n
                    } = this;
                    n._refCount++;
                    const s = new c(e, n),
                        r = t.subscribe(s);
                    return s.closed || (s.connection = n.connect()), r
                }
            }
            class c extends i.a {
                constructor(e, t) {
                    super(e), this.connectable = t
                }
                _unsubscribe() {
                    const {
                        connectable: e
                    } = this;
                    if (!e) return void(this.connection = null);
                    this.connectable = null;
                    const t = e._refCount;
                    if (t <= 0) return void(this.connection = null);
                    if (e._refCount = t - 1, t > 1) return void(this.connection = null);
                    const {
                        connection: n
                    } = this, s = e._connection;
                    this.connection = null, !s || n && s !== n || s.unsubscribe()
                }
            }
            class u extends r.a {
                constructor(e, t) {
                    super(), this.source = e, this.subjectFactory = t, this._refCount = 0, this._isComplete = !1
                }
                _subscribe(e) {
                    return this.getSubject().subscribe(e)
                }
                getSubject() {
                    const e = this._subject;
                    return e && !e.isStopped || (this._subject = this.subjectFactory()), this._subject
                }
                connect() {
                    let e = this._connection;
                    return e || (this._isComplete = !1, e = this._connection = new o.a, e.add(this.source.subscribe(new p(this.getSubject(), this))), e.closed && (this._connection = null, e = o.a.EMPTY)), e
                }
                refCount() {
                    return a()(this)
                }
            }
            const h = (() => {
                const e = u.prototype;
                return {
                    operator: {
                        value: null
                    },
                    _refCount: {
                        value: 0,
                        writable: !0
                    },
                    _subject: {
                        value: null,
                        writable: !0
                    },
                    _connection: {
                        value: null,
                        writable: !0
                    },
                    _subscribe: {
                        value: e._subscribe
                    },
                    _isComplete: {
                        value: e._isComplete,
                        writable: !0
                    },
                    getSubject: {
                        value: e.getSubject
                    },
                    connect: {
                        value: e.connect
                    },
                    refCount: {
                        value: e.refCount
                    }
                }
            })();
            class p extends s.b {
                constructor(e, t) {
                    super(e), this.connectable = t
                }
                _error(e) {
                    this._unsubscribe(), super._error(e)
                }
                _complete() {
                    this.connectable._isComplete = !0, this._unsubscribe(), super._complete()
                }
                _unsubscribe() {
                    const e = this.connectable;
                    if (e) {
                        this.connectable = null;
                        const t = e._connection;
                        e._refCount = 0, e._subject = null, e._connection = null, t && t.unsubscribe()
                    }
                }
            }
            i.a;
            class d {
                constructor(e, t) {
                    this.subjectFactory = e, this.selector = t
                }
                call(e, t) {
                    const {
                        selector: n
                    } = this, s = this.subjectFactory(), r = n(s).subscribe(e);
                    return r.add(t.subscribe(s)), r
                }
            }

            function f() {
                return new s.a
            }

            function m() {
                return e => {
                    return a()((t = f, function(e) {
                        let s;
                        if (s = "function" == typeof t ? t : function() {
                                return t
                            }, "function" == typeof n) return e.lift(new d(s, n));
                        const r = Object.create(e, h);
                        return r.source = e, r.subjectFactory = s, r
                    })(e));
                    var t, n
                }
            }
        },
        w88U: function(e, t, n) {
            "use strict";
            const s = n("YTqf").build,
                r = n("o2Ax").generate,
                i = n("0KBE"),
                o = n("BhAj"),
                a = n("IvIj");
            e.exports = function(e, t, n = {}) {
                let l = ["head", "get", "patch", "put", "post", "delete"];
                Array.isArray(n.methods) ? l = n.methods.map(e => e.trim().toLowerCase()) : "string" == typeof n.methods && (l = [n.methods.trim().toLowerCase()]), -1 !== l.indexOf("get") && -1 === l.indexOf("head") ? l.push("head") : -1 !== l.indexOf("head") && -1 === l.indexOf("get") && l.push("get");
                const c = {};
                c[e.replace(/^[\s/]*/, "/").replace(/[\s/]*$/, "/") + t.replace(/^[\s/]*/, "")] = {
                    namespace: e,
                    methods: l
                };
                const u = s(c),
                    h = r(u)[e],
                    p = h[Object.keys(h)[0]].Ctor;

                function d(e = {}) {
                    return new p({ ...e,
                        ...this ? this._options : {}
                    })
                }
                return n && n.params && n.params.forEach(e => {
                    "string" == typeof e && ("object" != typeof a[e] ? o(p.prototype, e, i(e)) : Object.keys(a[e]).forEach(t => {
                        o(p.prototype, t, a[e][t])
                    }))
                }), n && "object" == typeof n.mixins && Object.keys(n.mixins).forEach(e => {
                    o(p.prototype, e, n.mixins[e])
                }), d.Ctor = p, d
            }
        },
        yCtX: function(e, t, n) {
            "use strict";
            n.d(t, "a", function() {
                return o
            });
            var s = n("HDdC"),
                r = n("ngJS"),
                i = n("jZKg");

            function o(e, t) {
                return t ? Object(i.a)(e, t) : new s.a(Object(r.a)(e))
            }
        },
        yLpj: function(e, t) {
            var n;
            n = function() {
                return this
            }();
            try {
                n = n || new Function("return this")()
            } catch (s) {
                "object" == typeof window && (n = window)
            }
            e.exports = n
        },
        "z+Ro": function(e, t, n) {
            "use strict";

            function s(e) {
                return e && "function" == typeof e.schedule
            }
            n.d(t, "a", function() {
                return s
            })
        },
        zHhn: function(e, t, n) {
            "use strict";
            const s = e => {
                if ("number" == typeof e) return !0;
                if ("string" == typeof e) return /^\d+$/.test(e);
                if (Array.isArray(e)) {
                    for (let t = 0; t < e.length; t++)
                        if (!s(e[t])) return !1;
                    return !0
                }
                return !1
            };
            e.exports = s
        },
        zO7K: function(e, t, n) {
            "use strict";
            const s = n("/fTC").parse;
            e.exports = {
                locateAPIRootHeader: function(e) {
                    const t = "https://api.w.org/",
                        n = e.link || e.headers && e.headers.link,
                        r = s(n),
                        i = r && r[t];
                    if (i) return i;
                    throw new Error(`No header link found with rel="${t}"`)
                }
            }
        },
        zUnb: function(e, t, n) {
            "use strict";
            n.r(t);
            var s = n("8Y7J"),
                r = n("1uSB");
            /**
             * @license Angular v11.0.7
             * (c) 2010-2020 Google LLC. https://angular.io/
             * License: MIT
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            let i = null;

            function o() {
                return i
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const a = new s.B("DocumentToken");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class l {}

            function c() {
                return Object(s.oc)(u)
            }
            l.\u0275prov = Object(s.nc)({
                factory: c,
                token: l,
                providedIn: "platform"
            }), l.decorators = [{
                type: s.A,
                args: [{
                    providedIn: "platform",
                    useFactory: c
                }]
            }];
            new s.B("Location Initialized");
            class u extends l {
                constructor(e) {
                    super(), this._doc = e, this._init()
                }
                _init() {
                    this.location = o().getLocation(), this._history = o().getHistory()
                }
                getBaseHrefFromDOM() {
                    return o().getBaseHref(this._doc)
                }
                onPopState(e) {
                    o().getGlobalEventTarget(this._doc, "window").addEventListener("popstate", e, !1)
                }
                onHashChange(e) {
                    o().getGlobalEventTarget(this._doc, "window").addEventListener("hashchange", e, !1)
                }
                get href() {
                    return this.location.href
                }
                get protocol() {
                    return this.location.protocol
                }
                get hostname() {
                    return this.location.hostname
                }
                get port() {
                    return this.location.port
                }
                get pathname() {
                    return this.location.pathname
                }
                get search() {
                    return this.location.search
                }
                get hash() {
                    return this.location.hash
                }
                set pathname(e) {
                    this.location.pathname = e
                }
                pushState(e, t, n) {
                    h() ? this._history.pushState(e, t, n) : this.location.hash = n
                }
                replaceState(e, t, n) {
                    h() ? this._history.replaceState(e, t, n) : this.location.hash = n
                }
                forward() {
                    this._history.forward()
                }
                back() {
                    this._history.back()
                }
                getState() {
                    return this._history.state
                }
            }

            function h() {
                return !!window.history.pushState
            }

            function p() {
                return new u(Object(s.oc)(a))
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            function d(e, t) {
                if (0 == e.length) return t;
                if (0 == t.length) return e;
                let n = 0;
                return e.endsWith("/") && n++, t.startsWith("/") && n++, 2 == n ? e + t.substring(1) : 1 == n ? e + t : e + "/" + t
            }

            function f(e) {
                const t = e.match(/#|\?|$/),
                    n = t && t.index || e.length,
                    s = n - ("/" === e[n - 1] ? 1 : 0);
                return e.slice(0, s) + e.slice(n)
            }

            function m(e) {
                return e && "?" !== e[0] ? "?" + e : e
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            u.\u0275prov = Object(s.nc)({
                factory: p,
                token: u,
                providedIn: "platform"
            }), u.decorators = [{
                type: s.A,
                args: [{
                    providedIn: "platform",
                    useFactory: p
                }]
            }], u.ctorParameters = () => [{
                type: void 0,
                decorators: [{
                    type: s.z,
                    args: [a]
                }]
            }];
            class g {}

            function y(e) {
                const t = Object(s.oc)(a).location;
                return new _(Object(s.oc)(l), t && t.origin || "")
            }
            g.\u0275prov = Object(s.nc)({
                factory: y,
                token: g,
                providedIn: "root"
            }), g.decorators = [{
                type: s.A,
                args: [{
                    providedIn: "root",
                    useFactory: y
                }]
            }];
            const v = new s.B("appBaseHref");
            class _ extends g {
                constructor(e, t) {
                    if (super(), this._platformLocation = e, null == t && (t = this._platformLocation.getBaseHrefFromDOM()), null == t) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");
                    this._baseHref = t
                }
                onPopState(e) {
                    this._platformLocation.onPopState(e), this._platformLocation.onHashChange(e)
                }
                getBaseHref() {
                    return this._baseHref
                }
                prepareExternalUrl(e) {
                    return d(this._baseHref, e)
                }
                path(e = !1) {
                    const t = this._platformLocation.pathname + m(this._platformLocation.search),
                        n = this._platformLocation.hash;
                    return n && e ? `${t}${n}` : t
                }
                pushState(e, t, n, s) {
                    const r = this.prepareExternalUrl(n + m(s));
                    this._platformLocation.pushState(e, t, r)
                }
                replaceState(e, t, n, s) {
                    const r = this.prepareExternalUrl(n + m(s));
                    this._platformLocation.replaceState(e, t, r)
                }
                forward() {
                    this._platformLocation.forward()
                }
                back() {
                    this._platformLocation.back()
                }
            }
            _.decorators = [{
                type: s.A
            }], _.ctorParameters = () => [{
                type: l
            }, {
                type: String,
                decorators: [{
                    type: s.N
                }, {
                    type: s.z,
                    args: [v]
                }]
            }]
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            class b extends g {
                constructor(e, t) {
                    super(), this._platformLocation = e, this._baseHref = "", null != t && (this._baseHref = t)
                }
                onPopState(e) {
                    this._platformLocation.onPopState(e), this._platformLocation.onHashChange(e)
                }
                getBaseHref() {
                    return this._baseHref
                }
                path(e = !1) {
                    let t = this._platformLocation.hash;
                    return null == t && (t = "#"), t.length > 0 ? t.substring(1) : t
                }
                prepareExternalUrl(e) {
                    const t = d(this._baseHref, e);
                    return t.length > 0 ? "#" + t : t
                }
                pushState(e, t, n, s) {
                    let r = this.prepareExternalUrl(n + m(s));
                    0 == r.length && (r = this._platformLocation.pathname), this._platformLocation.pushState(e, t, r)
                }
                replaceState(e, t, n, s) {
                    let r = this.prepareExternalUrl(n + m(s));
                    0 == r.length && (r = this._platformLocation.pathname), this._platformLocation.replaceState(e, t, r)
                }
                forward() {
                    this._platformLocation.forward()
                }
                back() {
                    this._platformLocation.back()
                }
            }
            b.decorators = [{
                type: s.A
            }], b.ctorParameters = () => [{
                type: l
            }, {
                type: String,
                decorators: [{
                    type: s.N
                }, {
                    type: s.z,
                    args: [v]
                }]
            }]
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            class w {
                constructor(e, t) {
                    this._subject = new s.v, this._urlChangeListeners = [], this._platformStrategy = e;
                    const n = this._platformStrategy.getBaseHref();
                    this._platformLocation = t, this._baseHref = f(C(n)), this._platformStrategy.onPopState(e => {
                        this._subject.emit({
                            url: this.path(!0),
                            pop: !0,
                            state: e.state,
                            type: e.type
                        })
                    })
                }
                path(e = !1) {
                    return this.normalize(this._platformStrategy.path(e))
                }
                getState() {
                    return this._platformLocation.getState()
                }
                isCurrentPathEqualTo(e, t = "") {
                    return this.path() == this.normalize(e + m(t))
                }
                normalize(e) {
                    return w.stripTrailingSlash(function(e, t) {
                        return e && t.startsWith(e) ? t.substring(e.length) : t
                    }(this._baseHref, C(e)))
                }
                prepareExternalUrl(e) {
                    return e && "/" !== e[0] && (e = "/" + e), this._platformStrategy.prepareExternalUrl(e)
                }
                go(e, t = "", n = null) {
                    this._platformStrategy.pushState(n, "", e, t), this._notifyUrlChangeListeners(this.prepareExternalUrl(e + m(t)), n)
                }
                replaceState(e, t = "", n = null) {
                    this._platformStrategy.replaceState(n, "", e, t), this._notifyUrlChangeListeners(this.prepareExternalUrl(e + m(t)), n)
                }
                forward() {
                    this._platformStrategy.forward()
                }
                back() {
                    this._platformStrategy.back()
                }
                onUrlChange(e) {
                    this._urlChangeListeners.push(e), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(e => {
                        this._notifyUrlChangeListeners(e.url, e.state)
                    }))
                }
                _notifyUrlChangeListeners(e = "", t) {
                    this._urlChangeListeners.forEach(n => n(e, t))
                }
                subscribe(e, t, n) {
                    return this._subject.subscribe({
                        next: e,
                        error: t,
                        complete: n
                    })
                }
            }

            function E() {
                return new w(Object(s.oc)(g), Object(s.oc)(l))
            }

            function C(e) {
                return e.replace(/\/index.html$/, "")
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            w.normalizeQueryParams = m, w.joinWithSlash = d, w.stripTrailingSlash = f, w.\u0275prov = Object(s.nc)({
                factory: E,
                token: w,
                providedIn: "root"
            }), w.decorators = [{
                type: s.A,
                args: [{
                    providedIn: "root",
                    useFactory: E
                }]
            }], w.ctorParameters = () => [{
                type: g
            }, {
                type: l
            }];
            const S = {
                ADP: [void 0, void 0, 0],
                AFN: [void 0, void 0, 0],
                ALL: [void 0, void 0, 0],
                AMD: [void 0, void 0, 2],
                AOA: [void 0, "Kz"],
                ARS: [void 0, "$"],
                AUD: ["A$", "$"],
                BAM: [void 0, "KM"],
                BBD: [void 0, "$"],
                BDT: [void 0, "\u09f3"],
                BHD: [void 0, void 0, 3],
                BIF: [void 0, void 0, 0],
                BMD: [void 0, "$"],
                BND: [void 0, "$"],
                BOB: [void 0, "Bs"],
                BRL: ["R$"],
                BSD: [void 0, "$"],
                BWP: [void 0, "P"],
                BYN: [void 0, "\u0440.", 2],
                BYR: [void 0, void 0, 0],
                BZD: [void 0, "$"],
                CAD: ["CA$", "$", 2],
                CHF: [void 0, void 0, 2],
                CLF: [void 0, void 0, 4],
                CLP: [void 0, "$", 0],
                CNY: ["CN\xa5", "\xa5"],
                COP: [void 0, "$", 2],
                CRC: [void 0, "\u20a1", 2],
                CUC: [void 0, "$"],
                CUP: [void 0, "$"],
                CZK: [void 0, "K\u010d", 2],
                DJF: [void 0, void 0, 0],
                DKK: [void 0, "kr", 2],
                DOP: [void 0, "$"],
                EGP: [void 0, "E\xa3"],
                ESP: [void 0, "\u20a7", 0],
                EUR: ["\u20ac"],
                FJD: [void 0, "$"],
                FKP: [void 0, "\xa3"],
                GBP: ["\xa3"],
                GEL: [void 0, "\u20be"],
                GIP: [void 0, "\xa3"],
                GNF: [void 0, "FG", 0],
                GTQ: [void 0, "Q"],
                GYD: [void 0, "$", 2],
                HKD: ["HK$", "$"],
                HNL: [void 0, "L"],
                HRK: [void 0, "kn"],
                HUF: [void 0, "Ft", 2],
                IDR: [void 0, "Rp", 2],
                ILS: ["\u20aa"],
                INR: ["\u20b9"],
                IQD: [void 0, void 0, 0],
                IRR: [void 0, void 0, 0],
                ISK: [void 0, "kr", 0],
                ITL: [void 0, void 0, 0],
                JMD: [void 0, "$"],
                JOD: [void 0, void 0, 3],
                JPY: ["\xa5", void 0, 0],
                KHR: [void 0, "\u17db"],
                KMF: [void 0, "CF", 0],
                KPW: [void 0, "\u20a9", 0],
                KRW: ["\u20a9", void 0, 0],
                KWD: [void 0, void 0, 3],
                KYD: [void 0, "$"],
                KZT: [void 0, "\u20b8"],
                LAK: [void 0, "\u20ad", 0],
                LBP: [void 0, "L\xa3", 0],
                LKR: [void 0, "Rs"],
                LRD: [void 0, "$"],
                LTL: [void 0, "Lt"],
                LUF: [void 0, void 0, 0],
                LVL: [void 0, "Ls"],
                LYD: [void 0, void 0, 3],
                MGA: [void 0, "Ar", 0],
                MGF: [void 0, void 0, 0],
                MMK: [void 0, "K", 0],
                MNT: [void 0, "\u20ae", 2],
                MRO: [void 0, void 0, 0],
                MUR: [void 0, "Rs", 2],
                MXN: ["MX$", "$"],
                MYR: [void 0, "RM"],
                NAD: [void 0, "$"],
                NGN: [void 0, "\u20a6"],
                NIO: [void 0, "C$"],
                NOK: [void 0, "kr", 2],
                NPR: [void 0, "Rs"],
                NZD: ["NZ$", "$"],
                OMR: [void 0, void 0, 3],
                PHP: [void 0, "\u20b1"],
                PKR: [void 0, "Rs", 2],
                PLN: [void 0, "z\u0142"],
                PYG: [void 0, "\u20b2", 0],
                RON: [void 0, "lei"],
                RSD: [void 0, void 0, 0],
                RUB: [void 0, "\u20bd"],
                RUR: [void 0, "\u0440."],
                RWF: [void 0, "RF", 0],
                SBD: [void 0, "$"],
                SEK: [void 0, "kr", 2],
                SGD: [void 0, "$"],
                SHP: [void 0, "\xa3"],
                SLL: [void 0, void 0, 0],
                SOS: [void 0, void 0, 0],
                SRD: [void 0, "$"],
                SSP: [void 0, "\xa3"],
                STD: [void 0, void 0, 0],
                STN: [void 0, "Db"],
                SYP: [void 0, "\xa3", 0],
                THB: [void 0, "\u0e3f"],
                TMM: [void 0, void 0, 0],
                TND: [void 0, void 0, 3],
                TOP: [void 0, "T$"],
                TRL: [void 0, void 0, 0],
                TRY: [void 0, "\u20ba"],
                TTD: [void 0, "$"],
                TWD: ["NT$", "$", 2],
                TZS: [void 0, void 0, 2],
                UAH: [void 0, "\u20b4"],
                UGX: [void 0, void 0, 0],
                USD: ["$"],
                UYI: [void 0, void 0, 0],
                UYU: [void 0, "$"],
                UYW: [void 0, void 0, 4],
                UZS: [void 0, void 0, 2],
                VEF: [void 0, "Bs", 2],
                VND: ["\u20ab", void 0, 0],
                VUV: [void 0, void 0, 0],
                XAF: ["FCFA", void 0, 0],
                XCD: ["EC$", "$"],
                XOF: ["CFA", void 0, 0],
                XPF: ["CFPF", void 0, 0],
                XXX: ["\xa4"],
                YER: [void 0, void 0, 0],
                ZAR: [void 0, "R"],
                ZMK: [void 0, void 0, 0],
                ZMW: [void 0, "ZK"],
                ZWD: [void 0, void 0, 0]
            };
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            var x, T, A, D, P, k, O;

            function I(e, t) {
                return V(Object(s.Kb)(e)[s.ub.DateFormat], t)
            }

            function N(e, t) {
                return V(Object(s.Kb)(e)[s.ub.TimeFormat], t)
            }

            function M(e, t) {
                return V(Object(s.Kb)(e)[s.ub.DateTimeFormat], t)
            }

            function F(e, t) {
                const n = Object(s.Kb)(e),
                    r = n[s.ub.NumberSymbols][t];
                if (void 0 === r) {
                    if (t === k.CurrencyDecimal) return n[s.ub.NumberSymbols][k.Decimal];
                    if (t === k.CurrencyGroup) return n[s.ub.NumberSymbols][k.Group]
                }
                return r
            }

            function R(e, t) {
                return Object(s.Kb)(e)[s.ub.NumberFormats][t]
            }! function(e) {
                e[e.Decimal = 0] = "Decimal", e[e.Percent = 1] = "Percent", e[e.Currency = 2] = "Currency", e[e.Scientific = 3] = "Scientific"
            }(x || (x = {})),
            function(e) {
                e[e.Zero = 0] = "Zero", e[e.One = 1] = "One", e[e.Two = 2] = "Two", e[e.Few = 3] = "Few", e[e.Many = 4] = "Many", e[e.Other = 5] = "Other"
            }(T || (T = {})),
            function(e) {
                e[e.Format = 0] = "Format", e[e.Standalone = 1] = "Standalone"
            }(A || (A = {})),
            function(e) {
                e[e.Narrow = 0] = "Narrow", e[e.Abbreviated = 1] = "Abbreviated", e[e.Wide = 2] = "Wide", e[e.Short = 3] = "Short"
            }(D || (D = {})),
            function(e) {
                e[e.Short = 0] = "Short", e[e.Medium = 1] = "Medium", e[e.Long = 2] = "Long", e[e.Full = 3] = "Full"
            }(P || (P = {})),
            function(e) {
                e[e.Decimal = 0] = "Decimal", e[e.Group = 1] = "Group", e[e.List = 2] = "List", e[e.PercentSign = 3] = "PercentSign", e[e.PlusSign = 4] = "PlusSign", e[e.MinusSign = 5] = "MinusSign", e[e.Exponential = 6] = "Exponential", e[e.SuperscriptingExponent = 7] = "SuperscriptingExponent", e[e.PerMille = 8] = "PerMille", e[e[1 / 0] = 9] = "Infinity", e[e.NaN = 10] = "NaN", e[e.TimeSeparator = 11] = "TimeSeparator", e[e.CurrencyDecimal = 12] = "CurrencyDecimal", e[e.CurrencyGroup = 13] = "CurrencyGroup"
            }(k || (k = {})),
            function(e) {
                e[e.Sunday = 0] = "Sunday", e[e.Monday = 1] = "Monday", e[e.Tuesday = 2] = "Tuesday", e[e.Wednesday = 3] = "Wednesday", e[e.Thursday = 4] = "Thursday", e[e.Friday = 5] = "Friday", e[e.Saturday = 6] = "Saturday"
            }(O || (O = {}));
            const j = s.Nb;

            function L(e) {
                if (!e[s.ub.ExtraData]) throw new Error(`Missing extra locale data for the locale "${e[s.ub.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`)
            }

            function V(e, t) {
                for (let n = t; n > -1; n--)
                    if (void 0 !== e[n]) return e[n];
                throw new Error("Locale data API: locale data undefined")
            }

            function $(e) {
                const [t, n] = e.split(":");
                return {
                    hours: +t,
                    minutes: +n
                }
            }

            function B(e, t, n = "en") {
                const r = function(e) {
                        return Object(s.Kb)(e)[s.ub.Currencies]
                    }(n)[e] || S[e] || [],
                    i = r[1];
                return "narrow" === t && "string" == typeof i ? i : r[0] || e
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const H = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/,
                U = {},
                q = /((?:[^GyYMLwWdEabBhHmsSzZO']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/;
            var z, W, G;

            function K(e, t, n, s) {
                let r = function(e) {
                    if (oe(e)) return e;
                    if ("number" == typeof e && !isNaN(e)) return new Date(e);
                    if ("string" == typeof e) {
                        e = e.trim();
                        const t = parseFloat(e);
                        if (!isNaN(e - t)) return new Date(t);
                        if (/^(\d{4}-\d{1,2}-\d{1,2})$/.test(e)) {
                            const [t, n, s] = e.split("-").map(e => +e);
                            return new Date(t, n - 1, s)
                        }
                        let n;
                        if (n = e.match(H)) return function(e) {
                            const t = new Date(0);
                            let n = 0,
                                s = 0;
                            const r = e[8] ? t.setUTCFullYear : t.setFullYear,
                                i = e[8] ? t.setUTCHours : t.setHours;
                            e[9] && (n = Number(e[9] + e[10]), s = Number(e[9] + e[11]));
                            r.call(t, Number(e[1]), Number(e[2]) - 1, Number(e[3]));
                            const o = Number(e[4] || 0) - n,
                                a = Number(e[5] || 0) - s,
                                l = Number(e[6] || 0),
                                c = Math.floor(1e3 * parseFloat("0." + (e[7] || 0)));
                            return i.call(t, o, a, l, c), t
                        }(n)
                    }
                    const t = new Date(e);
                    if (!oe(t)) throw new Error(`Unable to convert "${e}" into a date`);
                    return t
                }(e);
                t = Q(n, t) || t;
                let i, o = [];
                for (; t;) {
                    if (i = q.exec(t), !i) {
                        o.push(t);
                        break
                    } {
                        o = o.concat(i.slice(1));
                        const e = o.pop();
                        if (!e) break;
                        t = e
                    }
                }
                let a = r.getTimezoneOffset();
                s && (a = ie(s, a), r = function(e, t, n) {
                    const s = n ? -1 : 1,
                        r = e.getTimezoneOffset(),
                        i = ie(t, r);
                    return function(e, t) {
                        return (e = new Date(e.getTime())).setMinutes(e.getMinutes() + t), e
                    }(e, s * (i - r))
                }(r, s, !0));
                let l = "";
                return o.forEach(e => {
                    const t = function(e) {
                        if (re[e]) return re[e];
                        let t;
                        switch (e) {
                            case "G":
                            case "GG":
                            case "GGG":
                                t = Y(G.Eras, D.Abbreviated);
                                break;
                            case "GGGG":
                                t = Y(G.Eras, D.Wide);
                                break;
                            case "GGGGG":
                                t = Y(G.Eras, D.Narrow);
                                break;
                            case "y":
                                t = X(W.FullYear, 1, 0, !1, !0);
                                break;
                            case "yy":
                                t = X(W.FullYear, 2, 0, !0, !0);
                                break;
                            case "yyy":
                                t = X(W.FullYear, 3, 0, !1, !0);
                                break;
                            case "yyyy":
                                t = X(W.FullYear, 4, 0, !1, !0);
                                break;
                            case "Y":
                                t = se(1);
                                break;
                            case "YY":
                                t = se(2, !0);
                                break;
                            case "YYY":
                                t = se(3);
                                break;
                            case "YYYY":
                                t = se(4);
                                break;
                            case "M":
                            case "L":
                                t = X(W.Month, 1, 1);
                                break;
                            case "MM":
                            case "LL":
                                t = X(W.Month, 2, 1);
                                break;
                            case "MMM":
                                t = Y(G.Months, D.Abbreviated);
                                break;
                            case "MMMM":
                                t = Y(G.Months, D.Wide);
                                break;
                            case "MMMMM":
                                t = Y(G.Months, D.Narrow);
                                break;
                            case "LLL":
                                t = Y(G.Months, D.Abbreviated, A.Standalone);
                                break;
                            case "LLLL":
                                t = Y(G.Months, D.Wide, A.Standalone);
                                break;
                            case "LLLLL":
                                t = Y(G.Months, D.Narrow, A.Standalone);
                                break;
                            case "w":
                                t = ne(1);
                                break;
                            case "ww":
                                t = ne(2);
                                break;
                            case "W":
                                t = ne(1, !0);
                                break;
                            case "d":
                                t = X(W.Date, 1);
                                break;
                            case "dd":
                                t = X(W.Date, 2);
                                break;
                            case "E":
                            case "EE":
                            case "EEE":
                                t = Y(G.Days, D.Abbreviated);
                                break;
                            case "EEEE":
                                t = Y(G.Days, D.Wide);
                                break;
                            case "EEEEE":
                                t = Y(G.Days, D.Narrow);
                                break;
                            case "EEEEEE":
                                t = Y(G.Days, D.Short);
                                break;
                            case "a":
                            case "aa":
                            case "aaa":
                                t = Y(G.DayPeriods, D.Abbreviated);
                                break;
                            case "aaaa":
                                t = Y(G.DayPeriods, D.Wide);
                                break;
                            case "aaaaa":
                                t = Y(G.DayPeriods, D.Narrow);
                                break;
                            case "b":
                            case "bb":
                            case "bbb":
                                t = Y(G.DayPeriods, D.Abbreviated, A.Standalone, !0);
                                break;
                            case "bbbb":
                                t = Y(G.DayPeriods, D.Wide, A.Standalone, !0);
                                break;
                            case "bbbbb":
                                t = Y(G.DayPeriods, D.Narrow, A.Standalone, !0);
                                break;
                            case "B":
                            case "BB":
                            case "BBB":
                                t = Y(G.DayPeriods, D.Abbreviated, A.Format, !0);
                                break;
                            case "BBBB":
                                t = Y(G.DayPeriods, D.Wide, A.Format, !0);
                                break;
                            case "BBBBB":
                                t = Y(G.DayPeriods, D.Narrow, A.Format, !0);
                                break;
                            case "h":
                                t = X(W.Hours, 1, -12);
                                break;
                            case "hh":
                                t = X(W.Hours, 2, -12);
                                break;
                            case "H":
                                t = X(W.Hours, 1);
                                break;
                            case "HH":
                                t = X(W.Hours, 2);
                                break;
                            case "m":
                                t = X(W.Minutes, 1);
                                break;
                            case "mm":
                                t = X(W.Minutes, 2);
                                break;
                            case "s":
                                t = X(W.Seconds, 1);
                                break;
                            case "ss":
                                t = X(W.Seconds, 2);
                                break;
                            case "S":
                                t = X(W.FractionalSeconds, 1);
                                break;
                            case "SS":
                                t = X(W.FractionalSeconds, 2);
                                break;
                            case "SSS":
                                t = X(W.FractionalSeconds, 3);
                                break;
                            case "Z":
                            case "ZZ":
                            case "ZZZ":
                                t = ee(z.Short);
                                break;
                            case "ZZZZZ":
                                t = ee(z.Extended);
                                break;
                            case "O":
                            case "OO":
                            case "OOO":
                            case "z":
                            case "zz":
                            case "zzz":
                                t = ee(z.ShortGMT);
                                break;
                            case "OOOO":
                            case "ZZZZ":
                            case "zzzz":
                                t = ee(z.Long);
                                break;
                            default:
                                return null
                        }
                        return re[e] = t, t
                    }(e);
                    l += t ? t(r, n, a) : "''" === e ? "'" : e.replace(/(^'|'$)/g, "").replace(/''/g, "'")
                }), l
            }

            function Q(e, t) {
                const n = function(e) {
                    return Object(s.Kb)(e)[s.ub.LocaleId]
                }(e);
                if (U[n] = U[n] || {}, U[n][t]) return U[n][t];
                let r = "";
                switch (t) {
                    case "shortDate":
                        r = I(e, P.Short);
                        break;
                    case "mediumDate":
                        r = I(e, P.Medium);
                        break;
                    case "longDate":
                        r = I(e, P.Long);
                        break;
                    case "fullDate":
                        r = I(e, P.Full);
                        break;
                    case "shortTime":
                        r = N(e, P.Short);
                        break;
                    case "mediumTime":
                        r = N(e, P.Medium);
                        break;
                    case "longTime":
                        r = N(e, P.Long);
                        break;
                    case "fullTime":
                        r = N(e, P.Full);
                        break;
                    case "short":
                        const t = Q(e, "shortTime"),
                            n = Q(e, "shortDate");
                        r = Z(M(e, P.Short), [t, n]);
                        break;
                    case "medium":
                        const s = Q(e, "mediumTime"),
                            i = Q(e, "mediumDate");
                        r = Z(M(e, P.Medium), [s, i]);
                        break;
                    case "long":
                        const o = Q(e, "longTime"),
                            a = Q(e, "longDate");
                        r = Z(M(e, P.Long), [o, a]);
                        break;
                    case "full":
                        const l = Q(e, "fullTime"),
                            c = Q(e, "fullDate");
                        r = Z(M(e, P.Full), [l, c])
                }
                return r && (U[n][t] = r), r
            }

            function Z(e, t) {
                return t && (e = e.replace(/\{([^}]+)}/g, function(e, n) {
                    return null != t && n in t ? t[n] : e
                })), e
            }

            function J(e, t, n = "-", s, r) {
                let i = "";
                (e < 0 || r && e <= 0) && (r ? e = 1 - e : (e = -e, i = n));
                let o = String(e);
                for (; o.length < t;) o = "0" + o;
                return s && (o = o.substr(o.length - t)), i + o
            }

            function X(e, t, n = 0, s = !1, r = !1) {
                return function(i, o) {
                    let a = function(e, t) {
                        switch (e) {
                            case W.FullYear:
                                return t.getFullYear();
                            case W.Month:
                                return t.getMonth();
                            case W.Date:
                                return t.getDate();
                            case W.Hours:
                                return t.getHours();
                            case W.Minutes:
                                return t.getMinutes();
                            case W.Seconds:
                                return t.getSeconds();
                            case W.FractionalSeconds:
                                return t.getMilliseconds();
                            case W.Day:
                                return t.getDay();
                            default:
                                throw new Error(`Unknown DateType value "${e}".`)
                        }
                    }(e, i);
                    if ((n > 0 || a > -n) && (a += n), e === W.Hours) 0 === a && -12 === n && (a = 12);
                    else if (e === W.FractionalSeconds) return l = t, J(a, 3).substr(0, l);
                    var l;
                    const c = F(o, k.MinusSign);
                    return J(a, t, c, s, r)
                }
            }

            function Y(e, t, n = A.Format, r = !1) {
                return function(i, o) {
                    return function(e, t, n, r, i, o) {
                        switch (n) {
                            case G.Months:
                                return function(e, t, n) {
                                    const r = Object(s.Kb)(e),
                                        i = V([r[s.ub.MonthsFormat], r[s.ub.MonthsStandalone]], t);
                                    return V(i, n)
                                }(t, i, r)[e.getMonth()];
                            case G.Days:
                                return function(e, t, n) {
                                    const r = Object(s.Kb)(e),
                                        i = V([r[s.ub.DaysFormat], r[s.ub.DaysStandalone]], t);
                                    return V(i, n)
                                }(t, i, r)[e.getDay()];
                            case G.DayPeriods:
                                const a = e.getHours(),
                                    l = e.getMinutes();
                                if (o) {
                                    const e = function(e) {
                                            const t = Object(s.Kb)(e);
                                            return L(t), (t[s.ub.ExtraData][2] || []).map(e => "string" == typeof e ? $(e) : [$(e[0]), $(e[1])])
                                        }(t),
                                        n = function(e, t, n) {
                                            const r = Object(s.Kb)(e);
                                            L(r);
                                            const i = V([r[s.ub.ExtraData][0], r[s.ub.ExtraData][1]], t) || [];
                                            return V(i, n) || []
                                        }(t, i, r),
                                        o = e.findIndex(e => {
                                            if (Array.isArray(e)) {
                                                const [t, n] = e, s = a >= t.hours && l >= t.minutes, r = a < n.hours || a === n.hours && l < n.minutes;
                                                if (t.hours < n.hours) {
                                                    if (s && r) return !0
                                                } else if (s || r) return !0
                                            } else if (e.hours === a && e.minutes === l) return !0;
                                            return !1
                                        });
                                    if (-1 !== o) return n[o]
                                }
                                return function(e, t, n) {
                                    const r = Object(s.Kb)(e),
                                        i = V([r[s.ub.DayPeriodsFormat], r[s.ub.DayPeriodsStandalone]], t);
                                    return V(i, n)
                                }(t, i, r)[a < 12 ? 0 : 1];
                            case G.Eras:
                                return function(e, t) {
                                    return V(Object(s.Kb)(e)[s.ub.Eras], t)
                                }(t, r)[e.getFullYear() <= 0 ? 0 : 1];
                            default:
                                throw new Error(`unexpected translation type ${n}`)
                        }
                    }(i, o, e, t, n, r)
                }
            }

            function ee(e) {
                return function(t, n, s) {
                    const r = -1 * s,
                        i = F(n, k.MinusSign),
                        o = r > 0 ? Math.floor(r / 60) : Math.ceil(r / 60);
                    switch (e) {
                        case z.Short:
                            return (r >= 0 ? "+" : "") + J(o, 2, i) + J(Math.abs(r % 60), 2, i);
                        case z.ShortGMT:
                            return "GMT" + (r >= 0 ? "+" : "") + J(o, 1, i);
                        case z.Long:
                            return "GMT" + (r >= 0 ? "+" : "") + J(o, 2, i) + ":" + J(Math.abs(r % 60), 2, i);
                        case z.Extended:
                            return 0 === s ? "Z" : (r >= 0 ? "+" : "") + J(o, 2, i) + ":" + J(Math.abs(r % 60), 2, i);
                        default:
                            throw new Error(`Unknown zone width "${e}"`)
                    }
                }
            }! function(e) {
                e[e.Short = 0] = "Short", e[e.ShortGMT = 1] = "ShortGMT", e[e.Long = 2] = "Long", e[e.Extended = 3] = "Extended"
            }(z || (z = {})),
            function(e) {
                e[e.FullYear = 0] = "FullYear", e[e.Month = 1] = "Month", e[e.Date = 2] = "Date", e[e.Hours = 3] = "Hours", e[e.Minutes = 4] = "Minutes", e[e.Seconds = 5] = "Seconds", e[e.FractionalSeconds = 6] = "FractionalSeconds", e[e.Day = 7] = "Day"
            }(W || (W = {})),
            function(e) {
                e[e.DayPeriods = 0] = "DayPeriods", e[e.Days = 1] = "Days", e[e.Months = 2] = "Months", e[e.Eras = 3] = "Eras"
            }(G || (G = {}));

            function te(e) {
                return new Date(e.getFullYear(), e.getMonth(), e.getDate() + (4 - e.getDay()))
            }

            function ne(e, t = !1) {
                return function(n, s) {
                    let r;
                    if (t) {
                        const e = new Date(n.getFullYear(), n.getMonth(), 1).getDay() - 1,
                            t = n.getDate();
                        r = 1 + Math.floor((t + e) / 7)
                    } else {
                        const e = te(n),
                            t = function(e) {
                                const t = new Date(e, 0, 1).getDay();
                                return new Date(e, 0, 1 + (t <= 4 ? 4 : 11) - t)
                            }(e.getFullYear()),
                            s = e.getTime() - t.getTime();
                        r = 1 + Math.round(s / 6048e5)
                    }
                    return J(r, e, F(s, k.MinusSign))
                }
            }

            function se(e, t = !1) {
                return function(n, s) {
                    return J(te(n).getFullYear(), e, F(s, k.MinusSign), t)
                }
            }
            const re = {};

            function ie(e, t) {
                e = e.replace(/:/g, "");
                const n = Date.parse("Jan 01, 1970 00:00:00 " + e) / 6e4;
                return isNaN(n) ? t : n
            }

            function oe(e) {
                return e instanceof Date && !isNaN(e.valueOf())
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const ae = /^(\d+)?\.((\d+)(-(\d+))?)?$/,
                le = ".",
                ce = "0";

            function ue(e, t, n, s, r, i, o = !1) {
                let a = "",
                    l = !1;
                if (isFinite(e)) {
                    let c = function(e) {
                        let t, n, s, r, i, o = Math.abs(e) + "",
                            a = 0;
                        (n = o.indexOf(le)) > -1 && (o = o.replace(le, ""));
                        (s = o.search(/e/i)) > 0 ? (n < 0 && (n = s), n += +o.slice(s + 1), o = o.substring(0, s)) : n < 0 && (n = o.length);
                        for (s = 0; o.charAt(s) === ce; s++);
                        if (s === (i = o.length)) t = [0], n = 1;
                        else {
                            for (i--; o.charAt(i) === ce;) i--;
                            for (n -= s, t = [], r = 0; s <= i; s++, r++) t[r] = Number(o.charAt(s))
                        }
                        n > 22 && (t = t.splice(0, 21), a = n - 1, n = 1);
                        return {
                            digits: t,
                            exponent: a,
                            integerLen: n
                        }
                    }(e);
                    o && (c = function(e) {
                        if (0 === e.digits[0]) return e;
                        const t = e.digits.length - e.integerLen;
                        e.exponent ? e.exponent += 2 : (0 === t ? e.digits.push(0, 0) : 1 === t && e.digits.push(0), e.integerLen += 2);
                        return e
                    }(c));
                    let u = t.minInt,
                        h = t.minFrac,
                        p = t.maxFrac;
                    if (i) {
                        const e = i.match(ae);
                        if (null === e) throw new Error(`${i} is not a valid digit info`);
                        const t = e[1],
                            n = e[3],
                            s = e[5];
                        null != t && (u = de(t)), null != n && (h = de(n)), null != s ? p = de(s) : null != n && h > p && (p = h)
                    }! function(e, t, n) {
                        if (t > n) throw new Error(`The minimum number of digits after fraction (${t}) is higher than the maximum (${n}).`);
                        let s = e.digits,
                            r = s.length - e.integerLen;
                        const i = Math.min(Math.max(t, r), n);
                        let o = i + e.integerLen,
                            a = s[o];
                        if (o > 0) {
                            s.splice(Math.max(e.integerLen, o));
                            for (let e = o; e < s.length; e++) s[e] = 0
                        } else {
                            r = Math.max(0, r), e.integerLen = 1, s.length = Math.max(1, o = i + 1), s[0] = 0;
                            for (let e = 1; e < o; e++) s[e] = 0
                        }
                        if (a >= 5)
                            if (o - 1 < 0) {
                                for (let t = 0; t > o; t--) s.unshift(0), e.integerLen++;
                                s.unshift(1), e.integerLen++
                            } else s[o - 1]++;
                        for (; r < Math.max(0, i); r++) s.push(0);
                        let l = 0 !== i;
                        const c = t + e.integerLen,
                            u = s.reduceRight(function(e, t, n, s) {
                                return t += e, s[n] = t < 10 ? t : t - 10, l && (0 === s[n] && n >= c ? s.pop() : l = !1), t >= 10 ? 1 : 0
                            }, 0);
                        u && (s.unshift(u), e.integerLen++)
                    }(c, h, p);
                    let d = c.digits,
                        f = c.integerLen;
                    const m = c.exponent;
                    let g = [];
                    for (l = d.every(e => !e); f < u; f++) d.unshift(0);
                    for (; f < 0; f++) d.unshift(0);
                    f > 0 ? g = d.splice(f, d.length) : (g = d, d = [0]);
                    const y = [];
                    for (d.length >= t.lgSize && y.unshift(d.splice(-t.lgSize, d.length).join("")); d.length > t.gSize;) y.unshift(d.splice(-t.gSize, d.length).join(""));
                    d.length && y.unshift(d.join("")), a = y.join(F(n, s)), g.length && (a += F(n, r) + g.join("")), m && (a += F(n, k.Exponential) + "+" + m)
                } else a = F(n, k.Infinity);
                return a = e < 0 && !l ? t.negPre + a + t.negSuf : t.posPre + a + t.posSuf, a
            }

            function he(e, t, n, s, r) {
                const i = pe(R(t, x.Currency), F(t, k.MinusSign));
                i.minFrac = function(e) {
                    let t;
                    const n = S[e];
                    return n && (t = n[2]), "number" == typeof t ? t : 2
                }(s), i.maxFrac = i.minFrac;
                return ue(e, i, t, k.CurrencyGroup, k.CurrencyDecimal, r).replace("\xa4", n).replace("\xa4", "").trim()
            }

            function pe(e, t = "-") {
                const n = {
                        minInt: 1,
                        minFrac: 0,
                        maxFrac: 0,
                        posPre: "",
                        posSuf: "",
                        negPre: "",
                        negSuf: "",
                        gSize: 0,
                        lgSize: 0
                    },
                    s = e.split(";"),
                    r = s[0],
                    i = s[1],
                    o = -1 !== r.indexOf(le) ? r.split(le) : [r.substring(0, r.lastIndexOf(ce) + 1), r.substring(r.lastIndexOf(ce) + 1)],
                    a = o[0],
                    l = o[1] || "";
                n.posPre = a.substr(0, a.indexOf("#"));
                for (let u = 0; u < l.length; u++) {
                    const e = l.charAt(u);
                    e === ce ? n.minFrac = n.maxFrac = u + 1 : "#" === e ? n.maxFrac = u + 1 : n.posSuf += e
                }
                const c = a.split(",");
                if (n.gSize = c[1] ? c[1].length : 0, n.lgSize = c[2] || c[1] ? (c[2] || c[1]).length : 0, i) {
                    const e = r.length - n.posPre.length - n.posSuf.length,
                        t = i.indexOf("#");
                    n.negPre = i.substr(0, t).replace(/'/g, ""), n.negSuf = i.substr(t + e).replace(/'/g, "")
                } else n.negPre = t + n.posPre, n.negSuf = n.posSuf;
                return n
            }

            function de(e) {
                const t = parseInt(e);
                if (isNaN(t)) throw new Error("Invalid integer literal when parsing " + e);
                return t
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class fe {}

            function me(e, t, n, s) {
                let r = `=${e}`;
                if (t.indexOf(r) > -1) return r;
                if (r = n.getPluralCategory(e, s), t.indexOf(r) > -1) return r;
                if (t.indexOf("other") > -1) return "other";
                throw new Error(`No plural message found for value "${e}"`)
            }
            class ge extends fe {
                constructor(e) {
                    super(), this.locale = e
                }
                getPluralCategory(e, t) {
                    switch (j(t || this.locale)(e)) {
                        case T.Zero:
                            return "zero";
                        case T.One:
                            return "one";
                        case T.Two:
                            return "two";
                        case T.Few:
                            return "few";
                        case T.Many:
                            return "many";
                        default:
                            return "other"
                    }
                }
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            function ye(e, t) {
                t = encodeURIComponent(t);
                for (const n of e.split(";")) {
                    const e = n.indexOf("="),
                        [s, r] = -1 == e ? [n, ""] : [n.slice(0, e), n.slice(e + 1)];
                    if (s.trim() === t) return decodeURIComponent(r)
                }
                return null
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ge.decorators = [{
                type: s.A
            }], ge.ctorParameters = () => [{
                type: String,
                decorators: [{
                    type: s.z,
                    args: [s.G]
                }]
            }]
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            class ve {
                constructor(e, t, n, s) {
                    this._iterableDiffers = e, this._keyValueDiffers = t, this._ngEl = n, this._renderer = s, this._iterableDiffer = null, this._keyValueDiffer = null, this._initialClasses = [], this._rawClass = null
                }
                set klass(e) {
                    this._removeClasses(this._initialClasses), this._initialClasses = "string" == typeof e ? e.split(/\s+/) : [], this._applyClasses(this._initialClasses), this._applyClasses(this._rawClass)
                }
                set ngClass(e) {
                    this._removeClasses(this._rawClass), this._applyClasses(this._initialClasses), this._iterableDiffer = null, this._keyValueDiffer = null, this._rawClass = "string" == typeof e ? e.split(/\s+/) : e, this._rawClass && (Object(s.Sb)(this._rawClass) ? this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create() : this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create())
                }
                ngDoCheck() {
                    if (this._iterableDiffer) {
                        const e = this._iterableDiffer.diff(this._rawClass);
                        e && this._applyIterableChanges(e)
                    } else if (this._keyValueDiffer) {
                        const e = this._keyValueDiffer.diff(this._rawClass);
                        e && this._applyKeyValueChanges(e)
                    }
                }
                _applyKeyValueChanges(e) {
                    e.forEachAddedItem(e => this._toggleClass(e.key, e.currentValue)), e.forEachChangedItem(e => this._toggleClass(e.key, e.currentValue)), e.forEachRemovedItem(e => {
                        e.previousValue && this._toggleClass(e.key, !1)
                    })
                }
                _applyIterableChanges(e) {
                    e.forEachAddedItem(e => {
                        if ("string" != typeof e.item) throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${Object(s.ic)(e.item)}`);
                        this._toggleClass(e.item, !0)
                    }), e.forEachRemovedItem(e => this._toggleClass(e.item, !1))
                }
                _applyClasses(e) {
                    e && (Array.isArray(e) || e instanceof Set ? e.forEach(e => this._toggleClass(e, !0)) : Object.keys(e).forEach(t => this._toggleClass(t, !!e[t])))
                }
                _removeClasses(e) {
                    e && (Array.isArray(e) || e instanceof Set ? e.forEach(e => this._toggleClass(e, !1)) : Object.keys(e).forEach(e => this._toggleClass(e, !1)))
                }
                _toggleClass(e, t) {
                    (e = e.trim()) && e.split(/\s+/g).forEach(e => {
                        t ? this._renderer.addClass(this._ngEl.nativeElement, e) : this._renderer.removeClass(this._ngEl.nativeElement, e)
                    })
                }
            }
            ve.decorators = [{
                type: s.s,
                args: [{
                    selector: "[ngClass]"
                }]
            }], ve.ctorParameters = () => [{
                type: s.E
            }, {
                type: s.F
            }, {
                type: s.t
            }, {
                type: s.U
            }], ve.propDecorators = {
                klass: [{
                    type: s.D,
                    args: ["class"]
                }],
                ngClass: [{
                    type: s.D,
                    args: ["ngClass"]
                }]
            };
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class _e {
                constructor(e) {
                    this._viewContainerRef = e, this._componentRef = null, this._moduleRef = null
                }
                ngOnChanges(e) {
                    if (this._viewContainerRef.clear(), this._componentRef = null, this.ngComponentOutlet) {
                        const t = this.ngComponentOutletInjector || this._viewContainerRef.parentInjector;
                        if (e.ngComponentOutletNgModuleFactory)
                            if (this._moduleRef && this._moduleRef.destroy(), this.ngComponentOutletNgModuleFactory) {
                                const e = t.get(s.K);
                                this._moduleRef = this.ngComponentOutletNgModuleFactory.create(e.injector)
                            } else this._moduleRef = null;
                        const n = (this._moduleRef ? this._moduleRef.componentFactoryResolver : t.get(s.p)).resolveComponentFactory(this.ngComponentOutlet);
                        this._componentRef = this._viewContainerRef.createComponent(n, this._viewContainerRef.length, t, this.ngComponentOutletContent)
                    }
                }
                ngOnDestroy() {
                    this._moduleRef && this._moduleRef.destroy()
                }
            }
            _e.decorators = [{
                type: s.s,
                args: [{
                    selector: "[ngComponentOutlet]"
                }]
            }], _e.ctorParameters = () => [{
                type: s.hb
            }], _e.propDecorators = {
                ngComponentOutlet: [{
                    type: s.D
                }],
                ngComponentOutletInjector: [{
                    type: s.D
                }],
                ngComponentOutletContent: [{
                    type: s.D
                }],
                ngComponentOutletNgModuleFactory: [{
                    type: s.D
                }]
            };
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class be {
                constructor(e, t, n, s) {
                    this.$implicit = e, this.ngForOf = t, this.index = n, this.count = s
                }
                get first() {
                    return 0 === this.index
                }
                get last() {
                    return this.index === this.count - 1
                }
                get even() {
                    return this.index % 2 == 0
                }
                get odd() {
                    return !this.even
                }
            }
            class we {
                constructor(e, t, n) {
                    this._viewContainer = e, this._template = t, this._differs = n, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null
                }
                set ngForOf(e) {
                    this._ngForOf = e, this._ngForOfDirty = !0
                }
                set ngForTrackBy(e) {
                    this._trackByFn = e
                }
                get ngForTrackBy() {
                    return this._trackByFn
                }
                set ngForTemplate(e) {
                    e && (this._template = e)
                }
                ngDoCheck() {
                    if (this._ngForOfDirty) {
                        this._ngForOfDirty = !1;
                        const n = this._ngForOf;
                        if (!this._differ && n) try {
                            this._differ = this._differs.find(n).create(this.ngForTrackBy)
                        } catch (t) {
                            throw new Error(`Cannot find a differ supporting object '${n}' of type '${e=n,e.name||typeof e}'. NgFor only supports binding to Iterables such as Arrays.`)
                        }
                    }
                    var e;
                    /**
                     * @license
                     * Copyright Google LLC All Rights Reserved.
                     *
                     * Use of this source code is governed by an MIT-style license that can be
                     * found in the LICENSE file at https://angular.io/license
                     */
                    if (this._differ) {
                        const e = this._differ.diff(this._ngForOf);
                        e && this._applyChanges(e)
                    }
                }
                _applyChanges(e) {
                    const t = [];
                    e.forEachOperation((e, n, s) => {
                        if (null == e.previousIndex) {
                            const n = this._viewContainer.createEmbeddedView(this._template, new be(null, this._ngForOf, -1, -1), null === s ? void 0 : s),
                                r = new Ee(e, n);
                            t.push(r)
                        } else if (null == s) this._viewContainer.remove(null === n ? void 0 : n);
                        else if (null !== n) {
                            const r = this._viewContainer.get(n);
                            this._viewContainer.move(r, s);
                            const i = new Ee(e, r);
                            t.push(i)
                        }
                    });
                    for (let n = 0; n < t.length; n++) this._perViewChange(t[n].view, t[n].record);
                    for (let n = 0, s = this._viewContainer.length; n < s; n++) {
                        const e = this._viewContainer.get(n);
                        e.context.index = n, e.context.count = s, e.context.ngForOf = this._ngForOf
                    }
                    e.forEachIdentityChange(e => {
                        this._viewContainer.get(e.currentIndex).context.$implicit = e.item
                    })
                }
                _perViewChange(e, t) {
                    e.context.$implicit = t.item
                }
                static ngTemplateContextGuard(e, t) {
                    return !0
                }
            }
            we.decorators = [{
                type: s.s,
                args: [{
                    selector: "[ngFor][ngForOf]"
                }]
            }], we.ctorParameters = () => [{
                type: s.hb
            }, {
                type: s.db
            }, {
                type: s.E
            }], we.propDecorators = {
                ngForOf: [{
                    type: s.D
                }],
                ngForTrackBy: [{
                    type: s.D
                }],
                ngForTemplate: [{
                    type: s.D
                }]
            };
            class Ee {
                constructor(e, t) {
                    this.record = e, this.view = t
                }
            }
            class Ce {
                constructor(e, t) {
                    this._viewContainer = e, this._context = new Se, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = t
                }
                set ngIf(e) {
                    this._context.$implicit = this._context.ngIf = e, this._updateView()
                }
                set ngIfThen(e) {
                    xe("ngIfThen", e), this._thenTemplateRef = e, this._thenViewRef = null, this._updateView()
                }
                set ngIfElse(e) {
                    xe("ngIfElse", e), this._elseTemplateRef = e, this._elseViewRef = null, this._updateView()
                }
                _updateView() {
                    this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context)))
                }
                static ngTemplateContextGuard(e, t) {
                    return !0
                }
            }
            Ce.decorators = [{
                type: s.s,
                args: [{
                    selector: "[ngIf]"
                }]
            }], Ce.ctorParameters = () => [{
                type: s.hb
            }, {
                type: s.db
            }], Ce.propDecorators = {
                ngIf: [{
                    type: s.D
                }],
                ngIfThen: [{
                    type: s.D
                }],
                ngIfElse: [{
                    type: s.D
                }]
            };
            class Se {
                constructor() {
                    this.$implicit = null, this.ngIf = null
                }
            }

            function xe(e, t) {
                if (!!(t && !t.createEmbeddedView)) throw new Error(`${e} must be a TemplateRef, but received '${Object(s.ic)(t)}'.`)
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class Te {
                constructor(e, t) {
                    this._viewContainerRef = e, this._templateRef = t, this._created = !1
                }
                create() {
                    this._created = !0, this._viewContainerRef.createEmbeddedView(this._templateRef)
                }
                destroy() {
                    this._created = !1, this._viewContainerRef.clear()
                }
                enforceState(e) {
                    e && !this._created ? this.create() : !e && this._created && this.destroy()
                }
            }
            class Ae {
                constructor() {
                    this._defaultUsed = !1, this._caseCount = 0, this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1
                }
                set ngSwitch(e) {
                    this._ngSwitch = e, 0 === this._caseCount && this._updateDefaultCases(!0)
                }
                _addCase() {
                    return this._caseCount++
                }
                _addDefault(e) {
                    this._defaultViews || (this._defaultViews = []), this._defaultViews.push(e)
                }
                _matchCase(e) {
                    const t = e == this._ngSwitch;
                    return this._lastCasesMatched = this._lastCasesMatched || t, this._lastCaseCheckIndex++, this._lastCaseCheckIndex === this._caseCount && (this._updateDefaultCases(!this._lastCasesMatched), this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1), t
                }
                _updateDefaultCases(e) {
                    if (this._defaultViews && e !== this._defaultUsed) {
                        this._defaultUsed = e;
                        for (let t = 0; t < this._defaultViews.length; t++) {
                            this._defaultViews[t].enforceState(e)
                        }
                    }
                }
            }
            Ae.decorators = [{
                type: s.s,
                args: [{
                    selector: "[ngSwitch]"
                }]
            }], Ae.propDecorators = {
                ngSwitch: [{
                    type: s.D
                }]
            };
            class De {
                constructor(e, t, n) {
                    this.ngSwitch = n, n._addCase(), this._view = new Te(e, t)
                }
                ngDoCheck() {
                    this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase))
                }
            }
            De.decorators = [{
                type: s.s,
                args: [{
                    selector: "[ngSwitchCase]"
                }]
            }], De.ctorParameters = () => [{
                type: s.hb
            }, {
                type: s.db
            }, {
                type: Ae,
                decorators: [{
                    type: s.w
                }]
            }], De.propDecorators = {
                ngSwitchCase: [{
                    type: s.D
                }]
            };
            class Pe {
                constructor(e, t, n) {
                    n._addDefault(new Te(e, t))
                }
            }
            Pe.decorators = [{
                type: s.s,
                args: [{
                    selector: "[ngSwitchDefault]"
                }]
            }], Pe.ctorParameters = () => [{
                type: s.hb
            }, {
                type: s.db
            }, {
                type: Ae,
                decorators: [{
                    type: s.w
                }]
            }]
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            class ke {
                constructor(e) {
                    this._localization = e, this._caseViews = {}
                }
                set ngPlural(e) {
                    this._switchValue = e, this._updateView()
                }
                addCase(e, t) {
                    this._caseViews[e] = t
                }
                _updateView() {
                    this._clearViews();
                    const e = Object.keys(this._caseViews),
                        t = me(this._switchValue, e, this._localization);
                    this._activateView(this._caseViews[t])
                }
                _clearViews() {
                    this._activeView && this._activeView.destroy()
                }
                _activateView(e) {
                    e && (this._activeView = e, this._activeView.create())
                }
            }
            ke.decorators = [{
                type: s.s,
                args: [{
                    selector: "[ngPlural]"
                }]
            }], ke.ctorParameters = () => [{
                type: fe
            }], ke.propDecorators = {
                ngPlural: [{
                    type: s.D
                }]
            };
            class Oe {
                constructor(e, t, n, s) {
                    this.value = e;
                    const r = !isNaN(Number(e));
                    s.addCase(r ? `=${e}` : e, new Te(n, t))
                }
            }
            Oe.decorators = [{
                type: s.s,
                args: [{
                    selector: "[ngPluralCase]"
                }]
            }], Oe.ctorParameters = () => [{
                type: String,
                decorators: [{
                    type: s.g,
                    args: ["ngPluralCase"]
                }]
            }, {
                type: s.db
            }, {
                type: s.hb
            }, {
                type: ke,
                decorators: [{
                    type: s.w
                }]
            }]
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            class Ie {
                constructor(e, t, n) {
                    this._ngEl = e, this._differs = t, this._renderer = n, this._ngStyle = null, this._differ = null
                }
                set ngStyle(e) {
                    this._ngStyle = e, !this._differ && e && (this._differ = this._differs.find(e).create())
                }
                ngDoCheck() {
                    if (this._differ) {
                        const e = this._differ.diff(this._ngStyle);
                        e && this._applyChanges(e)
                    }
                }
                _setStyle(e, t) {
                    const [n, s] = e.split(".");
                    null != (t = null != t && s ? `${t}${s}` : t) ? this._renderer.setStyle(this._ngEl.nativeElement, n, t) : this._renderer.removeStyle(this._ngEl.nativeElement, n)
                }
                _applyChanges(e) {
                    e.forEachRemovedItem(e => this._setStyle(e.key, null)), e.forEachAddedItem(e => this._setStyle(e.key, e.currentValue)), e.forEachChangedItem(e => this._setStyle(e.key, e.currentValue))
                }
            }
            Ie.decorators = [{
                type: s.s,
                args: [{
                    selector: "[ngStyle]"
                }]
            }], Ie.ctorParameters = () => [{
                type: s.t
            }, {
                type: s.F
            }, {
                type: s.U
            }], Ie.propDecorators = {
                ngStyle: [{
                    type: s.D,
                    args: ["ngStyle"]
                }]
            };
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class Ne {
                constructor(e) {
                    this._viewContainerRef = e, this._viewRef = null, this.ngTemplateOutletContext = null, this.ngTemplateOutlet = null
                }
                ngOnChanges(e) {
                    if (this._shouldRecreateView(e)) {
                        const e = this._viewContainerRef;
                        this._viewRef && e.remove(e.indexOf(this._viewRef)), this._viewRef = this.ngTemplateOutlet ? e.createEmbeddedView(this.ngTemplateOutlet, this.ngTemplateOutletContext) : null
                    } else this._viewRef && this.ngTemplateOutletContext && this._updateExistingContext(this.ngTemplateOutletContext)
                }
                _shouldRecreateView(e) {
                    const t = e.ngTemplateOutletContext;
                    return !!e.ngTemplateOutlet || t && this._hasContextShapeChanged(t)
                }
                _hasContextShapeChanged(e) {
                    const t = Object.keys(e.previousValue || {}),
                        n = Object.keys(e.currentValue || {});
                    if (t.length === n.length) {
                        for (let e of n)
                            if (-1 === t.indexOf(e)) return !0;
                        return !1
                    }
                    return !0
                }
                _updateExistingContext(e) {
                    for (let t of Object.keys(e)) this._viewRef.context[t] = this.ngTemplateOutletContext[t]
                }
            }
            Ne.decorators = [{
                type: s.s,
                args: [{
                    selector: "[ngTemplateOutlet]"
                }]
            }], Ne.ctorParameters = () => [{
                type: s.hb
            }], Ne.propDecorators = {
                ngTemplateOutletContext: [{
                    type: s.D
                }],
                ngTemplateOutlet: [{
                    type: s.D
                }]
            };
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const Me = [ve, _e, we, Ce, Ne, Ie, Ae, De, Pe, ke, Oe];
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            function Fe(e, t) {
                return Error(`InvalidPipeArgument: '${t}' for pipe '${Object(s.ic)(e)}'`)
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const Re = new class {
                    createSubscription(e, t) {
                        return e.then(t, e => {
                            throw e
                        })
                    }
                    dispose(e) {}
                    onDestroy(e) {}
                },
                je = new class {
                    createSubscription(e, t) {
                        return e.subscribe({
                            next: t,
                            error: e => {
                                throw e
                            }
                        })
                    }
                    dispose(e) {
                        e.unsubscribe()
                    }
                    onDestroy(e) {
                        e.unsubscribe()
                    }
                };
            class Le {
                constructor(e) {
                    this._ref = e, this._latestValue = null, this._subscription = null, this._obj = null, this._strategy = null
                }
                ngOnDestroy() {
                    this._subscription && this._dispose()
                }
                transform(e) {
                    return this._obj ? e !== this._obj ? (this._dispose(), this.transform(e)) : this._latestValue : (e && this._subscribe(e), this._latestValue)
                }
                _subscribe(e) {
                    this._obj = e, this._strategy = this._selectStrategy(e), this._subscription = this._strategy.createSubscription(e, t => this._updateLatestValue(e, t))
                }
                _selectStrategy(e) {
                    if (Object(s.Ub)(e)) return Re;
                    if (Object(s.Tb)(e)) return je;
                    throw Fe(Le, e)
                }
                _dispose() {
                    this._strategy.dispose(this._subscription), this._latestValue = null, this._subscription = null, this._obj = null
                }
                _updateLatestValue(e, t) {
                    e === this._obj && (this._latestValue = t, this._ref.markForCheck())
                }
            }
            Le.decorators = [{
                type: s.S,
                args: [{
                    name: "async",
                    pure: !1
                }]
            }], Le.ctorParameters = () => [{
                type: s.k
            }]
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            class Ve {
                transform(e) {
                    if (null == e) return null;
                    if ("string" != typeof e) throw Fe(Ve, e);
                    return e.toLowerCase()
                }
            }
            Ve.decorators = [{
                type: s.S,
                args: [{
                    name: "lowercase"
                }]
            }];
            const $e = /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D])\S*/g;
            class Be {
                transform(e) {
                    if (null == e) return null;
                    if ("string" != typeof e) throw Fe(Be, e);
                    return e.replace($e, e => e[0].toUpperCase() + e.substr(1).toLowerCase())
                }
            }
            Be.decorators = [{
                type: s.S,
                args: [{
                    name: "titlecase"
                }]
            }];
            class He {
                transform(e) {
                    if (null == e) return null;
                    if ("string" != typeof e) throw Fe(He, e);
                    return e.toUpperCase()
                }
            }
            He.decorators = [{
                type: s.S,
                args: [{
                    name: "uppercase"
                }]
            }];
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class Ue {
                constructor(e) {
                    this.locale = e
                }
                transform(e, t = "mediumDate", n, s) {
                    if (null == e || "" === e || e != e) return null;
                    try {
                        return K(e, t, s || this.locale, n)
                    } catch (r) {
                        throw Fe(Ue, r.message)
                    }
                }
            }
            Ue.decorators = [{
                type: s.S,
                args: [{
                    name: "date",
                    pure: !0
                }]
            }], Ue.ctorParameters = () => [{
                type: String,
                decorators: [{
                    type: s.z,
                    args: [s.G]
                }]
            }]
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            const qe = /#/g;
            class ze {
                constructor(e) {
                    this._localization = e
                }
                transform(e, t, n) {
                    if (null == e) return "";
                    if ("object" != typeof t || null === t) throw Fe(ze, t);
                    return t[me(e, Object.keys(t), this._localization, n)].replace(qe, e.toString())
                }
            }
            ze.decorators = [{
                type: s.S,
                args: [{
                    name: "i18nPlural",
                    pure: !0
                }]
            }], ze.ctorParameters = () => [{
                type: fe
            }]
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            class We {
                transform(e, t) {
                    if (null == e) return "";
                    if ("object" != typeof t || "string" != typeof e) throw Fe(We, t);
                    return t.hasOwnProperty(e) ? t[e] : t.hasOwnProperty("other") ? t.other : ""
                }
            }
            We.decorators = [{
                type: s.S,
                args: [{
                    name: "i18nSelect",
                    pure: !0
                }]
            }];
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class Ge {
                transform(e) {
                    return JSON.stringify(e, null, 2)
                }
            }
            Ge.decorators = [{
                type: s.S,
                args: [{
                    name: "json",
                    pure: !1
                }]
            }];
            class Ke {
                constructor(e) {
                    this.differs = e, this.keyValues = []
                }
                transform(e, t = Qe) {
                    if (!e || !(e instanceof Map) && "object" != typeof e) return null;
                    this.differ || (this.differ = this.differs.find(e).create());
                    const n = this.differ.diff(e);
                    return n && (this.keyValues = [], n.forEachItem(e => {
                        /**
                         * @license
                         * Copyright Google LLC All Rights Reserved.
                         *
                         * Use of this source code is governed by an MIT-style license that can be
                         * found in the LICENSE file at https://angular.io/license
                         */
                        var t, n;
                        this.keyValues.push((t = e.key, n = e.currentValue, {
                            key: t,
                            value: n
                        }))
                    }), this.keyValues.sort(t)), this.keyValues
                }
            }

            function Qe(e, t) {
                const n = e.key,
                    s = t.key;
                if (n === s) return 0;
                if (void 0 === n) return 1;
                if (void 0 === s) return -1;
                if (null === n) return 1;
                if (null === s) return -1;
                if ("string" == typeof n && "string" == typeof s) return n < s ? -1 : 1;
                if ("number" == typeof n && "number" == typeof s) return n - s;
                if ("boolean" == typeof n && "boolean" == typeof s) return n < s ? -1 : 1;
                const r = String(n),
                    i = String(s);
                return r == i ? 0 : r < i ? -1 : 1
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            Ke.decorators = [{
                type: s.S,
                args: [{
                    name: "keyvalue",
                    pure: !1
                }]
            }], Ke.ctorParameters = () => [{
                type: s.F
            }];
            class Ze {
                constructor(e) {
                    this._locale = e
                }
                transform(e, t, n) {
                    if (!Ye(e)) return null;
                    n = n || this._locale;
                    try {
                        return function(e, t, n) {
                            return ue(e, pe(R(t, x.Decimal), F(t, k.MinusSign)), t, k.Group, k.Decimal, n)
                        }(et(e), n, t)
                    } catch (s) {
                        throw Fe(Ze, s.message)
                    }
                }
            }
            Ze.decorators = [{
                type: s.S,
                args: [{
                    name: "number"
                }]
            }], Ze.ctorParameters = () => [{
                type: String,
                decorators: [{
                    type: s.z,
                    args: [s.G]
                }]
            }];
            class Je {
                constructor(e) {
                    this._locale = e
                }
                transform(e, t, n) {
                    if (!Ye(e)) return null;
                    n = n || this._locale;
                    try {
                        return function(e, t, n) {
                            return ue(e, pe(R(t, x.Percent), F(t, k.MinusSign)), t, k.Group, k.Decimal, n, !0).replace(new RegExp("%", "g"), F(t, k.PercentSign))
                        }(et(e), n, t)
                    } catch (s) {
                        throw Fe(Je, s.message)
                    }
                }
            }
            Je.decorators = [{
                type: s.S,
                args: [{
                    name: "percent"
                }]
            }], Je.ctorParameters = () => [{
                type: String,
                decorators: [{
                    type: s.z,
                    args: [s.G]
                }]
            }];
            class Xe {
                constructor(e, t = "USD") {
                    this._locale = e, this._defaultCurrencyCode = t
                }
                transform(e, t, n = "symbol", s, r) {
                    if (!Ye(e)) return null;
                    r = r || this._locale, "boolean" == typeof n && (n = n ? "symbol" : "code");
                    let i = t || this._defaultCurrencyCode;
                    "code" !== n && (i = "symbol" === n || "symbol-narrow" === n ? B(i, "symbol" === n ? "wide" : "narrow", r) : n);
                    try {
                        return he(et(e), r, i, t, s)
                    } catch (o) {
                        throw Fe(Xe, o.message)
                    }
                }
            }

            function Ye(e) {
                return !(null == e || "" === e || e != e)
            }

            function et(e) {
                if ("string" == typeof e && !isNaN(Number(e) - parseFloat(e))) return Number(e);
                if ("number" != typeof e) throw new Error(`${e} is not a number`);
                return e
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            Xe.decorators = [{
                type: s.S,
                args: [{
                    name: "currency"
                }]
            }], Xe.ctorParameters = () => [{
                type: String,
                decorators: [{
                    type: s.z,
                    args: [s.G]
                }]
            }, {
                type: String,
                decorators: [{
                    type: s.z,
                    args: [s.r]
                }]
            }];
            class tt {
                transform(e, t, n) {
                    if (null == e) return null;
                    if (!this.supports(e)) throw Fe(tt, e);
                    return e.slice(t, n)
                }
                supports(e) {
                    return "string" == typeof e || Array.isArray(e)
                }
            }
            tt.decorators = [{
                type: s.S,
                args: [{
                    name: "slice",
                    pure: !1
                }]
            }];
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const nt = [Le, He, Ve, Ge, tt, Ze, Je, Be, Xe, Ue, ze, We, Ke];
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class st {}
            st.decorators = [{
                type: s.I,
                args: [{
                    declarations: [Me, nt],
                    exports: [Me, nt],
                    providers: [{
                        provide: fe,
                        useClass: ge
                    }]
                }]
            }];
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            new s.fb("11.0.7");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class rt {}
            rt.\u0275prov = Object(s.nc)({
                token: rt,
                providedIn: "root",
                factory: () => new it(Object(s.oc)(a), window)
            });
            class it {
                constructor(e, t) {
                    this.document = e, this.window = t, this.offset = () => [0, 0]
                }
                setOffset(e) {
                    Array.isArray(e) ? this.offset = () => e : this.offset = e
                }
                getScrollPosition() {
                    return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0]
                }
                scrollToPosition(e) {
                    this.supportsScrolling() && this.window.scrollTo(e[0], e[1])
                }
                scrollToAnchor(e) {
                    var t;
                    if (!this.supportsScrolling()) return;
                    const n = null !== (t = this.document.getElementById(e)) && void 0 !== t ? t : this.document.getElementsByName(e)[0];
                    void 0 !== n && (this.scrollToElement(n), this.attemptFocus(n))
                }
                setHistoryScrollRestoration(e) {
                    if (this.supportScrollRestoration()) {
                        const t = this.window.history;
                        t && t.scrollRestoration && (t.scrollRestoration = e)
                    }
                }
                scrollToElement(e) {
                    const t = e.getBoundingClientRect(),
                        n = t.left + this.window.pageXOffset,
                        s = t.top + this.window.pageYOffset,
                        r = this.offset();
                    this.window.scrollTo(n - r[0], s - r[1])
                }
                attemptFocus(e) {
                    return e.focus(), this.document.activeElement === e
                }
                supportScrollRestoration() {
                    try {
                        if (!this.supportsScrolling()) return !1;
                        const e = ot(this.window.history) || ot(Object.getPrototypeOf(this.window.history));
                        return !(!e || !e.writable && !e.set)
                    } catch (e) {
                        return !1
                    }
                }
                supportsScrolling() {
                    try {
                        return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window
                    } catch (e) {
                        return !1
                    }
                }
            }

            function ot(e) {
                return Object.getOwnPropertyDescriptor(e, "scrollRestoration")
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            (() => {
                if (s.Pb.Node) s.Pb.Node.prototype.contains
            })();
            class at extends
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @license Angular v11.0.7
             * (c) 2010-2020 Google LLC. https://angular.io/
             * License: MIT
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class extends class {} {
                constructor() {
                    super()
                }
                supportsDOMEvents() {
                    return !0
                }
            } {
                static makeCurrent() {
                    var e;
                    e = new at, i || (i = e)
                }
                getProperty(e, t) {
                    return e[t]
                }
                log(e) {
                    window.console && window.console.log && window.console.log(e)
                }
                logGroup(e) {
                    window.console && window.console.group && window.console.group(e)
                }
                logGroupEnd() {
                    window.console && window.console.groupEnd && window.console.groupEnd()
                }
                onAndCancel(e, t, n) {
                    return e.addEventListener(t, n, !1), () => {
                        e.removeEventListener(t, n, !1)
                    }
                }
                dispatchEvent(e, t) {
                    e.dispatchEvent(t)
                }
                remove(e) {
                    return e.parentNode && e.parentNode.removeChild(e), e
                }
                getValue(e) {
                    return e.value
                }
                createElement(e, t) {
                    return (t = t || this.getDefaultDocument()).createElement(e)
                }
                createHtmlDocument() {
                    return document.implementation.createHTMLDocument("fakeTitle")
                }
                getDefaultDocument() {
                    return document
                }
                isElementNode(e) {
                    return e.nodeType === Node.ELEMENT_NODE
                }
                isShadowRoot(e) {
                    return e instanceof DocumentFragment
                }
                getGlobalEventTarget(e, t) {
                    return "window" === t ? window : "document" === t ? e : "body" === t ? e.body : null
                }
                getHistory() {
                    return window.history
                }
                getLocation() {
                    return window.location
                }
                getBaseHref(e) {
                    const t = function() {
                        if (!ct && (ct = document.querySelector("base"), !ct)) return null;
                        return ct.getAttribute("href")
                    }();
                    return null == t ? null : function(e) {
                        lt || (lt = document.createElement("a"));
                        return lt.setAttribute("href", e), "/" === lt.pathname.charAt(0) ? lt.pathname : "/" + lt.pathname
                    }
                    /**
                     * @license
                     * Copyright Google LLC All Rights Reserved.
                     *
                     * Use of this source code is governed by an MIT-style license that can be
                     * found in the LICENSE file at https://angular.io/license
                     */
                    (t)
                }
                resetBaseElement() {
                    ct = null
                }
                getUserAgent() {
                    return window.navigator.userAgent
                }
                performanceNow() {
                    return window.performance && window.performance.now ? window.performance.now() : (new Date).getTime()
                }
                supportsCookies() {
                    return !0
                }
                getCookie(e) {
                    return ye(document.cookie, e)
                }
            }
            let lt, ct = null;
            const ut = new s.B("TRANSITION_ID");
            const ht = [{
                provide: s.c,
                useFactory: function(e, t, n) {
                    return () => {
                        n.get(s.d).donePromise.then(() => {
                            const n = o();
                            Array.prototype.slice.apply(t.querySelectorAll("style[ng-transition]")).filter(t => t.getAttribute("ng-transition") === e).forEach(e => n.remove(e))
                        })
                    }
                },
                deps: [ut, a, s.C],
                multi: !0
            }];
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class pt {
                static init() {
                    Object(s.ob)(new pt)
                }
                addToWindow(e) {
                    s.Pb.getAngularTestability = (t, n = !0) => {
                        const s = e.findTestabilityInTree(t, n);
                        if (null == s) throw new Error("Could not find testability for element.");
                        return s
                    }, s.Pb.getAllAngularTestabilities = () => e.getAllTestabilities(), s.Pb.getAllAngularRootElements = () => e.getAllRootElements();
                    s.Pb.frameworkStabilizers || (s.Pb.frameworkStabilizers = []), s.Pb.frameworkStabilizers.push(e => {
                        const t = s.Pb.getAllAngularTestabilities();
                        let n = t.length,
                            r = !1;
                        const i = function(t) {
                            r = r || t, n--, 0 == n && e(r)
                        };
                        t.forEach(function(e) {
                            e.whenStable(i)
                        })
                    })
                }
                findTestabilityInTree(e, t, n) {
                    if (null == t) return null;
                    const s = e.getTestability(t);
                    return null != s ? s : n ? o().isShadowRoot(t) ? this.findTestabilityInTree(e, t.host, !0) : this.findTestabilityInTree(e, t.parentElement, !0) : null
                }
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            function dt(e, t) {
                if ("undefined" == typeof COMPILED || !COMPILED) {
                    (s.Pb.ng = s.Pb.ng || {})[e] = t
                }
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const ft = {
                ApplicationRef: s.f,
                NgZone: s.M
            };

            function mt(e) {
                return Object(s.Lb)(e)
            }
            const gt = [{
                    provide: s.c,
                    useFactory: function(e) {
                        return dt("probe", mt), dt("coreTokens", Object.assign(Object.assign({}, ft), (e || []).reduce((e, t) => (e[t.name] = t.token, e), {}))), () => mt
                    },
                    deps: [
                        [s.L, new s.N]
                    ],
                    multi: !0
                }],
                yt = new s.B("EventManagerPlugins");
            class vt {
                constructor(e, t) {
                    this._zone = t, this._eventNameToPlugin = new Map, e.forEach(e => e.manager = this), this._plugins = e.slice().reverse()
                }
                addEventListener(e, t, n) {
                    return this._findPluginFor(t).addEventListener(e, t, n)
                }
                addGlobalEventListener(e, t, n) {
                    return this._findPluginFor(t).addGlobalEventListener(e, t, n)
                }
                getZone() {
                    return this._zone
                }
                _findPluginFor(e) {
                    const t = this._eventNameToPlugin.get(e);
                    if (t) return t;
                    const n = this._plugins;
                    for (let s = 0; s < n.length; s++) {
                        const t = n[s];
                        if (t.supports(e)) return this._eventNameToPlugin.set(e, t), t
                    }
                    throw new Error(`No event manager plugin found for event ${e}`)
                }
            }
            vt.decorators = [{
                type: s.A
            }], vt.ctorParameters = () => [{
                type: Array,
                decorators: [{
                    type: s.z,
                    args: [yt]
                }]
            }, {
                type: s.M
            }];
            class _t {
                constructor(e) {
                    this._doc = e
                }
                addGlobalEventListener(e, t, n) {
                    const s = o().getGlobalEventTarget(this._doc, e);
                    if (!s) throw new Error(`Unsupported event target ${s} for event ${t}`);
                    return this.addEventListener(s, t, n)
                }
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class bt {
                constructor() {
                    this._stylesSet = new Set
                }
                addStyles(e) {
                    const t = new Set;
                    e.forEach(e => {
                        this._stylesSet.has(e) || (this._stylesSet.add(e), t.add(e))
                    }), this.onStylesAdded(t)
                }
                onStylesAdded(e) {}
                getAllStyles() {
                    return Array.from(this._stylesSet)
                }
            }
            bt.decorators = [{
                type: s.A
            }];
            class wt extends bt {
                constructor(e) {
                    super(), this._doc = e, this._hostNodes = new Set, this._styleNodes = new Set, this._hostNodes.add(e.head)
                }
                _addStylesToHost(e, t) {
                    e.forEach(e => {
                        const n = this._doc.createElement("style");
                        n.textContent = e, this._styleNodes.add(t.appendChild(n))
                    })
                }
                addHost(e) {
                    this._addStylesToHost(this._stylesSet, e), this._hostNodes.add(e)
                }
                removeHost(e) {
                    this._hostNodes.delete(e)
                }
                onStylesAdded(e) {
                    this._hostNodes.forEach(t => this._addStylesToHost(e, t))
                }
                ngOnDestroy() {
                    this._styleNodes.forEach(e => o().remove(e))
                }
            }
            wt.decorators = [{
                type: s.A
            }], wt.ctorParameters = () => [{
                type: void 0,
                decorators: [{
                    type: s.z,
                    args: [a]
                }]
            }]
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            const Et = {
                    svg: "http://www.w3.org/2000/svg",
                    xhtml: "http://www.w3.org/1999/xhtml",
                    xlink: "http://www.w3.org/1999/xlink",
                    xml: "http://www.w3.org/XML/1998/namespace",
                    xmlns: "http://www.w3.org/2000/xmlns/"
                },
                Ct = /%COMP%/g,
                St = "_nghost-%COMP%",
                xt = "_ngcontent-%COMP%";

            function Tt(e, t, n) {
                for (let s = 0; s < t.length; s++) {
                    let r = t[s];
                    Array.isArray(r) ? Tt(e, r, n) : (r = r.replace(Ct, e), n.push(r))
                }
                return n
            }

            function At(e) {
                return t => {
                    if ("__ngUnwrap__" === t) return e;
                    !1 === e(t) && (t.preventDefault(), t.returnValue = !1)
                }
            }
            class Dt {
                constructor(e, t, n) {
                    this.eventManager = e, this.sharedStylesHost = t, this.appId = n, this.rendererByCompId = new Map, this.defaultRenderer = new Pt(e)
                }
                createRenderer(e, t) {
                    if (!e || !t) return this.defaultRenderer;
                    switch (t.encapsulation) {
                        case s.ib.Emulated:
                            {
                                let n = this.rendererByCompId.get(t.id);
                                return n || (n = new kt(this.eventManager, this.sharedStylesHost, t, this.appId), this.rendererByCompId.set(t.id, n)),
                                n.applyToHost(e),
                                n
                            }
                        case 1:
                        case s.ib.ShadowDom:
                            return new Ot(this.eventManager, this.sharedStylesHost, e, t);
                        default:
                            if (!this.rendererByCompId.has(t.id)) {
                                const e = Tt(t.id, t.styles, []);
                                this.sharedStylesHost.addStyles(e), this.rendererByCompId.set(t.id, this.defaultRenderer)
                            }
                            return this.defaultRenderer
                    }
                }
                begin() {}
                end() {}
            }
            Dt.decorators = [{
                type: s.A
            }], Dt.ctorParameters = () => [{
                type: vt
            }, {
                type: wt
            }, {
                type: String,
                decorators: [{
                    type: s.z,
                    args: [s.b]
                }]
            }];
            class Pt {
                constructor(e) {
                    this.eventManager = e, this.data = Object.create(null)
                }
                destroy() {}
                createElement(e, t) {
                    return t ? document.createElementNS(Et[t] || t, e) : document.createElement(e)
                }
                createComment(e) {
                    return document.createComment(e)
                }
                createText(e) {
                    return document.createTextNode(e)
                }
                appendChild(e, t) {
                    e.appendChild(t)
                }
                insertBefore(e, t, n) {
                    e && e.insertBefore(t, n)
                }
                removeChild(e, t) {
                    e && e.removeChild(t)
                }
                selectRootElement(e, t) {
                    let n = "string" == typeof e ? document.querySelector(e) : e;
                    if (!n) throw new Error(`The selector "${e}" did not match any elements`);
                    return t || (n.textContent = ""), n
                }
                parentNode(e) {
                    return e.parentNode
                }
                nextSibling(e) {
                    return e.nextSibling
                }
                setAttribute(e, t, n, s) {
                    if (s) {
                        t = s + ":" + t;
                        const r = Et[s];
                        r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)
                    } else e.setAttribute(t, n)
                }
                removeAttribute(e, t, n) {
                    if (n) {
                        const s = Et[n];
                        s ? e.removeAttributeNS(s, t) : e.removeAttribute(`${n}:${t}`)
                    } else e.removeAttribute(t)
                }
                addClass(e, t) {
                    e.classList.add(t)
                }
                removeClass(e, t) {
                    e.classList.remove(t)
                }
                setStyle(e, t, n, r) {
                    r & (s.W.DashCase | s.W.Important) ? e.style.setProperty(t, n, r & s.W.Important ? "important" : "") : e.style[t] = n
                }
                removeStyle(e, t, n) {
                    n & s.W.DashCase ? e.style.removeProperty(t) : e.style[t] = ""
                }
                setProperty(e, t, n) {
                    e[t] = n
                }
                setValue(e, t) {
                    e.nodeValue = t
                }
                listen(e, t, n) {
                    return "string" == typeof e ? this.eventManager.addGlobalEventListener(e, t, At(n)) : this.eventManager.addEventListener(e, t, At(n))
                }
            }
            "@".charCodeAt(0);
            class kt extends Pt {
                constructor(e, t, n, s) {
                    super(e), this.component = n;
                    const r = Tt(s + "-" + n.id, n.styles, []);
                    var i;
                    t.addStyles(r), this.contentAttr = (i = s + "-" + n.id, xt.replace(Ct, i)), this.hostAttr = function(e) {
                        return St.replace(Ct, e)
                    }(s + "-" + n.id)
                }
                applyToHost(e) {
                    super.setAttribute(e, this.hostAttr, "")
                }
                createElement(e, t) {
                    const n = super.createElement(e, t);
                    return super.setAttribute(n, this.contentAttr, ""), n
                }
            }
            class Ot extends Pt {
                constructor(e, t, n, s) {
                    super(e), this.sharedStylesHost = t, this.hostEl = n, this.shadowRoot = n.attachShadow({
                        mode: "open"
                    }), this.sharedStylesHost.addHost(this.shadowRoot);
                    const r = Tt(s.id, s.styles, []);
                    for (let i = 0; i < r.length; i++) {
                        const e = document.createElement("style");
                        e.textContent = r[i], this.shadowRoot.appendChild(e)
                    }
                }
                nodeOrShadowRoot(e) {
                    return e === this.hostEl ? this.shadowRoot : e
                }
                destroy() {
                    this.sharedStylesHost.removeHost(this.shadowRoot)
                }
                appendChild(e, t) {
                    return super.appendChild(this.nodeOrShadowRoot(e), t)
                }
                insertBefore(e, t, n) {
                    return super.insertBefore(this.nodeOrShadowRoot(e), t, n)
                }
                removeChild(e, t) {
                    return super.removeChild(this.nodeOrShadowRoot(e), t)
                }
                parentNode(e) {
                    return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(e)))
                }
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class It extends _t {
                constructor(e) {
                    super(e)
                }
                supports(e) {
                    return !0
                }
                addEventListener(e, t, n) {
                    return e.addEventListener(t, n, !1), () => this.removeEventListener(e, t, n)
                }
                removeEventListener(e, t, n) {
                    return e.removeEventListener(t, n)
                }
            }
            It.decorators = [{
                type: s.A
            }], It.ctorParameters = () => [{
                type: void 0,
                decorators: [{
                    type: s.z,
                    args: [a]
                }]
            }]
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            const Nt = {
                    pan: !0,
                    panstart: !0,
                    panmove: !0,
                    panend: !0,
                    pancancel: !0,
                    panleft: !0,
                    panright: !0,
                    panup: !0,
                    pandown: !0,
                    pinch: !0,
                    pinchstart: !0,
                    pinchmove: !0,
                    pinchend: !0,
                    pinchcancel: !0,
                    pinchin: !0,
                    pinchout: !0,
                    press: !0,
                    pressup: !0,
                    rotate: !0,
                    rotatestart: !0,
                    rotatemove: !0,
                    rotateend: !0,
                    rotatecancel: !0,
                    swipe: !0,
                    swipeleft: !0,
                    swiperight: !0,
                    swipeup: !0,
                    swipedown: !0,
                    tap: !0
                },
                Mt = new s.B("HammerGestureConfig"),
                Ft = new s.B("HammerLoader");
            class Rt {
                constructor() {
                    this.events = [], this.overrides = {}
                }
                buildHammer(e) {
                    const t = new Hammer(e, this.options);
                    t.get("pinch").set({
                        enable: !0
                    }), t.get("rotate").set({
                        enable: !0
                    });
                    for (const n in this.overrides) t.get(n).set(this.overrides[n]);
                    return t
                }
            }
            Rt.decorators = [{
                type: s.A
            }];
            class jt extends _t {
                constructor(e, t, n, s) {
                    super(e), this._config = t, this.console = n, this.loader = s
                }
                supports(e) {
                    return !(!Nt.hasOwnProperty(e.toLowerCase()) && !this.isCustomEvent(e)) && (!(!window.Hammer && !this.loader) || (this.console.warn(`The "${e}" event cannot be bound because Hammer.JS is not loaded and no custom loader has been specified.`), !1))
                }
                addEventListener(e, t, n) {
                    const s = this.manager.getZone();
                    if (t = t.toLowerCase(), !window.Hammer && this.loader) {
                        let s = !1,
                            r = () => {
                                s = !0
                            };
                        return this.loader().then(() => {
                            if (!window.Hammer) return this.console.warn("The custom HAMMER_LOADER completed, but Hammer.JS is not present."), void(r = () => {});
                            s || (r = this.addEventListener(e, t, n))
                        }).catch(() => {
                            this.console.warn(`The "${t}" event cannot be bound because the custom Hammer.JS loader failed.`), r = () => {}
                        }), () => {
                            r()
                        }
                    }
                    return s.runOutsideAngular(() => {
                        const r = this._config.buildHammer(e),
                            i = function(e) {
                                s.runGuarded(function() {
                                    n(e)
                                })
                            };
                        return r.on(t, i), () => {
                            r.off(t, i), "function" == typeof r.destroy && r.destroy()
                        }
                    })
                }
                isCustomEvent(e) {
                    return this._config.events.indexOf(e) > -1
                }
            }
            jt.decorators = [{
                type: s.A
            }], jt.ctorParameters = () => [{
                type: void 0,
                decorators: [{
                    type: s.z,
                    args: [a]
                }]
            }, {
                type: Rt,
                decorators: [{
                    type: s.z,
                    args: [Mt]
                }]
            }, {
                type: s.qb
            }, {
                type: void 0,
                decorators: [{
                    type: s.N
                }, {
                    type: s.z,
                    args: [Ft]
                }]
            }];
            const Lt = [{
                    provide: yt,
                    useClass: jt,
                    multi: !0,
                    deps: [a, Mt, s.qb, [new s.N, Ft]]
                }, {
                    provide: Mt,
                    useClass: Rt,
                    deps: []
                }],
                Vt = Lt;
            (class {}).decorators = [{
                type: s.I,
                args: [{
                    providers: Lt
                }]
            }];
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const $t = ["alt", "control", "meta", "shift"],
                Bt = {
                    "\b": "Backspace",
                    "\t": "Tab",
                    "\x7f": "Delete",
                    "\x1b": "Escape",
                    Del: "Delete",
                    Esc: "Escape",
                    Left: "ArrowLeft",
                    Right: "ArrowRight",
                    Up: "ArrowUp",
                    Down: "ArrowDown",
                    Menu: "ContextMenu",
                    Scroll: "ScrollLock",
                    Win: "OS"
                },
                Ht = {
                    A: "1",
                    B: "2",
                    C: "3",
                    D: "4",
                    E: "5",
                    F: "6",
                    G: "7",
                    H: "8",
                    I: "9",
                    J: "*",
                    K: "+",
                    M: "-",
                    N: ".",
                    O: "/",
                    "`": "0",
                    "\x90": "NumLock"
                },
                Ut = {
                    alt: e => e.altKey,
                    control: e => e.ctrlKey,
                    meta: e => e.metaKey,
                    shift: e => e.shiftKey
                };
            class qt extends _t {
                constructor(e) {
                    super(e)
                }
                supports(e) {
                    return null != qt.parseEventName(e)
                }
                addEventListener(e, t, n) {
                    const s = qt.parseEventName(t),
                        r = qt.eventCallback(s.fullKey, n, this.manager.getZone());
                    return this.manager.getZone().runOutsideAngular(() => o().onAndCancel(e, s.domEventName, r))
                }
                static parseEventName(e) {
                    const t = e.toLowerCase().split("."),
                        n = t.shift();
                    if (0 === t.length || "keydown" !== n && "keyup" !== n) return null;
                    const s = qt._normalizeKey(t.pop());
                    let r = "";
                    if ($t.forEach(e => {
                            const n = t.indexOf(e);
                            n > -1 && (t.splice(n, 1), r += e + ".")
                        }), r += s, 0 != t.length || 0 === s.length) return null;
                    const i = {};
                    return i.domEventName = n, i.fullKey = r, i
                }
                static getEventFullKey(e) {
                    let t = "",
                        n = function(e) {
                            let t = e.key;
                            if (null == t) {
                                if (t = e.keyIdentifier, null == t) return "Unidentified";
                                t.startsWith("U+") && (t = String.fromCharCode(parseInt(t.substring(2), 16)), 3 === e.location && Ht.hasOwnProperty(t) && (t = Ht[t]))
                            }
                            return Bt[t] || t
                        }
                    /**
                     * @license
                     * Copyright Google LLC All Rights Reserved.
                     *
                     * Use of this source code is governed by an MIT-style license that can be
                     * found in the LICENSE file at https://angular.io/license
                     */
                    (e);
                    return n = n.toLowerCase(), " " === n ? n = "space" : "." === n && (n = "dot"), $t.forEach(s => {
                        if (s != n) {
                            (0, Ut[s])(e) && (t += s + ".")
                        }
                    }), t += n, t
                }
                static eventCallback(e, t, n) {
                    return s => {
                        qt.getEventFullKey(s) === e && n.runGuarded(() => t(s))
                    }
                }
                static _normalizeKey(e) {
                    switch (e) {
                        case "esc":
                            return "escape";
                        default:
                            return e
                    }
                }
            }
            qt.decorators = [{
                type: s.A
            }], qt.ctorParameters = () => [{
                type: void 0,
                decorators: [{
                    type: s.z,
                    args: [a]
                }]
            }];
            class zt {}

            function Wt(e) {
                return new Gt(e.get(a))
            }
            zt.\u0275prov = Object(s.nc)({
                factory: function() {
                    return Object(s.oc)(Gt)
                },
                token: zt,
                providedIn: "root"
            }), zt.decorators = [{
                type: s.A,
                args: [{
                    providedIn: "root",
                    useExisting: Object(s.lb)(() => Gt)
                }]
            }];
            class Gt extends zt {
                constructor(e) {
                    super(), this._doc = e
                }
                sanitize(e, t) {
                    if (null == t) return null;
                    switch (e) {
                        case s.Y.NONE:
                            return t;
                        case s.Y.HTML:
                            return Object(s.yb)(t, "HTML") ? Object(s.lc)(t) : Object(s.wb)(this._doc, String(t));
                        case s.Y.STYLE:
                            return Object(s.yb)(t, "Style") ? Object(s.lc)(t) : t;
                        case s.Y.SCRIPT:
                            if (Object(s.yb)(t, "Script")) return Object(s.lc)(t);
                            throw new Error("unsafe value used in a script context");
                        case s.Y.URL:
                            Object(s.Ob)(t);
                            return Object(s.yb)(t, "URL") ? Object(s.lc)(t) : Object(s.xb)(String(t));
                        case s.Y.RESOURCE_URL:
                            if (Object(s.yb)(t, "ResourceURL")) return Object(s.lc)(t);
                            throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)");
                        default:
                            throw new Error(`Unexpected SecurityContext ${e} (see https://g.co/ng/security#xss)`)
                    }
                }
                bypassSecurityTrustHtml(e) {
                    return Object(s.Ab)(e)
                }
                bypassSecurityTrustStyle(e) {
                    return Object(s.Db)(e)
                }
                bypassSecurityTrustScript(e) {
                    return Object(s.Cb)(e)
                }
                bypassSecurityTrustUrl(e) {
                    return Object(s.Eb)(e)
                }
                bypassSecurityTrustResourceUrl(e) {
                    return Object(s.Bb)(e)
                }
            }
            Gt.\u0275prov = Object(s.nc)({
                factory: function() {
                    return Wt(Object(s.oc)(s.y))
                },
                token: Gt,
                providedIn: "root"
            }), Gt.decorators = [{
                type: s.A,
                args: [{
                    providedIn: "root",
                    useFactory: Wt,
                    deps: [s.C]
                }]
            }], Gt.ctorParameters = () => [{
                type: void 0,
                decorators: [{
                    type: s.z,
                    args: [a]
                }]
            }]
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            const Kt = [{
                    provide: s.Q,
                    useValue: "browser"
                }, {
                    provide: s.R,
                    useValue: function() {
                        at.makeCurrent(), pt.init()
                    },
                    multi: !0
                }, {
                    provide: a,
                    useFactory: function() {
                        return Object(s.hc)(document), document
                    },
                    deps: []
                }],
                Qt = [{
                    provide: s.X,
                    useExisting: zt
                }, {
                    provide: zt,
                    useClass: Gt,
                    deps: [a]
                }],
                Zt = (Object(s.jb)(s.nb, "browser", Kt), [Qt, {
                    provide: s.tb,
                    useValue: "root"
                }, {
                    provide: s.u,
                    useFactory: function() {
                        return new s.u
                    },
                    deps: []
                }, {
                    provide: yt,
                    useClass: It,
                    multi: !0,
                    deps: [a, s.M, s.Q]
                }, {
                    provide: yt,
                    useClass: qt,
                    multi: !0,
                    deps: [a]
                }, Vt, {
                    provide: Dt,
                    useClass: Dt,
                    deps: [vt, wt, s.b]
                }, {
                    provide: s.V,
                    useExisting: Dt
                }, {
                    provide: bt,
                    useExisting: wt
                }, {
                    provide: wt,
                    useClass: wt,
                    deps: [a]
                }, {
                    provide: s.eb,
                    useClass: s.eb,
                    deps: [s.M]
                }, {
                    provide: vt,
                    useClass: vt,
                    deps: [yt, s.M]
                }, gt]);
            class Jt {
                constructor(e) {
                    if (e) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")
                }
                static withServerTransition(e) {
                    return {
                        ngModule: Jt,
                        providers: [{
                            provide: s.b,
                            useValue: e.appId
                        }, {
                            provide: ut,
                            useExisting: s.b
                        }, ht]
                    }
                }
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            function Xt() {
                return new Yt(Object(s.oc)(a))
            }
            Jt.decorators = [{
                type: s.I,
                args: [{
                    providers: Zt,
                    exports: [st, s.e]
                }]
            }], Jt.ctorParameters = () => [{
                type: Jt,
                decorators: [{
                    type: s.N
                }, {
                    type: s.ab
                }, {
                    type: s.z,
                    args: [Jt]
                }]
            }];
            class Yt {
                constructor(e) {
                    this._doc = e, this._dom = o()
                }
                addTag(e, t = !1) {
                    return e ? this._getOrCreateElement(e, t) : null
                }
                addTags(e, t = !1) {
                    return e ? e.reduce((e, n) => (n && e.push(this._getOrCreateElement(n, t)), e), []) : []
                }
                getTag(e) {
                    return e && this._doc.querySelector(`meta[${e}]`) || null
                }
                getTags(e) {
                    if (!e) return [];
                    const t = this._doc.querySelectorAll(`meta[${e}]`);
                    return t ? [].slice.call(t) : []
                }
                updateTag(e, t) {
                    if (!e) return null;
                    t = t || this._parseSelector(e);
                    const n = this.getTag(t);
                    return n ? this._setMetaElementAttributes(e, n) : this._getOrCreateElement(e, !0)
                }
                removeTag(e) {
                    this.removeTagElement(this.getTag(e))
                }
                removeTagElement(e) {
                    e && this._dom.remove(e)
                }
                _getOrCreateElement(e, t = !1) {
                    if (!t) {
                        const t = this._parseSelector(e),
                            n = this.getTag(t);
                        if (n && this._containsAttributes(e, n)) return n
                    }
                    const n = this._dom.createElement("meta");
                    this._setMetaElementAttributes(e, n);
                    return this._doc.getElementsByTagName("head")[0].appendChild(n), n
                }
                _setMetaElementAttributes(e, t) {
                    return Object.keys(e).forEach(n => t.setAttribute(this._getMetaKeyMap(n), e[n])), t
                }
                _parseSelector(e) {
                    const t = e.name ? "name" : "property";
                    return `${t}="${e[t]}"`
                }
                _containsAttributes(e, t) {
                    return Object.keys(e).every(n => t.getAttribute(this._getMetaKeyMap(n)) === e[n])
                }
                _getMetaKeyMap(e) {
                    return en[e] || e
                }
            }
            Yt.\u0275prov = Object(s.nc)({
                factory: Xt,
                token: Yt,
                providedIn: "root"
            }), Yt.decorators = [{
                type: s.A,
                args: [{
                    providedIn: "root",
                    useFactory: Xt,
                    deps: []
                }]
            }], Yt.ctorParameters = () => [{
                type: void 0,
                decorators: [{
                    type: s.z,
                    args: [a]
                }]
            }];
            const en = {
                httpEquiv: "http-equiv"
            };
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            function tn() {
                return new nn(Object(s.oc)(a))
            }
            class nn {
                constructor(e) {
                    this._doc = e
                }
                getTitle() {
                    return this._doc.title
                }
                setTitle(e) {
                    this._doc.title = e || ""
                }
            }
            nn.\u0275prov = Object(s.nc)({
                factory: tn,
                token: nn,
                providedIn: "root"
            }), nn.decorators = [{
                type: s.A,
                args: [{
                    providedIn: "root",
                    useFactory: tn,
                    deps: []
                }]
            }], nn.ctorParameters = () => [{
                type: void 0,
                decorators: [{
                    type: s.z,
                    args: [a]
                }]
            }]
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            "undefined" != typeof window && window;
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class sn {
                constructor() {
                    this.store = {}, this.onSerializeCallbacks = {}
                }
                static init(e) {
                    const t = new sn;
                    return t.store = e, t
                }
                get(e, t) {
                    return void 0 !== this.store[e] ? this.store[e] : t
                }
                set(e, t) {
                    this.store[e] = t
                }
                remove(e) {
                    delete this.store[e]
                }
                hasKey(e) {
                    return this.store.hasOwnProperty(e)
                }
                onSerialize(e, t) {
                    this.onSerializeCallbacks[e] = t
                }
                toJson() {
                    for (const t in this.onSerializeCallbacks)
                        if (this.onSerializeCallbacks.hasOwnProperty(t)) try {
                            this.store[t] = this.onSerializeCallbacks[t]()
                        } catch (e) {
                            console.warn("Exception in onSerialize callback: ", e)
                        }
                    return JSON.stringify(this.store)
                }
            }
            sn.decorators = [{
                type: s.A
            }];
            (class {}).decorators = [{
                type: s.I,
                args: [{
                    providers: [{
                        provide: sn,
                        useFactory: function(e, t) {
                            const n = e.getElementById(t + "-state");
                            let s = {};
                            if (n && n.textContent) try {
                                s = JSON.parse(function(e) {
                                    const t = {
                                        "&a;": "&",
                                        "&q;": '"',
                                        "&s;": "'",
                                        "&l;": "<",
                                        "&g;": ">"
                                    };
                                    return e.replace(/&[^;]+;/g, e => t[e])
                                }(n.textContent))
                            } catch (r) {
                                console.warn("Exception while restoring TransferState for app " + t, r)
                            }
                            return sn.init(s)
                        },
                        deps: [a, s.b]
                    }]
                }]
            }];
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            new s.fb("11.0.7");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @license Angular v11.0.7
             * (c) 2010-2020 Google LLC. https://angular.io/
             * License: MIT
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const rn = function() {
                const e = new Map;
                return e.set(r.j.ANALYZE_FOR_ENTRY_COMPONENTS, s.a), e.set(r.j.ElementRef, s.t), e.set(r.j.NgModuleRef, s.K), e.set(r.j.ViewContainerRef, s.hb), e.set(r.j.ChangeDetectorRef, s.k), e.set(r.j.Renderer2, s.U), e.set(r.j.QueryList, s.T), e.set(r.j.TemplateRef, s.db), e.set(r.j.CodegenComponentFactoryResolver, s.pb), e.set(r.j.ComponentFactoryResolver, s.p), e.set(r.j.ComponentFactory, s.o), e.set(r.j.ComponentRef, s.q), e.set(r.j.NgModuleFactory, s.J), e.set(r.j.createModuleFactory, s.Gb), e.set(r.j.moduleDef, s.Vb), e.set(r.j.moduleProviderDef, s.Wb), e.set(r.j.RegisterModuleFactoryFn, s.gc), e.set(r.j.Injector, s.C), e.set(r.j.ViewEncapsulation, s.ib), e.set(r.j.ChangeDetectionStrategy, s.j), e.set(r.j.SecurityContext, s.Y), e.set(r.j.LOCALE_ID, s.G), e.set(r.j.TRANSLATIONS_FORMAT, s.cb), e.set(r.j.inlineInterpolate, s.Qb), e.set(r.j.interpolate, s.Rb), e.set(r.j.EMPTY_ARRAY, s.rb), e.set(r.j.EMPTY_MAP, s.sb), e.set(r.j.viewDef, s.mc), e.set(r.j.elementDef, s.Jb), e.set(r.j.anchorDef, s.zb), e.set(r.j.textDef, s.jc), e.set(r.j.directiveDef, s.Ib), e.set(r.j.providerDef, s.dc), e.set(r.j.queryDef, s.ec), e.set(r.j.pureArrayDef, s.Zb), e.set(r.j.pureObjectDef, s.bc), e.set(r.j.purePipeDef, s.cc), e.set(r.j.pipeDef, s.ac), e.set(r.j.nodeValue, s.Yb), e.set(r.j.ngContentDef, s.Xb), e.set(r.j.unwrapValue, s.kc), e.set(r.j.createRendererType2, s.Hb), e.set(r.j.createComponentFactory, s.Fb), e
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ();
            const on = new s.B("ErrorCollector"),
                an = {
                    provide: s.P,
                    useValue: "/"
                },
                ln = {
                    get(e) {
                        throw new Error(`No ResourceLoader implementation has been provided. Can't read the url "${e}"`)
                    }
                },
                cn = new s.B("HtmlParser");
            const un = new class {
                    constructor() {
                        this.reflectionCapabilities = new s.vb
                    }
                    componentModuleUrl(e, t) {
                        const n = t.moduleId;
                        if ("string" == typeof n) {
                            return Object(r.A)(n) ? n : `package:${n}`
                        }
                        if (null != n) throw Object(r.B)(`moduleId should be a string in "${Object(s.ic)(e)}". See https://goo.gl/wIDDiL for more information.\nIf you're using Webpack you should inline the template and the styles, see https://goo.gl/X2J8zc.`);
                        return `./${Object(s.ic)(e)}`
                    }
                    parameters(e) {
                        return this.reflectionCapabilities.parameters(e)
                    }
                    tryAnnotations(e) {
                        return this.annotations(e)
                    }
                    annotations(e) {
                        return this.reflectionCapabilities.annotations(e)
                    }
                    shallowAnnotations(e) {
                        throw new Error("Not supported in JIT mode")
                    }
                    propMetadata(e) {
                        return this.reflectionCapabilities.propMetadata(e)
                    }
                    hasLifecycleHook(e, t) {
                        return this.reflectionCapabilities.hasLifecycleHook(e, t)
                    }
                    guards(e) {
                        return this.reflectionCapabilities.guards(e)
                    }
                    resolveExternalReference(e) {
                        return rn.get(e) || e.runtime
                    }
                },
                hn = ln,
                pn = new r.c,
                dn = [{
                    provide: r.b,
                    useValue: un
                }, {
                    provide: r.t,
                    useValue: hn
                }, {
                    provide: r.m,
                    deps: []
                }, {
                    provide: r.w,
                    useExisting: r.m
                }, {
                    provide: s.qb,
                    deps: []
                }, {
                    provide: r.n,
                    deps: []
                }, {
                    provide: r.q,
                    deps: [r.n]
                }, {
                    provide: cn,
                    useClass: r.h,
                    deps: []
                }, {
                    provide: r.i,
                    useFactory: (e, t, n, i, o) => {
                        const a = (t = t || "") ? i.missingTranslation : s.H.Ignore;
                        return new r.i(e, t, n, a, o)
                    },
                    deps: [cn, [new s.N, new s.z(s.bb)],
                        [new s.N, new s.z(s.cb)],
                        [r.c],
                        [s.qb]
                    ]
                }, {
                    provide: r.h,
                    useExisting: r.i
                }, {
                    provide: r.x,
                    deps: [r.c, r.b, r.q, r.g, r.i, s.qb]
                }, {
                    provide: r.l,
                    useClass: r.l,
                    deps: []
                }, {
                    provide: r.d,
                    deps: [r.t, r.y, r.h, r.c]
                }, {
                    provide: r.a,
                    deps: [r.c, r.h, r.p, r.e, r.r, r.w, r.g, r.d, s.qb, [s.N, r.u], r.b, [s.N, on]]
                }, an, {
                    provide: r.v,
                    deps: [r.y]
                }, {
                    provide: r.z,
                    deps: [r.b]
                }, {
                    provide: r.o,
                    deps: [r.b]
                }, {
                    provide: r.c,
                    useValue: pn
                }, {
                    provide: s.l,
                    useClass: class {
                        constructor(e, t, n, s, i, o, a, l, c, u, h) {
                            this._metadataResolver = t, this._delegate = new r.k(t, n, s, i, o, a, l, c, u, h, this.getExtraNgModuleProviders.bind(this)), this.injector = e
                        }
                        getExtraNgModuleProviders() {
                            return [this._metadataResolver.getProviderMetadata(new r.s(s.l, {
                                useValue: this
                            }))]
                        }
                        compileModuleSync(e) {
                            return this._delegate.compileModuleSync(e)
                        }
                        compileModuleAsync(e) {
                            return this._delegate.compileModuleAsync(e)
                        }
                        compileModuleAndAllComponentsSync(e) {
                            const t = this._delegate.compileModuleAndAllComponentsSync(e);
                            return {
                                ngModuleFactory: t.ngModuleFactory,
                                componentFactories: t.componentFactories
                            }
                        }
                        compileModuleAndAllComponentsAsync(e) {
                            return this._delegate.compileModuleAndAllComponentsAsync(e).then(e => ({
                                ngModuleFactory: e.ngModuleFactory,
                                componentFactories: e.componentFactories
                            }))
                        }
                        loadAotSummaries(e) {
                            this._delegate.loadAotSummaries(e)
                        }
                        hasAotSummary(e) {
                            return this._delegate.hasAotSummary(e)
                        }
                        getComponentFactory(e) {
                            return this._delegate.getComponentFactory(e)
                        }
                        clearCache() {
                            this._delegate.clearCache()
                        }
                        clearCacheFor(e) {
                            this._delegate.clearCacheFor(e)
                        }
                        getModuleId(e) {
                            const t = this._metadataResolver.getNgModuleMetadata(e);
                            return t && t.id || void 0
                        }
                    },
                    deps: [s.C, r.a, r.x, r.v, r.z, r.o, r.w, r.b, r.l, r.c, s.qb]
                }, {
                    provide: r.f,
                    deps: []
                }, {
                    provide: r.g,
                    useExisting: r.f
                }, {
                    provide: r.y,
                    deps: [s.P]
                }, {
                    provide: r.e,
                    deps: [r.b]
                }, {
                    provide: r.r,
                    deps: [r.b]
                }, {
                    provide: r.p,
                    deps: [r.b]
                }],
                fn = (s.l, dn);

            function mn(e) {
                for (let t = e.length - 1; t >= 0; t--)
                    if (void 0 !== e[t]) return e[t]
            }

            function gn(e) {
                const t = [];
                return e.forEach(e => e && t.push(...e)), t
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const yn = Object(s.jb)(s.nb, "coreDynamic", [{
                provide: s.h,
                useValue: {},
                multi: !0
            }, {
                provide: s.m,
                useClass: class {
                    constructor(e) {
                        const t = {
                            useJit: !0,
                            defaultEncapsulation: s.ib.Emulated,
                            missingTranslation: s.H.Warning
                        };
                        this._defaultOptions = [t, ...e]
                    }
                    createCompiler(e = []) {
                        const t = {
                            useJit: mn((n = this._defaultOptions.concat(e)).map(e => e.useJit)),
                            defaultEncapsulation: mn(n.map(e => e.defaultEncapsulation)),
                            providers: gn(n.map(e => e.providers)),
                            missingTranslation: mn(n.map(e => e.missingTranslation)),
                            preserveWhitespaces: mn(n.map(e => e.preserveWhitespaces))
                        };
                        var n;
                        return s.C.create([fn, {
                            provide: r.c,
                            useFactory: () => new r.c({
                                useJit: t.useJit,
                                jitDevMode: Object(s.mb)(),
                                defaultEncapsulation: t.defaultEncapsulation,
                                missingTranslation: t.missingTranslation,
                                preserveWhitespaces: t.preserveWhitespaces
                            }),
                            deps: []
                        }, t.providers]).get(s.l)
                    }
                },
                deps: [s.h]
            }]);
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class vn extends r.t {
                get(e) {
                    let t, n;
                    const s = new Promise((e, s) => {
                            t = e, n = s
                        }),
                        r = new XMLHttpRequest;
                    return r.open("GET", e, !0), r.responseType = "text", r.onload = function() {
                        const s = r.response || r.responseText;
                        let i = 1223 === r.status ? 204 : r.status;
                        0 === i && (i = s ? 200 : 0), 200 <= i && i <= 300 ? t(s) : n(`Failed to load ${e}`)
                    }, r.onerror = function() {
                        n(`Failed to load ${e}`)
                    }, r.send(), s
                }
            }
            vn.decorators = [{
                type: s.A
            }];
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const _n = {
                    providers: [{
                        provide: r.t,
                        useClass: vn,
                        deps: []
                    }]
                },
                bn = [Kt, {
                    provide: s.h,
                    useValue: _n,
                    multi: !0
                }, {
                    provide: s.Q,
                    useValue: "browser"
                }];
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class wn extends r.t {
                constructor() {
                    if (super(), this._cache = s.Pb.$templateCache, null == this._cache) throw new Error("CachedResourceLoader: Template cache was not found in $templateCache.")
                }
                get(e) {
                    return this._cache.hasOwnProperty(e) ? Promise.resolve(this._cache[e]) : Promise.reject("CachedResourceLoader: Did not find cached template for " + e)
                }
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            new s.fb("11.0.7"), r.t
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            const En = Object(s.jb)(yn, "browserDynamic", bn);

            function Cn(e, t, n, s) {
                var r, i = arguments.length,
                    o = i < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, n) : s;
                if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, s);
                else
                    for (var a = e.length - 1; a >= 0; a--)(r = e[a]) && (o = (i < 3 ? r(o) : i > 3 ? r(t, n, o) : r(t, n)) || o);
                return i > 3 && o && Object.defineProperty(t, n, o), o
            }

            function Sn(e, t) {
                if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
            }
            Object.create;
            Object.create;
            var xn = n("HDdC"),
                Tn = n("DH7j"),
                An = n("lJxs"),
                Dn = n("XoHu"),
                Pn = n("Cfvw");

            function kn(e, t) {
                return new xn.a(n => {
                    const s = e.length;
                    if (0 === s) return void n.complete();
                    const r = new Array(s);
                    let i = 0,
                        o = 0;
                    for (let a = 0; a < s; a++) {
                        const l = Object(Pn.a)(e[a]);
                        let c = !1;
                        n.add(l.subscribe({
                            next: e => {
                                c || (c = !0, o++), r[a] = e
                            },
                            error: e => n.error(e),
                            complete: () => {
                                i++, i !== s && c || (o === s && n.next(t ? t.reduce((e, t, n) => (e[t] = r[n], e), {}) : r), n.complete())
                            }
                        }))
                    }
                })
            }
            /**
             * @license Angular v11.0.7
             * (c) 2010-2020 Google LLC. https://angular.io/
             * License: MIT
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const On = new s.B("NgValueAccessor"),
                In = {
                    provide: On,
                    useExisting: Object(s.lb)(() => Nn),
                    multi: !0
                };
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class Nn {
                constructor(e, t) {
                    this._renderer = e, this._elementRef = t, this.onChange = e => {}, this.onTouched = () => {}
                }
                writeValue(e) {
                    this._renderer.setProperty(this._elementRef.nativeElement, "checked", e)
                }
                registerOnChange(e) {
                    this.onChange = e
                }
                registerOnTouched(e) {
                    this.onTouched = e
                }
                setDisabledState(e) {
                    this._renderer.setProperty(this._elementRef.nativeElement, "disabled", e)
                }
            }
            Nn.decorators = [{
                type: s.s,
                args: [{
                    selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]",
                    host: {
                        "(change)": "onChange($event.target.checked)",
                        "(blur)": "onTouched()"
                    },
                    providers: [In]
                }]
            }], Nn.ctorParameters = () => [{
                type: s.U
            }, {
                type: s.t
            }]
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            const Mn = {
                provide: On,
                useExisting: Object(s.lb)(() => Rn),
                multi: !0
            };
            const Fn = new s.B("CompositionEventMode");
            class Rn {
                constructor(e, t, n) {
                    this._renderer = e, this._elementRef = t, this._compositionMode = n, this.onChange = e => {}, this.onTouched = () => {}, this._composing = !1, null == this._compositionMode && (this._compositionMode = ! function() {
                        const e = o() ? o().getUserAgent() : "";
                        return /android (\d+)/.test(e.toLowerCase())
                    }())
                }
                writeValue(e) {
                    const t = null == e ? "" : e;
                    this._renderer.setProperty(this._elementRef.nativeElement, "value", t)
                }
                registerOnChange(e) {
                    this.onChange = e
                }
                registerOnTouched(e) {
                    this.onTouched = e
                }
                setDisabledState(e) {
                    this._renderer.setProperty(this._elementRef.nativeElement, "disabled", e)
                }
                _handleInput(e) {
                    (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(e)
                }
                _compositionStart() {
                    this._composing = !0
                }
                _compositionEnd(e) {
                    this._composing = !1, this._compositionMode && this.onChange(e)
                }
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            function jn(e) {
                return null == e || 0 === e.length
            }

            function Ln(e) {
                return null != e && "number" == typeof e.length
            }
            Rn.decorators = [{
                type: s.s,
                args: [{
                    selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]",
                    host: {
                        "(input)": "$any(this)._handleInput($event.target.value)",
                        "(blur)": "onTouched()",
                        "(compositionstart)": "$any(this)._compositionStart()",
                        "(compositionend)": "$any(this)._compositionEnd($event.target.value)"
                    },
                    providers: [Mn]
                }]
            }], Rn.ctorParameters = () => [{
                type: s.U
            }, {
                type: s.t
            }, {
                type: Boolean,
                decorators: [{
                    type: s.N
                }, {
                    type: s.z,
                    args: [Fn]
                }]
            }];
            const Vn = new s.B("NgValidators"),
                $n = new s.B("NgAsyncValidators"),
                Bn = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
            class Hn {
                static min(e) {
                    return t => {
                        if (jn(t.value) || jn(e)) return null;
                        const n = parseFloat(t.value);
                        return !isNaN(n) && n < e ? {
                            min: {
                                min: e,
                                actual: t.value
                            }
                        } : null
                    }
                }
                static max(e) {
                    return t => {
                        if (jn(t.value) || jn(e)) return null;
                        const n = parseFloat(t.value);
                        return !isNaN(n) && n > e ? {
                            max: {
                                max: e,
                                actual: t.value
                            }
                        } : null
                    }
                }
                static required(e) {
                    return jn(e.value) ? {
                        required: !0
                    } : null
                }
                static requiredTrue(e) {
                    return !0 === e.value ? null : {
                        required: !0
                    }
                }
                static email(e) {
                    return jn(e.value) || Bn.test(e.value) ? null : {
                        email: !0
                    }
                }
                static minLength(e) {
                    return t => jn(t.value) || !Ln(t.value) ? null : t.value.length < e ? {
                        minlength: {
                            requiredLength: e,
                            actualLength: t.value.length
                        }
                    } : null
                }
                static maxLength(e) {
                    return t => Ln(t.value) && t.value.length > e ? {
                        maxlength: {
                            requiredLength: e,
                            actualLength: t.value.length
                        }
                    } : null
                }
                static pattern(e) {
                    if (!e) return Hn.nullValidator;
                    let t, n;
                    return "string" == typeof e ? (n = "", "^" !== e.charAt(0) && (n += "^"), n += e, "$" !== e.charAt(e.length - 1) && (n += "$"), t = new RegExp(n)) : (n = e.toString(), t = e), e => {
                        if (jn(e.value)) return null;
                        const s = e.value;
                        return t.test(s) ? null : {
                            pattern: {
                                requiredPattern: n,
                                actualValue: s
                            }
                        }
                    }
                }
                static nullValidator(e) {
                    return null
                }
                static compose(e) {
                    if (!e) return null;
                    const t = e.filter(Un);
                    return 0 == t.length ? null : function(e) {
                        return zn(Wn(e, t))
                    }
                }
                static composeAsync(e) {
                    if (!e) return null;
                    const t = e.filter(Un);
                    return 0 == t.length ? null : function(e) {
                        return function(...e) {
                            if (1 === e.length) {
                                const t = e[0];
                                if (Object(Tn.a)(t)) return kn(t, null);
                                if (Object(Dn.a)(t) && Object.getPrototypeOf(t) === Object.prototype) {
                                    const e = Object.keys(t);
                                    return kn(e.map(e => t[e]), e)
                                }
                            }
                            if ("function" == typeof e[e.length - 1]) {
                                const t = e.pop();
                                return kn(e = 1 === e.length && Object(Tn.a)(e[0]) ? e[0] : e, null).pipe(Object(An.a)(e => t(...e)))
                            }
                            return kn(e, null)
                        }(Wn(e, t).map(qn)).pipe(Object(An.a)(zn))
                    }
                }
            }

            function Un(e) {
                return null != e
            }

            function qn(e) {
                const t = Object(s.Ub)(e) ? Object(Pn.a)(e) : e;
                return Object(s.Tb)(t), t
            }

            function zn(e) {
                let t = {};
                return e.forEach(e => {
                    t = null != e ? Object.assign(Object.assign({}, t), e) : t
                }), 0 === Object.keys(t).length ? null : t
            }

            function Wn(e, t) {
                return t.map(t => t(e))
            }

            function Gn(e) {
                return e.map(e => function(e) {
                    return !e.validate
                }(e) ? e : t => e.validate(t))
            }

            function Kn(e) {
                return null != e ? Hn.compose(Gn(e)) : null
            }

            function Qn(e) {
                return null != e ? Hn.composeAsync(Gn(e)) : null
            }

            function Zn(e, t) {
                return null === e ? [t] : Array.isArray(e) ? [...e, t] : [e, t]
            }

            function Jn(e) {
                return e._rawValidators
            }

            function Xn(e) {
                return e._rawAsyncValidators
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class Yn {
                constructor() {
                    this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = []
                }
                get value() {
                    return this.control ? this.control.value : null
                }
                get valid() {
                    return this.control ? this.control.valid : null
                }
                get invalid() {
                    return this.control ? this.control.invalid : null
                }
                get pending() {
                    return this.control ? this.control.pending : null
                }
                get disabled() {
                    return this.control ? this.control.disabled : null
                }
                get enabled() {
                    return this.control ? this.control.enabled : null
                }
                get errors() {
                    return this.control ? this.control.errors : null
                }
                get pristine() {
                    return this.control ? this.control.pristine : null
                }
                get dirty() {
                    return this.control ? this.control.dirty : null
                }
                get touched() {
                    return this.control ? this.control.touched : null
                }
                get status() {
                    return this.control ? this.control.status : null
                }
                get untouched() {
                    return this.control ? this.control.untouched : null
                }
                get statusChanges() {
                    return this.control ? this.control.statusChanges : null
                }
                get valueChanges() {
                    return this.control ? this.control.valueChanges : null
                }
                get path() {
                    return null
                }
                _setValidators(e) {
                    this._rawValidators = e || [], this._composedValidatorFn = Kn(this._rawValidators)
                }
                _setAsyncValidators(e) {
                    this._rawAsyncValidators = e || [], this._composedAsyncValidatorFn = Qn(this._rawAsyncValidators)
                }
                get validator() {
                    return this._composedValidatorFn || null
                }
                get asyncValidator() {
                    return this._composedAsyncValidatorFn || null
                }
                _registerOnDestroy(e) {
                    this._onDestroyCallbacks.push(e)
                }
                _invokeOnDestroyCallbacks() {
                    this._onDestroyCallbacks.forEach(e => e()), this._onDestroyCallbacks = []
                }
                reset(e) {
                    this.control && this.control.reset(e)
                }
                hasError(e, t) {
                    return !!this.control && this.control.hasError(e, t)
                }
                getError(e, t) {
                    return this.control ? this.control.getError(e, t) : null
                }
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class es extends Yn {
                get formDirective() {
                    return null
                }
                get path() {
                    return null
                }
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class ts extends Yn {
                constructor() {
                    super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null
                }
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class ns {
                constructor(e) {
                    this._cd = e
                }
                get ngClassUntouched() {
                    return !!this._cd.control && this._cd.control.untouched
                }
                get ngClassTouched() {
                    return !!this._cd.control && this._cd.control.touched
                }
                get ngClassPristine() {
                    return !!this._cd.control && this._cd.control.pristine
                }
                get ngClassDirty() {
                    return !!this._cd.control && this._cd.control.dirty
                }
                get ngClassValid() {
                    return !!this._cd.control && this._cd.control.valid
                }
                get ngClassInvalid() {
                    return !!this._cd.control && this._cd.control.invalid
                }
                get ngClassPending() {
                    return !!this._cd.control && this._cd.control.pending
                }
            }
            const ss = {
                "[class.ng-untouched]": "ngClassUntouched",
                "[class.ng-touched]": "ngClassTouched",
                "[class.ng-pristine]": "ngClassPristine",
                "[class.ng-dirty]": "ngClassDirty",
                "[class.ng-valid]": "ngClassValid",
                "[class.ng-invalid]": "ngClassInvalid",
                "[class.ng-pending]": "ngClassPending"
            };
            class rs extends ns {
                constructor(e) {
                    super(e)
                }
            }
            rs.decorators = [{
                type: s.s,
                args: [{
                    selector: "[formControlName],[ngModel],[formControl]",
                    host: ss
                }]
            }], rs.ctorParameters = () => [{
                type: ts,
                decorators: [{
                    type: s.Z
                }]
            }];
            class is extends ns {
                constructor(e) {
                    super(e)
                }
            }
            is.decorators = [{
                type: s.s,
                args: [{
                    selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]",
                    host: ss
                }]
            }], is.ctorParameters = () => [{
                type: es,
                decorators: [{
                    type: s.Z
                }]
            }]
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            const os = {
                provide: On,
                useExisting: Object(s.lb)(() => as),
                multi: !0
            };
            class as {
                constructor(e, t) {
                    this._renderer = e, this._elementRef = t, this.onChange = e => {}, this.onTouched = () => {}
                }
                writeValue(e) {
                    const t = null == e ? "" : e;
                    this._renderer.setProperty(this._elementRef.nativeElement, "value", t)
                }
                registerOnChange(e) {
                    this.onChange = t => {
                        e("" == t ? null : parseFloat(t))
                    }
                }
                registerOnTouched(e) {
                    this.onTouched = e
                }
                setDisabledState(e) {
                    this._renderer.setProperty(this._elementRef.nativeElement, "disabled", e)
                }
            }
            as.decorators = [{
                type: s.s,
                args: [{
                    selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]",
                    host: {
                        "(input)": "onChange($event.target.value)",
                        "(blur)": "onTouched()"
                    },
                    providers: [os]
                }]
            }], as.ctorParameters = () => [{
                type: s.U
            }, {
                type: s.t
            }]
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            const ls = {
                provide: On,
                useExisting: Object(s.lb)(() => us),
                multi: !0
            };
            class cs {
                constructor() {
                    this._accessors = []
                }
                add(e, t) {
                    this._accessors.push([e, t])
                }
                remove(e) {
                    for (let t = this._accessors.length - 1; t >= 0; --t)
                        if (this._accessors[t][1] === e) return void this._accessors.splice(t, 1)
                }
                select(e) {
                    this._accessors.forEach(t => {
                        this._isSameGroup(t, e) && t[1] !== e && t[1].fireUncheck(e.value)
                    })
                }
                _isSameGroup(e, t) {
                    return !!e[0].control && (e[0]._parent === t._control._parent && e[1].name === t.name)
                }
            }
            cs.decorators = [{
                type: s.A
            }];
            class us {
                constructor(e, t, n, s) {
                    this._renderer = e, this._elementRef = t, this._registry = n, this._injector = s, this.onChange = () => {}, this.onTouched = () => {}
                }
                ngOnInit() {
                    this._control = this._injector.get(ts), this._checkName(), this._registry.add(this._control, this)
                }
                ngOnDestroy() {
                    this._registry.remove(this)
                }
                writeValue(e) {
                    this._state = e === this.value, this._renderer.setProperty(this._elementRef.nativeElement, "checked", this._state)
                }
                registerOnChange(e) {
                    this._fn = e, this.onChange = () => {
                        e(this.value), this._registry.select(this)
                    }
                }
                fireUncheck(e) {
                    this.writeValue(e)
                }
                registerOnTouched(e) {
                    this.onTouched = e
                }
                setDisabledState(e) {
                    this._renderer.setProperty(this._elementRef.nativeElement, "disabled", e)
                }
                _checkName() {
                    this.name && this.formControlName && (this.name, this.formControlName), !this.name && this.formControlName && (this.name = this.formControlName)
                }
            }
            us.decorators = [{
                type: s.s,
                args: [{
                    selector: "input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]",
                    host: {
                        "(change)": "onChange()",
                        "(blur)": "onTouched()"
                    },
                    providers: [ls]
                }]
            }], us.ctorParameters = () => [{
                type: s.U
            }, {
                type: s.t
            }, {
                type: cs
            }, {
                type: s.C
            }], us.propDecorators = {
                name: [{
                    type: s.D
                }],
                formControlName: [{
                    type: s.D
                }],
                value: [{
                    type: s.D
                }]
            };
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const hs = {
                provide: On,
                useExisting: Object(s.lb)(() => ps),
                multi: !0
            };
            class ps {
                constructor(e, t) {
                    this._renderer = e, this._elementRef = t, this.onChange = e => {}, this.onTouched = () => {}
                }
                writeValue(e) {
                    this._renderer.setProperty(this._elementRef.nativeElement, "value", parseFloat(e))
                }
                registerOnChange(e) {
                    this.onChange = t => {
                        e("" == t ? null : parseFloat(t))
                    }
                }
                registerOnTouched(e) {
                    this.onTouched = e
                }
                setDisabledState(e) {
                    this._renderer.setProperty(this._elementRef.nativeElement, "disabled", e)
                }
            }
            ps.decorators = [{
                type: s.s,
                args: [{
                    selector: "input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]",
                    host: {
                        "(change)": "onChange($event.target.value)",
                        "(input)": "onChange($event.target.value)",
                        "(blur)": "onTouched()"
                    },
                    providers: [hs]
                }]
            }], ps.ctorParameters = () => [{
                type: s.U
            }, {
                type: s.t
            }]
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const ds = {
                provide: On,
                useExisting: Object(s.lb)(() => ms),
                multi: !0
            };

            function fs(e, t) {
                return null == e ? `${t}` : (t && "object" == typeof t && (t = "Object"), `${e}: ${t}`.slice(0, 50))
            }
            class ms {
                constructor(e, t) {
                    this._renderer = e, this._elementRef = t, this._optionMap = new Map, this._idCounter = 0, this.onChange = e => {}, this.onTouched = () => {}, this._compareWith = Object.is
                }
                set compareWith(e) {
                    this._compareWith = e
                }
                writeValue(e) {
                    this.value = e;
                    const t = this._getOptionId(e);
                    null == t && this._renderer.setProperty(this._elementRef.nativeElement, "selectedIndex", -1);
                    const n = fs(t, e);
                    this._renderer.setProperty(this._elementRef.nativeElement, "value", n)
                }
                registerOnChange(e) {
                    this.onChange = t => {
                        this.value = this._getOptionValue(t), e(this.value)
                    }
                }
                registerOnTouched(e) {
                    this.onTouched = e
                }
                setDisabledState(e) {
                    this._renderer.setProperty(this._elementRef.nativeElement, "disabled", e)
                }
                _registerOption() {
                    return (this._idCounter++).toString()
                }
                _getOptionId(e) {
                    for (const t of Array.from(this._optionMap.keys()))
                        if (this._compareWith(this._optionMap.get(t), e)) return t;
                    return null
                }
                _getOptionValue(e) {
                    const t = function(e) {
                        return e.split(":")[0]
                    }(e);
                    return this._optionMap.has(t) ? this._optionMap.get(t) : e
                }
            }
            ms.decorators = [{
                type: s.s,
                args: [{
                    selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]",
                    host: {
                        "(change)": "onChange($event.target.value)",
                        "(blur)": "onTouched()"
                    },
                    providers: [ds]
                }]
            }], ms.ctorParameters = () => [{
                type: s.U
            }, {
                type: s.t
            }], ms.propDecorators = {
                compareWith: [{
                    type: s.D
                }]
            };
            class gs {
                constructor(e, t, n) {
                    this._element = e, this._renderer = t, this._select = n, this._select && (this.id = this._select._registerOption())
                }
                set ngValue(e) {
                    null != this._select && (this._select._optionMap.set(this.id, e), this._setElementValue(fs(this.id, e)), this._select.writeValue(this._select.value))
                }
                set value(e) {
                    this._setElementValue(e), this._select && this._select.writeValue(this._select.value)
                }
                _setElementValue(e) {
                    this._renderer.setProperty(this._element.nativeElement, "value", e)
                }
                ngOnDestroy() {
                    this._select && (this._select._optionMap.delete(this.id), this._select.writeValue(this._select.value))
                }
            }
            gs.decorators = [{
                type: s.s,
                args: [{
                    selector: "option"
                }]
            }], gs.ctorParameters = () => [{
                type: s.t
            }, {
                type: s.U
            }, {
                type: ms,
                decorators: [{
                    type: s.N
                }, {
                    type: s.w
                }]
            }], gs.propDecorators = {
                ngValue: [{
                    type: s.D,
                    args: ["ngValue"]
                }],
                value: [{
                    type: s.D,
                    args: ["value"]
                }]
            };
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const ys = {
                provide: On,
                useExisting: Object(s.lb)(() => _s),
                multi: !0
            };

            function vs(e, t) {
                return null == e ? `${t}` : ("string" == typeof t && (t = `'${t}'`), t && "object" == typeof t && (t = "Object"), `${e}: ${t}`.slice(0, 50))
            }
            class _s {
                constructor(e, t) {
                    this._renderer = e, this._elementRef = t, this._optionMap = new Map, this._idCounter = 0, this.onChange = e => {}, this.onTouched = () => {}, this._compareWith = Object.is
                }
                set compareWith(e) {
                    this._compareWith = e
                }
                writeValue(e) {
                    let t;
                    if (this.value = e, Array.isArray(e)) {
                        const n = e.map(e => this._getOptionId(e));
                        t = (e, t) => {
                            e._setSelected(n.indexOf(t.toString()) > -1)
                        }
                    } else t = (e, t) => {
                        e._setSelected(!1)
                    };
                    this._optionMap.forEach(t)
                }
                registerOnChange(e) {
                    this.onChange = t => {
                        const n = [];
                        if (void 0 !== t.selectedOptions) {
                            const e = t.selectedOptions;
                            for (let t = 0; t < e.length; t++) {
                                const s = e.item(t),
                                    r = this._getOptionValue(s.value);
                                n.push(r)
                            }
                        } else {
                            const e = t.options;
                            for (let t = 0; t < e.length; t++) {
                                const s = e.item(t);
                                if (s.selected) {
                                    const e = this._getOptionValue(s.value);
                                    n.push(e)
                                }
                            }
                        }
                        this.value = n, e(n)
                    }
                }
                registerOnTouched(e) {
                    this.onTouched = e
                }
                setDisabledState(e) {
                    this._renderer.setProperty(this._elementRef.nativeElement, "disabled", e)
                }
                _registerOption(e) {
                    const t = (this._idCounter++).toString();
                    return this._optionMap.set(t, e), t
                }
                _getOptionId(e) {
                    for (const t of Array.from(this._optionMap.keys()))
                        if (this._compareWith(this._optionMap.get(t)._value, e)) return t;
                    return null
                }
                _getOptionValue(e) {
                    const t = function(e) {
                        return e.split(":")[0]
                    }(e);
                    return this._optionMap.has(t) ? this._optionMap.get(t)._value : e
                }
            }
            _s.decorators = [{
                type: s.s,
                args: [{
                    selector: "select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]",
                    host: {
                        "(change)": "onChange($event.target)",
                        "(blur)": "onTouched()"
                    },
                    providers: [ys]
                }]
            }], _s.ctorParameters = () => [{
                type: s.U
            }, {
                type: s.t
            }], _s.propDecorators = {
                compareWith: [{
                    type: s.D
                }]
            };
            class bs {
                constructor(e, t, n) {
                    this._element = e, this._renderer = t, this._select = n, this._select && (this.id = this._select._registerOption(this))
                }
                set ngValue(e) {
                    null != this._select && (this._value = e, this._setElementValue(vs(this.id, e)), this._select.writeValue(this._select.value))
                }
                set value(e) {
                    this._select ? (this._value = e, this._setElementValue(vs(this.id, e)), this._select.writeValue(this._select.value)) : this._setElementValue(e)
                }
                _setElementValue(e) {
                    this._renderer.setProperty(this._element.nativeElement, "value", e)
                }
                _setSelected(e) {
                    this._renderer.setProperty(this._element.nativeElement, "selected", e)
                }
                ngOnDestroy() {
                    this._select && (this._select._optionMap.delete(this.id), this._select.writeValue(this._select.value))
                }
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            function ws(e, t) {
                return [...t.path, e]
            }

            function Es(e, t) {
                xs(e, t, !0), t.valueAccessor.writeValue(e.value),
                    function(e, t) {
                        t.valueAccessor.registerOnChange(n => {
                            e._pendingValue = n, e._pendingChange = !0, e._pendingDirty = !0, "change" === e.updateOn && As(e, t)
                        })
                    }(e, t),
                    function(e, t) {
                        const n = (e, n) => {
                            t.valueAccessor.writeValue(e), n && t.viewToModelUpdate(e)
                        };
                        e.registerOnChange(n), t._registerOnDestroy(() => {
                            e._unregisterOnChange(n)
                        })
                    }(e, t),
                    function(e, t) {
                        t.valueAccessor.registerOnTouched(() => {
                            e._pendingTouched = !0, "blur" === e.updateOn && e._pendingChange && As(e, t), "submit" !== e.updateOn && e.markAsTouched()
                        })
                    }(e, t),
                    function(e, t) {
                        if (t.valueAccessor.setDisabledState) {
                            const n = e => {
                                t.valueAccessor.setDisabledState(e)
                            };
                            e.registerOnDisabledChange(n), t._registerOnDestroy(() => {
                                e._unregisterOnDisabledChange(n)
                            })
                        }
                    }(e, t)
            }

            function Cs(e, t) {
                const n = () => {
                    0
                };
                t.valueAccessor.registerOnChange(n), t.valueAccessor.registerOnTouched(n), Ts(e, t, !0), e && (t._invokeOnDestroyCallbacks(), e._registerOnCollectionChange(() => {}))
            }

            function Ss(e, t) {
                e.forEach(e => {
                    e.registerOnValidatorChange && e.registerOnValidatorChange(t)
                })
            }

            function xs(e, t, n) {
                const s = Jn(e);
                null !== t.validator ? e.setValidators(Zn(s, t.validator)) : "function" == typeof s && e.setValidators([s]);
                const r = Xn(e);
                if (null !== t.asyncValidator ? e.setAsyncValidators(Zn(r, t.asyncValidator)) : "function" == typeof r && e.setAsyncValidators([r]), n) {
                    const n = () => e.updateValueAndValidity();
                    Ss(t._rawValidators, n), Ss(t._rawAsyncValidators, n)
                }
            }

            function Ts(e, t, n) {
                if (null !== e) {
                    if (null !== t.validator) {
                        const n = Jn(e);
                        Array.isArray(n) && n.length > 0 && e.setValidators(n.filter(e => e !== t.validator))
                    }
                    if (null !== t.asyncValidator) {
                        const n = Xn(e);
                        Array.isArray(n) && n.length > 0 && e.setAsyncValidators(n.filter(e => e !== t.asyncValidator))
                    }
                }
                if (n) {
                    const e = () => {};
                    Ss(t._rawValidators, e), Ss(t._rawAsyncValidators, e)
                }
            }

            function As(e, t) {
                e._pendingDirty && e.markAsDirty(), e.setValue(e._pendingValue, {
                    emitModelToViewChange: !1
                }), t.viewToModelUpdate(e._pendingValue), e._pendingChange = !1
            }

            function Ds(e, t) {
                xs(e, t, !1)
            }

            function Ps(e, t) {
                if (!e.hasOwnProperty("model")) return !1;
                const n = e.model;
                return !!n.isFirstChange() || !Object.is(t, n.currentValue)
            }
            bs.decorators = [{
                type: s.s,
                args: [{
                    selector: "option"
                }]
            }], bs.ctorParameters = () => [{
                type: s.t
            }, {
                type: s.U
            }, {
                type: _s,
                decorators: [{
                    type: s.N
                }, {
                    type: s.w
                }]
            }], bs.propDecorators = {
                ngValue: [{
                    type: s.D,
                    args: ["ngValue"]
                }],
                value: [{
                    type: s.D,
                    args: ["value"]
                }]
            };
            const ks = [Nn, ps, as, ms, _s, us];

            function Os(e, t) {
                e._syncPendingControls(), t.forEach(e => {
                    const t = e.control;
                    "submit" === t.updateOn && t._pendingChange && (e.viewToModelUpdate(t._pendingValue), t._pendingChange = !1)
                })
            }

            function Is(e, t) {
                if (!t) return null;
                let n, s, r;
                return Array.isArray(t), t.forEach(e => {
                    var t;
                    e.constructor === Rn ? n = e : (t = e, ks.some(e => t.constructor === e) ? s = e : r = e)
                }), r || (s || (n || null))
            }

            function Ns(e, t) {
                const n = e.indexOf(t);
                n > -1 && e.splice(n, 1)
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const Ms = "VALID",
                Fs = "INVALID",
                Rs = "PENDING",
                js = "DISABLED";

            function Ls(e) {
                return (Hs(e) ? e.validators : e) || null
            }

            function Vs(e) {
                return Array.isArray(e) ? Kn(e) : e || null
            }

            function $s(e, t) {
                return (Hs(t) ? t.asyncValidators : e) || null
            }

            function Bs(e) {
                return Array.isArray(e) ? Qn(e) : e || null
            }

            function Hs(e) {
                return null != e && !Array.isArray(e) && "object" == typeof e
            }
            class Us {
                constructor(e, t) {
                    this._hasOwnPendingAsyncValidator = !1, this._onCollectionChange = () => {}, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._rawValidators = e, this._rawAsyncValidators = t, this._composedValidatorFn = Vs(this._rawValidators), this._composedAsyncValidatorFn = Bs(this._rawAsyncValidators)
                }
                get validator() {
                    return this._composedValidatorFn
                }
                set validator(e) {
                    this._rawValidators = this._composedValidatorFn = e
                }
                get asyncValidator() {
                    return this._composedAsyncValidatorFn
                }
                set asyncValidator(e) {
                    this._rawAsyncValidators = this._composedAsyncValidatorFn = e
                }
                get parent() {
                    return this._parent
                }
                get valid() {
                    return this.status === Ms
                }
                get invalid() {
                    return this.status === Fs
                }
                get pending() {
                    return this.status == Rs
                }
                get disabled() {
                    return this.status === js
                }
                get enabled() {
                    return this.status !== js
                }
                get dirty() {
                    return !this.pristine
                }
                get untouched() {
                    return !this.touched
                }
                get updateOn() {
                    return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change"
                }
                setValidators(e) {
                    this._rawValidators = e, this._composedValidatorFn = Vs(e)
                }
                setAsyncValidators(e) {
                    this._rawAsyncValidators = e, this._composedAsyncValidatorFn = Bs(e)
                }
                clearValidators() {
                    this.validator = null
                }
                clearAsyncValidators() {
                    this.asyncValidator = null
                }
                markAsTouched(e = {}) {
                    this.touched = !0, this._parent && !e.onlySelf && this._parent.markAsTouched(e)
                }
                markAllAsTouched() {
                    this.markAsTouched({
                        onlySelf: !0
                    }), this._forEachChild(e => e.markAllAsTouched())
                }
                markAsUntouched(e = {}) {
                    this.touched = !1, this._pendingTouched = !1, this._forEachChild(e => {
                        e.markAsUntouched({
                            onlySelf: !0
                        })
                    }), this._parent && !e.onlySelf && this._parent._updateTouched(e)
                }
                markAsDirty(e = {}) {
                    this.pristine = !1, this._parent && !e.onlySelf && this._parent.markAsDirty(e)
                }
                markAsPristine(e = {}) {
                    this.pristine = !0, this._pendingDirty = !1, this._forEachChild(e => {
                        e.markAsPristine({
                            onlySelf: !0
                        })
                    }), this._parent && !e.onlySelf && this._parent._updatePristine(e)
                }
                markAsPending(e = {}) {
                    this.status = Rs, !1 !== e.emitEvent && this.statusChanges.emit(this.status), this._parent && !e.onlySelf && this._parent.markAsPending(e)
                }
                disable(e = {}) {
                    const t = this._parentMarkedDirty(e.onlySelf);
                    this.status = js, this.errors = null, this._forEachChild(t => {
                        t.disable(Object.assign(Object.assign({}, e), {
                            onlySelf: !0
                        }))
                    }), this._updateValue(), !1 !== e.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors(Object.assign(Object.assign({}, e), {
                        skipPristineCheck: t
                    })), this._onDisabledChange.forEach(e => e(!0))
                }
                enable(e = {}) {
                    const t = this._parentMarkedDirty(e.onlySelf);
                    this.status = Ms, this._forEachChild(t => {
                        t.enable(Object.assign(Object.assign({}, e), {
                            onlySelf: !0
                        }))
                    }), this.updateValueAndValidity({
                        onlySelf: !0,
                        emitEvent: e.emitEvent
                    }), this._updateAncestors(Object.assign(Object.assign({}, e), {
                        skipPristineCheck: t
                    })), this._onDisabledChange.forEach(e => e(!1))
                }
                _updateAncestors(e) {
                    this._parent && !e.onlySelf && (this._parent.updateValueAndValidity(e), e.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched())
                }
                setParent(e) {
                    this._parent = e
                }
                updateValueAndValidity(e = {}) {
                    this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), this.status !== Ms && this.status !== Rs || this._runAsyncValidator(e.emitEvent)), !1 !== e.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !e.onlySelf && this._parent.updateValueAndValidity(e)
                }
                _updateTreeValidity(e = {
                    emitEvent: !0
                }) {
                    this._forEachChild(t => t._updateTreeValidity(e)), this.updateValueAndValidity({
                        onlySelf: !0,
                        emitEvent: e.emitEvent
                    })
                }
                _setInitialStatus() {
                    this.status = this._allControlsDisabled() ? js : Ms
                }
                _runValidator() {
                    return this.validator ? this.validator(this) : null
                }
                _runAsyncValidator(e) {
                    if (this.asyncValidator) {
                        this.status = Rs, this._hasOwnPendingAsyncValidator = !0;
                        const t = qn(this.asyncValidator(this));
                        this._asyncValidationSubscription = t.subscribe(t => {
                            this._hasOwnPendingAsyncValidator = !1, this.setErrors(t, {
                                emitEvent: e
                            })
                        })
                    }
                }
                _cancelExistingSubscription() {
                    this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1)
                }
                setErrors(e, t = {}) {
                    this.errors = e, this._updateControlsErrors(!1 !== t.emitEvent)
                }
                get(e) {
                    return function(e, t, n) {
                        if (null == t) return null;
                        if (Array.isArray(t) || (t = t.split(n)), Array.isArray(t) && 0 === t.length) return null;
                        let s = e;
                        return t.forEach(e => {
                            s = s instanceof zs ? s.controls.hasOwnProperty(e) ? s.controls[e] : null : s instanceof Ws && s.at(e) || null
                        }), s
                    }(this, e, ".")
                }
                getError(e, t) {
                    const n = t ? this.get(t) : this;
                    return n && n.errors ? n.errors[e] : null
                }
                hasError(e, t) {
                    return !!this.getError(e, t)
                }
                get root() {
                    let e = this;
                    for (; e._parent;) e = e._parent;
                    return e
                }
                _updateControlsErrors(e) {
                    this.status = this._calculateStatus(), e && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(e)
                }
                _initObservables() {
                    this.valueChanges = new s.v, this.statusChanges = new s.v
                }
                _calculateStatus() {
                    return this._allControlsDisabled() ? js : this.errors ? Fs : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(Rs) ? Rs : this._anyControlsHaveStatus(Fs) ? Fs : Ms
                }
                _anyControlsHaveStatus(e) {
                    return this._anyControls(t => t.status === e)
                }
                _anyControlsDirty() {
                    return this._anyControls(e => e.dirty)
                }
                _anyControlsTouched() {
                    return this._anyControls(e => e.touched)
                }
                _updatePristine(e = {}) {
                    this.pristine = !this._anyControlsDirty(), this._parent && !e.onlySelf && this._parent._updatePristine(e)
                }
                _updateTouched(e = {}) {
                    this.touched = this._anyControlsTouched(), this._parent && !e.onlySelf && this._parent._updateTouched(e)
                }
                _isBoxedValue(e) {
                    return "object" == typeof e && null !== e && 2 === Object.keys(e).length && "value" in e && "disabled" in e
                }
                _registerOnCollectionChange(e) {
                    this._onCollectionChange = e
                }
                _setUpdateStrategy(e) {
                    Hs(e) && null != e.updateOn && (this._updateOn = e.updateOn)
                }
                _parentMarkedDirty(e) {
                    const t = this._parent && this._parent.dirty;
                    return !e && !!t && !this._parent._anyControlsDirty()
                }
            }
            class qs extends Us {
                constructor(e = null, t, n) {
                    super(Ls(t), $s(n, t)), this._onChange = [], this._applyFormState(e), this._setUpdateStrategy(t), this._initObservables(), this.updateValueAndValidity({
                        onlySelf: !0,
                        emitEvent: !!n
                    })
                }
                setValue(e, t = {}) {
                    this.value = this._pendingValue = e, this._onChange.length && !1 !== t.emitModelToViewChange && this._onChange.forEach(e => e(this.value, !1 !== t.emitViewToModelChange)), this.updateValueAndValidity(t)
                }
                patchValue(e, t = {}) {
                    this.setValue(e, t)
                }
                reset(e = null, t = {}) {
                    this._applyFormState(e), this.markAsPristine(t), this.markAsUntouched(t), this.setValue(this.value, t), this._pendingChange = !1
                }
                _updateValue() {}
                _anyControls(e) {
                    return !1
                }
                _allControlsDisabled() {
                    return this.disabled
                }
                registerOnChange(e) {
                    this._onChange.push(e)
                }
                _unregisterOnChange(e) {
                    Ns(this._onChange, e)
                }
                registerOnDisabledChange(e) {
                    this._onDisabledChange.push(e)
                }
                _unregisterOnDisabledChange(e) {
                    Ns(this._onDisabledChange, e)
                }
                _forEachChild(e) {}
                _syncPendingControls() {
                    return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange)) && (this.setValue(this._pendingValue, {
                        onlySelf: !0,
                        emitModelToViewChange: !1
                    }), !0)
                }
                _applyFormState(e) {
                    this._isBoxedValue(e) ? (this.value = this._pendingValue = e.value, e.disabled ? this.disable({
                        onlySelf: !0,
                        emitEvent: !1
                    }) : this.enable({
                        onlySelf: !0,
                        emitEvent: !1
                    })) : this.value = this._pendingValue = e
                }
            }
            class zs extends Us {
                constructor(e, t, n) {
                    super(Ls(t), $s(n, t)), this.controls = e, this._initObservables(), this._setUpdateStrategy(t), this._setUpControls(), this.updateValueAndValidity({
                        onlySelf: !0,
                        emitEvent: !!n
                    })
                }
                registerControl(e, t) {
                    return this.controls[e] ? this.controls[e] : (this.controls[e] = t, t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange), t)
                }
                addControl(e, t) {
                    this.registerControl(e, t), this.updateValueAndValidity(), this._onCollectionChange()
                }
                removeControl(e) {
                    this.controls[e] && this.controls[e]._registerOnCollectionChange(() => {}), delete this.controls[e], this.updateValueAndValidity(), this._onCollectionChange()
                }
                setControl(e, t) {
                    this.controls[e] && this.controls[e]._registerOnCollectionChange(() => {}), delete this.controls[e], t && this.registerControl(e, t), this.updateValueAndValidity(), this._onCollectionChange()
                }
                contains(e) {
                    return this.controls.hasOwnProperty(e) && this.controls[e].enabled
                }
                setValue(e, t = {}) {
                    this._checkAllValuesPresent(e), Object.keys(e).forEach(n => {
                        this._throwIfControlMissing(n), this.controls[n].setValue(e[n], {
                            onlySelf: !0,
                            emitEvent: t.emitEvent
                        })
                    }), this.updateValueAndValidity(t)
                }
                patchValue(e, t = {}) {
                    Object.keys(e).forEach(n => {
                        this.controls[n] && this.controls[n].patchValue(e[n], {
                            onlySelf: !0,
                            emitEvent: t.emitEvent
                        })
                    }), this.updateValueAndValidity(t)
                }
                reset(e = {}, t = {}) {
                    this._forEachChild((n, s) => {
                        n.reset(e[s], {
                            onlySelf: !0,
                            emitEvent: t.emitEvent
                        })
                    }), this._updatePristine(t), this._updateTouched(t), this.updateValueAndValidity(t)
                }
                getRawValue() {
                    return this._reduceChildren({}, (e, t, n) => (e[n] = t instanceof qs ? t.value : t.getRawValue(), e))
                }
                _syncPendingControls() {
                    let e = this._reduceChildren(!1, (e, t) => !!t._syncPendingControls() || e);
                    return e && this.updateValueAndValidity({
                        onlySelf: !0
                    }), e
                }
                _throwIfControlMissing(e) {
                    if (!Object.keys(this.controls).length) throw new Error("\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");
                    if (!this.controls[e]) throw new Error(`Cannot find form control with name: ${e}.`)
                }
                _forEachChild(e) {
                    Object.keys(this.controls).forEach(t => e(this.controls[t], t))
                }
                _setUpControls() {
                    this._forEachChild(e => {
                        e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange)
                    })
                }
                _updateValue() {
                    this.value = this._reduceValue()
                }
                _anyControls(e) {
                    for (const t of Object.keys(this.controls)) {
                        const n = this.controls[t];
                        if (this.contains(t) && e(n)) return !0
                    }
                    return !1
                }
                _reduceValue() {
                    return this._reduceChildren({}, (e, t, n) => ((t.enabled || this.disabled) && (e[n] = t.value), e))
                }
                _reduceChildren(e, t) {
                    let n = e;
                    return this._forEachChild((e, s) => {
                        n = t(n, e, s)
                    }), n
                }
                _allControlsDisabled() {
                    for (const e of Object.keys(this.controls))
                        if (this.controls[e].enabled) return !1;
                    return Object.keys(this.controls).length > 0 || this.disabled
                }
                _checkAllValuesPresent(e) {
                    this._forEachChild((t, n) => {
                        if (void 0 === e[n]) throw new Error(`Must supply a value for form control with name: '${n}'.`)
                    })
                }
            }
            class Ws extends Us {
                constructor(e, t, n) {
                    super(Ls(t), $s(n, t)), this.controls = e, this._initObservables(), this._setUpdateStrategy(t), this._setUpControls(), this.updateValueAndValidity({
                        onlySelf: !0,
                        emitEvent: !!n
                    })
                }
                at(e) {
                    return this.controls[e]
                }
                push(e) {
                    this.controls.push(e), this._registerControl(e), this.updateValueAndValidity(), this._onCollectionChange()
                }
                insert(e, t) {
                    this.controls.splice(e, 0, t), this._registerControl(t), this.updateValueAndValidity()
                }
                removeAt(e) {
                    this.controls[e] && this.controls[e]._registerOnCollectionChange(() => {}), this.controls.splice(e, 1), this.updateValueAndValidity()
                }
                setControl(e, t) {
                    this.controls[e] && this.controls[e]._registerOnCollectionChange(() => {}), this.controls.splice(e, 1), t && (this.controls.splice(e, 0, t), this._registerControl(t)), this.updateValueAndValidity(), this._onCollectionChange()
                }
                get length() {
                    return this.controls.length
                }
                setValue(e, t = {}) {
                    this._checkAllValuesPresent(e), e.forEach((e, n) => {
                        this._throwIfControlMissing(n), this.at(n).setValue(e, {
                            onlySelf: !0,
                            emitEvent: t.emitEvent
                        })
                    }), this.updateValueAndValidity(t)
                }
                patchValue(e, t = {}) {
                    e.forEach((e, n) => {
                        this.at(n) && this.at(n).patchValue(e, {
                            onlySelf: !0,
                            emitEvent: t.emitEvent
                        })
                    }), this.updateValueAndValidity(t)
                }
                reset(e = [], t = {}) {
                    this._forEachChild((n, s) => {
                        n.reset(e[s], {
                            onlySelf: !0,
                            emitEvent: t.emitEvent
                        })
                    }), this._updatePristine(t), this._updateTouched(t), this.updateValueAndValidity(t)
                }
                getRawValue() {
                    return this.controls.map(e => e instanceof qs ? e.value : e.getRawValue())
                }
                clear() {
                    this.controls.length < 1 || (this._forEachChild(e => e._registerOnCollectionChange(() => {})), this.controls.splice(0), this.updateValueAndValidity())
                }
                _syncPendingControls() {
                    let e = this.controls.reduce((e, t) => !!t._syncPendingControls() || e, !1);
                    return e && this.updateValueAndValidity({
                        onlySelf: !0
                    }), e
                }
                _throwIfControlMissing(e) {
                    if (!this.controls.length) throw new Error("\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      ");
                    if (!this.at(e)) throw new Error(`Cannot find form control at index ${e}`)
                }
                _forEachChild(e) {
                    this.controls.forEach((t, n) => {
                        e(t, n)
                    })
                }
                _updateValue() {
                    this.value = this.controls.filter(e => e.enabled || this.disabled).map(e => e.value)
                }
                _anyControls(e) {
                    return this.controls.some(t => t.enabled && e(t))
                }
                _setUpControls() {
                    this._forEachChild(e => this._registerControl(e))
                }
                _checkAllValuesPresent(e) {
                    this._forEachChild((t, n) => {
                        if (void 0 === e[n]) throw new Error(`Must supply a value for form control at index: ${n}.`)
                    })
                }
                _allControlsDisabled() {
                    for (const e of this.controls)
                        if (e.enabled) return !1;
                    return this.controls.length > 0 || this.disabled
                }
                _registerControl(e) {
                    e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange)
                }
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const Gs = {
                    provide: es,
                    useExisting: Object(s.lb)(() => Qs)
                },
                Ks = Promise.resolve(null);
            class Qs extends es {
                constructor(e, t) {
                    super(), this.submitted = !1, this._directives = [], this.ngSubmit = new s.v, this.form = new zs({}, Kn(e), Qn(t))
                }
                ngAfterViewInit() {
                    this._setUpdateStrategy()
                }
                get formDirective() {
                    return this
                }
                get control() {
                    return this.form
                }
                get path() {
                    return []
                }
                get controls() {
                    return this.form.controls
                }
                addControl(e) {
                    Ks.then(() => {
                        const t = this._findContainer(e.path);
                        e.control = t.registerControl(e.name, e.control), Es(e.control, e), e.control.updateValueAndValidity({
                            emitEvent: !1
                        }), this._directives.push(e)
                    })
                }
                getControl(e) {
                    return this.form.get(e.path)
                }
                removeControl(e) {
                    Ks.then(() => {
                        const t = this._findContainer(e.path);
                        t && t.removeControl(e.name), Ns(this._directives, e)
                    })
                }
                addFormGroup(e) {
                    Ks.then(() => {
                        const t = this._findContainer(e.path),
                            n = new zs({});
                        Ds(n, e), t.registerControl(e.name, n), n.updateValueAndValidity({
                            emitEvent: !1
                        })
                    })
                }
                removeFormGroup(e) {
                    Ks.then(() => {
                        const t = this._findContainer(e.path);
                        t && t.removeControl(e.name)
                    })
                }
                getFormGroup(e) {
                    return this.form.get(e.path)
                }
                updateModel(e, t) {
                    Ks.then(() => {
                        this.form.get(e.path).setValue(t)
                    })
                }
                setValue(e) {
                    this.control.setValue(e)
                }
                onSubmit(e) {
                    return this.submitted = !0, Os(this.form, this._directives), this.ngSubmit.emit(e), !1
                }
                onReset() {
                    this.resetForm()
                }
                resetForm(e) {
                    this.form.reset(e), this.submitted = !1
                }
                _setUpdateStrategy() {
                    this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn)
                }
                _findContainer(e) {
                    return e.pop(), e.length ? this.form.get(e) : this.form
                }
            }
            Qs.decorators = [{
                type: s.s,
                args: [{
                    selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]",
                    providers: [Gs],
                    host: {
                        "(submit)": "onSubmit($event)",
                        "(reset)": "onReset()"
                    },
                    outputs: ["ngSubmit"],
                    exportAs: "ngForm"
                }]
            }], Qs.ctorParameters = () => [{
                type: Array,
                decorators: [{
                    type: s.N
                }, {
                    type: s.Z
                }, {
                    type: s.z,
                    args: [Vn]
                }]
            }, {
                type: Array,
                decorators: [{
                    type: s.N
                }, {
                    type: s.Z
                }, {
                    type: s.z,
                    args: [$n]
                }]
            }], Qs.propDecorators = {
                options: [{
                    type: s.D,
                    args: ["ngFormOptions"]
                }]
            };
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class Zs extends es {
                ngOnInit() {
                    this._checkParentType(), this.formDirective.addFormGroup(this)
                }
                ngOnDestroy() {
                    this.formDirective && this.formDirective.removeFormGroup(this)
                }
                get control() {
                    return this.formDirective.getFormGroup(this)
                }
                get path() {
                    return ws(null == this.name ? this.name : this.name.toString(), this._parent)
                }
                get formDirective() {
                    return this._parent ? this._parent.formDirective : null
                }
                _checkParentType() {}
            }
            Zs.decorators = [{
                type: s.s
            }];
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const Js = {
                provide: es,
                useExisting: Object(s.lb)(() => Xs)
            };
            class Xs extends Zs {
                constructor(e, t, n) {
                    super(), this._parent = e, this._setValidators(t), this._setAsyncValidators(n)
                }
                _checkParentType() {
                    !(this._parent instanceof Xs) && this._parent, 0
                }
            }
            Xs.decorators = [{
                type: s.s,
                args: [{
                    selector: "[ngModelGroup]",
                    providers: [Js],
                    exportAs: "ngModelGroup"
                }]
            }], Xs.ctorParameters = () => [{
                type: es,
                decorators: [{
                    type: s.w
                }, {
                    type: s.ab
                }]
            }, {
                type: Array,
                decorators: [{
                    type: s.N
                }, {
                    type: s.Z
                }, {
                    type: s.z,
                    args: [Vn]
                }]
            }, {
                type: Array,
                decorators: [{
                    type: s.N
                }, {
                    type: s.Z
                }, {
                    type: s.z,
                    args: [$n]
                }]
            }], Xs.propDecorators = {
                name: [{
                    type: s.D,
                    args: ["ngModelGroup"]
                }]
            };
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const Ys = {
                    provide: ts,
                    useExisting: Object(s.lb)(() => tr)
                },
                er = Promise.resolve(null);
            class tr extends ts {
                constructor(e, t, n, r) {
                    super(), this.control = new qs, this._registered = !1, this.update = new s.v, this._parent = e, this._setValidators(t), this._setAsyncValidators(n), this.valueAccessor = Is(0, r)
                }
                ngOnChanges(e) {
                    this._checkForErrors(), this._registered || this._setUpControl(), "isDisabled" in e && this._updateDisabled(e), Ps(e, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model)
                }
                ngOnDestroy() {
                    this.formDirective && this.formDirective.removeControl(this)
                }
                get path() {
                    return this._parent ? ws(this.name, this._parent) : [this.name]
                }
                get formDirective() {
                    return this._parent ? this._parent.formDirective : null
                }
                viewToModelUpdate(e) {
                    this.viewModel = e, this.update.emit(e)
                }
                _setUpControl() {
                    this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0
                }
                _setUpdateStrategy() {
                    this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn)
                }
                _isStandalone() {
                    return !this._parent || !(!this.options || !this.options.standalone)
                }
                _setUpStandalone() {
                    Es(this.control, this), this.control.updateValueAndValidity({
                        emitEvent: !1
                    })
                }
                _checkForErrors() {
                    this._isStandalone() || this._checkParentType(), this._checkName()
                }
                _checkParentType() {
                    0
                }
                _checkName() {
                    this.options && this.options.name && (this.name = this.options.name), !this._isStandalone() && this.name
                }
                _updateValue(e) {
                    er.then(() => {
                        this.control.setValue(e, {
                            emitViewToModelChange: !1
                        })
                    })
                }
                _updateDisabled(e) {
                    const t = e.isDisabled.currentValue,
                        n = "" === t || t && "false" !== t;
                    er.then(() => {
                        n && !this.control.disabled ? this.control.disable() : !n && this.control.disabled && this.control.enable()
                    })
                }
            }
            tr.decorators = [{
                type: s.s,
                args: [{
                    selector: "[ngModel]:not([formControlName]):not([formControl])",
                    providers: [Ys],
                    exportAs: "ngModel"
                }]
            }], tr.ctorParameters = () => [{
                type: es,
                decorators: [{
                    type: s.N
                }, {
                    type: s.w
                }]
            }, {
                type: Array,
                decorators: [{
                    type: s.N
                }, {
                    type: s.Z
                }, {
                    type: s.z,
                    args: [Vn]
                }]
            }, {
                type: Array,
                decorators: [{
                    type: s.N
                }, {
                    type: s.Z
                }, {
                    type: s.z,
                    args: [$n]
                }]
            }, {
                type: Array,
                decorators: [{
                    type: s.N
                }, {
                    type: s.Z
                }, {
                    type: s.z,
                    args: [On]
                }]
            }], tr.propDecorators = {
                name: [{
                    type: s.D
                }],
                isDisabled: [{
                    type: s.D,
                    args: ["disabled"]
                }],
                model: [{
                    type: s.D,
                    args: ["ngModel"]
                }],
                options: [{
                    type: s.D,
                    args: ["ngModelOptions"]
                }],
                update: [{
                    type: s.O,
                    args: ["ngModelChange"]
                }]
            };
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class nr {}
            nr.decorators = [{
                type: s.s,
                args: [{
                    selector: "form:not([ngNoForm]):not([ngNativeValidate])",
                    host: {
                        novalidate: ""
                    }
                }]
            }];
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const sr = new s.B("NgModelWithFormControlWarning"),
                rr = {
                    provide: ts,
                    useExisting: Object(s.lb)(() => ir)
                };
            class ir extends ts {
                constructor(e, t, n, r) {
                    super(), this._ngModelWarningConfig = r, this.update = new s.v, this._ngModelWarningSent = !1, this._setValidators(e), this._setAsyncValidators(t), this.valueAccessor = Is(0, n)
                }
                set isDisabled(e) {
                    0
                }
                ngOnChanges(e) {
                    this._isControlChanged(e) && (Es(this.form, this), this.control.disabled && this.valueAccessor.setDisabledState && this.valueAccessor.setDisabledState(!0), this.form.updateValueAndValidity({
                        emitEvent: !1
                    })), Ps(e, this.viewModel) && (this.form.setValue(this.model), this.viewModel = this.model)
                }
                get path() {
                    return []
                }
                get control() {
                    return this.form
                }
                viewToModelUpdate(e) {
                    this.viewModel = e, this.update.emit(e)
                }
                _isControlChanged(e) {
                    return e.hasOwnProperty("form")
                }
            }
            ir._ngModelWarningSentOnce = !1, ir.decorators = [{
                type: s.s,
                args: [{
                    selector: "[formControl]",
                    providers: [rr],
                    exportAs: "ngForm"
                }]
            }], ir.ctorParameters = () => [{
                type: Array,
                decorators: [{
                    type: s.N
                }, {
                    type: s.Z
                }, {
                    type: s.z,
                    args: [Vn]
                }]
            }, {
                type: Array,
                decorators: [{
                    type: s.N
                }, {
                    type: s.Z
                }, {
                    type: s.z,
                    args: [$n]
                }]
            }, {
                type: Array,
                decorators: [{
                    type: s.N
                }, {
                    type: s.Z
                }, {
                    type: s.z,
                    args: [On]
                }]
            }, {
                type: String,
                decorators: [{
                    type: s.N
                }, {
                    type: s.z,
                    args: [sr]
                }]
            }], ir.propDecorators = {
                form: [{
                    type: s.D,
                    args: ["formControl"]
                }],
                isDisabled: [{
                    type: s.D,
                    args: ["disabled"]
                }],
                model: [{
                    type: s.D,
                    args: ["ngModel"]
                }],
                update: [{
                    type: s.O,
                    args: ["ngModelChange"]
                }]
            };
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const or = {
                provide: es,
                useExisting: Object(s.lb)(() => ar)
            };
            class ar extends es {
                constructor(e, t) {
                    super(), this.validators = e, this.asyncValidators = t, this.submitted = !1, this.directives = [], this.form = null, this.ngSubmit = new s.v, this._setValidators(e), this._setAsyncValidators(t)
                }
                ngOnChanges(e) {
                    this._checkFormPresent(), e.hasOwnProperty("form") && (this._updateValidators(), this._updateDomValue(), this._updateRegistrations(), this._oldForm = this.form)
                }
                get formDirective() {
                    return this
                }
                get control() {
                    return this.form
                }
                get path() {
                    return []
                }
                addControl(e) {
                    const t = this.form.get(e.path);
                    return Es(t, e), t.updateValueAndValidity({
                        emitEvent: !1
                    }), this.directives.push(e), t
                }
                getControl(e) {
                    return this.form.get(e.path)
                }
                removeControl(e) {
                    Ns(this.directives, e)
                }
                addFormGroup(e) {
                    const t = this.form.get(e.path);
                    Ds(t, e), t.updateValueAndValidity({
                        emitEvent: !1
                    })
                }
                removeFormGroup(e) {}
                getFormGroup(e) {
                    return this.form.get(e.path)
                }
                addFormArray(e) {
                    const t = this.form.get(e.path);
                    Ds(t, e), t.updateValueAndValidity({
                        emitEvent: !1
                    })
                }
                removeFormArray(e) {}
                getFormArray(e) {
                    return this.form.get(e.path)
                }
                updateModel(e, t) {
                    this.form.get(e.path).setValue(t)
                }
                onSubmit(e) {
                    return this.submitted = !0, Os(this.form, this.directives), this.ngSubmit.emit(e), !1
                }
                onReset() {
                    this.resetForm()
                }
                resetForm(e) {
                    this.form.reset(e), this.submitted = !1
                }
                _updateDomValue() {
                    this.directives.forEach(e => {
                        const t = this.form.get(e.path);
                        e.control !== t && (Cs(e.control || null, e), t && Es(t, e), e.control = t)
                    }), this.form._updateTreeValidity({
                        emitEvent: !1
                    })
                }
                _updateRegistrations() {
                    this.form._registerOnCollectionChange(() => this._updateDomValue()), this._oldForm && this._oldForm._registerOnCollectionChange(() => {})
                }
                _updateValidators() {
                    xs(this.form, this, !1), this._oldForm && Ts(this._oldForm, this, !1)
                }
                _checkFormPresent() {
                    this.form, 0
                }
            }
            ar.decorators = [{
                type: s.s,
                args: [{
                    selector: "[formGroup]",
                    providers: [or],
                    host: {
                        "(submit)": "onSubmit($event)",
                        "(reset)": "onReset()"
                    },
                    exportAs: "ngForm"
                }]
            }], ar.ctorParameters = () => [{
                type: Array,
                decorators: [{
                    type: s.N
                }, {
                    type: s.Z
                }, {
                    type: s.z,
                    args: [Vn]
                }]
            }, {
                type: Array,
                decorators: [{
                    type: s.N
                }, {
                    type: s.Z
                }, {
                    type: s.z,
                    args: [$n]
                }]
            }], ar.propDecorators = {
                form: [{
                    type: s.D,
                    args: ["formGroup"]
                }],
                ngSubmit: [{
                    type: s.O
                }]
            };
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const lr = {
                provide: es,
                useExisting: Object(s.lb)(() => cr)
            };
            class cr extends Zs {
                constructor(e, t, n) {
                    super(), this._parent = e, this._setValidators(t), this._setAsyncValidators(n)
                }
                _checkParentType() {
                    pr(this._parent), 0
                }
            }
            cr.decorators = [{
                type: s.s,
                args: [{
                    selector: "[formGroupName]",
                    providers: [lr]
                }]
            }], cr.ctorParameters = () => [{
                type: es,
                decorators: [{
                    type: s.N
                }, {
                    type: s.w
                }, {
                    type: s.ab
                }]
            }, {
                type: Array,
                decorators: [{
                    type: s.N
                }, {
                    type: s.Z
                }, {
                    type: s.z,
                    args: [Vn]
                }]
            }, {
                type: Array,
                decorators: [{
                    type: s.N
                }, {
                    type: s.Z
                }, {
                    type: s.z,
                    args: [$n]
                }]
            }], cr.propDecorators = {
                name: [{
                    type: s.D,
                    args: ["formGroupName"]
                }]
            };
            const ur = {
                provide: es,
                useExisting: Object(s.lb)(() => hr)
            };
            class hr extends es {
                constructor(e, t, n) {
                    super(), this._parent = e, this._setValidators(t), this._setAsyncValidators(n)
                }
                ngOnInit() {
                    this._checkParentType(), this.formDirective.addFormArray(this)
                }
                ngOnDestroy() {
                    this.formDirective && this.formDirective.removeFormArray(this)
                }
                get control() {
                    return this.formDirective.getFormArray(this)
                }
                get formDirective() {
                    return this._parent ? this._parent.formDirective : null
                }
                get path() {
                    return ws(null == this.name ? this.name : this.name.toString(), this._parent)
                }
                _checkParentType() {
                    pr(this._parent), 0
                }
            }

            function pr(e) {
                return !(e instanceof cr || e instanceof ar || e instanceof hr)
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            hr.decorators = [{
                type: s.s,
                args: [{
                    selector: "[formArrayName]",
                    providers: [ur]
                }]
            }], hr.ctorParameters = () => [{
                type: es,
                decorators: [{
                    type: s.N
                }, {
                    type: s.w
                }, {
                    type: s.ab
                }]
            }, {
                type: Array,
                decorators: [{
                    type: s.N
                }, {
                    type: s.Z
                }, {
                    type: s.z,
                    args: [Vn]
                }]
            }, {
                type: Array,
                decorators: [{
                    type: s.N
                }, {
                    type: s.Z
                }, {
                    type: s.z,
                    args: [$n]
                }]
            }], hr.propDecorators = {
                name: [{
                    type: s.D,
                    args: ["formArrayName"]
                }]
            };
            const dr = {
                provide: ts,
                useExisting: Object(s.lb)(() => fr)
            };
            class fr extends ts {
                constructor(e, t, n, r, i) {
                    super(), this._ngModelWarningConfig = i, this._added = !1, this.update = new s.v, this._ngModelWarningSent = !1, this._parent = e, this._setValidators(t), this._setAsyncValidators(n), this.valueAccessor = Is(0, r)
                }
                set isDisabled(e) {
                    0
                }
                ngOnChanges(e) {
                    this._added || this._setUpControl(), Ps(e, this.viewModel) && (this.viewModel = this.model, this.formDirective.updateModel(this, this.model))
                }
                ngOnDestroy() {
                    this.formDirective && this.formDirective.removeControl(this)
                }
                viewToModelUpdate(e) {
                    this.viewModel = e, this.update.emit(e)
                }
                get path() {
                    return ws(null == this.name ? this.name : this.name.toString(), this._parent)
                }
                get formDirective() {
                    return this._parent ? this._parent.formDirective : null
                }
                _checkParentType() {
                    0
                }
                _setUpControl() {
                    this._checkParentType(), this.control = this.formDirective.addControl(this), this.control.disabled && this.valueAccessor.setDisabledState && this.valueAccessor.setDisabledState(!0), this._added = !0
                }
            }
            fr._ngModelWarningSentOnce = !1, fr.decorators = [{
                type: s.s,
                args: [{
                    selector: "[formControlName]",
                    providers: [dr]
                }]
            }], fr.ctorParameters = () => [{
                type: es,
                decorators: [{
                    type: s.N
                }, {
                    type: s.w
                }, {
                    type: s.ab
                }]
            }, {
                type: Array,
                decorators: [{
                    type: s.N
                }, {
                    type: s.Z
                }, {
                    type: s.z,
                    args: [Vn]
                }]
            }, {
                type: Array,
                decorators: [{
                    type: s.N
                }, {
                    type: s.Z
                }, {
                    type: s.z,
                    args: [$n]
                }]
            }, {
                type: Array,
                decorators: [{
                    type: s.N
                }, {
                    type: s.Z
                }, {
                    type: s.z,
                    args: [On]
                }]
            }, {
                type: String,
                decorators: [{
                    type: s.N
                }, {
                    type: s.z,
                    args: [sr]
                }]
            }], fr.propDecorators = {
                name: [{
                    type: s.D,
                    args: ["formControlName"]
                }],
                isDisabled: [{
                    type: s.D,
                    args: ["disabled"]
                }],
                model: [{
                    type: s.D,
                    args: ["ngModel"]
                }],
                update: [{
                    type: s.O,
                    args: ["ngModelChange"]
                }]
            };
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const mr = {
                    provide: Vn,
                    useExisting: Object(s.lb)(() => yr),
                    multi: !0
                },
                gr = {
                    provide: Vn,
                    useExisting: Object(s.lb)(() => vr),
                    multi: !0
                };
            class yr {
                constructor() {
                    this._required = !1
                }
                get required() {
                    return this._required
                }
                set required(e) {
                    this._required = null != e && !1 !== e && "false" != `${e}`, this._onChange && this._onChange()
                }
                validate(e) {
                    return this.required ? Hn.required(e) : null
                }
                registerOnValidatorChange(e) {
                    this._onChange = e
                }
            }
            yr.decorators = [{
                type: s.s,
                args: [{
                    selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]",
                    providers: [mr],
                    host: {
                        "[attr.required]": 'required ? "" : null'
                    }
                }]
            }], yr.propDecorators = {
                required: [{
                    type: s.D
                }]
            };
            class vr extends yr {
                validate(e) {
                    return this.required ? Hn.requiredTrue(e) : null
                }
            }
            vr.decorators = [{
                type: s.s,
                args: [{
                    selector: "input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]",
                    providers: [gr],
                    host: {
                        "[attr.required]": 'required ? "" : null'
                    }
                }]
            }];
            const _r = {
                provide: Vn,
                useExisting: Object(s.lb)(() => br),
                multi: !0
            };
            class br {
                constructor() {
                    this._enabled = !1
                }
                set email(e) {
                    this._enabled = "" === e || !0 === e || "true" === e, this._onChange && this._onChange()
                }
                validate(e) {
                    return this._enabled ? Hn.email(e) : null
                }
                registerOnValidatorChange(e) {
                    this._onChange = e
                }
            }
            br.decorators = [{
                type: s.s,
                args: [{
                    selector: "[email][formControlName],[email][formControl],[email][ngModel]",
                    providers: [_r]
                }]
            }], br.propDecorators = {
                email: [{
                    type: s.D
                }]
            };
            const wr = {
                provide: Vn,
                useExisting: Object(s.lb)(() => Er),
                multi: !0
            };
            class Er {
                constructor() {
                    this._validator = Hn.nullValidator
                }
                ngOnChanges(e) {
                    "minlength" in e && (this._createValidator(), this._onChange && this._onChange())
                }
                validate(e) {
                    return null == this.minlength ? null : this._validator(e)
                }
                registerOnValidatorChange(e) {
                    this._onChange = e
                }
                _createValidator() {
                    this._validator = Hn.minLength("number" == typeof this.minlength ? this.minlength : parseInt(this.minlength, 10))
                }
            }
            Er.decorators = [{
                type: s.s,
                args: [{
                    selector: "[minlength][formControlName],[minlength][formControl],[minlength][ngModel]",
                    providers: [wr],
                    host: {
                        "[attr.minlength]": "minlength ? minlength : null"
                    }
                }]
            }], Er.propDecorators = {
                minlength: [{
                    type: s.D
                }]
            };
            const Cr = {
                provide: Vn,
                useExisting: Object(s.lb)(() => Sr),
                multi: !0
            };
            class Sr {
                constructor() {
                    this._validator = Hn.nullValidator
                }
                ngOnChanges(e) {
                    "maxlength" in e && (this._createValidator(), this._onChange && this._onChange())
                }
                validate(e) {
                    return null != this.maxlength ? this._validator(e) : null
                }
                registerOnValidatorChange(e) {
                    this._onChange = e
                }
                _createValidator() {
                    this._validator = Hn.maxLength("number" == typeof this.maxlength ? this.maxlength : parseInt(this.maxlength, 10))
                }
            }
            Sr.decorators = [{
                type: s.s,
                args: [{
                    selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]",
                    providers: [Cr],
                    host: {
                        "[attr.maxlength]": "maxlength ? maxlength : null"
                    }
                }]
            }], Sr.propDecorators = {
                maxlength: [{
                    type: s.D
                }]
            };
            const xr = {
                provide: Vn,
                useExisting: Object(s.lb)(() => Tr),
                multi: !0
            };
            class Tr {
                constructor() {
                    this._validator = Hn.nullValidator
                }
                ngOnChanges(e) {
                    "pattern" in e && (this._createValidator(), this._onChange && this._onChange())
                }
                validate(e) {
                    return this._validator(e)
                }
                registerOnValidatorChange(e) {
                    this._onChange = e
                }
                _createValidator() {
                    this._validator = Hn.pattern(this.pattern)
                }
            }
            Tr.decorators = [{
                type: s.s,
                args: [{
                    selector: "[pattern][formControlName],[pattern][formControl],[pattern][ngModel]",
                    providers: [xr],
                    host: {
                        "[attr.pattern]": "pattern ? pattern : null"
                    }
                }]
            }], Tr.propDecorators = {
                pattern: [{
                    type: s.D
                }]
            };
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            const Ar = [nr, gs, bs, Rn, as, ps, Nn, ms, _s, us, rs, is, yr, Er, Sr, Tr, vr, br],
                Dr = [tr, Xs, Qs],
                Pr = [ir, ar, fr, cr, hr];
            class kr {}
            kr.decorators = [{
                type: s.I,
                args: [{
                    declarations: Ar,
                    exports: Ar
                }]
            }];
            class Or {
                group(e, t = null) {
                    const n = this._reduceControls(e);
                    let s, r = null,
                        i = null;
                    return null != t && (!
                        /**
                         * @license
                         * Copyright Google LLC All Rights Reserved.
                         *
                         * Use of this source code is governed by an MIT-style license that can be
                         * found in the LICENSE file at https://angular.io/license
                         */
                        function(e) {
                            return void 0 !== e.asyncValidators || void 0 !== e.validators || void 0 !== e.updateOn
                        }(t) ? (r = null != t.validator ? t.validator : null, i = null != t.asyncValidator ? t.asyncValidator : null) : (r = null != t.validators ? t.validators : null, i = null != t.asyncValidators ? t.asyncValidators : null, s = null != t.updateOn ? t.updateOn : void 0)), new zs(n, {
                        asyncValidators: i,
                        updateOn: s,
                        validators: r
                    })
                }
                control(e, t, n) {
                    return new qs(e, t, n)
                }
                array(e, t, n) {
                    const s = e.map(e => this._createControl(e));
                    return new Ws(s, t, n)
                }
                _reduceControls(e) {
                    const t = {};
                    return Object.keys(e).forEach(n => {
                        t[n] = this._createControl(e[n])
                    }), t
                }
                _createControl(e) {
                    if (e instanceof qs || e instanceof zs || e instanceof Ws) return e;
                    if (Array.isArray(e)) {
                        const t = e[0],
                            n = e.length > 1 ? e[1] : null,
                            s = e.length > 2 ? e[2] : null;
                        return this.control(t, n, s)
                    }
                    return this.control(e)
                }
            }
            Or.decorators = [{
                type: s.A
            }];
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            new s.fb("11.0.7");
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class Ir {}
            Ir.decorators = [{
                type: s.I,
                args: [{
                    declarations: Dr,
                    providers: [cs],
                    exports: [kr, Dr]
                }]
            }];
            class Nr {
                static withConfig(e) {
                    return {
                        ngModule: Nr,
                        providers: [{
                            provide: sr,
                            useValue: e.warnOnNgModelWithFormControl
                        }]
                    }
                }
            }
            Nr.decorators = [{
                type: s.I,
                args: [{
                    declarations: [Pr],
                    providers: [Or, cs],
                    exports: [kr, Pr]
                }]
            }];
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            var Mr = n("GS7A"),
                Fr = n("fDlF");
            /**
             * @license Angular v11.0.7
             * (c) 2010-2020 Google LLC. https://angular.io/
             * License: MIT
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class Rr extends Mr.b {
                constructor(e, t) {
                    super(), this._nextAnimationId = 0;
                    const n = {
                        id: "0",
                        encapsulation: s.ib.None,
                        styles: [],
                        data: {
                            animation: []
                        }
                    };
                    this._renderer = e.createRenderer(t.body, n)
                }
                build(e) {
                    const t = this._nextAnimationId.toString();
                    this._nextAnimationId++;
                    const n = Array.isArray(e) ? Object(Mr.f)(e) : e;
                    return Vr(this._renderer, null, t, "register", [n]), new jr(t, this._renderer)
                }
            }
            Rr.decorators = [{
                type: s.A
            }], Rr.ctorParameters = () => [{
                type: s.V
            }, {
                type: void 0,
                decorators: [{
                    type: s.z,
                    args: [a]
                }]
            }];
            class jr extends Mr.c {
                constructor(e, t) {
                    super(), this._id = e, this._renderer = t
                }
                create(e, t) {
                    return new Lr(this._id, e, t || {}, this._renderer)
                }
            }
            class Lr {
                constructor(e, t, n, s) {
                    this.id = e, this.element = t, this._renderer = s, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", n)
                }
                _listen(e, t) {
                    return this._renderer.listen(this.element, `@@${this.id}:${e}`, t)
                }
                _command(e, ...t) {
                    return Vr(this._renderer, this.element, this.id, e, t)
                }
                onDone(e) {
                    this._listen("done", e)
                }
                onStart(e) {
                    this._listen("start", e)
                }
                onDestroy(e) {
                    this._listen("destroy", e)
                }
                init() {
                    this._command("init")
                }
                hasStarted() {
                    return this._started
                }
                play() {
                    this._command("play"), this._started = !0
                }
                pause() {
                    this._command("pause")
                }
                restart() {
                    this._command("restart")
                }
                finish() {
                    this._command("finish")
                }
                destroy() {
                    this._command("destroy")
                }
                reset() {
                    this._command("reset")
                }
                setPosition(e) {
                    this._command("setPosition", e)
                }
                getPosition() {
                    var e, t;
                    return null !== (t = null === (e = this._renderer.engine.players[+this.id]) || void 0 === e ? void 0 : e.getPosition()) && void 0 !== t ? t : 0
                }
            }

            function Vr(e, t, n, s, r) {
                return e.setProperty(t, `@@${n}:${s}`, r)
            }
            const $r = "@",
                Br = "@.disabled";
            class Hr {
                constructor(e, t, n) {
                    this.delegate = e, this.engine = t, this._zone = n, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, this.promise = Promise.resolve(0), t.onRemovalComplete = (e, t) => {
                        t && t.parentNode(e) && t.removeChild(e.parentNode, e)
                    }
                }
                createRenderer(e, t) {
                    const n = this.delegate.createRenderer(e, t);
                    if (!(e && t && t.data && t.data.animation)) {
                        let e = this._rendererCache.get(n);
                        return e || (e = new Ur("", n, this.engine), this._rendererCache.set(n, e)), e
                    }
                    const s = t.id,
                        r = t.id + "-" + this._currentId;
                    this._currentId++, this.engine.register(r, e);
                    const i = t => {
                        Array.isArray(t) ? t.forEach(i) : this.engine.registerTrigger(s, r, e, t.name, t)
                    };
                    return t.data.animation.forEach(i), new qr(this, r, n, this.engine)
                }
                begin() {
                    this._cdRecurDepth++, this.delegate.begin && this.delegate.begin()
                }
                _scheduleCountTask() {
                    this.promise.then(() => {
                        this._microtaskId++
                    })
                }
                scheduleListenerCallback(e, t, n) {
                    e >= 0 && e < this._microtaskId ? this._zone.run(() => t(n)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => {
                        this._zone.run(() => {
                            this._animationCallbacksBuffer.forEach(e => {
                                const [t, n] = e;
                                t(n)
                            }), this._animationCallbacksBuffer = []
                        })
                    }), this._animationCallbacksBuffer.push([t, n]))
                }
                end() {
                    this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => {
                        this._scheduleCountTask(), this.engine.flush(this._microtaskId)
                    }), this.delegate.end && this.delegate.end()
                }
                whenRenderingDone() {
                    return this.engine.whenRenderingDone()
                }
            }
            Hr.decorators = [{
                type: s.A
            }], Hr.ctorParameters = () => [{
                type: s.V
            }, {
                type: Fr.b
            }, {
                type: s.M
            }];
            class Ur {
                constructor(e, t, n) {
                    this.namespaceId = e, this.delegate = t, this.engine = n, this.destroyNode = this.delegate.destroyNode ? e => t.destroyNode(e) : null
                }
                get data() {
                    return this.delegate.data
                }
                destroy() {
                    this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy()
                }
                createElement(e, t) {
                    return this.delegate.createElement(e, t)
                }
                createComment(e) {
                    return this.delegate.createComment(e)
                }
                createText(e) {
                    return this.delegate.createText(e)
                }
                appendChild(e, t) {
                    this.delegate.appendChild(e, t), this.engine.onInsert(this.namespaceId, t, e, !1)
                }
                insertBefore(e, t, n, s = !0) {
                    this.delegate.insertBefore(e, t, n), this.engine.onInsert(this.namespaceId, t, e, s)
                }
                removeChild(e, t, n) {
                    this.engine.onRemove(this.namespaceId, t, this.delegate, n)
                }
                selectRootElement(e, t) {
                    return this.delegate.selectRootElement(e, t)
                }
                parentNode(e) {
                    return this.delegate.parentNode(e)
                }
                nextSibling(e) {
                    return this.delegate.nextSibling(e)
                }
                setAttribute(e, t, n, s) {
                    this.delegate.setAttribute(e, t, n, s)
                }
                removeAttribute(e, t, n) {
                    this.delegate.removeAttribute(e, t, n)
                }
                addClass(e, t) {
                    this.delegate.addClass(e, t)
                }
                removeClass(e, t) {
                    this.delegate.removeClass(e, t)
                }
                setStyle(e, t, n, s) {
                    this.delegate.setStyle(e, t, n, s)
                }
                removeStyle(e, t, n) {
                    this.delegate.removeStyle(e, t, n)
                }
                setProperty(e, t, n) {
                    t.charAt(0) == $r && t == Br ? this.disableAnimations(e, !!n) : this.delegate.setProperty(e, t, n)
                }
                setValue(e, t) {
                    this.delegate.setValue(e, t)
                }
                listen(e, t, n) {
                    return this.delegate.listen(e, t, n)
                }
                disableAnimations(e, t) {
                    this.engine.disableAnimations(e, t)
                }
            }
            class qr extends Ur {
                constructor(e, t, n, s) {
                    super(t, n, s), this.factory = e, this.namespaceId = t
                }
                setProperty(e, t, n) {
                    t.charAt(0) == $r ? "." == t.charAt(1) && t == Br ? (n = void 0 === n || !!n, this.disableAnimations(e, n)) : this.engine.process(this.namespaceId, e, t.substr(1), n) : this.delegate.setProperty(e, t, n)
                }
                listen(e, t, n) {
                    if (t.charAt(0) == $r) {
                        const s = function(e) {
                            switch (e) {
                                case "body":
                                    return document.body;
                                case "document":
                                    return document;
                                case "window":
                                    return window;
                                default:
                                    return e
                            }
                        }(e);
                        let r = t.substr(1),
                            i = "";
                        return r.charAt(0) != $r && ([r, i] = function(e) {
                                const t = e.indexOf("."),
                                    n = e.substring(0, t),
                                    s = e.substr(t + 1);
                                return [n, s]
                            }
                            /**
                             * @license
                             * Copyright Google LLC All Rights Reserved.
                             *
                             * Use of this source code is governed by an MIT-style license that can be
                             * found in the LICENSE file at https://angular.io/license
                             */
                            (r)), this.engine.listen(this.namespaceId, s, r, i, e => {
                            const t = e._data || -1;
                            this.factory.scheduleListenerCallback(t, n, e)
                        })
                    }
                    return this.delegate.listen(e, t, n)
                }
            }
            class zr extends Fr.b {
                constructor(e, t, n) {
                    super(e.body, t, n)
                }
            }
            zr.decorators = [{
                type: s.A
            }], zr.ctorParameters = () => [{
                type: void 0,
                decorators: [{
                    type: s.z,
                    args: [a]
                }]
            }, {
                type: Fr.a
            }, {
                type: Fr.c
            }];
            const Wr = new s.B("AnimationModuleType"),
                Gr = [{
                    provide: Mr.b,
                    useClass: Rr
                }, {
                    provide: Fr.c,
                    useFactory: function() {
                        return new Fr.g
                    }
                }, {
                    provide: Fr.b,
                    useClass: zr
                }, {
                    provide: s.V,
                    useFactory: function(e, t, n) {
                        return new Hr(e, t, n)
                    },
                    deps: [Dt, Fr.b, s.M]
                }],
                Kr = [{
                    provide: Fr.a,
                    useFactory: function() {
                        return Object(Fr.h)() ? new Fr.f : new Fr.d
                    }
                }, {
                    provide: Wr,
                    useValue: "BrowserAnimations"
                }, ...Gr],
                Qr = [{
                    provide: Fr.a,
                    useClass: Fr.e
                }, {
                    provide: Wr,
                    useValue: "NoopAnimations"
                }, ...Gr];
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class Zr {}
            Zr.decorators = [{
                type: s.I,
                args: [{
                    exports: [Jt],
                    providers: Kr
                }]
            }];
            (class {}).decorators = [{
                type: s.I,
                args: [{
                    exports: [Jt],
                    providers: Qr
                }]
            }];
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            let Jr = class {
                constructor() {}
                isAndroid() {
                    return navigator.userAgent.toLowerCase().indexOf("android") > -1
                }
            };
            Jr.ctorParameters = () => [], Jr = Cn([Object(s.A)(), Sn("design:paramtypes", [])], Jr);
            let Xr = class {
                constructor(e) {
                    this.platformService = e, this.isParallaxEnabled = !0
                }
                ngOnInit() {
                    this.isParallaxEnabled = !this.platformService.isAndroid()
                }
                ngAfterContentInit() {
                    this.isParallaxEnabled
                }
            };
            Xr.ctorParameters = () => [{
                type: Jr
            }], Xr.propDecorators = {
                selector: [{
                    type: s.D
                }]
            }, Xr = Cn([Object(s.n)({
                selector: "rellax",
                template: "<div><ng-content></ng-content></div>"
            }), Sn("design:paramtypes", [Jr])], Xr);
            var Yr = n("XNiG"),
                ei = n("n6bG");
            Object.prototype.toString;

            function ti(e, t, n, s) {
                return Object(ei.a)(n) && (s = n, n = void 0), s ? ti(e, t, n).pipe(Object(An.a)(e => Object(Tn.a)(e) ? s(...e) : s(e))) : new xn.a(s => {
                    ni(e, t, function(e) {
                        arguments.length > 1 ? s.next(Array.prototype.slice.call(arguments)) : s.next(e)
                    }, s, n)
                })
            }

            function ni(e, t, n, s, r) {
                let i;
                if (function(e) {
                        return e && "function" == typeof e.addEventListener && "function" == typeof e.removeEventListener
                    }(e)) {
                    const s = e;
                    e.addEventListener(t, n, r), i = () => s.removeEventListener(t, n, r)
                } else if (function(e) {
                        return e && "function" == typeof e.on && "function" == typeof e.off
                    }(e)) {
                    const s = e;
                    e.on(t, n), i = () => s.off(t, n)
                } else if (function(e) {
                        return e && "function" == typeof e.addListener && "function" == typeof e.removeListener
                    }(e)) {
                    const s = e;
                    e.addListener(t, n), i = () => s.removeListener(t, n)
                } else {
                    if (!e || !e.length) throw new TypeError("Invalid event target");
                    for (let i = 0, o = e.length; i < o; i++) ni(e[i], t, n, s, r)
                }
                s.add(i)
            }
            var si = n("VRyK"),
                ri = n("quSY");
            class ii extends ri.a {
                constructor(e, t) {
                    super()
                }
                schedule(e, t = 0) {
                    return this
                }
            }
            class oi {
                constructor(e, t = oi.now) {
                    this.SchedulerAction = e, this.now = t
                }
                schedule(e, t = 0, n) {
                    return new this.SchedulerAction(this, e).schedule(n, t)
                }
            }
            oi.now = () => Date.now();
            class ai extends oi {
                constructor(e, t = oi.now) {
                    super(e, () => ai.delegate && ai.delegate !== this ? ai.delegate.now() : t()), this.actions = [], this.active = !1, this.scheduled = void 0
                }
                schedule(e, t = 0, n) {
                    return ai.delegate && ai.delegate !== this ? ai.delegate.schedule(e, t, n) : super.schedule(e, t, n)
                }
                flush(e) {
                    const {
                        actions: t
                    } = this;
                    if (this.active) return void t.push(e);
                    let n;
                    this.active = !0;
                    do {
                        if (n = e.execute(e.state, e.delay)) break
                    } while (e = t.shift());
                    if (this.active = !1, n) {
                        for (; e = t.shift();) e.unsubscribe();
                        throw n
                    }
                }
            }
            const li = new ai(class extends ii {
                constructor(e, t) {
                    super(e, t), this.scheduler = e, this.work = t, this.pending = !1
                }
                schedule(e, t = 0) {
                    if (this.closed) return this;
                    this.state = e;
                    const n = this.id,
                        s = this.scheduler;
                    return null != n && (this.id = this.recycleAsyncId(s, n, t)), this.pending = !0, this.delay = t, this.id = this.id || this.requestAsyncId(s, this.id, t), this
                }
                requestAsyncId(e, t, n = 0) {
                    return setInterval(e.flush.bind(e, this), n)
                }
                recycleAsyncId(e, t, n = 0) {
                    if (null !== n && this.delay === n && !1 === this.pending) return t;
                    clearInterval(t)
                }
                execute(e, t) {
                    if (this.closed) return new Error("executing a cancelled action");
                    this.pending = !1;
                    const n = this._execute(e, t);
                    if (n) return n;
                    !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null))
                }
                _execute(e, t) {
                    let n, s = !1;
                    try {
                        this.work(e)
                    } catch (r) {
                        s = !0, n = !!r && r || new Error(r)
                    }
                    if (s) return this.unsubscribe(), n
                }
                _unsubscribe() {
                    const e = this.id,
                        t = this.scheduler,
                        n = t.actions,
                        s = n.indexOf(this);
                    this.work = null, this.state = null, this.pending = !1, this.scheduler = null, -1 !== s && n.splice(s, 1), null != e && (this.id = this.recycleAsyncId(t, e, null)), this.delay = null
                }
            });

            function ci(e = 0, t = li) {
                var n;
                return n = e, (Object(Tn.a)(n) || !(n - parseFloat(n) + 1 >= 0) || e < 0) && (e = 0), t && "function" == typeof t.schedule || (t = li), new xn.a(n => (n.add(t.schedule(ui, e, {
                    subscriber: n,
                    counter: 0,
                    period: e
                })), n))
            }

            function ui(e) {
                const {
                    subscriber: t,
                    counter: n,
                    period: s
                } = e;
                t.next(n), this.schedule({
                    subscriber: t,
                    counter: n + 1,
                    period: s
                }, s)
            }
            var hi = n("l7GE"),
                pi = n("ZUHj");

            function di(e) {
                return t => t.lift(new fi(e))
            }
            class fi {
                constructor(e) {
                    this.notifier = e
                }
                call(e, t) {
                    const n = new mi(e),
                        s = Object(pi.a)(n, this.notifier);
                    return s && !n.seenValue ? (n.add(s), t.subscribe(n)) : n
                }
            }
            class mi extends hi.a {
                constructor(e) {
                    super(e), this.seenValue = !1
                }
                notifyNext(e, t, n, s, r) {
                    this.seenValue = !0, this.complete()
                }
                notifyComplete() {}
            }

            function gi(e) {
                return t => t.lift(new yi(e))
            }
            class yi {
                constructor(e) {
                    this.durationSelector = e
                }
                call(e, t) {
                    return t.subscribe(new vi(e, this.durationSelector))
                }
            }
            class vi extends hi.a {
                constructor(e, t) {
                    super(e), this.durationSelector = t, this.hasValue = !1, this.durationSubscription = null
                }
                _next(e) {
                    try {
                        const t = this.durationSelector.call(this, e);
                        t && this._tryNext(e, t)
                    } catch (t) {
                        this.destination.error(t)
                    }
                }
                _complete() {
                    this.emitValue(), this.destination.complete()
                }
                _tryNext(e, t) {
                    let n = this.durationSubscription;
                    this.value = e, this.hasValue = !0, n && (n.unsubscribe(), this.remove(n)), n = Object(pi.a)(this, t), n && !n.closed && this.add(this.durationSubscription = n)
                }
                notifyNext(e, t, n, s, r) {
                    this.emitValue()
                }
                notifyComplete() {
                    this.emitValue()
                }
                emitValue() {
                    if (this.hasValue) {
                        const e = this.value,
                            t = this.durationSubscription;
                        t && (this.durationSubscription = null, t.unsubscribe(), this.remove(t)), this.value = null, this.hasValue = !1, super._next(e)
                    }
                }
            }
            var _i = n("z+Ro"),
                bi = n("yCtX"),
                wi = n("jZKg");
            var Ei = n("5+tZ");
            var Ci, Si = n("7o/Q");
            class xi {
                constructor(e, t) {
                    this.predicate = e, this.thisArg = t
                }
                call(e, t) {
                    return t.subscribe(new Ti(e, this.predicate, this.thisArg))
                }
            }
            class Ti extends Si.a {
                constructor(e, t, n) {
                    super(e), this.predicate = t, this.thisArg = n, this.count = 0
                }
                _next(e) {
                    let t;
                    try {
                        t = this.predicate.call(this.thisArg, e, this.count++)
                    } catch (n) {
                        return void this.destination.error(n)
                    }
                    t && this.destination.next(e)
                }
            }
            /**
             * @license Angular v11.0.7
             * (c) 2010-2020 Google LLC. https://angular.io/
             * License: MIT
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class Ai {}
            class Di {}
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class Pi {
                constructor(e) {
                    this.normalizedNames = new Map, this.lazyUpdate = null, e ? this.lazyInit = "string" == typeof e ? () => {
                        this.headers = new Map, e.split("\n").forEach(e => {
                            const t = e.indexOf(":");
                            if (t > 0) {
                                const n = e.slice(0, t),
                                    s = n.toLowerCase(),
                                    r = e.slice(t + 1).trim();
                                this.maybeSetNormalizedName(n, s), this.headers.has(s) ? this.headers.get(s).push(r) : this.headers.set(s, [r])
                            }
                        })
                    } : () => {
                        this.headers = new Map, Object.keys(e).forEach(t => {
                            let n = e[t];
                            const s = t.toLowerCase();
                            "string" == typeof n && (n = [n]), n.length > 0 && (this.headers.set(s, n), this.maybeSetNormalizedName(t, s))
                        })
                    } : this.headers = new Map
                }
                has(e) {
                    return this.init(), this.headers.has(e.toLowerCase())
                }
                get(e) {
                    this.init();
                    const t = this.headers.get(e.toLowerCase());
                    return t && t.length > 0 ? t[0] : null
                }
                keys() {
                    return this.init(), Array.from(this.normalizedNames.values())
                }
                getAll(e) {
                    return this.init(), this.headers.get(e.toLowerCase()) || null
                }
                append(e, t) {
                    return this.clone({
                        name: e,
                        value: t,
                        op: "a"
                    })
                }
                set(e, t) {
                    return this.clone({
                        name: e,
                        value: t,
                        op: "s"
                    })
                }
                delete(e, t) {
                    return this.clone({
                        name: e,
                        value: t,
                        op: "d"
                    })
                }
                maybeSetNormalizedName(e, t) {
                    this.normalizedNames.has(t) || this.normalizedNames.set(t, e)
                }
                init() {
                    this.lazyInit && (this.lazyInit instanceof Pi ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(e => this.applyUpdate(e)), this.lazyUpdate = null))
                }
                copyFrom(e) {
                    e.init(), Array.from(e.headers.keys()).forEach(t => {
                        this.headers.set(t, e.headers.get(t)), this.normalizedNames.set(t, e.normalizedNames.get(t))
                    })
                }
                clone(e) {
                    const t = new Pi;
                    return t.lazyInit = this.lazyInit && this.lazyInit instanceof Pi ? this.lazyInit : this, t.lazyUpdate = (this.lazyUpdate || []).concat([e]), t
                }
                applyUpdate(e) {
                    const t = e.name.toLowerCase();
                    switch (e.op) {
                        case "a":
                        case "s":
                            let n = e.value;
                            if ("string" == typeof n && (n = [n]), 0 === n.length) return;
                            this.maybeSetNormalizedName(e.name, t);
                            const s = ("a" === e.op ? this.headers.get(t) : void 0) || [];
                            s.push(...n), this.headers.set(t, s);
                            break;
                        case "d":
                            const r = e.value;
                            if (r) {
                                let e = this.headers.get(t);
                                if (!e) return;
                                e = e.filter(e => -1 === r.indexOf(e)), 0 === e.length ? (this.headers.delete(t), this.normalizedNames.delete(t)) : this.headers.set(t, e)
                            } else this.headers.delete(t), this.normalizedNames.delete(t)
                    }
                }
                forEach(e) {
                    this.init(), Array.from(this.normalizedNames.keys()).forEach(t => e(this.normalizedNames.get(t), this.headers.get(t)))
                }
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class ki {
                encodeKey(e) {
                    return Oi(e)
                }
                encodeValue(e) {
                    return Oi(e)
                }
                decodeKey(e) {
                    return decodeURIComponent(e)
                }
                decodeValue(e) {
                    return decodeURIComponent(e)
                }
            }

            function Oi(e) {
                return encodeURIComponent(e).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/gi, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%2B/gi, "+").replace(/%3D/gi, "=").replace(/%3F/gi, "?").replace(/%2F/gi, "/")
            }
            class Ii {
                constructor(e = {}) {
                    if (this.updates = null, this.cloneFrom = null, this.encoder = e.encoder || new ki, e.fromString) {
                        if (e.fromObject) throw new Error("Cannot specify both fromString and fromObject.");
                        this.map = function(e, t) {
                            const n = new Map;
                            e.length > 0 && e.split("&").forEach(e => {
                                const s = e.indexOf("="),
                                    [r, i] = -1 == s ? [t.decodeKey(e), ""] : [t.decodeKey(e.slice(0, s)), t.decodeValue(e.slice(s + 1))],
                                    o = n.get(r) || [];
                                o.push(i), n.set(r, o)
                            });
                            return n
                        }(e.fromString, this.encoder)
                    } else e.fromObject ? (this.map = new Map, Object.keys(e.fromObject).forEach(t => {
                        const n = e.fromObject[t];
                        this.map.set(t, Array.isArray(n) ? n : [n])
                    })) : this.map = null
                }
                has(e) {
                    return this.init(), this.map.has(e)
                }
                get(e) {
                    this.init();
                    const t = this.map.get(e);
                    return t ? t[0] : null
                }
                getAll(e) {
                    return this.init(), this.map.get(e) || null
                }
                keys() {
                    return this.init(), Array.from(this.map.keys())
                }
                append(e, t) {
                    return this.clone({
                        param: e,
                        value: t,
                        op: "a"
                    })
                }
                set(e, t) {
                    return this.clone({
                        param: e,
                        value: t,
                        op: "s"
                    })
                }
                delete(e, t) {
                    return this.clone({
                        param: e,
                        value: t,
                        op: "d"
                    })
                }
                toString() {
                    return this.init(), this.keys().map(e => {
                        const t = this.encoder.encodeKey(e);
                        return this.map.get(e).map(e => t + "=" + this.encoder.encodeValue(e)).join("&")
                    }).filter(e => "" !== e).join("&")
                }
                clone(e) {
                    const t = new Ii({
                        encoder: this.encoder
                    });
                    return t.cloneFrom = this.cloneFrom || this, t.updates = (this.updates || []).concat([e]), t
                }
                init() {
                    null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(e => this.map.set(e, this.cloneFrom.map.get(e))), this.updates.forEach(e => {
                        switch (e.op) {
                            case "a":
                            case "s":
                                const t = ("a" === e.op ? this.map.get(e.param) : void 0) || [];
                                t.push(e.value), this.map.set(e.param, t);
                                break;
                            case "d":
                                if (void 0 === e.value) {
                                    this.map.delete(e.param);
                                    break
                                } {
                                    let t = this.map.get(e.param) || [];
                                    const n = t.indexOf(e.value); - 1 !== n && t.splice(n, 1), t.length > 0 ? this.map.set(e.param, t) : this.map.delete(e.param)
                                }
                        }
                    }), this.cloneFrom = this.updates = null)
                }
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            function Ni(e) {
                return "undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer
            }

            function Mi(e) {
                return "undefined" != typeof Blob && e instanceof Blob
            }

            function Fi(e) {
                return "undefined" != typeof FormData && e instanceof FormData
            }
            class Ri {
                constructor(e, t, n, s) {
                    let r;
                    if (this.url = t, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = e.toUpperCase(), function(e) {
                            switch (e) {
                                case "DELETE":
                                case "GET":
                                case "HEAD":
                                case "OPTIONS":
                                case "JSONP":
                                    return !1;
                                default:
                                    return !0
                            }
                        }(this.method) || s ? (this.body = void 0 !== n ? n : null, r = s) : r = n, r && (this.reportProgress = !!r.reportProgress, this.withCredentials = !!r.withCredentials, r.responseType && (this.responseType = r.responseType), r.headers && (this.headers = r.headers), r.params && (this.params = r.params)), this.headers || (this.headers = new Pi), this.params) {
                        const e = this.params.toString();
                        if (0 === e.length) this.urlWithParams = t;
                        else {
                            const n = t.indexOf("?"),
                                s = -1 === n ? "?" : n < t.length - 1 ? "&" : "";
                            this.urlWithParams = t + s + e
                        }
                    } else this.params = new Ii, this.urlWithParams = t
                }
                serializeBody() {
                    return null === this.body ? null : Ni(this.body) || Mi(this.body) || Fi(this.body) || "string" == typeof this.body ? this.body : this.body instanceof Ii ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString()
                }
                detectContentTypeHeader() {
                    return null === this.body || Fi(this.body) ? null : Mi(this.body) ? this.body.type || null : Ni(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof Ii ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || Array.isArray(this.body) ? "application/json" : null
                }
                clone(e = {}) {
                    const t = e.method || this.method,
                        n = e.url || this.url,
                        s = e.responseType || this.responseType,
                        r = void 0 !== e.body ? e.body : this.body,
                        i = void 0 !== e.withCredentials ? e.withCredentials : this.withCredentials,
                        o = void 0 !== e.reportProgress ? e.reportProgress : this.reportProgress;
                    let a = e.headers || this.headers,
                        l = e.params || this.params;
                    return void 0 !== e.setHeaders && (a = Object.keys(e.setHeaders).reduce((t, n) => t.set(n, e.setHeaders[n]), a)), e.setParams && (l = Object.keys(e.setParams).reduce((t, n) => t.set(n, e.setParams[n]), l)), new Ri(t, n, r, {
                        params: l,
                        headers: a,
                        reportProgress: o,
                        responseType: s,
                        withCredentials: i
                    })
                }
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ! function(e) {
                e[e.Sent = 0] = "Sent", e[e.UploadProgress = 1] = "UploadProgress", e[e.ResponseHeader = 2] = "ResponseHeader", e[e.DownloadProgress = 3] = "DownloadProgress", e[e.Response = 4] = "Response", e[e.User = 5] = "User"
            }(Ci || (Ci = {}));
            class ji {
                constructor(e, t = 200, n = "OK") {
                    this.headers = e.headers || new Pi, this.status = void 0 !== e.status ? e.status : t, this.statusText = e.statusText || n, this.url = e.url || null, this.ok = this.status >= 200 && this.status < 300
                }
            }
            class Li extends ji {
                constructor(e = {}) {
                    super(e), this.type = Ci.ResponseHeader
                }
                clone(e = {}) {
                    return new Li({
                        headers: e.headers || this.headers,
                        status: void 0 !== e.status ? e.status : this.status,
                        statusText: e.statusText || this.statusText,
                        url: e.url || this.url || void 0
                    })
                }
            }
            class Vi extends ji {
                constructor(e = {}) {
                    super(e), this.type = Ci.Response, this.body = void 0 !== e.body ? e.body : null
                }
                clone(e = {}) {
                    return new Vi({
                        body: void 0 !== e.body ? e.body : this.body,
                        headers: e.headers || this.headers,
                        status: void 0 !== e.status ? e.status : this.status,
                        statusText: e.statusText || this.statusText,
                        url: e.url || this.url || void 0
                    })
                }
            }
            class $i extends ji {
                constructor(e) {
                    super(e, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.status >= 200 && this.status < 300 ? this.message = `Http failure during parsing for ${e.url||"(unknown url)"}` : this.message = `Http failure response for ${e.url||"(unknown url)"}: ${e.status} ${e.statusText}`, this.error = e.error || null
                }
            }
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            function Bi(e, t) {
                return {
                    body: t,
                    headers: e.headers,
                    observe: e.observe,
                    params: e.params,
                    reportProgress: e.reportProgress,
                    responseType: e.responseType,
                    withCredentials: e.withCredentials
                }
            }
            class Hi {
                constructor(e) {
                    this.handler = e
                }
                request(e, t, n = {}) {
                    let s;
                    if (e instanceof Ri) s = e;
                    else {
                        let r, i;
                        r = n.headers instanceof Pi ? n.headers : new Pi(n.headers), n.params && (i = n.params instanceof Ii ? n.params : new Ii({
                            fromObject: n.params
                        })), s = new Ri(e, t, void 0 !== n.body ? n.body : null, {
                            headers: r,
                            params: i,
                            reportProgress: n.reportProgress,
                            responseType: n.responseType || "json",
                            withCredentials: n.withCredentials
                        })
                    }
                    const r = function(...e) {
                        let t = e[e.length - 1];
                        return Object(_i.a)(t) ? (e.pop(), Object(wi.a)(e, t)) : Object(bi.a)(e)
                    }(s).pipe((i = e => this.handler.handle(e), Object(Ei.a)(i, o, 1)));
                    var i, o;
                    if (e instanceof Ri || "events" === n.observe) return r;
                    const a = r.pipe((l = e => e instanceof Vi, function(e) {
                        return e.lift(new xi(l, c))
                    }));
                    var l, c;
                    switch (n.observe || "body") {
                        case "body":
                            switch (s.responseType) {
                                case "arraybuffer":
                                    return a.pipe(Object(An.a)(e => {
                                        if (null !== e.body && !(e.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer.");
                                        return e.body
                                    }));
                                case "blob":
                                    return a.pipe(Object(An.a)(e => {
                                        if (null !== e.body && !(e.body instanceof Blob)) throw new Error("Response is not a Blob.");
                                        return e.body
                                    }));
                                case "text":
                                    return a.pipe(Object(An.a)(e => {
                                        if (null !== e.body && "string" != typeof e.body) throw new Error("Response is not a string.");
                                        return e.body
                                    }));
                                case "json":
                                default:
                                    return a.pipe(Object(An.a)(e => e.body))
                            }
                        case "response":
                            return a;
                        default:
                            throw new Error(`Unreachable: unhandled observe type ${n.observe}}`)
                    }
                }
                delete(e, t = {}) {
                    return this.request("DELETE", e, t)
                }
                get(e, t = {}) {
                    return this.request("GET", e, t)
                }
                head(e, t = {}) {
                    return this.request("HEAD", e, t)
                }
                jsonp(e, t) {
                    return this.request("JSONP", e, {
                        params: (new Ii).append(t, "JSONP_CALLBACK"),
                        observe: "body",
                        responseType: "json"
                    })
                }
                options(e, t = {}) {
                    return this.request("OPTIONS", e, t)
                }
                patch(e, t, n = {}) {
                    return this.request("PATCH", e, Bi(n, t))
                }
                post(e, t, n = {}) {
                    return this.request("POST", e, Bi(n, t))
                }
                put(e, t, n = {}) {
                    return this.request("PUT", e, Bi(n, t))
                }
            }
            Hi.decorators = [{
                type: s.A
            }], Hi.ctorParameters = () => [{
                type: Ai
            }]
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            class Ui {
                constructor(e, t) {
                    this.next = e, this.interceptor = t
                }
                handle(e) {
                    return this.interceptor.intercept(e, this.next)
                }
            }
            const qi = new s.B("HTTP_INTERCEPTORS");
            class zi {
                intercept(e, t) {
                    return t.handle(e)
                }
            }
            zi.decorators = [{
                type: s.A
            }];
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            let Wi = 0;
            class Gi {}
            class Ki {
                constructor(e, t) {
                    this.callbackMap = e, this.document = t, this.resolvedPromise = Promise.resolve()
                }
                nextCallback() {
                    return "ng_jsonp_callback_" + Wi++
                }
                handle(e) {
                    if ("JSONP" !== e.method) throw new Error("JSONP requests must use JSONP request method.");
                    if ("json" !== e.responseType) throw new Error("JSONP requests must use Json response type.");
                    return new xn.a(t => {
                        const n = this.nextCallback(),
                            s = e.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, `=${n}$1`),
                            r = this.document.createElement("script");
                        r.src = s;
                        let i = null,
                            o = !1,
                            a = !1;
                        this.callbackMap[n] = e => {
                            delete this.callbackMap[n], a || (i = e, o = !0)
                        };
                        const l = () => {
                                r.parentNode && r.parentNode.removeChild(r), delete this.callbackMap[n]
                            },
                            c = e => {
                                a || this.resolvedPromise.then(() => {
                                    l(), o ? (t.next(new Vi({
                                        body: i,
                                        status: 200,
                                        statusText: "OK",
                                        url: s
                                    })), t.complete()) : t.error(new $i({
                                        url: s,
                                        status: 0,
                                        statusText: "JSONP Error",
                                        error: new Error("JSONP injected script did not invoke callback.")
                                    }))
                                })
                            },
                            u = e => {
                                a || (l(), t.error(new $i({
                                    error: e,
                                    status: 0,
                                    statusText: "JSONP Error",
                                    url: s
                                })))
                            };
                        return r.addEventListener("load", c), r.addEventListener("error", u), this.document.body.appendChild(r), t.next({
                            type: Ci.Sent
                        }), () => {
                            a = !0, r.removeEventListener("load", c), r.removeEventListener("error", u), l()
                        }
                    })
                }
            }
            Ki.decorators = [{
                type: s.A
            }], Ki.ctorParameters = () => [{
                type: Gi
            }, {
                type: void 0,
                decorators: [{
                    type: s.z,
                    args: [a]
                }]
            }];
            class Qi {
                constructor(e) {
                    this.jsonp = e
                }
                intercept(e, t) {
                    return "JSONP" === e.method ? this.jsonp.handle(e) : t.handle(e)
                }
            }
            Qi.decorators = [{
                type: s.A
            }], Qi.ctorParameters = () => [{
                type: Ki
            }]
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            const Zi = /^\)\]\}',?\n/;
            class Ji {}
            class Xi {
                constructor() {}
                build() {
                    return new XMLHttpRequest
                }
            }
            Xi.decorators = [{
                type: s.A
            }], Xi.ctorParameters = () => [];
            class Yi {
                constructor(e) {
                    this.xhrFactory = e
                }
                handle(e) {
                    if ("JSONP" === e.method) throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed.");
                    return new xn.a(t => {
                        const n = this.xhrFactory.build();
                        if (n.open(e.method, e.urlWithParams), e.withCredentials && (n.withCredentials = !0), e.headers.forEach((e, t) => n.setRequestHeader(e, t.join(","))), e.headers.has("Accept") || n.setRequestHeader("Accept", "application/json, text/plain, */*"), !e.headers.has("Content-Type")) {
                            const t = e.detectContentTypeHeader();
                            null !== t && n.setRequestHeader("Content-Type", t)
                        }
                        if (e.responseType) {
                            const t = e.responseType.toLowerCase();
                            n.responseType = "json" !== t ? t : "text"
                        }
                        const s = e.serializeBody();
                        let r = null;
                        const i = () => {
                                if (null !== r) return r;
                                const t = 1223 === n.status ? 204 : n.status,
                                    s = n.statusText || "OK",
                                    i = new Pi(n.getAllResponseHeaders()),
                                    o = function(e) {
                                        return "responseURL" in e && e.responseURL ? e.responseURL : /^X-Request-URL:/m.test(e.getAllResponseHeaders()) ? e.getResponseHeader("X-Request-URL") : null
                                    }(n) || e.url;
                                return r = new Li({
                                    headers: i,
                                    status: t,
                                    statusText: s,
                                    url: o
                                }), r
                            },
                            o = () => {
                                let {
                                    headers: s,
                                    status: r,
                                    statusText: o,
                                    url: a
                                } = i(), l = null;
                                204 !== r && (l = void 0 === n.response ? n.responseText : n.response), 0 === r && (r = l ? 200 : 0);
                                let c = r >= 200 && r < 300;
                                if ("json" === e.responseType && "string" == typeof l) {
                                    const e = l;
                                    l = l.replace(Zi, "");
                                    try {
                                        l = "" !== l ? JSON.parse(l) : null
                                    } catch (u) {
                                        l = e, c && (c = !1, l = {
                                            error: u,
                                            text: l
                                        })
                                    }
                                }
                                c ? (t.next(new Vi({
                                    body: l,
                                    headers: s,
                                    status: r,
                                    statusText: o,
                                    url: a || void 0
                                })), t.complete()) : t.error(new $i({
                                    error: l,
                                    headers: s,
                                    status: r,
                                    statusText: o,
                                    url: a || void 0
                                }))
                            },
                            a = e => {
                                const {
                                    url: s
                                } = i(), r = new $i({
                                    error: e,
                                    status: n.status || 0,
                                    statusText: n.statusText || "Unknown Error",
                                    url: s || void 0
                                });
                                t.error(r)
                            };
                        let l = !1;
                        const c = s => {
                                l || (t.next(i()), l = !0);
                                let r = {
                                    type: Ci.DownloadProgress,
                                    loaded: s.loaded
                                };
                                s.lengthComputable && (r.total = s.total), "text" === e.responseType && n.responseText && (r.partialText = n.responseText), t.next(r)
                            },
                            u = e => {
                                let n = {
                                    type: Ci.UploadProgress,
                                    loaded: e.loaded
                                };
                                e.lengthComputable && (n.total = e.total), t.next(n)
                            };
                        return n.addEventListener("load", o), n.addEventListener("error", a), e.reportProgress && (n.addEventListener("progress", c), null !== s && n.upload && n.upload.addEventListener("progress", u)), n.send(s), t.next({
                            type: Ci.Sent
                        }), () => {
                            n.removeEventListener("error", a), n.removeEventListener("load", o), e.reportProgress && (n.removeEventListener("progress", c), null !== s && n.upload && n.upload.removeEventListener("progress", u)), n.readyState !== n.DONE && n.abort()
                        }
                    })
                }
            }
            Yi.decorators = [{
                type: s.A
            }], Yi.ctorParameters = () => [{
                type: Ji
            }]
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            const eo = new s.B("XSRF_COOKIE_NAME"),
                to = new s.B("XSRF_HEADER_NAME");
            class no {}
            class so {
                constructor(e, t, n) {
                    this.doc = e, this.platform = t, this.cookieName = n, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0
                }
                getToken() {
                    if ("server" === this.platform) return null;
                    const e = this.doc.cookie || "";
                    return e !== this.lastCookieString && (this.parseCount++, this.lastToken = ye(e, this.cookieName), this.lastCookieString = e), this.lastToken
                }
            }
            so.decorators = [{
                type: s.A
            }], so.ctorParameters = () => [{
                type: void 0,
                decorators: [{
                    type: s.z,
                    args: [a]
                }]
            }, {
                type: String,
                decorators: [{
                    type: s.z,
                    args: [s.Q]
                }]
            }, {
                type: String,
                decorators: [{
                    type: s.z,
                    args: [eo]
                }]
            }];
            class ro {
                constructor(e, t) {
                    this.tokenService = e, this.headerName = t
                }
                intercept(e, t) {
                    const n = e.url.toLowerCase();
                    if ("GET" === e.method || "HEAD" === e.method || n.startsWith("http://") || n.startsWith("https://")) return t.handle(e);
                    const s = this.tokenService.getToken();
                    return null === s || e.headers.has(this.headerName) || (e = e.clone({
                        headers: e.headers.set(this.headerName, s)
                    })), t.handle(e)
                }
            }
            ro.decorators = [{
                type: s.A
            }], ro.ctorParameters = () => [{
                type: no
            }, {
                type: String,
                decorators: [{
                    type: s.z,
                    args: [to]
                }]
            }]
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            class io {
                constructor(e, t) {
                    this.backend = e, this.injector = t, this.chain = null
                }
                handle(e) {
                    if (null === this.chain) {
                        const e = this.injector.get(qi, []);
                        this.chain = e.reduceRight((e, t) => new Ui(e, t), this.backend)
                    }
                    return this.chain.handle(e)
                }
            }
            io.decorators = [{
                type: s.A
            }], io.ctorParameters = () => [{
                type: Di
            }, {
                type: s.C
            }];
            class oo {
                static disable() {
                    return {
                        ngModule: oo,
                        providers: [{
                            provide: ro,
                            useClass: zi
                        }]
                    }
                }
                static withOptions(e = {}) {
                    return {
                        ngModule: oo,
                        providers: [e.cookieName ? {
                            provide: eo,
                            useValue: e.cookieName
                        } : [], e.headerName ? {
                            provide: to,
                            useValue: e.headerName
                        } : []]
                    }
                }
            }
            oo.decorators = [{
                type: s.I,
                args: [{
                    providers: [ro, {
                        provide: qi,
                        useExisting: ro,
                        multi: !0
                    }, {
                        provide: no,
                        useClass: so
                    }, {
                        provide: eo,
                        useValue: "XSRF-TOKEN"
                    }, {
                        provide: to,
                        useValue: "X-XSRF-TOKEN"
                    }]
                }]
            }];
            class ao {}
            ao.decorators = [{
                type: s.I,
                args: [{
                    imports: [oo.withOptions({
                        cookieName: "XSRF-TOKEN",
                        headerName: "X-XSRF-TOKEN"
                    })],
                    providers: [Hi, {
                        provide: Ai,
                        useClass: io
                    }, Yi, {
                        provide: Di,
                        useExisting: Yi
                    }, Xi, {
                        provide: Ji,
                        useExisting: Xi
                    }]
                }]
            }];
            (class {}).decorators = [{
                type: s.I,
                args: [{
                    providers: [Ki, {
                        provide: Gi,
                        useFactory: function() {
                            return "object" == typeof window ? window : {}
                        }
                    }, {
                        provide: qi,
                        useClass: Qi,
                        multi: !0
                    }]
                }]
            }];
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            /**
             * @license
             * Copyright Google LLC All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            let lo = class {};
            lo = Cn([Object(s.n)({
                selector: "noindex",
                template: "<ng-content></ng-content>"
            })], lo);
            let co = class {};
            co = Cn([Object(s.I)({
                imports: [st],
                declarations: [lo],
                exports: [lo]
            })], co);
            let uo = class {
                constructor() {}
                ngAfterContentInit() {
                    var e = e || {};
                    (e = {
                        globeData: null,
                        globeKitView: null,
                        globeKitContainer: null,
                        introDone: !1,
                        camPower: 0,
                        camZ: 42,
                        lowRes: !1,
                        init: function(t) {
                            e.globeKitContainer = document.getElementById("globekit-canvas-container"), e.lowRes = "ontouchstart" in document.documentElement, e.globeKitView = new GK.View({
                                canvas: document.getElementById("globekit-canvas"),
                                textureDir: "/wp-content/themes/piano/frontend/images/globekit",
                                modelsDir: "/wp-content/themes/piano/frontend/globekit-bin",
                                sceneOffset: vec2.fromValues(.33, 0),
                                clearColor: vec4.fromValues(249 / 255, 249 / 255, 249 / 255, 1),
                                antialias: !1,
                                alpha: !1,
                                lowRes: e.lowRes,
                                onload: function() {
                                    e.playIntroAnimation()
                                }
                            }), e.globeData = new GlobeData(e.globeKitView), GlobeData.processData(), e.windowDidResize(), e.addEventListeners(), e.configureDrawables()
                        },
                        addCities: function() {
                            for (var t = [], n = 0; n < GlobeDataCities.length; n++) {
                                var s = GlobeDataCities[n],
                                    r = vec3.fromValues(s.rectifiedPos[0], s.rectifiedPos[1], s.rectifiedPos[2]);
                                t.push(r)
                            }
                            e.globeKitView.addPoints(t)
                        },
                        addEventListeners: function() {
                            window.addEventListener("resize", GK.debounce(function() {
                                e.windowDidResize()
                            }, 75)), window.addEventListener("orientationchange", function() {
                                e.windowDidResize()
                            }), window.addEventListener("mousemove", function(t) {
                                if (e.introDone) {
                                    var n = .5 * e.globeKitView.canvas.width + .165 * e.globeKitView.canvas.width,
                                        s = .5 * e.globeKitView.canvas.height,
                                        r = vec2.fromValues(t.clientX, t.clientY),
                                        i = vec2.fromValues(n, s),
                                        o = 1 - vec2.distance(r, i) / e.globeKitView.canvas.width;
                                    o = GK.Ease.smoothstep(.5, 1, o), e.globeKitView.scene.camTargetZ = e.camZ - 3 * o * e.camPower
                                }
                            })
                        },
                        windowDidResize: function() {
                            var t = e.globeKitContainer.offsetWidth,
                                n = e.globeKitContainer.offsetHeight;
                            e.globeKitView.canvas.width = t, e.globeKitView.canvas.height = n, e.globeKitView.resize(), e.globeKitView.scene.globe.pointSize = e.getGlobePointSize(), window.innerWidth < 768 ? (e.globeKitView.scene.camera.sceneOffset = vec2.fromValues(0, .25), e.globeKitView.scene.camTargetZ = 62, e.camZ = 62) : (e.globeKitView.scene.camera.sceneOffset = vec2.fromValues(.33, 0), e.globeKitView.scene.camTargetZ = 42, e.camZ = 42)
                        },
                        getGlobePointSize: function() {
                            var t = .00185 * e.globeKitView.canvas.height;
                            return e.lowRes && (t *= 1.5), t
                        },
                        configureDrawables: function() {
                            var t = e.globeKitView.scene;
                            t.camera.position = vec3.fromValues(0, 0, e.camZ);
                            vec3.fromValues(1, 1, 1);
                            var n = vec3.fromValues(100 / 255, 100 / 255, 100 / 255),
                                s = vec3.fromValues(200 / 255, 200 / 255, 200 / 255),
                                r = (vec3.fromValues(135 / 255, 140 / 255, 157 / 255), vec3.fromValues(18 / 255, 53 / 255, 144 / 255));
                            t.globe.alpha = 0, t.globe.noisePower = 12, t.points.alpha = 0, t.quad.alpha = 0, t.dimension.alpha = 0, t.publisherEvent.progress = 0, t.globe.pointSize = e.getGlobePointSize(), t.globe.color1 = s, t.globe.color2 = s, t.globe.crestColor = n, t.globe.takeoverColor = r, t.globe.scatterColor = n, t.points.color1 = n, t.points.pointSize = 20, t.epicenter.color1 = n, t.epicenter.color2 = n
                        },
                        playIntroAnimation: function() {
                            e.globeKitContainer.style.visibility = "visible";
                            var t = e.globeKitView.scene;
                            t.setYawPitch(1.5, -.6), t.globe.offsetPower = 1;
                            var n = t.globe.offsetPower,
                                s = 0 - n,
                                r = 1.2 * t.globe.pointSize,
                                i = t.globe.pointSize - r,
                                o = .75 * e.camZ,
                                a = e.camZ - o,
                                l = t.globe.noisePower,
                                c = 2 - l;
                            t.yawSpeed = .03, t.pitchSpeed = -4e-4;
                            var u = !1,
                                h = !1,
                                p = new GK.Animation(4.2);
                            p.updateFn = function(p) {
                                var d = GK.Ease.inOutQuad(p),
                                    f = GK.Ease.smoothstep(0, .3, p);
                                t.yawSpeed = -(.03 - .03 * GK.Ease.outSine(p)), t.pitchSpeed = -(4e-4 - 4e-4 * GK.Ease.outSine(p));
                                var m = GK.Ease.smoothstep(.56, 1, d),
                                    g = GK.Ease.smoothstep(.56, 1, d);
                                t.globe.offsetPower = n + g * s, t.globe.pointSize = r + m * i, t.globe.alpha = f;
                                var y = GK.Ease.smoothstep(.75, 1, d);
                                t.globe.noisePower = l + y * c;
                                var v = GK.Ease.smoothstep(.6, 1, d);
                                e.camZ = o + v * a, e.globeKitView.scene.camera.position = vec3.fromValues(0, 0, e.camZ);
                                var _ = GK.Ease.smoothstep(.7, .9, p);
                                t.dimension.alpha = _, t.quad.alpha = _, t.points.alpha = _, p > .1 && !u && (e.globeKitView.pulse(.4, .25, 0, 4), u = !0), p > .8 && !h && (e.globeData.start(), h = !0)
                            }, p.completeFn = function() {
                                e.introDone = !0, p = null;
                                var n = vec3.fromValues(157 / 255, 166 / 255, 196 / 255);
                                t.globe.crestColor = n;
                                var s = new GK.Animation(2);
                                s.updateFn = function(t) {
                                    e.camPower = t
                                }, s.start()
                            }, p.start()
                        },
                        destroy: function() {
                            for (var t = e.globeKitView.attachedElements, n = 0; n < t.length; n++) {
                                var s = t[n];
                                s.parentNode.removeChild(s)
                            }
                            clearTimeout(e.unfocusTimeout), e.globeKitView.destroy(), delete e.globeKitView
                        }
                    }).init()
                }
            };
            uo.ctorParameters = () => [], uo = Cn([Object(s.n)({
                selector: "globe-hero",
                template: "<div><ng-content></ng-content></div>"
            }), Sn("design:paramtypes", [])], uo);
            class ho {
                constructor(e, t) {
                    this.compare = e, this.keySelector = t
                }
                call(e, t) {
                    return t.subscribe(new po(e, this.compare, this.keySelector))
                }
            }
            class po extends Si.a {
                constructor(e, t, n) {
                    super(e), this.keySelector = n, this.hasKey = !1, "function" == typeof t && (this.compare = t)
                }
                compare(e, t) {
                    return e === t
                }
                _next(e) {
                    let t;
                    try {
                        const {
                            keySelector: n
                        } = this;
                        t = n ? n(e) : e
                    } catch (s) {
                        return this.destination.error(s)
                    }
                    let n = !1;
                    if (this.hasKey) try {
                        const {
                            compare: e
                        } = this;
                        n = e(this.key, t)
                    } catch (s) {
                        return this.destination.error(s)
                    } else this.hasKey = !0;
                    n || (this.key = t, this.destination.next(e))
                }
            }
            let fo = class {
                constructor(e) {
                    this.ngZone = e, this.destroy$ = new Yr.a, this.maxOpacity = .25, this.minOpacity = 0, this.scroll$ = ti(document, "scroll")
                }
                ngAfterViewInit() {
                    this.shadowhost && (window.innerWidth <= 760 ? this.shadow.nativeElement.style.opacity = this.minOpacity.toString() : (this.shadowHostNode = document.querySelector(`[data-hero-shadow-host=${this.shadowhost}]`), this.windowHeight = window.innerHeight, this.shadow.nativeElement.style.opacity = this.maxOpacity.toString(), this.ngZone.runOutsideAngular(() => {
                        var e, t;
                        this.scroll$.pipe(di(this.destroy$), gi(() => ci(10)), Object(An.a)(() => {
                            let e = this.shadowHostNode.getBoundingClientRect(),
                                t = this.windowHeight - e.bottom;
                            if (e.bottom < 0) return this.minOpacity;
                            if (t < 0) return this.maxOpacity;
                            if (t > 0 && e.bottom > 0) {
                                let e = t / this.windowHeight;
                                return (this.maxOpacity * (1 - e)).toFixed(5)
                            }
                        }), (e = (e, t) => e === t, n => n.lift(new ho(e, t)))).subscribe(e => {
                            this.shadow.nativeElement.style.opacity = e ? e.toString() : "0"
                        })
                    })))
                }
                ngOnDestroy() {
                    this.destroy$.next(), this.destroy$.complete()
                }
            };
            fo.ctorParameters = () => [{
                type: s.M
            }], fo.propDecorators = {
                shadowhost: [{
                    type: s.D
                }],
                shadow: [{
                    type: s.gb,
                    args: ["shadow"]
                }]
            }, fo = Cn([Object(s.n)({
                selector: "hero-shadow",
                template: '<div #shadow class="shadow"></div>',
                styles: ['\n    .shadow {\n      content: "";\n      display: none;\n      position: absolute;\n      width: 100%;\n      z-index: 2;\n      top: 100vh;\n      height: 100vh;\n      background-color: #101820;\n    }\n\n    @media (min-width: 768px) {\n        .shadow {\n            display: block;\n        }\n    }\n  ']
            }), Sn("design:paramtypes", [s.M])], fo);
            const mo = {
                provide: On,
                useExisting: Object(s.lb)(() => go),
                multi: !0
            };
            let go = class {
                constructor() {
                    this.options = [], this.onSelect = new s.v, this.selected = {}
                }
                select(e) {
                    this.selected = e, this.onSelect.emit(e), this.onChangeCallback(e)
                }
                writeValue(e) {
                    e && (this.selected = e)
                }
                registerOnChange(e) {
                    this.onChangeCallback = e
                }
                registerOnTouched(e) {
                    this.onTouchedCallback = e
                }
                setDisabledState() {}
            };
            go.propDecorators = {
                title: [{
                    type: s.D
                }],
                options: [{
                    type: s.D
                }],
                onSelect: [{
                    type: s.O
                }]
            }, go = Cn([Object(s.n)({
                selector: "marketing-select",
                template: '<div>\r\n  <input  readonly [value]="selected.label || \'\'"\r\n         class="request-demo__form-input contact-us__form-input pn-input pn-input--flat pn-input--pointer" placeholder="{{selected.label || title}}">\r\n  <div>\r\n    <ul class="pn-marketing-dropdown__body">\r\n      <li\r\n        *ngFor="let option of options"\r\n        (click)="select(option)"\r\n        [class.pn-marketing-dropdown__item--active]="option.value === selected.value"\r\n        class="pn-marketing-dropdown__item pn-marketing-dropdown__item--hoverable pn-marketing-text">\r\n        <span>{{option.label}}</span>\r\n      </li>\r\n    </ul>\r\n  </div>\r\n</div>\r\n',
                providers: [mo],
                styles: [""]
            })], go);
            let yo = class {
                constructor() {
                    this.options = [], this.onSelect = new s.v, this.selected = {}, this.locationList = [{
                        value: null,
                        label: "Everywhere",
                        entry: []
                    }]
                }
                ngOnInit() {
                    this.selected = this.locationList[0], this.setDropdownShiftX()
                }
                ngOnChanges() {
                    this.setLocationsList(this.options)
                }
                select(e) {
                    this.selected = e, this.onSelect.emit(e)
                }
                setLocationsList(e) {
                    if (e)
                        for (let t = 0; t < e.length; t++) this.locationList.push({
                            value: e[t],
                            label: e[t],
                            entry: [e[t]]
                        }), this.locationList[0].entry.push(e[t])
                }
                setDropdownShiftX() {
                    this.dropdownShiftX = document.documentElement.clientWidth < 1223 ? 0 : -43
                }
            };
            yo.propDecorators = {
                defaultTitle: [{
                    type: s.D
                }],
                options: [{
                    type: s.D
                }],
                onSelect: [{
                    type: s.O
                }]
            }, yo = Cn([Object(s.n)({
                selector: "jobs-location-select",
                template: '<div>\r\n    <span  class="pn-jobs-location-dropdown__title">\r\n        <span class="pn-jobs-location-dropdown__title-text">{{selected.label || defaultTitle}}</span>\r\n        <span class="pn-jobs-location-dropdown__title-icon pn-icon pn-icon--down"></span>\r\n    </span>\r\n    <div class="pn-jobs-location-dropdown__body">\r\n        <ul class="pn-jobs-location-dropdown__list">\r\n            <li\r\n                *ngFor="let option of locationList"\r\n                (click)="select(option)"\r\n                [class.active]="option.value === selected.value"\r\n                class="pn-jobs-location-dropdown__item pn-jobs-location-dropdown__item--hoverable pn-marketing-text">\r\n                <span class="pn-jobs-location-dropdown__label">{{option.label}}</span>\r\n            </li>\r\n        </ul>\r\n    </div>\r\n</div>\r\n',
                styles: [""]
            })], yo);
            let vo = class {
                constructor() {
                    this.regExpObj = {
                        regExpr: /<[^>]*>/g,
                        doubleSpaces: /\s{2,}/g,
                        vacancyStart: /position overview\s|role description\s/i,
                        space: /&nbsp;/g,
                        gt_and_lt: /&lt;(.*?)&gt;/gi,
                        gt: /(&gt;)/g,
                        lt: /(&lt;)/g
                    }, this.replaceKeyword = "PNREPLACE"
                }
                transform(e, t, n = this.regExpObj.regExpr, s = this.regExpObj.doubleSpaces, r = this.regExpObj.vacancyStart) {
                    let i = e.replace(n, " ").replace(s, " "),
                        o = i.match(r),
                        a = o ? o.index + o[0].length : 0,
                        l = i.slice(a).split(" ");
                    return l.length = t, l.join(" ") + "..."
                }
            };
            vo = Cn([Object(s.S)({
                name: "getFirstDescription"
            })], vo);
            let _o = new s.B("app.config");
            const bo = {
                wpApiUrl: "/wp-json/piano/v1",
                wpApiUrlDefault: "/wp-json/wp/v2",
                themeUrl: "/wp-content/themes/piano"
            };
            /**
             * @license Angular v8.0.0-beta.10+1.sha-a28b3e3
             * (c) 2010-2019 Google LLC. https://angular.io/
             * License: MIT
             */
            class wo {
                constructor() {}
                build() {
                    return new XMLHttpRequest
                }
            }
            wo.decorators = [{
                type: s.A
            }], wo.ctorParameters = () => []
            /**
             * @license
             * Copyright Google Inc. All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            const Eo = {
                Get: 0,
                Post: 1,
                Put: 2,
                Delete: 3,
                Options: 4,
                Head: 5,
                Patch: 6
            };
            Eo[Eo.Get] = "Get", Eo[Eo.Post] = "Post", Eo[Eo.Put] = "Put", Eo[Eo.Delete] = "Delete", Eo[Eo.Options] = "Options", Eo[Eo.Head] = "Head", Eo[Eo.Patch] = "Patch";
            const Co = {
                Unsent: 0,
                Open: 1,
                HeadersReceived: 2,
                Loading: 3,
                Done: 4,
                Cancelled: 5
            };
            Co[Co.Unsent] = "Unsent", Co[Co.Open] = "Open", Co[Co.HeadersReceived] = "HeadersReceived", Co[Co.Loading] = "Loading", Co[Co.Done] = "Done", Co[Co.Cancelled] = "Cancelled";
            const So = {
                Basic: 0,
                Cors: 1,
                Default: 2,
                Error: 3,
                Opaque: 4
            };
            So[So.Basic] = "Basic", So[So.Cors] = "Cors", So[So.Default] = "Default", So[So.Error] = "Error", So[So.Opaque] = "Opaque";
            const xo = {
                NONE: 0,
                JSON: 1,
                FORM: 2,
                FORM_DATA: 3,
                TEXT: 4,
                BLOB: 5,
                ARRAY_BUFFER: 6
            };
            xo[xo.NONE] = "NONE", xo[xo.JSON] = "JSON", xo[xo.FORM] = "FORM", xo[xo.FORM_DATA] = "FORM_DATA", xo[xo.TEXT] = "TEXT", xo[xo.BLOB] = "BLOB", xo[xo.ARRAY_BUFFER] = "ARRAY_BUFFER";
            const To = {
                Text: 0,
                Json: 1,
                ArrayBuffer: 2,
                Blob: 3
            };
            To[To.Text] = "Text", To[To.Json] = "Json", To[To.ArrayBuffer] = "ArrayBuffer", To[To.Blob] = "Blob";
            /**
             * @license
             * Copyright Google Inc. All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            class Ao {
                constructor(e) {
                    this._headers = new Map, this._normalizedNames = new Map, e && (e instanceof Ao ? e.forEach((e, t) => {
                        e.forEach(e => this.append(t, e))
                    }) : Object.keys(e).forEach(t => {
                        const n = Array.isArray(e[t]) ? e[t] : [e[t]];
                        this.delete(t), n.forEach(e => this.append(t, e))
                    }))
                }
                static fromResponseHeaderString(e) {
                    const t = new Ao;
                    return e.split("\n").forEach(e => {
                        const n = e.indexOf(":");
                        if (n > 0) {
                            const s = e.slice(0, n),
                                r = e.slice(n + 1).trim();
                            t.set(s, r)
                        }
                    }), t
                }
                append(e, t) {
                    const n = this.getAll(e);
                    null === n ? this.set(e, t) : n.push(t)
                }
                delete(e) {
                    const t = e.toLowerCase();
                    this._normalizedNames.delete(t), this._headers.delete(t)
                }
                forEach(e) {
                    this._headers.forEach((t, n) => e(t, this._normalizedNames.get(n), this._headers))
                }
                get(e) {
                    const t = this.getAll(e);
                    return null === t ? null : t.length > 0 ? t[0] : null
                }
                has(e) {
                    return this._headers.has(e.toLowerCase())
                }
                keys() {
                    return Array.from(this._normalizedNames.values())
                }
                set(e, t) {
                    Array.isArray(t) ? t.length && this._headers.set(e.toLowerCase(), [t.join(",")]) : this._headers.set(e.toLowerCase(), [t]), this.mayBeSetNormalizedName(e)
                }
                values() {
                    return Array.from(this._headers.values())
                }
                toJSON() {
                    const e = {};
                    return this._headers.forEach((t, n) => {
                        const s = [];
                        t.forEach(e => s.push(...e.split(","))), e[this._normalizedNames.get(n)] = s
                    }), e
                }
                getAll(e) {
                    return this.has(e) && this._headers.get(e.toLowerCase()) || null
                }
                entries() {
                    throw new Error('"entries" method is not implemented on Headers class')
                }
                mayBeSetNormalizedName(e) {
                    const t = e.toLowerCase();
                    this._normalizedNames.has(t) || this._normalizedNames.set(t, e)
                }
            }
            class Do {
                constructor(e = {}) {
                    const {
                        body: t,
                        status: n,
                        headers: s,
                        statusText: r,
                        type: i,
                        url: o
                    } = e;
                    this.body = null != t ? t : null, this.status = null != n ? n : null, this.headers = null != s ? s : null, this.statusText = null != r ? r : null, this.type = null != i ? i : null, this.url = null != o ? o : null
                }
                merge(e) {
                    return new Do({
                        body: e && null != e.body ? e.body : this.body,
                        status: e && null != e.status ? e.status : this.status,
                        headers: e && null != e.headers ? e.headers : this.headers,
                        statusText: e && null != e.statusText ? e.statusText : this.statusText,
                        type: e && null != e.type ? e.type : this.type,
                        url: e && null != e.url ? e.url : this.url
                    })
                }
            }
            class Po extends Do {
                constructor() {
                    super({
                        status: 200,
                        statusText: "Ok",
                        type: So.Default,
                        headers: new Ao
                    })
                }
            }
            Po.decorators = [{
                type: s.A
            }], Po.ctorParameters = () => []
            /**
             * @license
             * Copyright Google Inc. All Rights Reserved.
             *
             * Use of this source code is governed by an MIT-style license that can be
             * found in the LICENSE file at https://angular.io/license
             */
            ;
            class ko {}
            class Oo {}

            function Io(e) {
                if ("string" != typeof e) return e;
                switch (e.toUpperCase()) {
                    case "GET":
                        return Eo.Get;
                    case "POST":
                        return Eo.Post;
                    case "PUT":
                        return Eo.Put;
                    case "DELETE":
                        return Eo.Delete;
                    case "OPTIONS":
                        return Eo.Options;
                    case "HEAD":
                        return Eo.Head;
                    case "PATCH":
                        return Eo.Patch
                }
                throw new Error(`Invalid request method. The method "${e}" is not supported.`)
            }
            class No {
                encodeKey(e) {
                    return Mo(e)
                }
                encodeValue(e) {
                    return Mo(e)
                }
            }

            function Mo(e) {
                return encodeURIComponent(e).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/gi, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%2B/gi, "+").replace(/%3D/gi, "=").replace(/%3F/gi, "?").replace(/%2F/gi, "/")
            }
            class Fo {
                constructor(e = "", t = new No) {
                    this.rawParams = e, this.queryEncoder = t, this.paramsMap =
                        /**
                         * @license
                         * Copyright Google Inc. All Rights Reserved.
                         *
                         * Use of this source code is governed by an MIT-style license that can be
                         * found in the LICENSE file at https://angular.io/license
                         */
                        function(e = "") {
                            const t = new Map;
                            e.length > 0 && e.split("&").forEach(e => {
                                const n = e.indexOf("="),
                                    [s, r] = -1 == n ? [e, ""] : [e.slice(0, n), e.slice(n + 1)],
                                    i = t.get(s) || [];
                                i.push(r), t.set(s, i)
                            });
                            return t
                        }(e)
                }
                clone() {
                    const e = new Fo("", this.queryEncoder);
                    return e.appendAll(this), e
                }
                has(e) {
                    return this.paramsMap.has(e)
                }
                get(e) {
                    const t = this.paramsMap.get(e);
                    return Array.isArray(t) ? t[0] : null
                }
                getAll(e) {
                    return this.paramsMap.get(e) || []
                }
                set(e, t) {
                    if (null == t) return void this.delete(e);
                    const n = this.paramsMap.get(e) || [];
                    n.length = 0, n.push(t), this.paramsMap.set(e, n)
                }
                setAll(e) {
                    e.paramsMap.forEach((e, t) => {
                        const n = this.paramsMap.get(t) || [];
                        n.length = 0, n.push(e[0]), this.paramsMap.set(t, n)
                    })
                }
                append(e, t) {
                    if (null == t) return;
                    const n = this.paramsMap.get(e) || [];
                    n.push(t), this.paramsMap.set(e, n)
                }
                appendAll(e) {
                    e.paramsMap.forEach((e, t) => {
                        const n = this.paramsMap.get(t) || [];
                        for (let s = 0; s < e.length; ++s) n.push(e[s]);
                        this.paramsMap.set(t, n)
                    })
                }
                replaceAll(e) {
                    e.paramsMap.forEach((e, t) => {
                        const n = this.paramsMap.get(t) || [];
                        n.length = 0;
                        for (let s = 0; s < e.length; ++s) n.push(e[s]);
                        this.paramsMap.set(t, n)
                    })
                }
                toString() {
                    const e = [];
                    return this.paramsMap.forEach((t, n) => {
                        t.forEach(t => e.push(this.queryEncoder.encodeKey(n) + "=" + this.queryEncoder.encodeValue(t)))
                    }), e.join("&")
                }
                delete(e) {
                    this.paramsMap.delete(e)
                }
            }
            class Ro {
                json() {
                    return "string" == typeof this._body ? JSON.parse(this._body) : this._body instanceof ArrayBuffer ? JSON.parse(this.text()) : this._body
                }
                text(e = "legacy") {
                    if (this._body instanceof Fo) return this._body.toString();
                    if (this._body instanceof ArrayBuffer) switch (e) {
                        case "legacy":
                            return String.fromCharCode.apply(null, new Uint16Array(this._body));
                        case "iso-8859":
                            return String.fromCharCode.apply(null, new Uint8Array(this._body));
                        default:
                            throw new Error(`Invalid value for encodingHint: ${e}`)
                    }
                    return null == this._body ? "" : "object" == typeof this._body ? JSON.stringify(this._body, null, 2) : this._body.toString()
                }
                arrayBuffer() {
                    return this._body instanceof ArrayBuffer ? this._body : function(e) {
                        const t = new Uint16Array(e.length);
                        for (let n = 0, s = e.length; n < s; n++) t[n] = e.charCodeAt(n);
                        return t.buffer
                    }(this.text())
                }
                blob() {
                    if (this._body instanceof Blob) return this._body;
                    if (this._body instanceof ArrayBuffer) return new Blob([this._body]);
                    throw new Error("The request body isn't either a blob or an array buffer")
                }
            }
            class jo extends Ro {
                constructor(e) {
                    super(), this._body = e.body, this.status = e.status, this.ok = this.status >= 200 && this.status <= 299, this.statusText = e.statusText, this.headers = e.headers, this.type = e.type, this.url = e.url
                }
                toString() {
                    return `Response with status: ${this.status} ${this.statusText} for URL: ${this.url}`
                }
            }
            let Lo = 0;
            const Vo = "__ng_jsonp__";
            let $o = null;

            function Bo() {
                const e = "object" == typeof window ? window : {};
                return null === $o && ($o = e[Vo] = {}), $o
            }
            class Ho {
                build(e) {
                    const t = document.createElement("script");
                    return t.src = e, t
                }
                nextRequestID() {
                    return "__req" + Lo++
                }
                requestCallback(e) {
                    return `__ng_jsonp__.${e}.finished`
                }
                exposeConnection(e, t) {
                    Bo()[e] = t
                }
                removeConnection(e) {
                    Bo()[e] = null
                }
                send(e) {
                    document.body.appendChild(e)
                }
                cleanup(e) {
                    e.parentNode && e.parentNode.removeChild(e)
                }
            }
            Ho.decorators = [{
                type: s.A
            }];
            class Uo {
                constructor(e, t, n) {
                    if (this._dom = t, this.baseResponseOptions = n, this._finished = !1, e.method !== Eo.Get) throw new TypeError("JSONP requests must use GET request method.");
                    this.request = e, this.response = new xn.a(s => {
                        this.readyState = Co.Loading;
                        const r = this._id = t.nextRequestID();
                        t.exposeConnection(r, this);
                        const i = t.requestCallback(this._id);
                        let o = e.url;
                        o.indexOf("=JSONP_CALLBACK&") > -1 ? o = o.replace("=JSONP_CALLBACK&", `=${i}&`) : o.lastIndexOf("=JSONP_CALLBACK") === o.length - "=JSONP_CALLBACK".length && (o = o.substring(0, o.length - "=JSONP_CALLBACK".length) + `=${i}`);
                        const a = this._script = t.build(o),
                            l = e => {
                                if (this.readyState === Co.Cancelled) return;
                                if (this.readyState = Co.Done, t.cleanup(a), !this._finished) {
                                    let e = new Do({
                                        body: "JSONP injected script did not invoke callback.",
                                        type: So.Error,
                                        url: o
                                    });
                                    return n && (e = n.merge(e)), void s.error(new jo(e))
                                }
                                let r = new Do({
                                    body: this._responseData,
                                    url: o
                                });
                                this.baseResponseOptions && (r = this.baseResponseOptions.merge(r)), s.next(new jo(r)), s.complete()
                            },
                            c = e => {
                                if (this.readyState === Co.Cancelled) return;
                                this.readyState = Co.Done, t.cleanup(a);
                                let r = new Do({
                                    body: e.message,
                                    type: So.Error
                                });
                                n && (r = n.merge(r)), s.error(new jo(r))
                            };
                        return a.addEventListener("load", l), a.addEventListener("error", c), t.send(a), () => {
                            this.readyState = Co.Cancelled, a.removeEventListener("load", l), a.removeEventListener("error", c), this._dom.cleanup(a)
                        }
                    })
                }
                finished(e) {
                    this._finished = !0, this._dom.removeConnection(this._id), this.readyState !== Co.Cancelled && (this._responseData = e)
                }
            }
            class qo extends ko {
                constructor(e, t) {
                    super(), this._browserJSONP = e, this._baseResponseOptions = t
                }
                createConnection(e) {
                    return new Uo(e, this._browserJSONP, this._baseResponseOptions)
                }
            }
            qo.decorators = [{
                type: s.A
            }], qo.ctorParameters = () => [{
                type: Ho
            }, {
                type: Do
            }];
            const zo = /^\)\]\}',?\n/;
            class Wo {
                constructor(e, t, n) {
                    this.request = e, this.response = new xn.a(s => {
                        const r = t.build();
                        r.open(Eo[e.method].toUpperCase(), e.url), null != e.withCredentials && (r.withCredentials = e.withCredentials);
                        const i = () => {
                                let t = 1223 === r.status ? 204 : r.status,
                                    i = null;
                                204 !== t && (i = void 0 === r.response ? r.responseText : r.response, "string" == typeof i && (i = i.replace(zo, ""))), 0 === t && (t = i ? 200 : 0);
                                const o = Ao.fromResponseHeaderString(r.getAllResponseHeaders()),
                                    a = ("responseURL" in (l = r) ? l.responseURL : /^X-Request-URL:/m.test(l.getAllResponseHeaders()) ? l.getResponseHeader("X-Request-URL") : null) || e.url;
                                var l;
                                const c = r.statusText || "OK";
                                let u = new Do({
                                    body: i,
                                    status: t,
                                    headers: o,
                                    statusText: c,
                                    url: a
                                });
                                null != n && (u = n.merge(u));
                                const h = new jo(u);
                                if (h.ok = (e => e >= 200 && e < 300)(t), h.ok) return s.next(h), void s.complete();
                                s.error(h)
                            },
                            o = e => {
                                let t = new Do({
                                    body: e,
                                    type: So.Error,
                                    status: r.status,
                                    statusText: r.statusText
                                });
                                null != n && (t = n.merge(t)), s.error(new jo(t))
                            };
                        if (this.setDetectedContentType(e, r), null == e.headers && (e.headers = new Ao), e.headers.has("Accept") || e.headers.append("Accept", "application/json, text/plain, */*"), e.headers.forEach((e, t) => r.setRequestHeader(t, e.join(","))), null != e.responseType && null != r.responseType) switch (e.responseType) {
                            case To.ArrayBuffer:
                                r.responseType = "arraybuffer";
                                break;
                            case To.Json:
                                r.responseType = "json";
                                break;
                            case To.Text:
                                r.responseType = "text";
                                break;
                            case To.Blob:
                                r.responseType = "blob";
                                break;
                            default:
                                throw new Error("The selected responseType is not supported")
                        }
                        return r.addEventListener("load", i), r.addEventListener("error", o), r.send(this.request.getBody()), () => {
                            r.removeEventListener("load", i), r.removeEventListener("error", o), r.abort()
                        }
                    })
                }
                setDetectedContentType(e, t) {
                    if (null == e.headers || null == e.headers.get("Content-Type")) switch (e.contentType) {
                        case xo.NONE:
                            break;
                        case xo.JSON:
                            t.setRequestHeader("content-type", "application/json");
                            break;
                        case xo.FORM:
                            t.setRequestHeader("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
                            break;
                        case xo.TEXT:
                            t.setRequestHeader("content-type", "text/plain");
                            break;
                        case xo.BLOB:
                            const n = e.blob();
                            n.type && t.setRequestHeader("content-type", n.type)
                    }
                }
            }
            class Go {
                constructor(e = "XSRF-TOKEN", t = "X-XSRF-TOKEN") {
                    this._cookieName = e, this._headerName = t
                }
                configureRequest(e) {
                    const t = o().getCookie(this._cookieName);
                    t && e.headers.set(this._headerName, t)
                }
            }
            class Ko {
                constructor(e, t, n) {
                    this._browserXHR = e, this._baseResponseOptions = t, this._xsrfStrategy = n
                }
                createConnection(e) {
                    return this._xsrfStrategy.configureRequest(e), new Wo(e, this._browserXHR, this._baseResponseOptions)
                }
            }
            Ko.decorators = [{
                type: s.A
            }], Ko.ctorParameters = () => [{
                type: wo
            }, {
                type: Do
            }, {
                type: Oo
            }];
            class Qo {
                get search() {
                    return this.params
                }
                set search(e) {
                    this.params = e
                }
                constructor(e = {}) {
                    const {
                        method: t,
                        headers: n,
                        body: s,
                        url: r,
                        search: i,
                        params: o,
                        withCredentials: a,
                        responseType: l
                    } = e;
                    this.method = null != t ? Io(t) : null, this.headers = null != n ? n : null, this.body = null != s ? s : null, this.url = null != r ? r : null, this.params = this._mergeSearchParams(o || i), this.withCredentials = null != a ? a : null, this.responseType = null != l ? l : null
                }
                merge(e) {
                    return new Qo({
                        method: e && null != e.method ? e.method : this.method,
                        headers: e && null != e.headers ? e.headers : new Ao(this.headers),
                        body: e && null != e.body ? e.body : this.body,
                        url: e && null != e.url ? e.url : this.url,
                        params: e && this._mergeSearchParams(e.params || e.search),
                        withCredentials: e && null != e.withCredentials ? e.withCredentials : this.withCredentials,
                        responseType: e && null != e.responseType ? e.responseType : this.responseType
                    })
                }
                _mergeSearchParams(e) {
                    return e ? e instanceof Fo ? e.clone() : "string" == typeof e ? new Fo(e) : this._parseParams(e) : this.params
                }
                _parseParams(e = {}) {
                    const t = new Fo;
                    return Object.keys(e).forEach(n => {
                        const s = e[n];
                        Array.isArray(s) ? s.forEach(e => this._appendParam(n, e, t)) : this._appendParam(n, s, t)
                    }), t
                }
                _appendParam(e, t, n) {
                    "string" != typeof t && (t = JSON.stringify(t)), n.append(e, t)
                }
            }
            class Zo extends Qo {
                constructor() {
                    super({
                        method: Eo.Get,
                        headers: new Ao
                    })
                }
            }
            Zo.decorators = [{
                type: s.A
            }], Zo.ctorParameters = () => [];
            class Jo extends Ro {
                constructor(e) {
                    super();
                    const t = e.url;
                    this.url = e.url;
                    const n = e.params || e.search;
                    if (n) {
                        let e;
                        if (e = "object" != typeof n || n instanceof Fo ? n.toString() : function(e) {
                                const t = new Fo;
                                return Object.keys(e).forEach(n => {
                                    const s = e[n];
                                    s && Array.isArray(s) ? s.forEach(e => t.append(n, e.toString())) : t.append(n, s.toString())
                                }), t
                            }(n).toString(), e.length > 0) {
                            let n = "?"; - 1 != this.url.indexOf("?") && (n = "&" == this.url[this.url.length - 1] ? "" : "&"), this.url = t + n + e
                        }
                    }
                    this._body = e.body, this.method = Io(e.method), this.headers = new Ao(e.headers), this.contentType = this.detectContentType(), this.withCredentials = e.withCredentials, this.responseType = e.responseType
                }
                detectContentType() {
                    switch (this.headers.get("content-type")) {
                        case "application/json":
                            return xo.JSON;
                        case "application/x-www-form-urlencoded":
                            return xo.FORM;
                        case "multipart/form-data":
                            return xo.FORM_DATA;
                        case "text/plain":
                        case "text/html":
                            return xo.TEXT;
                        case "application/octet-stream":
                            return this._body instanceof na ? xo.ARRAY_BUFFER : xo.BLOB;
                        default:
                            return this.detectContentTypeFromBody()
                    }
                }
                detectContentTypeFromBody() {
                    return null == this._body ? xo.NONE : this._body instanceof Fo ? xo.FORM : this._body instanceof ea ? xo.FORM_DATA : this._body instanceof ta ? xo.BLOB : this._body instanceof na ? xo.ARRAY_BUFFER : this._body && "object" == typeof this._body ? xo.JSON : xo.TEXT
                }
                getBody() {
                    switch (this.contentType) {
                        case xo.JSON:
                        case xo.FORM:
                            return this.text();
                        case xo.FORM_DATA:
                            return this._body;
                        case xo.TEXT:
                            return this.text();
                        case xo.BLOB:
                            return this.blob();
                        case xo.ARRAY_BUFFER:
                            return this.arrayBuffer();
                        default:
                            return null
                    }
                }
            }
            const Xo = function() {},
                Yo = "object" == typeof window ? window : Xo,
                ea = Yo.FormData || Xo,
                ta = Yo.Blob || Xo,
                na = Yo.ArrayBuffer || Xo;

            function sa(e, t) {
                return e.createConnection(t).response
            }

            function ra(e, t, n, s) {
                const r = e;
                return t ? r.merge(new Qo({
                    method: t.method || n,
                    url: t.url || s,
                    search: t.search,
                    params: t.params,
                    headers: t.headers,
                    body: t.body,
                    withCredentials: t.withCredentials,
                    responseType: t.responseType
                })) : r.merge(new Qo({
                    method: n,
                    url: s
                }))
            }
            class ia {
                constructor(e, t) {
                    this._backend = e, this._defaultOptions = t
                }
                request(e, t) {
                    let n;
                    if ("string" == typeof e) n = sa(this._backend, new Jo(ra(this._defaultOptions, t, Eo.Get, e)));
                    else {
                        if (!(e instanceof Jo)) throw new Error("First argument must be a url string or Request instance.");
                        n = sa(this._backend, e)
                    }
                    return n
                }
                get(e, t) {
                    return this.request(new Jo(ra(this._defaultOptions, t, Eo.Get, e)))
                }
                post(e, t, n) {
                    return this.request(new Jo(ra(this._defaultOptions.merge(new Qo({
                        body: t
                    })), n, Eo.Post, e)))
                }
                put(e, t, n) {
                    return this.request(new Jo(ra(this._defaultOptions.merge(new Qo({
                        body: t
                    })), n, Eo.Put, e)))
                }
                delete(e, t) {
                    return this.request(new Jo(ra(this._defaultOptions, t, Eo.Delete, e)))
                }
                patch(e, t, n) {
                    return this.request(new Jo(ra(this._defaultOptions.merge(new Qo({
                        body: t
                    })), n, Eo.Patch, e)))
                }
                head(e, t) {
                    return this.request(new Jo(ra(this._defaultOptions, t, Eo.Head, e)))
                }
                options(e, t) {
                    return this.request(new Jo(ra(this._defaultOptions, t, Eo.Options, e)))
                }
            }
            ia.decorators = [{
                type: s.A
            }], ia.ctorParameters = () => [{
                type: ko
            }, {
                type: Qo
            }];
            class oa extends ia {
                constructor(e, t) {
                    super(e, t)
                }
                request(e, t) {
                    let n;
                    if ("string" == typeof e && (e = new Jo(ra(this._defaultOptions, t, Eo.Get, e))), !(e instanceof Jo)) throw new Error("First argument must be a url string or Request instance.");
                    if (e.method !== Eo.Get) throw new Error("JSONP requests must use GET request method.");
                    return n = sa(this._backend, e), n
                }
            }
            oa.decorators = [{
                type: s.A
            }], oa.ctorParameters = () => [{
                type: ko
            }, {
                type: Qo
            }];
            (class {}).decorators = [{
                type: s.I,
                args: [{
                    providers: [{
                        provide: ia,
                        useFactory: function(e, t) {
                            return new ia(e, t)
                        },
                        deps: [Ko, Qo]
                    }, wo, {
                        provide: Qo,
                        useClass: Zo
                    }, {
                        provide: Do,
                        useClass: Po
                    }, Ko, {
                        provide: Oo,
                        useFactory: function() {
                            return new Go
                        }
                    }]
                }]
            }];
            (class {}).decorators = [{
                type: s.I,
                args: [{
                    providers: [{
                        provide: oa,
                        useFactory: function(e, t) {
                            return new oa(e, t)
                        },
                        deps: [qo, Qo]
                    }, Ho, {
                        provide: Qo,
                        useClass: Zo
                    }, {
                        provide: Do,
                        useClass: Po
                    }, qo]
                }]
            }];
            new s.fb("8.0.0-beta.10+1.sha-a28b3e3");

            function aa(e) {
                return t => t.lift(new la(e))
            }
            class la {
                constructor(e) {
                    this.callback = e
                }
                call(e, t) {
                    return t.subscribe(new ca(e, this.callback))
                }
            }
            class ca extends Si.a {
                constructor(e, t) {
                    super(e), this.add(new ri.a(t))
                }
            }
            let ua = class {
                constructor(e) {
                    this.http = e, this._request$ = new Yr.a, this._response$ = new Yr.a, this.response$ = this._response$, this.request$ = this._request$
                }
                get(...e) {
                    return this.beforeEachRequest(), this.http.get.apply(this.http, e).pipe(aa(() => this.afterEachRequest()))
                }
                post(...e) {
                    return this.beforeEachRequest(), this.http.post.apply(this.http, e).pipe(aa(() => this.afterEachRequest()))
                }
                delete(...e) {
                    return this.beforeEachRequest(), this.http.delete.apply(this.http, e).pipe(aa(() => this.afterEachRequest()))
                }
                beforeEachRequest() {
                    console.log("beforeEachRequest..."), this._request$.next()
                }
                afterEachRequest() {
                    console.log("afterEachRequest..."), this._response$.next()
                }
            };
            ua.ctorParameters = () => [{
                type: Hi
            }], ua = Cn([Object(s.A)(), Sn("design:paramtypes", [Hi])], ua);
            let ha = class {
                constructor(e, t) {
                    this.http = e, this.appConfig = t
                }
                commonHeaders(e = {
                    headers: []
                }) {
                    const t = new Ao;
                    return t.append("X-WP-Nonce", WP_API_Settings.nonce), e && e.headers.length && Object.keys(e.headers).forEach(n => {
                        t.append(e.headers[n].key, e.headers[n].value)
                    }), t
                }
                get(e) {
                    return this.http.get(e, new Qo({
                        headers: this.commonHeaders()
                    })).toPromise()
                }
                post(e, t = {}, n) {
                    return this.http.post(e, t, new Qo({
                        headers: this.commonHeaders(n)
                    })).toPromise()
                }
                deleteReq(e, t = {}) {
                    return this.http.delete(e, new Qo({
                        headers: this.commonHeaders()
                    })).toPromise()
                }
                customApiUrl(e) {
                    return this.appConfig.wpApiUrl + e
                }
                defaultApiUrl(e) {
                    return this.appConfig.wpApiUrlDefault + e
                }
                themeApiUrl(e) {
                    return this.appConfig.themeUrl + e
                }
                handleError(e) {
                    return console.error("An error occurred", e), Promise.reject(e.message || e)
                }
            };
            ha.ctorParameters = () => [{
                type: ua
            }, {
                type: void 0,
                decorators: [{
                    type: s.z,
                    args: [_o]
                }]
            }], ha = Cn([Object(s.A)(), Sn("design:paramtypes", [ua, Object])], ha);
            let pa = class {
                constructor(e) {
                    this.wpService = e, this.ru = {
                        formTitle: "\u041e\u0442\u043a\u043b\u0438\u043a\u043d\u0443\u0442\u044c\u0441\u044f",
                        firstNamePlaceholder: "\u0418\u043c\u044f*",
                        lastNamePlaceholder: "\u0424\u0430\u043c\u0438\u043b\u0438\u044f*",
                        emailPlaceholder: "E-mail*",
                        phoneNumberPlaceholder: "\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u043d\u044b\u0439 \u0442\u0435\u043b\u0435\u0444\u043e\u043d",
                        resumePlaceholder: "\u0420\u0435\u0437\u044e\u043c\u0435",
                        commentPlaceholder: "\u041d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0441\u043b\u043e\u0432 \u043e \u0441\u0435\u0431\u0435*",
                        submitName: "\u041e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u044c",
                        missedFieldsMsg: "\u0417\u0430\u043f\u043e\u043b\u043d\u0438\u0442\u0435 \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u043f\u043e\u043b\u044f.",
                        invalidEmailMsg: "\u041f\u0440\u043e\u0432\u0435\u0440\u044c\u0442\u0435 \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0432\u0432\u0435\u0434\u0451\u043d\u043d\u043e\u0433\u043e email.",
                        successfullySubmitMsg: "\u0414\u0430\u043d\u043d\u044b\u0435 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u044b.",
                        thankYouMsg: "\u0421\u043f\u0430\u0441\u0438\u0431\u043e, \u0447\u0442\u043e \u0437\u0430\u0438\u043d\u0442\u0435\u0440\u0435\u0441\u043e\u0432\u0430\u043b\u0438\u0441\u044c \u043d\u0430\u0448\u0435\u0439 \u043a\u043e\u043c\u043f\u0430\u043d\u0438\u0435\u0439. \u0421 \u0432\u0430\u043c\u0438 \u0441\u0432\u044f\u0436\u0443\u0442\u0441\u044f \u0432 \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0435\u0435 \u0432\u0440\u0435\u043c\u044f.",
                        closeModalName: "\u0417\u0430\u043a\u0440\u044b\u0442\u044c"
                    }, this.en = {
                        formTitle: "Apply to Job",
                        firstNamePlaceholder: "First name*",
                        lastNamePlaceholder: "Last name*",
                        emailPlaceholder: "E-mail*",
                        phoneNumberPlaceholder: "Phone number",
                        resumePlaceholder: "Resume",
                        commentPlaceholder: "Tell something about yourself*",
                        submitName: "Submit",
                        missedFieldsMsg: "Sorry, you\u2019re missing a few fields.",
                        invalidEmailMsg: "Please enter the correct Email address.",
                        successfullySubmitMsg: "Form submitted successfully!",
                        thankYouMsg: "Thank you for submitting your application. We will review your application and contact you shortly.",
                        closeModalName: "Close"
                    }
                }
                getEnLocale() {
                    return this.en
                }
                getRuLocale() {
                    return this.ru
                }
                leaveRequest(e) {
                    return this.wpService.post(this.wpService.customApiUrl("/messages/applyJob"), e, {
                        headers: []
                    })
                }
                uploadResumeFile(e) {
                    this.uploadFile(e)
                }
                ajaxSendFile(e) {
                    return new Promise(t => {
                        const n = this.wpService.themeApiUrl("/php/uploader/uploader.php"),
                            s = new XMLHttpRequest,
                            r = new FormData;
                        s.open("POST", n, !0), s.onreadystatechange = function() {
                            4 == s.readyState && 200 == s.status && t(s.responseText)
                        }, r.append("resume", e), s.send(r)
                    })
                }
                uploadFile(e) {
                    this.ajaxSendFile(e).then(e => {
                        this.filesData = e
                    })
                }
                removeFilesData() {
                    this.filesData = void 0
                }
                getFilesData() {
                    return this.filesData
                }
            };
            pa.ctorParameters = () => [{
                type: ha
            }], pa = Cn([Object(s.A)(), Sn("design:paramtypes", [ha])], pa);
            var da = n("9ppp");
            class fa extends Yr.a {
                constructor(e) {
                    super(), this._value = e
                }
                get value() {
                    return this.getValue()
                }
                _subscribe(e) {
                    const t = super._subscribe(e);
                    return t && !t.closed && e.next(this._value), t
                }
                getValue() {
                    if (this.hasError) throw this.thrownError;
                    if (this.closed) throw new da.a;
                    return this._value
                }
                next(e) {
                    super.next(this._value = e)
                }
            }
            const ma = (() => {
                    function e() {
                        return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this
                    }
                    return e.prototype = Object.create(Error.prototype), e
                })(),
                ga = new xn.a(e => e.complete());

            function ya(e) {
                return e ? function(e) {
                    return new xn.a(t => e.schedule(() => t.complete()))
                }(e) : ga
            }
            class va {
                constructor(e) {
                    if (this.total = e, this.total < 0) throw new ma
                }
                call(e, t) {
                    return t.subscribe(new _a(e, this.total))
                }
            }
            class _a extends Si.a {
                constructor(e, t) {
                    super(e), this.total = t, this.count = 0
                }
                _next(e) {
                    const t = this.total,
                        n = ++this.count;
                    n <= t && (this.destination.next(e), n === t && (this.destination.complete(), this.unsubscribe()))
                }
            }
            let ba = class {
                constructor(e) {
                    this.wpService = e, this.isModalOpen$ = new fa(!1)
                }
                toggle() {
                    var e;
                    this.isModalOpen$.pipe((e = 1, t => 0 === e ? ya() : t.lift(new va(e)))).subscribe(e => {
                        this.isModalOpen$.next(!e)
                    })
                }
                close() {
                    this.isModalOpen$.next(!1)
                }
                leaveRequest(e) {
                    return this.wpService.post(this.wpService.customApiUrl("/messages/jobReminder"), e, {
                        headers: []
                    })
                }
            };
            ba.ctorParameters = () => [{
                type: ha
            }], ba = Cn([Object(s.A)(), Sn("design:paramtypes", [ha])], ba);
            let wa = class {
                constructor(e, t, s) {
                    this.jobReminderService = e, this.applyJobService = t, this.appConfig = s, this.thankYouIsVisible = !1, this.resumeInputText = "", this.states = {
                        isOpen: void 0,
                        submitted: !1,
                        requiredFieldsEmpty: !0,
                        successfullySubmitted: !1,
                        submitInProgress: !1,
                        submitEndedWithUnknownError: !1,
                        notFoundError: !1
                    }, this.formData = {
                        firstName: "",
                        lastName: "",
                        email: "",
                        phoneNumber: "",
                        resume: null,
                        comment: ""
                    }, this.applyJobForm = new zs({
                        firstName: new qs("", [Hn.required, this.checkForSpacesValidator]),
                        lastName: new qs("", [Hn.required, this.checkForSpacesValidator]),
                        email: new qs("", [Hn.required, Hn.pattern("([a-zA-Z0-9+_-]+\\.)*[a-zA-Z0-9+_-]+@[a-z0-9_-]+(\\.[a-z0-9_-]+)*\\.[a-z]{2,6}")]),
                        phoneNumber: new qs("", []),
                        resume: new qs("", []),
                        comment: new qs("", [Hn.required, this.checkForSpacesValidator])
                    }), this.WPAPI = n("+m56"), this.wp = new this.WPAPI({
                        endpoint: "http://localhost:8888/wp-json/"
                    })
                }
                setLocale() {
                    this.jobApplyFormLabels = "/job-page/" == location.pathname ? this.applyJobService.getEnLocale() : this.applyJobService.getRuLocale()
                }
                get firstName() {
                    return this.applyJobForm.get("firstName")
                }
                get lastName() {
                    return this.applyJobForm.get("lastName")
                }
                get email() {
                    return this.applyJobForm.get("email")
                }
                get resume() {
                    return this.applyJobForm.get("resume")
                }
                showThankYouModal() {
                    let e = document.body,
                        t = document.getElementsByClassName("pn-footer-slidein-layer")[0];
                    e.style.position = "fixed", t.style.zIndex = "20", this.thankYouIsVisible = !0
                }
                hideThankYouModal() {
                    let e = document.body,
                        t = document.getElementsByClassName("pn-footer-slidein-layer")[0];
                    e.style.position = "", t.style.zIndex = "", this.thankYouIsVisible = !1
                }
                checkForSpacesValidator(e) {
                    return e.value && e.value.trim() ? null : {
                        spacesError: !0
                    }
                }
                checkFormValid(e) {
                    return this.states.requiredFieldsEmpty = Object.keys(e.controls).filter(t => {
                        let n = e.controls[t];
                        return n.errors && ("required" in n.errors || "spacesError" in n.errors)
                    }).length > 0, this.states.requiredFieldsEmpty
                }
                ngOnInit() {
                    this.setLocale()
                }
                textAreaResize() {
                    this.textArea.nativeElement.scrollTop > 0 && (this.textArea.nativeElement.style.height = this.textArea.nativeElement.scrollHeight + "px"), "" == this.textArea.nativeElement.value && (this.textArea.nativeElement.style.height = "")
                }
                onFileChange(e, t) {
                    if (t) return "resume" === e ? (this.applyJobService.uploadResumeFile(t), this.resumeInputText = t.name, void(this.formData.resume = t)) : void 0
                }
                clearFileInput(e) {
                    if ("resume" === e) return this.resumeInputText = "", this.formData.resume = {}, this.applyJobForm.patchValue({
                        resume: null
                    }), this.resumeInput.nativeElement.value = "", void this.applyJobService.removeFilesData()
                }
                onSubmit(e, t) {
                    const n = new FormData,
                        s = new FormData,
                        r = this.applyJobService.getFilesData(),
                        i = {
                            vacancy: this.vacancy,
                            firstName: t.firstName,
                            lastName: t.lastName,
                            email: t.email,
                            phoneNumber: t.phoneNumber || "",
                            resume: r,
                            comment: t.comment
                        };
                    if (t.resume && t.resume[0] && s.append("resume", t.resume[0]), e.invalid) return this.states.submitted || (this.states.submitted = !0), void(this.states.requiredFieldsEmpty = this.checkFormValid(e));
                    Object.keys(i).forEach(e => {
                        n.append(e, i[e])
                    }), this.states.submitInProgress = !0, this.applyJobService.leaveRequest(n).then(() => {
                        this.states.submitInProgress = !1, this.states.successfullySubmitted = !0, this.states.submitted = !1, this.showThankYouModal(), this.resetFormFields(), this.textAreaResize()
                    }).catch(e => {
                        404 === e.status && (this.states.notFoundError = !0), this.states.submitInProgress = !1, this.states.submitEndedWithUnknownError = !0
                    })
                }
                resetFormFields() {
                    this.applyJobForm.reset(), this.clearFileInput("resume")
                }
                open(e) {
                    e.preventDefault(), this.jobReminderService.toggle()
                }
            };
            wa.ctorParameters = () => [{
                type: ba
            }, {
                type: pa
            }, {
                type: void 0,
                decorators: [{
                    type: s.z,
                    args: [_o]
                }]
            }], wa.propDecorators = {
                vacancy: [{
                    type: s.D,
                    args: ["vacancy"]
                }],
                textArea: [{
                    type: s.gb,
                    args: ["textarea"]
                }],
                resumeInput: [{
                    type: s.gb,
                    args: ["resume"]
                }],
                coverLetterInput: [{
                    type: s.gb,
                    args: ["coverLetter"]
                }]
            }, wa = Cn([Object(s.n)({
                selector: "job-apply-form",
                template: '<form\r\n  [class.pn-job-form--submitted]="states.submitted"\r\n  (ngSubmit)="onSubmit(applyJobForm, applyJobForm.value)"\r\n  [formGroup]="applyJobForm"\r\n  class="pn-job-form"\r\n  (keyup)="checkFormValid(applyJobForm)"\r\n>\r\n    <h3 class="pn-job-form__title">{{jobApplyFormLabels.formTitle}}</h3>\r\n    <div class="pn-job-form__errors">\r\n        <div class="pn-job-form__error"\r\n             *ngIf="states.submitEndedWithUnknownError && states.notFoundError"\r\n        >\r\n            Sorry, but something was wrong.\r\n        </div>\r\n        \x3c!--<div class="pn-job-form__error"\r\n            *ngIf="firstName.invalid && firstName.touched && states.submitted"\r\n        >\r\n            Please fill the First name field.\r\n        </div>\r\n        <div class="pn-job-form__error"\r\n             *ngIf="lastName.invalid && lastName.touched && states.submitted"\r\n        >\r\n            Please fill the Last name field.\r\n        </div>\r\n        <div *ngIf="!resume.value && states.submitted"\r\n             class="pn-job-form__error"\r\n        >\r\n            Please attach correct Resume file.\r\n        </div>--\x3e\r\n\r\n        <div *ngIf="states.submitted && email.errors?.pattern"\r\n             class="pn-job-form__error"\r\n        >\r\n            {{jobApplyFormLabels.invalidEmailMsg}}\r\n        </div>\r\n        <div *ngIf="states.requiredFieldsEmpty && states.submitted"\r\n            class="pn-job-form__error"\r\n        >\r\n            {{jobApplyFormLabels.missedFieldsMsg}}\r\n        </div>\r\n    </div>\r\n    <fieldset class="pn-job-form__fieldset">\r\n        <input type="text" class="pn-job-form__input" placeholder="{{jobApplyFormLabels.firstNamePlaceholder}}"\r\n           tabindex="1"\r\n           maxlength="40"\r\n           formControlName="firstName"\r\n           [(ngModel)]="formData.firstName"\r\n        >\r\n    </fieldset>\r\n    <fieldset class="pn-job-form__fieldset">\r\n        <input type="text" class="pn-job-form__input" placeholder="{{jobApplyFormLabels.lastNamePlaceholder}}"\r\n           tabindex="2"\r\n           maxlength="40"\r\n           formControlName="lastName"\r\n           [(ngModel)]="formData.lastName"\r\n        >\r\n    </fieldset>\r\n    <fieldset class="pn-job-form__fieldset">\r\n        <input type="email" class="pn-job-form__input" placeholder="{{jobApplyFormLabels.emailPlaceholder}}"\r\n           tabindex="3"\r\n           maxlength="40"\r\n           formControlName="email"\r\n           [(ngModel)]="formData.email"\r\n        >\r\n    </fieldset>\r\n    <fieldset class="pn-job-form__fieldset">\r\n        <input type="text" class="pn-job-form__input" placeholder="{{jobApplyFormLabels.phoneNumberPlaceholder}}"\r\n            tabindex="4"\r\n            maxlength="20"\r\n            formControlName="phoneNumber"\r\n            [(ngModel)]="formData.phoneNumber"\r\n        >\r\n    </fieldset>\r\n    \x3c!--<fieldset class="pn-job-form__fieldset">\r\n        <input type="text" class="pn-job-form__input" placeholder="Website"\r\n            tabindex="5"\r\n            maxlength="40"\r\n            formControlName="website"\r\n            [(ngModel)]="formData.website"\r\n        >\r\n    </fieldset>--\x3e\r\n    <fieldset class="pn-job-form__fieldset">\r\n        <input id="resume_input"\r\n               tabindex="5"\r\n               type="file"\r\n               accept=".doc, .pdf, .txt, .docx"\r\n               class="pn-job-form__input pn-job-form__input--file"\r\n               placeholder="{{jobApplyFormLabels.resumePlaceholder}}"\r\n               #resume\r\n               formControlName="resume"\r\n               (change)="onFileChange(\'resume\', $event.target.files[0])"\r\n        >\r\n        <label for="resume_input" class="pn-job-form__file-label">\r\n            {{ resumeInputText ? resumeInputText : jobApplyFormLabels.resumePlaceholder }}\r\n        </label>\r\n        <span *ngIf="resumeInputText.length <= 0" class="pn-job-form__icon pn-job-form__icon--attach"></span>\r\n        <span *ngIf="resumeInputText.length > 0" (click)="clearFileInput(\'resume\')" class="pn-job-form__icon pn-job-form__icon--trash"></span>\r\n    </fieldset>\r\n    <fieldset class="pn-job-form__fieldset">\r\n        <textarea class="pn-job-form__textarea"\r\n                  tabindex="6"\r\n                  rows="1"\r\n                  placeholder="{{jobApplyFormLabels.commentPlaceholder}}"\r\n                  formControlName="comment"\r\n                  [(ngModel)]="formData.comment"\r\n                  (keyup)="textAreaResize()"\r\n                  #textarea\r\n        ></textarea>\r\n    </fieldset>\r\n    \x3c!--<fieldset class="pn-job-form__fieldset">\r\n        <input id="cover_letter_input" type="file"\r\n               class="pn-job-form__input pn-job-form__input&#45;&#45;file"\r\n               placeholder="Cover letter"\r\n               accept=".doc, .pdf, .txt"\r\n               #coverLetter\r\n               formControlName="coverLetter"\r\n               (change)="onFileChange(\'coverLetter\', $event?.srcElement?.files[0])"\r\n        >\r\n        <label for="cover_letter_input" class="pn-job-form__file-label">\r\n            {{ coverLetterInputText ? coverLetterInputText : \'Cover letter\' }}\r\n        </label>\r\n        <span *ngIf="coverLetterInputText.length <= 0" class="pn-job-form__icon pn-job-form__icon&#45;&#45;attach"></span>\r\n        <span *ngIf="coverLetterInputText.length > 0" (click)="clearFileInput(\'coverLetter\')" class="pn-job-form__icon pn-job-form__icon&#45;&#45;trash"></span>\r\n    </fieldset>--\x3e\r\n\r\n    <div class="pn-job-form__submit">\r\n        <button class="pn-job-form__btn-submit"\r\n                type="submit">\r\n            {{jobApplyFormLabels.submitName}}\r\n        </button>\r\n    </div>\r\n    \x3c!--<a (click)="open($event)" href="#" class="pn-job-form__link">Remind me to apply later</a>--\x3e\r\n</form>\r\n\r\n<div class="pn-job-form__thank-you" [class.pn-job-form__thank-you--visible]="thankYouIsVisible">\r\n    <div class="thank-you">\r\n        <div class="pn-marketing-heading-1 thank-you__title">Thank you</div>\r\n        <div class="pn-marketing-text">\r\n            {{jobApplyFormLabels.thankYouMsg}}\r\n        </div>\r\n        <div class="thank-you__controls">\r\n            <button\r\n                    (click)="hideThankYouModal()"\r\n                    type="button"\r\n                    class="request-demo__submit pn-marketing-button pn-marketing-button--dark">{{jobApplyFormLabels.closeModalName}}</button>\r\n        </div>\r\n    </div>\r\n</div>\r\n',
                styles: [""]
            }), Sn("design:paramtypes", [ba, pa, Object])], wa);
            let Ea = class {
                constructor(e, t) {
                    this.jobReminderService = e, this.appConfig = t, this.states = {
                        isOpen: void 0,
                        submitted: !1,
                        requiredFieldsEmpty: !0,
                        successfullySubmitted: !1,
                        submitInProgress: !1,
                        submitEndedWithUnknownError: !1
                    }, this.formData = {
                        email: ""
                    }
                }
                onKeydownEscHandler(e) {
                    this.close()
                }
                ngOnInit() {
                    this.jobReminderService.isModalOpen$.subscribe(this.toggleModal.bind(this))
                }
                toggleModal(e) {
                    this.states.isOpen = e
                }
                close() {
                    this.jobReminderService.close()
                }
                onSubmit(e, t) {
                    !t && (this.states.requiredFieldsEmpty = Object.keys(e.controls).filter(t => {
                        let n = e.controls[t];
                        return n.errors && "required" in n.errors || n.errors
                    }).length > 0, this.states.requiredFieldsEmpty) || (this.states.submitInProgress = !0, this.jobReminderService.leaveRequest(this.formData).then(() => {
                        this.states.submitInProgress = !1, this.states.successfullySubmitted = !0
                    }).catch(() => {
                        this.states.submitInProgress = !1, this.states.submitEndedWithUnknownError = !0
                    }))
                }
            };
            Ea.ctorParameters = () => [{
                type: ba
            }, {
                type: void 0,
                decorators: [{
                    type: s.z,
                    args: [_o]
                }]
            }], Ea.propDecorators = {
                onKeydownEscHandler: [{
                    type: s.x,
                    args: ["document:keydown.escape", ["$event"]]
                }],
                reminderForm: [{
                    type: s.gb,
                    args: ["reminderForm"]
                }]
            }, Ea = Cn([Object(s.n)({
                selector: "job-reminder",
                template: '<div class="pn-job-reminder"\r\n      *ngIf="states.isOpen"\r\n      [@modal]="states.isOpen"\r\n>\r\n    <span class="pn-job-reminder__close-btn pn-icon pn-icon--x" (click)="close()"></span>\r\n    <form class="pn-job-reminder__form"\r\n          [class.pn-job-reminder__form--submitted]="reminderForm.submitted"\r\n          #reminderForm="ngForm"\r\n          (ngSubmit)="onSubmit(reminderForm, reminderForm.valid)"\r\n          *ngIf="!states.successfullySubmitted"\r\n    >\r\n        <h2 class="pn-job-reminder__title">Subscribe our newsletter</h2>\r\n        <p class="pn-job-reminder__description">\r\n            Subscribe to our mailing list to get updates to your email inbox.\r\n        </p>\r\n        <div class="pn-job-reminder__errors">\r\n            <div *ngIf="reminderForm.submitted && emailField.errors?.email && emailField.errors?.required"\r\n                 class="pn-job-reminder__error"\r\n            >\r\n                Please type correct email address.\r\n            </div>\r\n        </div>\r\n        <input class="pn-job-reminder__input"\r\n               type="email"\r\n               placeholder="Your Email"\r\n               required\r\n               name="email"\r\n               email\r\n               #emailField="ngModel"\r\n               [(ngModel)]="formData.email"\r\n        >\r\n        <button class="pn-job-reminder__btn">Submit</button>\r\n    </form>\r\n\r\n    <div class="pn-job-reminder__thanks-message"\r\n         *ngIf="states.successfullySubmitted"\r\n    >\r\n        <h2 class="pn-job-reminder__title">Thank you.</h2>\r\n        <p class="pn-job-reminder__description">\r\n            Your email is now subscribed to our newsletter. Stay tuned for updates, release notes, insights, and trends from Piano.\r\n        </p>\r\n        <button class="pn-job-reminder__btn" (click)="close()">Close</button>\r\n    </div>\r\n</div>',
                animations: [Object(Mr.i)("modal", [Object(Mr.h)("* => void", [Object(Mr.g)({
                    opacity: "1"
                }), Object(Mr.e)(100, Object(Mr.g)({
                    opacity: "0"
                }))]), Object(Mr.h)("void => *", [Object(Mr.g)({
                    opacity: "0"
                }), Object(Mr.e)(100, Object(Mr.g)({
                    opacity: "1"
                }))])])],
                styles: [""]
            }), Sn("design:paramtypes", [ba, Object])], Ea);
            var Ca = n("7vnS"),
                Sa = n.n(Ca);
            let xa = class {
                transform(e, t, n, s = 2) {
                    return t ? t && n.length < s ? e.filter(function(s) {
                        let r = Sa()(s, n[0]);
                        return r ? "string" == typeof t ? r.toLowerCase().includes(t.toLowerCase()) : void 0 : e
                    }) : e.filter(function(e) {
                        let s = n.filter(function(s) {
                            if (!Boolean(Sa()(e, s))) return !1;
                            for (let r = 0; r < n.length; r++) {
                                if (Sa()(e, s).toLowerCase().includes(t[r].toLowerCase())) return !0
                            }
                            return !1
                        });
                        return !!s && s.length > 0
                    }) : e
                }
            };
            xa = Cn([Object(s.S)({
                name: "filterByQuery"
            })], xa);
            let Ta = n("EI6l"),
                Aa = class {
                    constructor() {}
                    scrollToElement(e, t = 0, n = 500, s = "easeInOutCubic") {
                        let r = new Ta,
                            i = document.querySelector(e);
                        const o = {
                            speed: n,
                            offset: t,
                            easing: s
                        };
                        r.animateScroll(i, null, o)
                    }
                };
            Aa.ctorParameters = () => [], Aa = Cn([Object(s.A)(), Sn("design:paramtypes", [])], Aa);
            let Da = class {
                constructor(e, t) {
                    this.scrollService = e, this.elementRef = t
                }
                scrollTo(e) {
                    this.offset = "viewport" === this.offset ? -window.innerHeight : this.offset, console.log(this.offset), this.scrollService.scrollToElement(this.selector, parseInt(this.offset) || 0, parseInt(this.duration) || 500, this.easing || "easeInOutCubic")
                }
            };
            Da.ctorParameters = () => [{
                type: Aa
            }, {
                type: s.t
            }], Da.propDecorators = {
                selector: [{
                    type: s.D,
                    args: ["scroll-to"]
                }],
                duration: [{
                    type: s.D,
                    args: ["scroll-duration"]
                }],
                offset: [{
                    type: s.D,
                    args: ["scroll-offset"]
                }],
                easing: [{
                    type: s.D,
                    args: ["scroll-easing"]
                }],
                scrollTo: [{
                    type: s.x,
                    args: ["click", ["$event"]]
                }]
            }, Da = Cn([Object(s.s)({
                selector: "[scroll-to]"
            }), Sn("design:paramtypes", [Aa, s.t])], Da);
            var Pa = n("Mj6V"),
                ka = n.n(Pa);
            let Oa = class {
                constructor(e) {
                    this.httpService = e
                }
                ngOnInit() {
                    this.httpService.request$.subscribe(() => {
                        ka.a.start()
                    }), this.httpService.response$.subscribe(() => {
                        ka.a.done()
                    })
                }
            };
            Oa.ctorParameters = () => [{
                type: ua
            }], Oa = Cn([Object(s.n)({
                selector: "progress-bar",
                template: "",
                styles: ["/* Make clicks pass-through */\n#nprogress {\n  pointer-events: none;\n}\n#nprogress .bar {\n  background: #1c2544;\n  position: fixed;\n  z-index: 1031;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 2px;\n}\n/* Fancy blur effect */\n#nprogress .peg {\n  display: block;\n  position: absolute;\n  right: 0px;\n  width: 100px;\n  height: 100%;\n  box-shadow: 0 0 10px #1c2544, 0 0 5px #1c2544;\n  opacity: 1;\n  transform: rotate(3deg) translate(0px, -4px);\n}\n.nprogress-custom-parent {\n  overflow: hidden;\n  position: relative;\n}\n.nprogress-custom-parent #nprogress .spinner,\n.nprogress-custom-parent #nprogress .bar {\n  position: absolute;\n}\n@keyframes nprogress-spinner {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}"]
            }), Sn("design:paramtypes", [ua])], Oa);
            let Ia = class {
                constructor() {}
                ngOnInit() {
                    if (Peppermint) {
                        Peppermint(document.getElementById("pn-analytics-reviews-slider"), {
                            speed: 400,
                            slideshow: !0,
                            slideshowInterval: 6e3,
                            stopSlideshowAfterInteraction: !0,
                            mouseDrag: !1,
                            dots: !0,
                            onSlideChange: function(e) {
                                document.querySelectorAll(".pn-analytics-reviews-slider__slide").forEach(e => {
                                    e.classList.remove("pn-analytics-reviews-slider__slide--active")
                                }), document.querySelectorAll(".pn-analytics-reviews-slider__slide")[e].classList.add("pn-analytics-reviews-slider__slide--active")
                            }
                        })
                    }
                }
            };
            Ia.ctorParameters = () => [], Ia = Cn([Object(s.n)({
                selector: "analytics-reviews-slider",
                template: "<ng-content></ng-content>"
            }), Sn("design:paramtypes", [])], Ia);
            let Na = class {
                constructor() {}
                ngOnInit() {
                    if (Peppermint) {
                        Peppermint(document.getElementById("pn-analytics-benefits-slider"), {
                            speed: 400,
                            slideshow: !0,
                            slideshowInterval: 6e3,
                            stopSlideshowAfterInteraction: !0,
                            mouseDrag: !1,
                            dots: !0,
                            onSlideChange: function(e) {}
                        })
                    }
                }
            };
            Na.ctorParameters = () => [], Na = Cn([Object(s.n)({
                selector: "analytics-benefits-slider",
                template: "<ng-content></ng-content>"
            }), Sn("design:paramtypes", [])], Na);
            let Ma = class {
                constructor() {
                    this.contentCardOptions = {
                        defaultStates: [{
                            method: "pxElement",
                            value: 200,
                            state: "active"
                        }, {
                            method: "default",
                            state: "inactive"
                        }],
                        contentCard: {
                            currentState: "inactive",
                            states: [{
                                method: "percentElement",
                                value: 85,
                                state: "active",
                                class: "pn-content-card__animation-holder--in-view"
                            }, {
                                method: "default",
                                state: "inactive"
                            }]
                        }
                    }
                }
            };
            Ma = Cn([Object(s.n)({
                selector: "curation-card",
                template: '<div class="pn-content-card__animation-holder"><ng-content></ng-content></div>',
                animations: []
            })], Ma);
            const Fa = {
                provide: On,
                useExisting: Object(s.lb)(() => Ra),
                multi: !0
            };
            let Ra = class {
                constructor() {
                    this.onSelect = new s.v, this.isOpenDropdown = !1, this.componentTagName = "AUTOCOMPLETE", this.selectedValue = ""
                }
                ngOnInit() {
                    this.setOutsideClickListener(), this.displayedCountries = this.options
                }
                setOutsideClickListener() {
                    document.documentElement.addEventListener("click", () => this.closeDropdown())
                }
                setInputFocus() {
                    setTimeout(() => this.searchField.nativeElement.focus(), 0)
                }
                clearSearchField() {
                    this.searchField.nativeElement.value = "", this.resetOptionsList(), this.setInputFocus()
                }
                closeByTab(e) {
                    9 === e.keyCode && this.closeDropdown()
                }
                closeDropdown() {
                    this.isOpenDropdown = !1, this.resetOptionsList()
                }
                openDropdown() {
                    this.isOpenDropdown = !0, this.setInputFocus()
                }
                resetOptionsList() {
                    this.displayedCountries = this.options
                }
                dropdownToggle() {
                    this.isOpenDropdown ? this.closeDropdown() : this.openDropdown()
                }
                filterCountries(e) {
                    let t = e.toLowerCase();
                    this.displayedCountries = this.options.filter(e => -1 !== e.value.toLowerCase().indexOf(t))
                }
                chooseCountry(e) {
                    this.selectedValue = e, this.onChangeCallback(e), this.resetOptionsList(), this.closeDropdown()
                }
                writeValue() {}
                registerOnChange(e) {
                    this.onChangeCallback = e
                }
                registerOnTouched() {}
                setDisabledState() {}
            };
            Ra.ctorParameters = () => [], Ra.propDecorators = {
                searchField: [{
                    type: s.gb,
                    args: ["searchField"]
                }],
                title: [{
                    type: s.D
                }],
                options: [{
                    type: s.D
                }],
                onSelect: [{
                    type: s.O
                }]
            }, Ra = Cn([Object(s.n)({
                selector: "autocomplete",
                template: '<div class="autocomplete" (click)="$event.stopPropagation()">\r\n    <input (click)="dropdownToggle()"\r\n           [value]="selectedValue"\r\n           readonly="readonly"\r\n           placeholder="{{title}}"\r\n           class="request-demo__form-input pn-input pn-input--flat autocomplete-toggle">\r\n    <div class="autocomplete-dropdown" *ngIf="isOpenDropdown">\r\n        <span *ngIf="!searchField.value"\r\n              class="pn-icon pn-icon--search"></span>\r\n        <span *ngIf="searchField.value"\r\n              (click)="clearSearchField()"\r\n              class="pn-icon pn-icon--x"></span>\r\n        <input #searchField\r\n                (input)="filterCountries(searchField.value)"\r\n                (keydown)="closeByTab($event)"\r\n                placeholder="Search for country..."\r\n                type="text"\r\n                class="autocomplete-dropdown__search">\r\n        <ul class="autocomplete-dropdown__list">\r\n            <li *ngFor="let country of displayedCountries"\r\n                (click)="chooseCountry(country.value)"\r\n                [class.pn-marketing-dropdown__item--active]="country.value === selectedValue"\r\n                class="autocomplete-dropdown__list-item pn-marketing-dropdown__item pn-marketing-dropdown__item--hoverable pn-marketing-text">\r\n                {{country.value}}\r\n            </li>\r\n        </ul>\r\n    </div>\r\n</div>',
                providers: [Fa]
            }), Sn("design:paramtypes", [])], Ra);
            let ja = class {
                openPrivacyCenter() {
                    window.tC && window.tC.privacyCenter.showPrivacyCenter()
                }
            };
            ja = Cn([Object(s.n)({
                selector: "privacy-center-button",
                template: '<button\r\n  class="pn-privacy-button"\r\n  (click)="openPrivacyCenter()"\r\n  type="button">\r\n  <svg\r\n    width="14"\r\n    height="16"\r\n    class="pn-privacy-button__icon"\r\n    aria-hidden="true">\r\n    <path fill-rule="evenodd" clip-rule="evenodd" d="M11.063 16h-9a2 2 0 01-2-2V7a2 2 0 012-2h9a2 2 0 012 2v7a2 2 0 01-2 2zm1-9a1 1 0 00-1-1h-9a1 1 0 00-1 1v7a1 1 0 001 1h9a1 1 0 001-1V7zm-6 2h1v3h-1V9zm3-4V3.5a2.5 2.5 0 10-5 0V5h-1V3.5a3.5 3.5 0 117 0V5h-1z"/>\r\n  </svg>\r\n  Privacy Center\r\n</button>\r\n',
                styles: [""]
            })], ja);

            function La({
                error: e,
                subscriber: t
            }) {
                t.error(e)
            }
            var Va = n("51Dv");

            function $a(e) {
                return function(t) {
                    const n = new Ba(e),
                        s = t.lift(n);
                    return n.caught = s
                }
            }
            class Ba {
                constructor(e) {
                    this.selector = e
                }
                call(e, t) {
                    return t.subscribe(new Ha(e, this.selector, this.caught))
                }
            }
            class Ha extends hi.a {
                constructor(e, t, n) {
                    super(e), this.selector = t, this.caught = n
                }
                error(e) {
                    if (!this.isStopped) {
                        let n;
                        try {
                            n = this.selector(e, this.caught)
                        } catch (t) {
                            return void super.error(t)
                        }
                        this._unsubscribeAndRecycle();
                        const s = new Va.a(this, void 0, void 0);
                        this.add(s);
                        const r = Object(pi.a)(this, n, void 0, void 0, s);
                        r !== s && this.add(r)
                    }
                }
            }
            let Ua = class {
                constructor(e) {
                    this.httpClient = e
                }
                getPosts(e) {
                    let t = document.location.pathname;
                    return 2 == t.split("/")[1].length ? (t = t.split("/")[1], this.httpClient.post(`/${t}/wp-json/piano/v1/blog/getposts`, e).pipe($a(e => this.throwError(e)))) : this.httpClient.post("/wp-json/piano/v1/blog/getposts", e).pipe($a(e => this.throwError(e)))
                }
                throwError(e) {
                    return t = e, n ? new xn.a(e => n.schedule(La, 0, {
                        error: t,
                        subscriber: e
                    })) : new xn.a(e => e.error(t));
                    var t, n
                }
            };
            Ua.ctorParameters = () => [{
                type: Hi
            }], Ua = Cn([Object(s.A)(), Sn("design:paramtypes", [Hi])], Ua);
            let qa = class {
                constructor() {
                    this.lang = this.getLang(), this.translationsEN = {
                        "Load more": "Load more"
                    }, this.translationsJA = {
                        "Load more": "\u3082\u3063\u3068\u8aad\u307f\u8fbc\u3080"
                    }, this.translationsFR = {
                        "Load more": "Load more"
                    }, this.translationsDE = {
                        "Load more": "Load more"
                    }, this.translationsES = {
                        "Load more": "Load more"
                    }, this.translations = {
                        en: this.translationsEN,
                        ja: this.translationsJA,
                        fr: this.translationsFR,
                        de: this.translationsDE,
                        es: this.translationsES
                    }
                }
                getLang() {
                    let e = document.cookie.match(new RegExp("(?:^|; )" + "STYXKEY_language".replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, "\\$1") + "=([^;]*)"));
                    return e ? decodeURIComponent(e[1]) : ""
                }
                t(e) {
                    return this.translations[this.lang][e] || e
                }
            };
            qa = Cn([Object(s.A)()], qa);
            let za = class {
                constructor(e, t) {
                    this.postListingService = e, this.i18n = t, this.displayedPostsList = [], this.offset = 0, this.limit = 6, this.noMorePostsAvailable = !1
                }
                ngOnInit() {
                    this.getPosts({
                        category: this.category,
                        offset: 0,
                        limit: this.limit,
                        postStatus: "publish"
                    })
                }
                loadMorePosts(e) {
                    let t = {
                        category: e,
                        offset: this.currentOffset(),
                        limit: this.limit,
                        postStatus: "publish"
                    };
                    this.getPosts(t)
                }
                currentOffset() {
                    return this.displayedPostsList.length
                }
                getPosts(e) {
                    this.postListingSubs = this.postListingService.getPosts({
                        categorySlug: e.category,
                        offset: e.offset,
                        postType: "post",
                        limit: e.limit,
                        postStatus: e.postStatus,
                        orderBy: "date"
                    }).subscribe(e => {
                        0 === e.length ? this.noMorePostsAvailable = !0 : (this.displayedPostsList = this.displayedPostsList.concat(e), this.displayedPostsList.forEach(e => {
                            e.post_taxonomies.forEach(t => {
                                "category" === t.name && t.values.forEach(t => {
                                    "customer-stories" !== t.slug && "ebooks-guidebooks" !== t.slug && "webinars" !== t.slug && "piano-news" !== t.slug || (e.resourceTypeCategory = t.slug)
                                })
                            })
                        }))
                    }, e => console.log(e))
                }
            };
            za.ctorParameters = () => [{
                type: Ua
            }, {
                type: qa
            }], za.propDecorators = {
                category: [{
                    type: s.D
                }]
            }, za = Cn([Object(s.n)({
                selector: "post-listing",
                template: '<main class="grid--big no-scroll">\r\n    <a *ngFor="let post of displayedPostsList" href="{{ post.post_permalink }}" class="item card">\r\n        <figure *ngIf="post.feat_image"><img src="{{ post.feat_image }}" alt=""></figure>\r\n        <div class="copy">\r\n            <h3>{{ post.post_title }}</h3>\r\n            <div class="post-date">\r\n                <i class="date-icon">\r\n                    <svg *ngIf="post.resourceTypeCategory === \'customer-stories\' && !post.video_embed_code" width="20" height="20" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4 2a1 1 0 00-1 1v11a1 1 0 001 1h9a1 1 0 001-1V5.25L10.792 2H4zm9.083 12.071H3.917V2.93h6.416l2.75 2.785v8.357zM5 16h10V8h1v8a1 1 0 01-1 1H5v-1z" fill="#141B24" fill-opacity=".4"/><path fill-rule="evenodd" clip-rule="evenodd" d="M10.583 11H6.417L6 10.617c.53-.755 1.45-1.257 2.5-1.257s1.97.502 2.5 1.257l-.417.383zM8.5 8.5a1.25 1.25 0 110-2.499 1.25 1.25 0 010 2.499z" fill="#141B24" fill-opacity=".4"/></svg>\r\n                    <svg *ngIf="post.resourceTypeCategory === \'ebooks-guidebooks\'&& !post.video_embed_code" width="20" height="20" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M17.5 3.698l.108-.488h-.002l-.003-.001-.013-.003-.043-.009a10.443 10.443 0 00-.73-.113 11.933 11.933 0 00-1.901-.073c-1.365.06-3.077.392-4.416 1.51-1.339-1.118-3.05-1.45-4.416-1.51a11.934 11.934 0 00-2.472.157 6.886 6.886 0 00-.159.03l-.043.008-.013.003h-.005v.001l.108.488-.108-.488L3 3.297v12.024l.608-.135h.001l.007-.002.033-.006a9.474 9.474 0 01.652-.1 10.933 10.933 0 011.74-.068c1.386.06 2.985.421 4.105 1.542l.354.353.354-.353c1.12-1.12 2.719-1.482 4.105-1.542a10.933 10.933 0 012.256.143c.06.01.106.019.136.025l.033.006.007.002h.001l.608.135V3.298l-.392-.088-.108.488zM4 14.108v-9.99a10.936 10.936 0 012.04-.108c1.328.058 2.85.391 3.96 1.402v9.738c-1.247-.824-2.716-1.087-3.916-1.139A11.936 11.936 0 004 14.108zm7 1.042c1.247-.824 2.716-1.087 3.916-1.139a11.935 11.935 0 012.084.097v-9.99a10.936 10.936 0 00-2.04-.108c-1.328.058-2.85.391-3.96 1.402v9.738z" fill="#141B24" fill-opacity=".4"/></svg>\r\n                    <svg *ngIf="post.resourceTypeCategory === \'webinars\' && !post.video_embed_code" width="20" height="20" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M5 4h10a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2V6a2 2 0 012-2zm0 1h10a1 1 0 011 1v6a1 1 0 01-1 1H5a1 1 0 01-1-1V6a1 1 0 011-1zm1 10h8v1H6v-1z" fill="#141B24" fill-opacity=".4"/></svg>\r\n                    <svg *ngIf="post.resourceTypeCategory === \'piano-news\' && !post.video_embed_code" width="20" height="20" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M14 3H3v10a2 2 0 002 2h9V3zm.268 13H16a2 2 0 002-2V6a1 1 0 00-1-1h-2V3a1 1 0 00-1-1H3a1 1 0 00-1 1v10a3 3 0 003 3h9.268zM15 14V6h2v8a1 1 0 11-2 0zm-6.5-3a2.5 2.5 0 100-5 2.5 2.5 0 000 5z" fill="#141B24" fill-opacity=".4"/></svg>\r\n                    <svg *ngIf="post.video_embed_code" width="20" height="20" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M17 10a7 7 0 11-14 0 7 7 0 0114 0zm1 0a8 8 0 11-16 0 8 8 0 0116 0zm-5.5 0l-4-2.5v5l4-2.5z" fill="#141B24" fill-opacity=".4"/></svg>\r\n                    <svg *ngIf="!post.resourceTypeCategory && !post.video_embed_code" width="20" height="20" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.786 5H7.5c.434 0 .786.352.786.786V8.5a.786.786 0 01-.786.786H4.786A.786.786 0 014 8.5V5.786C4 5.352 4.352 5 4.786 5zm0 .714a.071.071 0 00-.072.072V8.5c0 .04.032.071.072.071H7.5a.07.07 0 00.071-.071V5.786a.071.071 0 00-.071-.072H4.786zm10.643.715h-5v-.715h5v.715zm0 2.857h-5V8.57h5v.715zm0 2.857H4v-.714h11.429v.714zm0 2.857H4v-.714h11.429V15z" fill="#141B24" fill-opacity=".4"/></svg>\r\n                </i>\r\n                <span class="date">{{ post.post_date | date:\'longDate\' }}</span>\r\n            </div>\r\n        </div>\r\n    </a>\r\n</main>\r\n<footer class="load-more">\r\n    <button (click)="loadMorePosts(category)" class="button--light down" [disabled]="noMorePostsAvailable">\r\n        <span class="button-text">{{ i18n.t(\'Load more\') }}</span>\r\n        <i>\r\n            <svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.1 5L5.8 0.699999L6.5 -9.53674e-07L12 5.5L6.5 11L5.8 10.3L10.1 6L0 6L1.90735e-06 5L10.1 5Z" /></svg>\r\n        </i>\r\n    </button>\r\n</footer>\r\n\r\n',
                styles: [""]
            }), Sn("design:paramtypes", [Ua, qa])], za);
            let Wa = class {
                constructor() {
                    this.activeSlide = 0, this.slides = document.getElementsByClassName("swiper-slide")
                }
                ngOnInit() {
                    const e = document.querySelector(".feature-prev"),
                        t = document.querySelector(".feature-next");
                    this.slides[0].classList.add("active"), this.turnFeatureTitleColor(), e.addEventListener("click", e => {
                        this.prevSlide(), this.turnFeatureTitleColor()
                    }), t.addEventListener("click", e => {
                        this.nextSlide(), this.turnFeatureTitleColor()
                    })
                }
                turnFeatureTitleColor() {
                    let e = document.querySelector("#Features-Nav-Title");
                    document.querySelector(".feature.active .copy").classList.contains("copy--white") ? e.style.color = "#ffffff" : e.removeAttribute("style")
                }
                nextSlide() {
                    this.activeSlide === this.slides.length - 1 ? this.activeSlide = 0 : this.activeSlide++;
                    for (let e = 0; e < this.slides.length; e++) this.slides[e].classList.remove("active");
                    this.slides[this.activeSlide].classList.add("active")
                }
                prevSlide() {
                    0 === this.activeSlide ? this.activeSlide = this.slides.length - 1 : this.activeSlide--;
                    for (let e = 0; e < this.slides.length; e++) this.slides[e].classList.remove("active");
                    this.slides[this.activeSlide].classList.add("active")
                }
            };
            Wa.ctorParameters = () => [], Wa = Cn([Object(s.n)({
                selector: "resources-featured-slider",
                template: "<ng-content></ng-content>"
            }), Sn("design:paramtypes", [])], Wa);
            let Ga = class {
                constructor() {
                    this.isSearch = !1, this.isMobileCategory = !1
                }
                ngOnInit() {
                    const e = document.querySelector("#search-button"),
                        t = document.querySelector("#Utility-Bar"),
                        n = document.querySelector("#search-form"),
                        s = document.querySelector(".utility-bar__search-form"),
                        r = document.querySelector("#search-submit"),
                        i = document.querySelector("#close-search"),
                        o = document.querySelector("#search-keyword"),
                        a = () => {
                            this.isSearch = !this.isSearch, this.isSearch ? (t.style.display = "none", n.style.display = "block") : (t.style.display = "flex", n.style.display = "none")
                        };
                    e.addEventListener("click", () => {
                        a(), o.focus()
                    }), i.addEventListener("click", () => {
                        a()
                    }), r.addEventListener("click", () => {
                        s.submit()
                    });
                    const l = document.querySelector("#mobile-category-button"),
                        c = document.querySelector(".utility-bar__mobile-category");
                    l.addEventListener("click", () => {
                        l.classList.toggle("active"), c.classList.toggle("active"), document.body.classList.toggle("fixed")
                    });
                    document.querySelectorAll(".mobile-category__button").forEach(e => {
                        e.addEventListener("click", function() {
                            this.nextElementSibling.classList.toggle("active")
                        })
                    })
                }
            };
            Ga.ctorParameters = () => [], Ga = Cn([Object(s.n)({
                selector: "utility-bar",
                template: "<ng-content></ng-content>"
            }), Sn("design:paramtypes", [])], Ga);
            let Ka = class {
                constructor() {}
                registerLangSwitcher() {
                    document.addEventListener("$PIANOIO_TOPBAR:langChanged", e => {
                        window.location.href = window.location.origin + "/" + e.detail.language + window.location.pathname
                    })
                }
                instance() {
                    return new Promise((e, t) => {
                        !this._instance && "$PIANOIO_TOPBAR" in window && (this._instance = window.$PIANOIO_TOPBAR, e(this._instance)), this._instance && e(this._instance), document.addEventListener("$PIANOIO_TOPBAR:apiInitialized", () => {
                            this._instance = window.$PIANOIO_TOPBAR, e(this._instance)
                        })
                    })
                }
            };
            Ka.ctorParameters = () => [], Ka = Cn([Object(s.A)(), Sn("design:paramtypes", [])], Ka);
            let Qa = class {
                constructor(e, t, n, s) {
                    this.compiler = e, this.injector = t, this.topBarService = n, this.ngZone = s, this.stopWatchRequestDemo = !1, this.destroy$ = new Yr.a, this.stopwatch$ = new Yr.a
                }
                registerTopBar() {
                    this.ngZone.runOutsideAngular(() => {
                        ti(document, "scroll").pipe(di(Object(si.a)(this.destroy$, this.stopwatch$)), gi(() => ci(20))).subscribe(() => {
                            window.scrollY > window.innerHeight - 60 && this.ngZone.run(() => {
                                this.topBarService.instance().then(e => {
                                    e.showRequestDemoButton(), this.stopWatchRequestDemo = !0
                                }), this.stopwatch$.next(), this.stopwatch$.complete()
                            })
                        })
                    }), this.topBarService.registerLangSwitcher()
                }
                ngOnInit() {
                    this.compileModule(this.contentProjection, this.injector), this.registerTopBar()
                }
                compileModule(e, t) {
                    let n = document.body.querySelector("piano-app-template");
                    const r = function({
                        components: e
                    }) {
                        return Object(s.I)({
                            imports: [Jt, Zr, ao, Ir, Nr, co],
                            schemas: [s.i],
                            declarations: e
                        })(class {})
                    }({
                        components: [function(e, t) {
                            return Object(s.n)({
                                selector: t,
                                template: e,
                                encapsulation: s.ib.None
                            })(class {})
                        }(n.innerHTML, "piano-app-template"), Xr, uo, fo, go, yo, vo, wa, Ea, xa, Da, Oa, Ia, Na, Ma, Ra, ja, za, Wa, Ga]
                    });
                    this.compiler.compileModuleAndAllComponentsAsync(r).then(e => e.componentFactories[1]).then(s => {
                        n.remove(), e.createComponent(s, 0, t)
                    })
                }
                ngOnDestroy() {
                    this.destroy$.next(), this.destroy$.complete()
                }
            };
            var Za;
            Qa.ctorParameters = () => [{
                type: s.l
            }, {
                type: s.C
            }, {
                type: Ka
            }, {
                type: s.M
            }], Qa.propDecorators = {
                contentProjection: [{
                    type: s.gb,
                    args: ["contentProjection", {
                        read: s.hb,
                        static: !0
                    }]
                }]
            }, Qa = Cn([Object(s.n)({
                selector: "piano-app",
                template: "<div #contentProjection></div>"
            }), Sn("design:paramtypes", [s.l, s.C, Ka, s.M])], Qa);
            let Ja = Za = class {
                constructor() {
                    this.onChange = e => {}, this.onTouched = () => {}
                }
                writeValue(e) {}
                registerOnChange(e) {
                    this.onChange = e
                }
                registerOnTouched(e) {
                    this.onTouched = e
                }
            };
            var Xa;
            Ja = Za = Cn([Object(s.s)({
                selector: "input[type=file]",
                host: {
                    "(change)": "onChange($event.target.files)",
                    "(blur)": "onTouched()"
                },
                providers: [{
                    provide: On,
                    useExisting: Za,
                    multi: !0
                }]
            })], Ja);
            let Ya = Xa = class {
                static validate(e) {
                    return null == e.value || 0 == e.value.length ? {
                        required: !0
                    } : null
                }
                validate(e) {
                    return Xa.validate(e)
                }
            };
            var el;
            Ya = Xa = Cn([Object(s.s)({
                selector: "[requiredFile]",
                providers: [{
                    provide: Vn,
                    useExisting: Xa,
                    multi: !0
                }]
            })], Ya);
            let tl = el = class {
                validate(e) {
                    return e.value ? e.value.trim() ? null : {
                        spacesError: !0
                    } : null
                }
            };
            tl = el = Cn([Object(s.s)({
                selector: "[inputSpaceValidator]",
                providers: [{
                    provide: Vn,
                    useExisting: el,
                    multi: !0
                }]
            })], tl);
            let nl = class {};
            nl = Cn([Object(s.I)({
                schemas: [s.i],
                imports: [Jt, Zr, ao, Ir, Nr, co],
                declarations: [Qa, Ja, Ya, tl],
                providers: [ua, Ua, pa, ba, Aa, ha, Jr, Ka, qa, {
                    provide: _o,
                    useValue: bo
                }],
                bootstrap: [Qa],
                exports: [Ja, Ya, tl]
            })], nl), Object(s.kb)(), document.addEventListener("DOMContentLoaded", () => {
                En().bootstrapModule(nl).catch(e => console.error(e))
            })
        },
        zn8P: function(e, t) {
            function n(e) {
                return Promise.resolve().then(function() {
                    var t = new Error("Cannot find module '" + e + "'");
                    throw t.code = "MODULE_NOT_FOUND", t
                })
            }
            n.keys = function() {
                return []
            }, n.resolve = n, e.exports = n, n.id = "zn8P"
        }
    },
    [
        [0, 0]
    ]
]);